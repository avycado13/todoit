(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// packages/react/compose-refs/src/compose-refs.tsx
__turbopack_context__.s([
    "composeRefs",
    ()=>composeRefs,
    "useComposedRefs",
    ()=>useComposedRefs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs() {
    for(var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++){
        refs[_key] = arguments[_key];
    }
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs() {
    for(var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++){
        refs[_key] = arguments[_key];
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"](composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/slot.tsx
__turbopack_context__.s([
    "Root",
    ()=>Slot,
    "Slot",
    ()=>Slot,
    "Slottable",
    ()=>Slottable,
    "createSlot",
    ()=>createSlot,
    "createSlottable",
    ()=>createSlottable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$compose$2d$refs$40$1$2e$1$2e$2_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
;
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child)=>{
                if (child === slottable) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].only(null);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"](newElement) ? newElement.props.children : null;
                } else {
                    return child;
                }
            });
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
                ...slotProps,
                ref: forwardedRef,
                children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"](newElement) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneElement"](newElement, void 0, newChildren) : null
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children
        });
    });
    Slot2.displayName = "".concat(ownerName, ".Slot");
    return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
    const SlotClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"](children)) {
            const childrenRef = getElementRef(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"]) {
                props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$compose$2d$refs$40$1$2e$1$2e$2_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneElement"](children, props2);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].only(null) : null;
    });
    SlotClone.displayName = "".concat(ownerName, ".SlotClone");
    return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
    const Slottable2 = (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children
        });
    };
    Slottable2.displayName = "".concat(ownerName, ".Slottable");
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"](child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    const result = childPropValue(...args);
                    slotPropValue(...args);
                    return result;
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    var _Object_getOwnPropertyDescriptor, _Object_getOwnPropertyDescriptor1;
    let getter = (_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(element.props, "ref")) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = (_Object_getOwnPropertyDescriptor1 = Object.getOwnPropertyDescriptor(element, "ref")) === null || _Object_getOwnPropertyDescriptor1 === void 0 ? void 0 : _Object_getOwnPropertyDescriptor1.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.2.0_@types+react@19.2.1__@types+rea_e5f28545a81d3a9cbba4676d380d9706/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/primitive.tsx
__turbopack_context__.s([
    "Primitive",
    ()=>Primitive,
    "Root",
    ()=>Root,
    "dispatchDiscreteCustomEvent",
    ()=>dispatchDiscreteCustomEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$slot$40$1$2e$2$2e$3_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
;
;
var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
];
var Primitive = NODES.reduce((primitive, node)=>{
    const Slot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$slot$40$1$2e$2$2e$3_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSlot"])("Primitive.".concat(node));
    const Node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { asChild, ...primitiveProps } = props;
        const Comp = asChild ? Slot : node;
        if (typeof window !== "undefined") {
            window[Symbol.for("radix-ui")] = true;
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Comp, {
            ...primitiveProps,
            ref: forwardedRef
        });
    });
    Node.displayName = "Primitive.".concat(node);
    return {
        ...primitive,
        [node]: Node
    };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
    if (target) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flushSync"](()=>target.dispatchEvent(event));
}
var Root = Primitive;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-separator@1.1.7_@types+react-dom@19.2.0_@types+react@19.2.1__@types+rea_4614ec30d7df5dc18a0bd1b3d5dffd86/node_modules/@radix-ui/react-separator/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/separator.tsx
__turbopack_context__.s([
    "Root",
    ()=>Root,
    "Separator",
    ()=>Separator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$primitive$40$2$2e$1$2e$3_$40$types$2b$react$2d$dom$40$19$2e$2$2e$0_$40$types$2b$react$40$19$2e$2$2e$1_$5f40$types$2b$rea_e5f28545a81d3a9cbba4676d380d9706$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.2.0_@types+react@19.2.1__@types+rea_e5f28545a81d3a9cbba4676d380d9706/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
;
var NAME = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = [
    "horizontal",
    "vertical"
];
var Separator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
    const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
    const ariaOrientation = orientation === "vertical" ? orientation : void 0;
    const semanticProps = decorative ? {
        role: "none"
    } : {
        "aria-orientation": ariaOrientation,
        role: "separator"
    };
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$primitive$40$2$2e$1$2e$3_$40$types$2b$react$2d$dom$40$19$2e$2$2e$0_$40$types$2b$react$40$19$2e$2$2e$1_$5f40$types$2b$rea_e5f28545a81d3a9cbba4676d380d9706$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
        "data-orientation": orientation,
        ...semanticProps,
        ...domProps,
        ref: forwardedRef
    });
});
Separator.displayName = NAME;
function isValidOrientation(orientation) {
    return ORIENTATIONS.includes(orientation);
}
var Root = Separator;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_apply_descriptor_get
]);
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) return descriptor.get.call(receiver);
    return descriptor.value;
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_extract_field_descriptor
]);
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
    return privateMap.get(receiver);
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_get.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_field_get
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_apply_descriptor_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_extract_field_descriptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js [app-client] (ecmascript)");
;
;
function _class_private_field_get(receiver, privateMap) {
    var descriptor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_extract_field_descriptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(receiver, privateMap, "get");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_apply_descriptor_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(receiver, descriptor);
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_check_private_redeclaration.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_check_private_redeclaration
]);
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_init.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_field_init
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_check_private_redeclaration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_check_private_redeclaration.js [app-client] (ecmascript)");
;
function _class_private_field_init(obj, privateMap, value) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_check_private_redeclaration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(obj, privateMap);
    privateMap.set(obj, value);
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_apply_descriptor_set
]);
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) descriptor.set.call(receiver, value);
    else {
        if (!descriptor.writable) {
            // This should only throw in strict mode, but class bodies are
            // always strict and private fields can only be used inside
            // class bodies.
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_set.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_field_set
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_apply_descriptor_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_extract_field_descriptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js [app-client] (ecmascript)");
;
;
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_extract_field_descriptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(receiver, privateMap, "set");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_apply_descriptor_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(receiver, descriptor, value);
    return value;
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_define_property
]);
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else obj[key] = value;
    return obj;
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_apply_descriptor_update.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_apply_descriptor_update
]);
function _class_apply_descriptor_update(receiver, descriptor) {
    if (descriptor.set) {
        if (!descriptor.get) throw new TypeError("attempted to read set only private field");
        if (!("__destrWrapper" in descriptor)) {
            descriptor.__destrWrapper = {
                set value (v){
                    descriptor.set.call(receiver, v);
                },
                get value () {
                    return descriptor.get.call(receiver);
                }
            };
        }
        return descriptor.__destrWrapper;
    } else {
        if (!descriptor.writable) {
            // This should only throw in strict mode, but class bodies are
            // always strict and private fields can only be used inside
            // class bodies.
            throw new TypeError("attempted to set read only private field");
        }
        return descriptor;
    }
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_update.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_field_update
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_apply_descriptor_update$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_apply_descriptor_update.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_extract_field_descriptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js [app-client] (ecmascript)");
;
;
function _class_private_field_update(receiver, privateMap) {
    var descriptor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_extract_field_descriptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(receiver, privateMap, "update");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_apply_descriptor_update$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(receiver, descriptor);
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_method_get.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_method_get
]);
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) throw new TypeError("attempted to get private field on non-instance");
    return fn;
}
;
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_method_init.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_class_private_method_init
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_check_private_redeclaration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_check_private_redeclaration.js [app-client] (ecmascript)");
;
function _class_private_method_init(obj, privateSet) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_check_private_redeclaration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(obj, privateSet);
    privateSet.add(obj);
}
;
}),
"[project]/node_modules/.pnpm/@badrap+valita@0.3.11/node_modules/@badrap/valita/dist/mjs/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @module
 * A typesafe validation & parsing library for TypeScript.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * const vehicle = v.union(
 *   v.object({ type: v.literal("plane"), airline: v.string() }),
 *   v.object({ type: v.literal("train") }),
 *   v.object({ type: v.literal("automobile"), make: v.string() })
 * );
 * vehicle.parse({ type: "bike" });
 * // ValitaError: invalid_literal at .type (expected "plane", "train" or "automobile")
 * ```
 */ __turbopack_context__.s([
    "ValitaError",
    ()=>ValitaError,
    "array",
    ()=>array,
    "bigint",
    ()=>bigint,
    "boolean",
    ()=>boolean,
    "err",
    ()=>err,
    "lazy",
    ()=>lazy,
    "literal",
    ()=>literal,
    "never",
    ()=>never,
    "null",
    ()=>null_,
    "number",
    ()=>number,
    "object",
    ()=>object,
    "ok",
    ()=>ok,
    "record",
    ()=>record,
    "string",
    ()=>string,
    "tuple",
    ()=>tuple,
    "undefined",
    ()=>undefined_,
    "union",
    ()=>union,
    "unknown",
    ()=>unknown
]);
function joinIssues(left, right) {
    return left ? {
        ok: false,
        code: "join",
        left,
        right
    } : right;
}
function prependPath(key, tree) {
    return {
        ok: false,
        code: "prepend",
        key,
        tree
    };
}
function cloneIssueWithPath(tree, path) {
    const code = tree.code;
    switch(code){
        case "invalid_type":
            return {
                code,
                path,
                expected: tree.expected
            };
        case "invalid_literal":
            return {
                code,
                path,
                expected: tree.expected
            };
        case "missing_value":
            return {
                code,
                path
            };
        case "invalid_length":
            return {
                code,
                path,
                minLength: tree.minLength,
                maxLength: tree.maxLength
            };
        case "unrecognized_keys":
            return {
                code,
                path,
                keys: tree.keys
            };
        case "invalid_union":
            return {
                code,
                path,
                tree: tree.tree
            };
        default:
            return {
                code,
                path,
                error: tree.error
            };
    }
}
function collectIssues(tree) {
    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], issues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    for(;;){
        if (tree.code === "join") {
            collectIssues(tree.left, path.slice(), issues);
            tree = tree.right;
        } else if (tree.code === "prepend") {
            path.push(tree.key);
            tree = tree.tree;
        } else {
            if (tree.code === "custom_error" && typeof tree.error === "object" && tree.error.path !== undefined) {
                path.push(...tree.error.path);
            }
            issues.push(cloneIssueWithPath(tree, path));
            return issues;
        }
    }
}
function separatedList(list, sep) {
    if (list.length === 0) {
        return "nothing";
    } else if (list.length === 1) {
        return list[0];
    } else {
        return "".concat(list.slice(0, -1).join(", "), " ").concat(sep, " ").concat(list[list.length - 1]);
    }
}
function formatLiteral(value) {
    return typeof value === "bigint" ? "".concat(value, "n") : JSON.stringify(value);
}
function countIssues(tree) {
    let count = 0;
    for(;;){
        if (tree.code === "join") {
            count += countIssues(tree.left);
            tree = tree.right;
        } else if (tree.code === "prepend") {
            tree = tree.tree;
        } else {
            return count + 1;
        }
    }
}
function formatIssueTree(tree) {
    let path = "";
    let count = 0;
    for(;;){
        if (tree.code === "join") {
            count += countIssues(tree.right);
            tree = tree.left;
        } else if (tree.code === "prepend") {
            path += "." + tree.key;
            tree = tree.tree;
        } else {
            break;
        }
    }
    let message = "validation failed";
    if (tree.code === "invalid_type") {
        message = "expected ".concat(separatedList(tree.expected, "or"));
    } else if (tree.code === "invalid_literal") {
        message = "expected ".concat(separatedList(tree.expected.map(formatLiteral), "or"));
    } else if (tree.code === "missing_value") {
        message = "missing value";
    } else if (tree.code === "unrecognized_keys") {
        const keys = tree.keys;
        message = "unrecognized ".concat(keys.length === 1 ? "key" : "keys", " ").concat(separatedList(keys.map(formatLiteral), "and"));
    } else if (tree.code === "invalid_length") {
        const min = tree.minLength;
        const max = tree.maxLength;
        message = "expected an array with ";
        if (min > 0) {
            if (max === min) {
                message += "".concat(min);
            } else if (max !== undefined) {
                message += "between ".concat(min, " and ").concat(max);
            } else {
                message += "at least ".concat(min);
            }
        } else {
            message += "at most ".concat(max);
        }
        message += " item(s)";
    } else if (tree.code === "custom_error") {
        const error = tree.error;
        if (typeof error === "string") {
            message = error;
        } else if (error !== undefined) {
            if (error.message !== undefined) {
                message = error.message;
            }
            if (error.path !== undefined) {
                path += "." + error.path.join(".");
            }
        }
    }
    let msg = "".concat(tree.code, " at .").concat(path.slice(1), " (").concat(message, ")");
    if (count === 1) {
        msg += " (+ 1 other issue)";
    } else if (count > 1) {
        msg += " (+ ".concat(count, " other issues)");
    }
    return msg;
}
class ValitaError extends Error {
    get issues() {
        if (this._issues === undefined) {
            this._issues = collectIssues(this.issueTree);
        }
        return this._issues;
    }
    constructor(issueTree){
        super(formatIssueTree(issueTree));
        this.issueTree = issueTree;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = new.target.name;
        this._issues = undefined;
    }
}
class ErrImpl {
    get issues() {
        if (this._issues === undefined) {
            this._issues = collectIssues(this.issueTree);
        }
        return this._issues;
    }
    get message() {
        if (this._message === undefined) {
            this._message = formatIssueTree(this.issueTree);
        }
        return this._message;
    }
    throw() {
        throw new ValitaError(this.issueTree);
    }
    constructor(issueTree){
        this.issueTree = issueTree;
        this.ok = false;
        this._issues = undefined;
        this._message = undefined;
    }
}
function ok(value) {
    return {
        ok: true,
        value
    };
}
/**
 * Create a value for returning a parsing error from chain().
 *
 * An optional error message can be provided.
 *
 * @example
 * ```ts
 * const t = v.string().chain(() => v.err("bad value"));
 *
 * t.parse("hello");
 * // ValitaError: custom_error at . (bad value)
 * ```
 */ function err(error) {
    return new ErrImpl({
        ok: false,
        code: "custom_error",
        error
    });
}
function isObject(v) {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}
const FLAG_FORBID_EXTRA_KEYS = 0x1;
const FLAG_STRIP_EXTRA_KEYS = 0x2;
const FLAG_MISSING_VALUE = 0x4;
class AbstractType {
    optional(defaultFn) {
        const optional = new Optional(this);
        if (!defaultFn) {
            return optional;
        }
        return new TransformType(optional, (v)=>{
            return v === undefined ? {
                ok: true,
                value: defaultFn()
            } : undefined;
        });
    }
    default(defaultValue) {
        const defaultResult = ok(defaultValue);
        return new TransformType(this.optional(), (v)=>{
            return v === undefined ? defaultResult : undefined;
        });
    }
    assert(func, error) {
        const err = {
            ok: false,
            code: "custom_error",
            error
        };
        return new TransformType(this, (v, options)=>func(v, options) ? undefined : err);
    }
    map(func) {
        return new TransformType(this, (v, options)=>({
                ok: true,
                value: func(v, options)
            }));
    }
    chain(func) {
        return new TransformType(this, (v, options)=>{
            const r = func(v, options);
            return r.ok ? r : r.issueTree;
        });
    }
}
/**
 * A base class for all concreate validators/parsers.
 */ class Type extends AbstractType {
    /**
     * Return new validator that accepts both the original type and `null`.
     */ nullable() {
        return new Nullable(this);
    }
    toTerminals(func) {
        func(this);
    }
    /**
     * Parse a value without throwing.
     */ try(v, options) {
        let flags = FLAG_FORBID_EXTRA_KEYS;
        if ((options === null || options === void 0 ? void 0 : options.mode) === "passthrough") {
            flags = 0;
        } else if ((options === null || options === void 0 ? void 0 : options.mode) === "strip") {
            flags = FLAG_STRIP_EXTRA_KEYS;
        }
        const r = this.func(v, flags);
        if (r === undefined) {
            return {
                ok: true,
                value: v
            };
        } else if (r.ok) {
            return {
                ok: true,
                value: r.value
            };
        } else {
            return new ErrImpl(r);
        }
    }
    /**
     * Parse a value. Throw a ValitaError on failure.
     */ parse(v, options) {
        let flags = FLAG_FORBID_EXTRA_KEYS;
        if ((options === null || options === void 0 ? void 0 : options.mode) === "passthrough") {
            flags = 0;
        } else if ((options === null || options === void 0 ? void 0 : options.mode) === "strip") {
            flags = FLAG_STRIP_EXTRA_KEYS;
        }
        const r = this.func(v, flags);
        if (r === undefined) {
            return v;
        } else if (r.ok) {
            return r.value;
        } else {
            throw new ValitaError(r);
        }
    }
}
class Nullable extends Type {
    func(v, flags) {
        return v === null ? undefined : this.type.func(v, flags);
    }
    toTerminals(func) {
        func(nullSingleton);
        this.type.toTerminals(func);
    }
    nullable() {
        return this;
    }
    constructor(type){
        super();
        this.type = type;
        this.name = "nullable";
    }
}
/**
 * A validator/parser marked as "optional", signifying that their value can
 * be missing from the parsed object.
 *
 * As such optionals can only be used as property validators within
 * object validators.
 */ class Optional extends AbstractType {
    func(v, flags) {
        return v === undefined || flags & FLAG_MISSING_VALUE ? undefined : this.type.func(v, flags);
    }
    toTerminals(func) {
        func(this);
        func(undefinedSingleton);
        this.type.toTerminals(func);
    }
    optional(defaultFn) {
        if (!defaultFn) {
            return this;
        }
        return new TransformType(this, (v)=>{
            return v === undefined ? {
                ok: true,
                value: defaultFn()
            } : undefined;
        });
    }
    constructor(type){
        super();
        this.type = type;
        this.name = "optional";
    }
}
// Set a bit in position `index` to one and return the updated bitset.
// This function may or may not mutate `bits` in-place.
function setBit(bits, index) {
    if (typeof bits !== "number") {
        const idx = index >> 5;
        for(let i = bits.length; i <= idx; i++){
            bits.push(0);
        }
        bits[idx] |= 1 << index % 32;
        return bits;
    } else if (index < 32) {
        return bits | 1 << index;
    } else {
        return setBit([
            bits,
            0
        ], index);
    }
}
// Get the bit at position `index`.
function getBit(bits, index) {
    if (typeof bits === "number") {
        return index < 32 ? bits >>> index & 1 : 0;
    } else {
        return bits[index >> 5] >>> index % 32 & 1;
    }
}
class ObjectType extends Type {
    check(func, error) {
        var _a;
        const issue = {
            ok: false,
            code: "custom_error",
            error
        };
        return new ObjectType(this.shape, this.restType, [
            ...(_a = this.checks) !== null && _a !== void 0 ? _a : [],
            {
                func: func,
                issue
            }
        ]);
    }
    func(v, flags) {
        if (!isObject(v)) {
            return this._invalidType;
        }
        let func = this._func;
        if (func === undefined) {
            func = createObjectMatcher(this.shape, this.restType, this.checks);
            this._func = func;
        }
        return func(v, flags);
    }
    rest(restType) {
        return new ObjectType(this.shape, restType);
    }
    extend(shape) {
        return new ObjectType(Object.assign(Object.assign({}, this.shape), shape), this.restType);
    }
    pick() {
        for(var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++){
            keys[_key] = arguments[_key];
        }
        const shape = {};
        keys.forEach((key)=>{
            shape[key] = this.shape[key];
        });
        return new ObjectType(shape, undefined);
    }
    omit() {
        for(var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++){
            keys[_key] = arguments[_key];
        }
        const shape = Object.assign({}, this.shape);
        keys.forEach((key)=>{
            delete shape[key];
        });
        return new ObjectType(shape, this.restType);
    }
    partial() {
        var _a;
        const shape = {};
        Object.keys(this.shape).forEach((key)=>{
            shape[key] = this.shape[key].optional();
        });
        const rest = (_a = this.restType) === null || _a === void 0 ? void 0 : _a.optional();
        return new ObjectType(shape, rest);
    }
    constructor(shape, restType, checks){
        super();
        this.shape = shape;
        this.restType = restType;
        this.checks = checks;
        this.name = "object";
        this._invalidType = {
            ok: false,
            code: "invalid_type",
            expected: [
                "object"
            ]
        };
    }
}
function createObjectMatcher(shape, rest, checks) {
    const requiredKeys = [];
    const optionalKeys = [];
    for(const key in shape){
        let hasOptional = false;
        shape[key].toTerminals((t)=>{
            hasOptional || (hasOptional = t.name === "optional");
        });
        if (hasOptional) {
            optionalKeys.push(key);
        } else {
            requiredKeys.push(key);
        }
    }
    const keys = [
        ...requiredKeys,
        ...optionalKeys
    ];
    const totalCount = keys.length;
    if (totalCount === 0 && (rest === null || rest === void 0 ? void 0 : rest.name) === "unknown") {
        // A fast path for record(unknown())
        return function(obj, _) {
            if (checks !== undefined) {
                for(let i = 0; i < checks.length; i++){
                    if (!checks[i].func(obj)) {
                        return checks[i].issue;
                    }
                }
            }
            return undefined;
        };
    }
    const types = keys.map((key)=>shape[key]);
    const requiredCount = requiredKeys.length;
    const invertedIndexes = Object.create(null);
    keys.forEach((key, index)=>{
        invertedIndexes[key] = ~index;
    });
    const missingValues = requiredKeys.map((key)=>prependPath(key, {
            ok: false,
            code: "missing_value"
        }));
    function set(obj, key, value) {
        if (key === "__proto__") {
            Object.defineProperty(obj, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        } else {
            obj[key] = value;
        }
    }
    return function(obj, flags) {
        let copied = false;
        let output = obj;
        let issues;
        let unrecognized = undefined;
        let seenBits = 0;
        let seenCount = 0;
        if (flags & FLAG_FORBID_EXTRA_KEYS || flags & FLAG_STRIP_EXTRA_KEYS || rest !== undefined) {
            for(const key in obj){
                const value = obj[key];
                const index = ~invertedIndexes[key];
                let r;
                if (index >= 0) {
                    seenCount++;
                    seenBits = setBit(seenBits, index);
                    r = types[index].func(value, flags);
                } else if (rest !== undefined) {
                    r = rest.func(value, flags);
                } else {
                    if (flags & FLAG_FORBID_EXTRA_KEYS) {
                        if (unrecognized === undefined) {
                            unrecognized = [
                                key
                            ];
                        } else {
                            unrecognized.push(key);
                        }
                    } else if (flags & FLAG_STRIP_EXTRA_KEYS && issues === undefined && !copied) {
                        output = {};
                        copied = true;
                        for(let m = 0; m < totalCount; m++){
                            if (getBit(seenBits, m)) {
                                const k = keys[m];
                                set(output, k, obj[k]);
                            }
                        }
                    }
                    continue;
                }
                if (r === undefined) {
                    if (copied && issues === undefined) {
                        set(output, key, value);
                    }
                } else if (!r.ok) {
                    issues = joinIssues(issues, prependPath(key, r));
                } else if (issues === undefined) {
                    if (!copied) {
                        output = {};
                        copied = true;
                        if (rest === undefined) {
                            for(let m = 0; m < totalCount; m++){
                                if (m !== index && getBit(seenBits, m)) {
                                    const k = keys[m];
                                    set(output, k, obj[k]);
                                }
                            }
                        } else {
                            for(const k in obj){
                                set(output, k, obj[k]);
                            }
                        }
                    }
                    set(output, key, r.value);
                }
            }
        }
        if (seenCount < totalCount) {
            for(let i = 0; i < totalCount; i++){
                if (getBit(seenBits, i)) {
                    continue;
                }
                const key = keys[i];
                const value = obj[key];
                let keyFlags = flags & ~FLAG_MISSING_VALUE;
                if (value === undefined && !(key in obj)) {
                    if (i < requiredCount) {
                        issues = joinIssues(issues, missingValues[i]);
                        continue;
                    }
                    keyFlags |= FLAG_MISSING_VALUE;
                }
                const r = types[i].func(value, keyFlags);
                if (r === undefined) {
                    if (copied && issues === undefined && !(keyFlags & FLAG_MISSING_VALUE)) {
                        set(output, key, value);
                    }
                } else if (!r.ok) {
                    issues = joinIssues(issues, prependPath(key, r));
                } else if (issues === undefined) {
                    if (!copied) {
                        output = {};
                        copied = true;
                        if (rest === undefined) {
                            for(let m = 0; m < totalCount; m++){
                                if (m < i || getBit(seenBits, m)) {
                                    const k = keys[m];
                                    set(output, k, obj[k]);
                                }
                            }
                        } else {
                            for(const k in obj){
                                set(output, k, obj[k]);
                            }
                            for(let m = 0; m < i; m++){
                                if (!getBit(seenBits, m)) {
                                    const k = keys[m];
                                    set(output, k, obj[k]);
                                }
                            }
                        }
                    }
                    set(output, key, r.value);
                }
            }
        }
        if (unrecognized !== undefined) {
            issues = joinIssues(issues, {
                ok: false,
                code: "unrecognized_keys",
                keys: unrecognized
            });
        }
        if (issues === undefined && checks !== undefined) {
            for(let i = 0; i < checks.length; i++){
                if (!checks[i].func(output)) {
                    return checks[i].issue;
                }
            }
        }
        if (issues === undefined && copied) {
            return {
                ok: true,
                value: output
            };
        } else {
            return issues;
        }
    };
}
class ArrayOrTupleType extends Type {
    func(arr, flags) {
        var _a;
        if (!Array.isArray(arr)) {
            return this.invalidType;
        }
        const length = arr.length;
        const minLength = this.minLength;
        const maxLength = (_a = this.maxLength) !== null && _a !== void 0 ? _a : Infinity;
        if (length < minLength || length > maxLength) {
            return this.invalidLength;
        }
        const headEnd = this.prefix.length;
        const tailStart = arr.length - this.suffix.length;
        let issueTree = undefined;
        let output = arr;
        for(let i = 0; i < arr.length; i++){
            const type = i < headEnd ? this.prefix[i] : i >= tailStart ? this.suffix[i - tailStart] : this.restType;
            const r = type.func(arr[i], flags);
            if (r !== undefined) {
                if (r.ok) {
                    if (output === arr) {
                        output = arr.slice();
                    }
                    output[i] = r.value;
                } else {
                    issueTree = joinIssues(issueTree, prependPath(i, r));
                }
            }
        }
        if (issueTree) {
            return issueTree;
        } else if (arr === output) {
            return undefined;
        } else {
            return {
                ok: true,
                value: output
            };
        }
    }
    concat(type) {
        if (this.rest) {
            if (type.rest) {
                throw new TypeError("can not concatenate two variadic types");
            }
            return new ArrayOrTupleType(this.prefix, this.rest, [
                ...this.suffix,
                ...type.prefix,
                ...type.suffix
            ]);
        } else if (type.rest) {
            return new ArrayOrTupleType([
                ...this.prefix,
                ...this.suffix,
                ...type.prefix
            ], type.rest, type.suffix);
        } else {
            return new ArrayOrTupleType([
                ...this.prefix,
                ...this.suffix,
                ...type.prefix,
                ...type.suffix
            ], type.rest, type.suffix);
        }
    }
    constructor(prefix, rest, suffix){
        super();
        this.prefix = prefix;
        this.rest = rest;
        this.suffix = suffix;
        this.name = "array";
        this.restType = rest !== null && rest !== void 0 ? rest : never();
        this.minLength = this.prefix.length + this.suffix.length;
        this.maxLength = rest ? undefined : this.minLength;
        this.invalidType = {
            ok: false,
            code: "invalid_type",
            expected: [
                "array"
            ]
        };
        this.invalidLength = {
            ok: false,
            code: "invalid_length",
            minLength: this.minLength,
            maxLength: this.maxLength
        };
    }
}
function toInputType(v) {
    const type = typeof v;
    if (type !== "object") {
        return type;
    } else if (v === null) {
        return "null";
    } else if (Array.isArray(v)) {
        return "array";
    } else {
        return type;
    }
}
function dedup(arr) {
    return Array.from(new Set(arr));
}
function findCommonKeys(rs) {
    const map = new Map();
    rs.forEach((r)=>{
        for(const key in r){
            map.set(key, (map.get(key) || 0) + 1);
        }
    });
    const result = [];
    map.forEach((count, key)=>{
        if (count === rs.length) {
            result.push(key);
        }
    });
    return result;
}
function groupTerminals(terminals) {
    const order = new Map();
    const literals = new Map();
    const types = new Map();
    const unknowns = [];
    const optionals = [];
    const expectedTypes = [];
    terminals.forEach((param)=>{
        let { root, terminal } = param;
        var _a;
        order.set(root, (_a = order.get(root)) !== null && _a !== void 0 ? _a : order.size);
        if (terminal.name === "never") {
        // skip
        } else if (terminal.name === "optional") {
            optionals.push(root);
        } else if (terminal.name === "unknown") {
            unknowns.push(root);
        } else if (terminal.name === "literal") {
            const roots = literals.get(terminal.value) || [];
            roots.push(root);
            literals.set(terminal.value, roots);
            expectedTypes.push(toInputType(terminal.value));
        } else {
            const roots = types.get(terminal.name) || [];
            roots.push(root);
            types.set(terminal.name, roots);
            expectedTypes.push(terminal.name);
        }
    });
    literals.forEach((roots, value)=>{
        const options = types.get(toInputType(value));
        if (options) {
            options.push(...roots);
            literals.delete(value);
        }
    });
    const byOrder = (a, b)=>{
        var _a, _b;
        return ((_a = order.get(a)) !== null && _a !== void 0 ? _a : 0) - ((_b = order.get(b)) !== null && _b !== void 0 ? _b : 0);
    };
    types.forEach((roots, type)=>types.set(type, dedup(roots.concat(unknowns).sort(byOrder))));
    literals.forEach((roots, value)=>literals.set(value, dedup(roots.concat(unknowns)).sort(byOrder)));
    return {
        types,
        literals,
        unknowns: dedup(unknowns).sort(byOrder),
        optionals: dedup(optionals).sort(byOrder),
        expectedTypes: dedup(expectedTypes)
    };
}
function createObjectKeyMatcher(objects, key) {
    const list = [];
    for (const { root, terminal } of objects){
        terminal.shape[key].toTerminals((t)=>list.push({
                root,
                terminal: t
            }));
    }
    const { types, literals, optionals, unknowns, expectedTypes } = groupTerminals(list);
    if (unknowns.length > 0 || optionals.length > 1) {
        return undefined;
    }
    for (const roots of literals.values()){
        if (roots.length > 1) {
            return undefined;
        }
    }
    for (const roots of types.values()){
        if (roots.length > 1) {
            return undefined;
        }
    }
    const missingValue = prependPath(key, {
        ok: false,
        code: "missing_value"
    });
    const issue = prependPath(key, types.size === 0 ? {
        ok: false,
        code: "invalid_literal",
        expected: Array.from(literals.keys())
    } : {
        ok: false,
        code: "invalid_type",
        expected: expectedTypes
    });
    const litMap = literals.size > 0 ? new Map() : undefined;
    for (const [literal, options] of literals){
        litMap.set(literal, options[0]);
    }
    const byType = types.size > 0 ? {} : undefined;
    for (const [type, options] of types){
        byType[type] = options[0];
    }
    return function(_obj, flags) {
        var _a;
        const obj = _obj;
        const value = obj[key];
        if (value === undefined && !(key in obj)) {
            return optionals.length > 0 ? optionals[0].func(obj, flags) : missingValue;
        }
        const option = (_a = byType === null || byType === void 0 ? void 0 : byType[toInputType(value)]) !== null && _a !== void 0 ? _a : litMap === null || litMap === void 0 ? void 0 : litMap.get(value);
        return option ? option.func(obj, flags) : issue;
    };
}
function createUnionObjectMatcher(terminals) {
    if (terminals.some((param)=>{
        let { terminal: t } = param;
        return t.name === "unknown";
    })) {
        return undefined;
    }
    const objects = terminals.filter((item)=>{
        return item.terminal.name === "object";
    });
    if (objects.length < 2) {
        return undefined;
    }
    const shapes = objects.map((param)=>{
        let { terminal } = param;
        return terminal.shape;
    });
    for (const key of findCommonKeys(shapes)){
        const matcher = createObjectKeyMatcher(objects, key);
        if (matcher) {
            return matcher;
        }
    }
    return undefined;
}
function createUnionBaseMatcher(terminals) {
    const { expectedTypes, literals, types, unknowns, optionals } = groupTerminals(terminals);
    const issue = types.size === 0 && unknowns.length === 0 ? {
        ok: false,
        code: "invalid_literal",
        expected: Array.from(literals.keys())
    } : {
        ok: false,
        code: "invalid_type",
        expected: expectedTypes
    };
    const litMap = literals.size > 0 ? literals : undefined;
    const byType = types.size > 0 ? {} : undefined;
    for (const [type, options] of types){
        byType[type] = options;
    }
    return function(value, flags) {
        var _a, _b;
        let options;
        if (flags & FLAG_MISSING_VALUE) {
            options = optionals;
        } else {
            options = (_b = (_a = byType === null || byType === void 0 ? void 0 : byType[toInputType(value)]) !== null && _a !== void 0 ? _a : litMap === null || litMap === void 0 ? void 0 : litMap.get(value)) !== null && _b !== void 0 ? _b : unknowns;
        }
        if (!options) {
            return issue;
        }
        let count = 0;
        let issueTree = issue;
        for(let i = 0; i < options.length; i++){
            const r = options[i].func(value, flags);
            if (r === undefined || r.ok) {
                return r;
            }
            issueTree = count > 0 ? joinIssues(issueTree, r) : r;
            count++;
        }
        if (count > 1) {
            return {
                ok: false,
                code: "invalid_union",
                tree: issueTree
            };
        }
        return issueTree;
    };
}
class UnionType extends Type {
    toTerminals(func) {
        this.options.forEach((o)=>o.toTerminals(func));
    }
    func(v, flags) {
        let func = this._func;
        if (func === undefined) {
            const flattened = [];
            this.options.forEach((option)=>option.toTerminals((terminal)=>{
                    flattened.push({
                        root: option,
                        terminal
                    });
                }));
            const base = createUnionBaseMatcher(flattened);
            const object = createUnionObjectMatcher(flattened);
            if (!object) {
                func = base;
            } else {
                func = function(v, f) {
                    if (isObject(v)) {
                        return object(v, f);
                    }
                    return base(v, f);
                };
            }
            this._func = func;
        }
        return func(v, flags);
    }
    constructor(options){
        super();
        this.options = options;
        this.name = "union";
    }
}
const STRICT = Object.freeze({
    mode: "strict"
});
const STRIP = Object.freeze({
    mode: "strip"
});
const PASSTHROUGH = Object.freeze({
    mode: "passthrough"
});
class TransformType extends Type {
    func(v, flags) {
        let chain = this.transformChain;
        if (!chain) {
            chain = [];
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            let next = this;
            while(next instanceof TransformType){
                chain.push(next.transform);
                next = next.transformed;
            }
            chain.reverse();
            this.transformChain = chain;
            this.transformRoot = next;
        }
        // eslint-disable-next-line
        let result = this.transformRoot.func(v, flags);
        if (result !== undefined && !result.ok) {
            return result;
        }
        let current;
        if (result !== undefined) {
            current = result.value;
        } else if (flags & FLAG_MISSING_VALUE) {
            current = undefined;
            result = this.undef;
        } else {
            current = v;
        }
        const options = flags & FLAG_FORBID_EXTRA_KEYS ? STRICT : flags & FLAG_STRIP_EXTRA_KEYS ? STRIP : PASSTHROUGH;
        for(let i = 0; i < chain.length; i++){
            const r = chain[i](current, options);
            if (r !== undefined) {
                if (!r.ok) {
                    return r;
                }
                current = r.value;
                result = r;
            }
        }
        return result;
    }
    toTerminals(func) {
        this.transformed.toTerminals(func);
    }
    constructor(transformed, transform){
        super();
        this.transformed = transformed;
        this.transform = transform;
        this.name = "transform";
        this.undef = ok(undefined);
        this.transformChain = undefined;
        this.transformRoot = undefined;
    }
}
class LazyType extends Type {
    func(v, flags) {
        if (!this.type) {
            this.type = this.definer();
        }
        return this.type.func(v, flags);
    }
    toTerminals(func) {
        if (this.recursing) {
            return;
        }
        try {
            this.recursing = true;
            if (!this.type) {
                this.type = this.definer();
            }
            this.type.toTerminals(func);
        } finally{
            this.recursing = false;
        }
    }
    constructor(definer){
        super();
        this.definer = definer;
        this.name = "lazy";
        this.recursing = false;
    }
}
class NeverType extends Type {
    func(_, __) {
        return this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "never";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: []
        };
    }
}
const neverSingleton = new NeverType();
/**
 * Create a validator that never matches any value,
 * analogous to the TypeScript type `never`.
 */ function never() {
    return neverSingleton;
}
class UnknownType extends Type {
    func(_, __) {
        return undefined;
    }
    constructor(){
        super(...arguments);
        this.name = "unknown";
    }
}
const unknownSingleton = new UnknownType();
/**
 * Create a validator that matches any value,
 * analogous to the TypeScript type `unknown`.
 */ function unknown() {
    return unknownSingleton;
}
class UndefinedType extends Type {
    func(v, _) {
        return v === undefined ? undefined : this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "undefined";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "undefined"
            ]
        };
    }
}
const undefinedSingleton = new UndefinedType();
/**
 * Create a validator that matches `undefined`.
 */ function undefined_() {
    return undefinedSingleton;
}
class NullType extends Type {
    func(v, _) {
        return v === null ? undefined : this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "null";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "null"
            ]
        };
    }
}
const nullSingleton = new NullType();
/**
 * Create a validator that matches `null`.
 */ function null_() {
    return nullSingleton;
}
class NumberType extends Type {
    func(v, _) {
        return typeof v === "number" ? undefined : this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "number";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "number"
            ]
        };
    }
}
const numberSingleton = new NumberType();
/**
 * Create a validator that matches any number value.
 */ function number() {
    return numberSingleton;
}
class BigIntType extends Type {
    func(v, _) {
        return typeof v === "bigint" ? undefined : this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "bigint";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "bigint"
            ]
        };
    }
}
const bigintSingleton = new BigIntType();
/**
 * Create a validator that matches any bigint value.
 */ function bigint() {
    return bigintSingleton;
}
class StringType extends Type {
    func(v, _) {
        return typeof v === "string" ? undefined : this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "string";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "string"
            ]
        };
    }
}
const stringSingleton = new StringType();
/**
 * Create a validator that matches any string value.
 */ function string() {
    return stringSingleton;
}
class BooleanType extends Type {
    func(v, _) {
        return typeof v === "boolean" ? undefined : this.issue;
    }
    constructor(){
        super(...arguments);
        this.name = "boolean";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "boolean"
            ]
        };
    }
}
const booleanSingleton = new BooleanType();
/**
 * Create a validator that matches any boolean value.
 */ function boolean() {
    return booleanSingleton;
}
class LiteralType extends Type {
    func(v, _) {
        return v === this.value ? undefined : this.issue;
    }
    constructor(value){
        super();
        this.value = value;
        this.name = "literal";
        this.issue = {
            ok: false,
            code: "invalid_literal",
            expected: [
                value
            ]
        };
    }
}
/**
 * Create a validator for a specific string, number, bigint or boolean value.
 */ function literal(value) {
    return new LiteralType(value);
}
/**
 * Create a validator for an object type.
 */ function object(obj) {
    return new ObjectType(obj, undefined);
}
/**
 * Create a validator for a record type `Record<string, T>`,
 * where `T` is the output type of the given subvalidator.
 */ function record(valueType) {
    return new ObjectType({}, valueType !== null && valueType !== void 0 ? valueType : unknown());
}
/**
 * Create a validator for an array type `T[]`,
 * where `T` is the output type of the given subvalidator.
 */ function array(item) {
    return new ArrayOrTupleType([], item !== null && item !== void 0 ? item : unknown(), []);
}
/**
 * Create a validator for an array type `[T1, T2, ..., Tn]`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 */ function tuple(items) {
    return new ArrayOrTupleType(items, undefined, []);
}
/**
 * Create a validator that matches any type `T1 | T2 | ... | Tn`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 *
 * This is analogous to how TypeScript's union types are constructed.
 */ function union() {
    for(var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++){
        options[_key] = arguments[_key];
    }
    return new UnionType(options);
}
/**
 * Create a validator that can reference itself, directly or indirectly.
 *
 * In most cases an explicit type annotation is also needed, as TypeScript
 * cannot infer return types of recursive functions.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * type T = string | T[];
 * const type: v.Type<T> = v.lazy(() => v.union(v.string(), v.array(type)));
 * ```
 */ function lazy(definer) {
    return new LazyType(definer);
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/compare-utf8@0.1.1/node_modules/compare-utf8/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
/**
 * Compares two JavaScript strings as if they were UTF-8 encoded byte arrays.
 * @param {string} a
 * @param {string} b
 * @returns {number}
 */ __turbopack_context__.s([
    "compareUTF8",
    ()=>compareUTF8,
    "greaterThan",
    ()=>greaterThan,
    "greaterThanEq",
    ()=>greaterThanEq,
    "lessThan",
    ()=>lessThan,
    "lessThanEq",
    ()=>lessThanEq,
    "utf16LengthForCodePoint",
    ()=>utf16LengthForCodePoint
]);
function compareUTF8(a, b) {
    const aLength = a.length;
    const bLength = b.length;
    const length = Math.min(aLength, bLength);
    for(let i = 0; i < length;){
        const aCodePoint = a.codePointAt(i);
        const bCodePoint = b.codePointAt(i);
        if (aCodePoint !== bCodePoint) {
            // Code points below 0x80 are represented the same way in UTF-8 as in
            // UTF-16.
            if (aCodePoint < 0x80 && bCodePoint < 0x80) {
                return aCodePoint - bCodePoint;
            }
            // get the UTF-8 bytes for the code points
            const aLength = utf8Bytes(aCodePoint, aBytes);
            const bLength = utf8Bytes(bCodePoint, bBytes);
            return compareArrays(aBytes, aLength, bBytes, bLength);
        }
        i += utf16LengthForCodePoint(aCodePoint);
    }
    return aLength - bLength;
}
/**
 * @param {number[]} a
 * @param {number} aLength
 * @param {number[]} b
 * @param {number} bLength
 * @returns {number}
 */ function compareArrays(a, aLength, b, bLength) {
    const length = Math.min(aLength, bLength);
    for(let i = 0; i < length; i++){
        const aValue = a[i];
        const bValue = b[i];
        if (aValue !== bValue) {
            return aValue - bValue;
        }
    }
    return aLength - bLength;
}
function utf16LengthForCodePoint(aCodePoint) {
    return aCodePoint > 0xffff ? 2 : 1;
}
// 2 preallocated arrays for utf8Bytes.
const arr = ()=>Array.from({
        length: 4
    }, ()=>0);
const aBytes = arr();
const bBytes = arr();
/**
 * @param {number} codePoint
 * @param {number[]} bytes
 * @returns {number}
 */ function utf8Bytes(codePoint, bytes) {
    if (codePoint < 0x80) {
        bytes[0] = codePoint;
        return 1;
    }
    let count;
    let offset;
    if (codePoint <= 0x07ff) {
        count = 1;
        offset = 0xc0;
    } else if (codePoint <= 0xffff) {
        count = 2;
        offset = 0xe0;
    } else if (codePoint <= 0x10ffff) {
        count = 3;
        offset = 0xf0;
    } else {
        throw new Error("Invalid code point");
    }
    bytes[0] = (codePoint >> 6 * count) + offset;
    let i = 1;
    for(; count > 0; count--){
        const temp = codePoint >> 6 * (count - 1);
        bytes[i++] = 0x80 | temp & 0x3f;
    }
    return i;
}
function greaterThan(a, b) {
    return compareUTF8(a, b) > 0;
}
function greaterThanEq(a, b) {
    return compareUTF8(a, b) >= 0;
}
function lessThan(a, b) {
    return compareUTF8(a, b) < 0;
}
function lessThanEq(a, b) {
    return compareUTF8(a, b) <= 0;
}
}),
"[project]/node_modules/.pnpm/@rocicorp+resolver@1.0.2/node_modules/@rocicorp/resolver/out/resolver.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolver",
    ()=>resolver
]);
function resolver() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
}),
"[project]/node_modules/.pnpm/@rocicorp+lock@1.0.4/node_modules/@rocicorp/lock/out/lock.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Lock",
    ()=>Lock,
    "RWLock",
    ()=>RWLock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@rocicorp+resolver@1.0.2/node_modules/@rocicorp/resolver/out/resolver.js [app-client] (ecmascript)");
;
;
class Lock {
    async lock() {
        const previous = this._lockP;
        const { promise, resolve } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolver"])();
        this._lockP = promise;
        await previous;
        return resolve;
    }
    withLock(f) {
        return run(this.lock(), f);
    }
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lockP", null);
    }
}
class RWLock {
    read() {
        return this._lock.withLock(async ()=>{
            await this._writeP;
            const { promise, resolve } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolver"])();
            this._readP.push(promise);
            return resolve;
        });
    }
    withRead(f) {
        return run(this.read(), f);
    }
    async write() {
        return await this._lock.withLock(async ()=>{
            await this._writeP;
            await Promise.all(this._readP);
            const { promise, resolve } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolver"])();
            this._writeP = promise;
            this._readP = [];
            return resolve;
        });
    }
    withWrite(f) {
        return run(this.write(), f);
    }
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lock", new Lock());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_writeP", null);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_readP", []);
    }
}
async function run(p, f) {
    const release = await p;
    try {
        return await f();
    } finally{
        release();
    }
}
}),
"[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xxHash32",
    ()=>xxHash32
]);
const PRIME32_1 = 2654435761;
const PRIME32_2 = 2246822519;
const PRIME32_3 = 3266489917;
const PRIME32_4 = 668265263;
const PRIME32_5 = 374761393;
let encoder;
function xxHash32(input) {
    let seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const buffer = typeof input === 'string' ? (encoder !== null && encoder !== void 0 ? encoder : encoder = new TextEncoder()).encode(input) : input;
    const b = buffer;
    /*
        Step 1. Initialize internal accumulators
        Each accumulator gets an initial value based on optional seed input. Since the seed is optional, it can be 0.

        ```
            u32 acc1 = seed + PRIME32_1 + PRIME32_2;
            u32 acc2 = seed + PRIME32_2;
            u32 acc3 = seed + 0;
            u32 acc4 = seed - PRIME32_1;
        ```
        Special case : input is less than 16 bytes
        When input is too small (< 16 bytes), the algorithm will not process any stripe. Consequently, it will not
        make use of parallel accumulators.

        In which case, a simplified initialization is performed, using a single accumulator :

        u32 acc  = seed + PRIME32_5;
        The algorithm then proceeds directly to step 4.
    */ let acc = seed + PRIME32_5 & 0xffffffff;
    let offset = 0;
    if (b.length >= 16) {
        const accN = [
            seed + PRIME32_1 + PRIME32_2 & 0xffffffff,
            seed + PRIME32_2 & 0xffffffff,
            seed + 0 & 0xffffffff,
            seed - PRIME32_1 & 0xffffffff
        ];
        /*
            Step 2. Process stripes
            A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 lanes, of 4 bytes each.
            The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.

            Each lane read its associated 32-bit value using little-endian convention.

            For each {lane, accumulator}, the update process is called a round, and applies the following formula :

            ```
            accN = accN + (laneN * PRIME32_2);
            accN = accN <<< 13;
            accN = accN * PRIME32_1;
            ```

            This shuffles the bits so that any bit from input lane impacts several bits in output accumulator.
            All operations are performed modulo 2^32.

            Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume
            the whole input, except the last remaining bytes which cannot form a stripe (< 16 bytes). When that
            happens, move to step 3.
        */ const b = buffer;
        const limit = b.length - 16;
        let lane = 0;
        for(offset = 0; (offset & 0xfffffff0) <= limit; offset += 4){
            const i = offset;
            const laneN0 = b[i + 0] + (b[i + 1] << 8);
            const laneN1 = b[i + 2] + (b[i + 3] << 8);
            const laneNP = laneN0 * PRIME32_2 + (laneN1 * PRIME32_2 << 16);
            let acc = accN[lane] + laneNP & 0xffffffff;
            acc = acc << 13 | acc >>> 19;
            const acc0 = acc & 0xffff;
            const acc1 = acc >>> 16;
            accN[lane] = acc0 * PRIME32_1 + (acc1 * PRIME32_1 << 16) & 0xffffffff;
            lane = lane + 1 & 0x3;
        }
        /*
            Step 3. Accumulator convergence
            All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator
            of same width (32-bit). The associated formula is as follows :

            ```
            acc = (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18);
            ```
        */ acc = (accN[0] << 1 | accN[0] >>> 31) + (accN[1] << 7 | accN[1] >>> 25) + (accN[2] << 12 | accN[2] >>> 20) + (accN[3] << 18 | accN[3] >>> 14) & 0xffffffff;
    }
    /*
        Step 4. Add input length
        The input total length is presumed known at this stage. This step is just about adding the length to
        accumulator, so that it participates to final mixing.

        ```
        acc = acc + (u32)inputLength;
        ```
    */ acc = acc + buffer.length & 0xffffffff;
    /*
        Step 5. Consume remaining input
        There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according
        to following pseudo-code :
        ```
        while (remainingLength >= 4) {
            lane = read_32bit_little_endian(input_ptr);
            acc = acc + lane * PRIME32_3;
            acc = (acc <<< 17) * PRIME32_4;
            input_ptr += 4; remainingLength -= 4;
        }
        ```
        This process ensures that all input bytes are present in the final mix.
    */ const limit = buffer.length - 4;
    for(; offset <= limit; offset += 4){
        const i = offset;
        const laneN0 = b[i + 0] + (b[i + 1] << 8);
        const laneN1 = b[i + 2] + (b[i + 3] << 8);
        const laneP = laneN0 * PRIME32_3 + (laneN1 * PRIME32_3 << 16);
        acc = acc + laneP & 0xffffffff;
        acc = acc << 17 | acc >>> 15;
        acc = (acc & 0xffff) * PRIME32_4 + ((acc >>> 16) * PRIME32_4 << 16) & 0xffffffff;
    }
    /*
        ```
        while (remainingLength >= 1) {
            lane = read_byte(input_ptr);
            acc = acc + lane * PRIME32_5;
            acc = (acc <<< 11) * PRIME32_1;
            input_ptr += 1; remainingLength -= 1;
        }
        ```
    */ for(; offset < b.length; ++offset){
        const lane = b[offset];
        acc = acc + lane * PRIME32_5;
        acc = acc << 11 | acc >>> 21;
        acc = (acc & 0xffff) * PRIME32_1 + ((acc >>> 16) * PRIME32_1 << 16) & 0xffffffff;
    }
    /*
        Step 6. Final mix (avalanche)
        The final mix ensures that all input bits have a chance to impact any bit in the output digest,
        resulting in an unbiased distribution. This is also called avalanche effect.
        ```
        acc = acc xor (acc >> 15);
        acc = acc * PRIME32_2;
        acc = acc xor (acc >> 13);
        acc = acc * PRIME32_3;
        acc = acc xor (acc >> 16);
        ```
    */ acc = acc ^ acc >>> 15;
    acc = ((acc & 0xffff) * PRIME32_2 & 0xffffffff) + ((acc >>> 16) * PRIME32_2 << 16);
    acc = acc ^ acc >>> 13;
    acc = ((acc & 0xffff) * PRIME32_3 & 0xffffffff) + ((acc >>> 16) * PRIME32_3 << 16);
    acc = acc ^ acc >>> 16;
    // turn any negatives back into a positive number;
    return acc < 0 ? acc + 4294967296 : acc;
} //# sourceMappingURL=xxHash32.js.map
}),
"[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$xxhash$40$4$2e$0$2e$0$2f$node_modules$2f$js$2d$xxhash$2f$dist$2f$esm$2f$xxHash32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js [app-client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
}),
"[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$xxhash$40$4$2e$0$2e$0$2f$node_modules$2f$js$2d$xxhash$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/index.js [app-client] (ecmascript) <locals>");
;
}),
"[project]/node_modules/.pnpm/@rocicorp+logger@5.4.0/node_modules/@rocicorp/logger/out/logger.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * A [[LogSink]] implementation that logs to multiple sinks.
 */ __turbopack_context__.s([
    "ConsoleLogger",
    ()=>ConsoleLogger,
    "FormatLogger",
    ()=>FormatLogger,
    "LogContext",
    ()=>LogContext,
    "OptionalLoggerImpl",
    ()=>OptionalLoggerImpl,
    "SilentLogger",
    ()=>SilentLogger,
    "TeeLogSink",
    ()=>TeeLogSink,
    "consoleLogSink",
    ()=>consoleLogSink,
    "logLevelPrefix",
    ()=>logLevelPrefix,
    "nodeConsoleLogSink",
    ()=>nodeConsoleLogSink
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_init.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_class_private_field_set.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
;
;
;
var _sinks = /*#__PURE__*/ new WeakMap();
class TeeLogSink {
    log(level, context) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            args[_key - 2] = arguments[_key];
        }
        for (const logger of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _sinks)){
            logger.log(level, context, ...args);
        }
    }
    async flush() {
        await Promise.all((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _sinks).map((logger)=>{
            var _logger_flush;
            return (_logger_flush = logger.flush) === null || _logger_flush === void 0 ? void 0 : _logger_flush.call(logger);
        }));
    }
    constructor(sinks){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _sinks, {
            writable: true,
            value: void 0
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _sinks, sinks);
    }
}
class OptionalLoggerImpl {
    constructor(logSink, level = 'info', context){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "debug", undefined);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "info", undefined);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "warn", undefined);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "error", undefined);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "flush", void 0);
        const impl = (level)=>function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return logSink.log(level, context, ...args);
            };
        /* eslint-disable no-fallthrough , @typescript-eslint/ban-ts-comment */ switch(level){
            // @ts-ignore
            case 'debug':
                this.debug = impl('debug');
            // @ts-ignore
            case 'info':
                this.info = impl('info');
            // @ts-ignore
            case 'warn':
                this.warn = impl('warn');
            // @ts-ignore
            case 'error':
                this.error = impl('error');
        }
        /* eslint-enable @typescript-eslint/ban-ts-comment, no-fallthrough */ this.flush = ()=>{
            var _logSink_flush;
            var _logSink_flush1;
            return (_logSink_flush1 = (_logSink_flush = logSink.flush) === null || _logSink_flush === void 0 ? void 0 : _logSink_flush.call(logSink)) !== null && _logSink_flush1 !== void 0 ? _logSink_flush1 : Promise.resolve();
        };
    }
}
class ConsoleLogger extends OptionalLoggerImpl {
    constructor(level, context){
        super(consoleLogSink, level, context);
    }
}
const consoleLogSink = {
    log (level, context) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            args[_key - 2] = arguments[_key];
        }
        console[level](...stringified(context), ...args.map(normalizeArgument));
    }
};
var _format = /*#__PURE__*/ new WeakMap();
class FormatLogger {
    log(level, context) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            args[_key - 2] = arguments[_key];
        }
        console[level](...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _format).call(this, level, ...stringified(context), ...args));
    }
    constructor(format){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _format, {
            writable: true,
            value: void 0
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _format, format);
    }
}
const nodeConsoleLogSink = {
    log (level, context) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            args[_key - 2] = arguments[_key];
        }
        console[level](logLevelPrefix[level], ...stringified(context), ...args.map(normalizeArgument));
    }
};
const logLevelPrefix = {
    error: 'ERR',
    warn: 'WRN',
    info: 'INF',
    debug: 'DBG'
};
class SilentLogger {
}
var _logSink = /*#__PURE__*/ new WeakMap(), _level = /*#__PURE__*/ new WeakMap(), _context = /*#__PURE__*/ new WeakMap();
class LogContext extends OptionalLoggerImpl {
    /**
     * Creates a new Logger that with the given key and value
     * added to the logged Context.
     */ withContext(key, value) {
        const ctx = {
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _context),
            [key]: value
        };
        return new LogContext((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _level), ctx, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _logSink));
    }
    constructor(level = 'info', context, logSink = consoleLogSink){
        super(logSink, level, context), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _logSink, {
            writable: true,
            value: void 0
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _level, {
            writable: true,
            value: void 0
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _context, {
            writable: true,
            value: void 0
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _level, level);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _logSink, logSink);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$swc$2b$helpers$40$0$2e$5$2e$15$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_private_field_set$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _context, context);
    }
}
function stringified(context) {
    const args = [];
    for (const [k, v] of Object.entries(context !== null && context !== void 0 ? context : {})){
        const arg = v === undefined ? k : "".concat(k, "=").concat(v);
        args.push(arg);
    }
    return args;
}
function normalizeArgument(v) {
    switch(typeof v){
        case 'string':
        case 'number':
        case 'boolean':
        case 'undefined':
        case 'symbol':
        case 'bigint':
            return v;
        case 'object':
            if (v === null) {
                return null;
            }
            break;
    }
    return JSON.stringify(v, errorReplacer);
}
function errorReplacer(_key, v) {
    if (v instanceof Error) {
        return {
            name: v.name,
            message: v.message,
            stack: v.stack,
            ...'cause' in v ? {
                cause: v.cause
            } : null
        };
    }
    return v;
}
}),
]);

//# sourceMappingURL=node_modules__pnpm_e7fefa45._.js.map