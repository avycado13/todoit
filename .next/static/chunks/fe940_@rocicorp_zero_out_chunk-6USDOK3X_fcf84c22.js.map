{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/call-default-fetch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/error-responses.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/http-request-info.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/patch-operation.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/get-default-puller.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/idb-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/browser-env.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/write-impl-base.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/make-idb-name.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/abort-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/sleep.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/bg-interval.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/gc.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/key.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/store-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/deleted-clients.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/navigator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/mem-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/read-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/write-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/idb-store-with-mem-fallback.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/get-kv-store-provider.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/log-options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/idb-databases-store-db-name.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/idb-databases-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/collect-idb-databases.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/transaction-closed-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/custom-queries.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/error-kind-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/builder/table-builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/client-schema.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/builder/schema-builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/update-needed-reason-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/replicache-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/document-visible.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/connection-loop-delegates.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/connection-loop.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/lazy-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/transactions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/scan-iterator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/scan-options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/rebase.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/get-default-pusher.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/http-status-unauthorized.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/report-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/to-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/handle-pull-response-result-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/pull-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/sync-head-name.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/pull.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/pusher.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/push.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/mutation-recovery.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/broadcast-channel.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/new-client-channel.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/on-persist-channel.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/pending-mutations.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/client-gc.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/client-group-gc.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/heartbeat.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/visitor.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/gather-mem-only-visitor.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/persist.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/gather-not-cached-visitor.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/refresh.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/process-scheduler.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/request-idle.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/set-interval-with-signal.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/subscriptions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/invoke-kind-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/request-id.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/subscribable.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/delete-clients.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/queries-patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/connect.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/mutation-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/push.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/mutations-patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/row-patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/poke.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/pong.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/pull.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/down.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/protocol-version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/name-mapper.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/mutate/custom.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/metrics-delegate.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/util/socket.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/active-clients-manager.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/connection-state-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/memory-storage.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/btree-set.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/measure-push-operator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/constraint.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/memory-source.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/ivm-branch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/context.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/crud.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/sentinels.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/custom.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/delete-clients-manager.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/enable-analytics.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/http-string.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/log-options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/datadog/src/datadog-log-sink.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/metric-name-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/metrics.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/mutation-tracker.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/ping-result-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/query-manager.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/reload-error-handler.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/server-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/server-option.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero-log-context.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero-poke-handler.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero-rep.ts"],"sourcesContent":["import type {HTTPRequestInfo} from './http-request-info.ts';\n\n/**\n * Helper function for {@link getDefaultPuller} and {@link getDefaultPusher}.\n */\nexport async function callDefaultFetch<Body>(\n  url: string,\n  auth: string,\n  requestID: string,\n  requestBody: Body,\n): Promise<readonly [Response | undefined, HTTPRequestInfo]> {\n  const init = {\n    headers: {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'Content-type': 'application/json',\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'Authorization': auth,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'X-Replicache-RequestID': requestID,\n    },\n    body: JSON.stringify(requestBody),\n    method: 'POST',\n  };\n  const request = new Request(url, init);\n  const response = await fetch(request);\n  const httpStatusCode = response.status;\n  if (httpStatusCode !== 200) {\n    return [\n      undefined,\n      {\n        httpStatusCode,\n        errorMessage: await response.text(),\n      },\n    ];\n  }\n  return [\n    response,\n    {\n      httpStatusCode,\n      errorMessage: '',\n    },\n  ];\n}\n","import {assert} from '../../shared/src/asserts.ts';\n\nfunction isError(obj: unknown, type: string): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    (obj as {error: unknown}).error === type\n  );\n}\n\ntype ErrorResponse = {error: string};\n\nexport function isErrorResponse(obj: object): obj is ErrorResponse {\n  return typeof (obj as {error: unknown}).error === 'string';\n}\n\n/**\n * In certain scenarios the server can signal that it does not know about the\n * client. For example, the server might have lost all of its state (this might\n * happen during the development of the server).\n */\nexport type ClientStateNotFoundResponse = {\n  error: 'ClientStateNotFound';\n};\n\nexport function isClientStateNotFoundResponse(\n  v: unknown,\n): v is ClientStateNotFoundResponse {\n  return isError(v, 'ClientStateNotFound');\n}\n\n/**\n * The server endpoint may respond with a `VersionNotSupported` error if it does\n * not know how to handle the pull, push or schema version.\n */\nexport type VersionNotSupportedResponse = {\n  error: 'VersionNotSupported';\n  versionType?: 'pull' | 'push' | 'schema' | undefined;\n};\n\nexport function isVersionNotSupportedResponse(\n  v: unknown,\n): v is VersionNotSupportedResponse {\n  if (!isError(v, 'VersionNotSupported')) {\n    return false;\n  }\n\n  const {versionType} = v as Record<string, unknown>;\n  switch (versionType) {\n    case undefined:\n    case 'pull':\n    case 'push':\n    case 'schema':\n      return true;\n  }\n\n  return false;\n}\n\nexport function assertVersionNotSupportedResponse(\n  v: unknown,\n): asserts v is VersionNotSupportedResponse {\n  assert(isVersionNotSupportedResponse(v));\n}\n","import {\n  assertNumber,\n  assertObject,\n  assertString,\n} from '../../shared/src/asserts.ts';\n\nexport function assertHTTPRequestInfo(\n  v: unknown,\n): asserts v is HTTPRequestInfo {\n  assertObject(v);\n  assertNumber(v.httpStatusCode);\n  assertString(v.errorMessage);\n}\n\nexport type HTTPRequestInfo = {\n  httpStatusCode: number;\n  errorMessage: string;\n};\n","import {\n  assertArray,\n  assertObject,\n  assertString,\n} from '../../shared/src/asserts.ts';\nimport {\n  type ReadonlyJSONObject,\n  type ReadonlyJSONValue,\n  assertJSONObject,\n  assertJSONValue,\n} from '../../shared/src/json.ts';\n\nexport type PatchOperationInternal =\n  | {\n      readonly op: 'put';\n      readonly key: string;\n      readonly value: ReadonlyJSONValue;\n    }\n  | {\n      readonly op: 'update';\n      readonly key: string;\n      readonly merge?: ReadonlyJSONObject | undefined;\n      readonly constrain?: readonly string[] | undefined;\n    }\n  | {\n      readonly op: 'del';\n      readonly key: string;\n    }\n  | {\n      readonly op: 'clear';\n    };\n\n/**\n * This type describes the patch field in a {@link PullResponse} and it is used\n * to describe how to update the Replicache key-value store.\n */\nexport type PatchOperation =\n  | {\n      readonly op: 'put';\n      readonly key: string;\n      readonly value: ReadonlyJSONValue;\n    }\n  | {\n      readonly op: 'del';\n      readonly key: string;\n    }\n  | {\n      readonly op: 'clear';\n    };\n\nexport function assertPatchOperations(\n  p: unknown,\n): asserts p is PatchOperationInternal[] {\n  assertArray(p);\n  for (const item of p) {\n    assertPatchOperation(item);\n  }\n}\n\nfunction assertPatchOperation(p: unknown): asserts p is PatchOperationInternal {\n  assertObject(p);\n  switch (p.op) {\n    case 'put':\n      assertString(p.key);\n      assertJSONValue(p.value);\n      break;\n    case 'update':\n      assertString(p.key);\n      if (p.merge !== undefined) {\n        assertJSONObject(p.merge);\n      }\n      if (p.constrain !== undefined) {\n        assertArray(p.constrain);\n        for (const key of p.constrain) {\n          assertString(key);\n        }\n      }\n      break;\n    case 'del':\n      assertString(p.key);\n      break;\n    case 'clear':\n      break;\n    default:\n      throw new Error(\n        `unknown patch op \\`${p.op}\\`, expected one of \\`put\\`, \\`del\\`, \\`clear\\``,\n      );\n  }\n}\n","import {\n  assertNumber,\n  assertObject,\n  assertString,\n} from '../../shared/src/asserts.ts';\nimport {callDefaultFetch} from './call-default-fetch.ts';\nimport {assertCookie} from './cookies.ts';\nimport {\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n} from './error-responses.ts';\nimport {assertHTTPRequestInfo} from './http-request-info.ts';\nimport {assertPatchOperations} from './patch-operation.ts';\nimport type {\n  PullResponseV1,\n  Puller,\n  PullerResult,\n  PullerResultV1,\n} from './puller.ts';\nimport type {PullRequest} from './sync/pull.ts';\n\n/**\n * This creates a default puller which uses HTTP POST to send the pull request.\n */\nexport function getDefaultPuller(rep: {pullURL: string; auth: string}): Puller {\n  async function puller(\n    requestBody: PullRequest,\n    requestID: string,\n  ): Promise<PullerResult> {\n    const [response, httpRequestInfo] = await callDefaultFetch(\n      rep.pullURL,\n      rep.auth,\n      requestID,\n      requestBody,\n    );\n    if (!response) {\n      return {httpRequestInfo};\n    }\n\n    return {\n      response: await response.json(),\n      httpRequestInfo,\n    };\n  }\n\n  defaultPullers.add(puller);\n  return puller;\n}\n\nconst defaultPullers = new WeakSet();\n\nexport function isDefaultPuller(puller: Puller): boolean {\n  return defaultPullers.has(puller);\n}\n\nexport function assertPullResponseV1(v: unknown): asserts v is PullResponseV1 {\n  assertObject(v);\n  if (isClientStateNotFoundResponse(v) || isVersionNotSupportedResponse(v)) {\n    return;\n  }\n  const v2 = v as Record<string, unknown>;\n  if (v2.cookie !== undefined) {\n    assertCookie(v2.cookie);\n  }\n  assertLastMutationIDChanges(v2.lastMutationIDChanges);\n  assertPatchOperations(v2.patch);\n}\n\nfunction assertLastMutationIDChanges(\n  lastMutationIDChanges: unknown,\n): asserts lastMutationIDChanges is Record<string, number> {\n  assertObject(lastMutationIDChanges);\n  for (const [key, value] of Object.entries(lastMutationIDChanges)) {\n    assertString(key);\n    assertNumber(value);\n  }\n}\n\nexport function assertPullerResultV1(v: unknown): asserts v is PullerResultV1 {\n  assertObject(v);\n  assertHTTPRequestInfo(v.httpRequestInfo);\n  if (v.response !== undefined) {\n    assertPullResponseV1(v.response);\n  }\n}\n","import {resolver} from '@rocicorp/resolver';\nimport {assertNotNull} from '../../../shared/src/asserts.ts';\nimport {mustGetBrowserGlobal} from '../../../shared/src/browser-env.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport {\n  type FrozenJSONValue,\n  deepFreezeAllowUndefined,\n} from '../frozen-json.ts';\nimport type {Read, Store, Write} from './store.ts';\nimport {WriteImplBase, deleteSentinel} from './write-impl-base.ts';\n\nconst RELAXED = {durability: 'relaxed'} as const;\nconst OBJECT_STORE = 'chunks';\n\nexport class IDBStore implements Store {\n  #db: Promise<IDBDatabase>;\n  #closed = false;\n  #idbDeleted = false;\n\n  constructor(name: string) {\n    this.#db = openDatabase(name);\n  }\n\n  read(): Promise<Read> {\n    return this.#withReopen(readImpl);\n  }\n\n  write(): Promise<Write> {\n    return this.#withReopen(writeImpl);\n  }\n\n  async close(): Promise<void> {\n    if (!this.#idbDeleted) {\n      const db = await this.#db;\n      db.close();\n    }\n    this.#closed = true;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  async #withReopen<R>(fn: (db: IDBDatabase) => R): Promise<R> {\n    // Tries to reopen an IndexedDB, and rejects if the database needs\n    // upgrading (is missing for whatever reason).\n    const reopenExistingDB = async (name: string): Promise<IDBDatabase> => {\n      const {promise, resolve, reject} = resolver<IDBDatabase>();\n      const req = indexedDB.open(name);\n\n      req.onupgradeneeded = () => {\n        const tx = req.transaction;\n        assertNotNull(tx);\n        tx.abort();\n        this.#idbDeleted = true;\n        reject(\n          new IDBNotFoundError(\n            `Expected IndexedDB not found: ${name}. This likely means that the user deleted IndexedDB instances while the app was running. This is non-fatal. The app will continue running in memory until reload.`,\n          ),\n        );\n      };\n\n      req.onsuccess = () => resolve(req.result);\n      req.onerror = () => reject(req.error);\n\n      const db = await promise;\n      db.onversionchange = () => db.close();\n      return db;\n    };\n\n    // We abstract on `readImpl` to work around an issue in Safari. Safari does\n    // not allow any microtask between a transaction is created until it is\n    // first used. We used to use `await read()` here instead of `await\n    // this._db` but then there is a microtask between the creation of the\n    // transaction and the return of this function. By doing `await this._db`\n    // here we only await the db and no await is involved with the transaction.\n    // See https://github.com/jakearchibald/idb-keyval/commit/1af0a00b1a70a678d2f9cf5e74c55a22e57324c5#r55989916\n    const db = await this.#db;\n\n    try {\n      return fn(db);\n    } catch (e: unknown) {\n      if (!this.#closed && e instanceof DOMException) {\n        if (e.name === 'InvalidStateError') {\n          this.#db = reopenExistingDB(db.name);\n          const reopened = await this.#db;\n          return fn(reopened);\n        } else if (e.name === 'NotFoundError') {\n          // This edge-case can happen if the db has been deleted and the\n          // user/developer has DevTools open in certain browsers.\n          // See discussion at https://github.com/rocicorp/replicache-internal/pull/216\n          this.#idbDeleted = true;\n          mustGetBrowserGlobal('indexedDB').deleteDatabase(db.name);\n          throw new IDBNotFoundError(\n            `Expected IndexedDB ${db.name} missing object store. Deleting db. This is non-fatal, the app will continue working in memory until it is reloaded.`,\n          );\n        }\n      }\n      throw e;\n    }\n  }\n}\n\nclass ReadImpl implements Read {\n  readonly #tx: IDBTransaction;\n  #closed = false;\n\n  constructor(tx: IDBTransaction) {\n    this.#tx = tx;\n  }\n\n  has(key: string): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const req = objectStore(this.#tx).count(key);\n      req.onsuccess = () => resolve(req.result > 0);\n      req.onerror = () => reject(req.error);\n    });\n  }\n\n  get(key: string): Promise<FrozenJSONValue | undefined> {\n    return new Promise((resolve, reject) => {\n      const req = objectStore(this.#tx).get(key);\n      req.onsuccess = () => resolve(deepFreezeAllowUndefined(req.result));\n      req.onerror = () => reject(req.error);\n    });\n  }\n\n  release(): void {\n    this.#closed = true;\n    // Do nothing. We rely on IDB locking.\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n}\n\nclass WriteImpl extends WriteImplBase {\n  readonly #tx: IDBTransaction;\n  #closed = false;\n\n  constructor(tx: IDBTransaction) {\n    super(new ReadImpl(tx));\n    this.#tx = tx;\n  }\n\n  commit(): Promise<void> {\n    if (this._pending.size === 0) {\n      return promiseVoid;\n    }\n\n    return new Promise((resolve, reject) => {\n      const tx = this.#tx;\n      const store = objectStore(tx);\n      for (const [key, val] of this._pending) {\n        if (val === deleteSentinel) {\n          store.delete(key);\n        } else {\n          store.put(val, key);\n        }\n      }\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  release(): void {\n    // We rely on IDB locking so no need to do anything here.\n    this.#closed = true;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n}\n\nfunction writeImpl(db: IDBDatabase): Write {\n  const tx = db.transaction(OBJECT_STORE, 'readwrite', RELAXED);\n  return new WriteImpl(tx);\n}\n\nfunction readImpl(db: IDBDatabase): Read {\n  const tx = db.transaction(OBJECT_STORE, 'readonly');\n  return new ReadImpl(tx);\n}\n\nfunction objectStore(tx: IDBTransaction): IDBObjectStore {\n  return tx.objectStore(OBJECT_STORE);\n}\n\nfunction openDatabase(name: string): Promise<IDBDatabase> {\n  const idb = mustGetBrowserGlobal('indexedDB');\n  return new Promise((resolve, reject) => {\n    const req = idb.open(name);\n    req.onupgradeneeded = () => {\n      req.result.createObjectStore(OBJECT_STORE);\n    };\n    req.onsuccess = () => {\n      const db = req.result;\n      // Another tab/process wants to modify the db, so release it.\n      db.onversionchange = () => db.close();\n      resolve(db);\n    };\n    req.onerror = () => reject(req.error);\n  });\n}\n\n/**\n * This error is thrown when we detect that the IndexedDB has been removed. This\n * does not normally happen but can happen during development if the user has\n * DevTools open and deletes the IndexedDB from there.\n */\nexport class IDBNotFoundError extends Error {\n  name = 'IDBNotFoundError';\n}\n","// Helpers for some objects from the browser environment. These are wrapped in\n// functions because Replicache runs in environments that do not have these\n// objects (such as Web Workers, Deno etc).\n\ntype GlobalThis = typeof globalThis;\n\nconst overrides = new Map<keyof GlobalThis, GlobalThis[keyof GlobalThis]>();\n\nexport function overrideBrowserGlobal<T extends keyof GlobalThis>(\n  name: T,\n  value: GlobalThis[T],\n) {\n  overrides.set(name, value);\n}\n\nexport function clearBrowserOverrides() {\n  overrides.clear();\n}\n\nexport function getBrowserGlobal<T extends keyof GlobalThis>(\n  name: T,\n): GlobalThis[T] | undefined {\n  if (overrides.has(name)) {\n    return overrides.get(name);\n  }\n  return globalThis[name];\n}\n\n/**\n * Returns the global method with the given name, bound to the global object.\n * This is important because some methods (e.g. `requestAnimationFrame`) are not\n * bound to the global object by default.\n *\n * If you end up using {@linkcode getBrowserGlobal} instead in a case like this:\n *\n * ```js\n * this.#raf = getBrowserGlobal('requestAnimationFrame') ?? rafFallback;\n * ...\n * this.#raf(() => ...);\n * ```\n *\n * You will end up with `Uncaught TypeError: Illegal invocation` because `this`\n * is not bound to the global object\n */\nexport function getBrowserGlobalMethod<T extends keyof GlobalThis>(\n  name: T,\n): GlobalThis[T] | undefined {\n  return getBrowserGlobal(name)?.bind(globalThis);\n}\n\nexport function mustGetBrowserGlobal<T extends keyof GlobalThis>(\n  name: T,\n): GlobalThis[T] {\n  const r = getBrowserGlobal(name);\n  if (r === undefined) {\n    throw new Error(\n      `Unsupported JavaScript environment: Could not find ${name}.`,\n    );\n  }\n  return r;\n}\n","import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {\n  promiseFalse,\n  promiseTrue,\n  promiseVoid,\n} from '../../../shared/src/resolved-promises.ts';\nimport {\n  type FrozenJSONValue,\n  deepFreeze,\n  deepFreezeAllowUndefined,\n} from '../frozen-json.ts';\nimport type {Read} from './store.ts';\n\nexport const deleteSentinel = Symbol();\ntype DeleteSentinel = typeof deleteSentinel;\n\nexport class WriteImplBase {\n  protected readonly _pending: Map<string, FrozenJSONValue | DeleteSentinel> =\n    new Map();\n  readonly #read: Read;\n\n  constructor(read: Read) {\n    this.#read = read;\n  }\n\n  has(key: string): Promise<boolean> {\n    switch (this._pending.get(key)) {\n      case undefined:\n        return this.#read.has(key);\n      case deleteSentinel:\n        return promiseFalse;\n      default:\n        return promiseTrue;\n    }\n  }\n\n  async get(key: string): Promise<FrozenJSONValue | undefined> {\n    const v = this._pending.get(key);\n    switch (v) {\n      case deleteSentinel:\n        return undefined;\n      case undefined: {\n        const v = await this.#read.get(key);\n        return deepFreezeAllowUndefined(v);\n      }\n      default:\n        return v;\n    }\n  }\n\n  put(key: string, value: ReadonlyJSONValue): Promise<void> {\n    this._pending.set(key, deepFreeze(value));\n    return promiseVoid;\n  }\n\n  del(key: string): Promise<void> {\n    this._pending.set(key, deleteSentinel);\n    return promiseVoid;\n  }\n\n  release(): void {\n    this.#read.release();\n  }\n\n  get closed(): boolean {\n    return this.#read.closed;\n  }\n}\n","import * as FormatVersion from './format-version-enum.ts';\n\n/**\n * Returns the name of the IDB database that will be used for a particular Replicache instance.\n * @param name The name of the Replicache instance (i.e., the `name` field of `ReplicacheOptions`).\n * @param schemaVersion The schema version of the database (i.e., the `schemaVersion` field of `ReplicacheOptions`).\n * @returns\n */\n\nexport function makeIDBName(name: string, schemaVersion?: string): string {\n  return makeIDBNameInternal(name, schemaVersion, FormatVersion.Latest);\n}\n\nfunction makeIDBNameInternal(\n  name: string,\n  schemaVersion: string | undefined,\n  formatVersion: number,\n): string {\n  const n = `rep:${name}:${formatVersion}`;\n  return schemaVersion ? `${n}:${schemaVersion}` : n;\n}\n\nexport {makeIDBNameInternal as makeIDBNameForTesting};\n","export class AbortError extends Error {\n  name = 'AbortError';\n}\n","import {resolver} from '@rocicorp/resolver';\nimport {AbortError} from './abort-error.ts';\n\nconst promiseVoid = Promise.resolve();\nconst promiseNever = new Promise<void>(() => undefined);\n\n/**\n * Creates a promise that resolves after `ms` milliseconds. Note that if you\n * pass in `0` no `setTimeout` is used and the promise resolves immediately. In\n * other words no macro task is used in that case.\n *\n * Pass in an AbortSignal to clear the timeout.\n */\nexport function sleep(ms: number, signal?: AbortSignal): Promise<void> {\n  const newAbortError = () => new AbortError('Aborted');\n\n  if (signal?.aborted) {\n    return Promise.reject(newAbortError());\n  }\n\n  if (ms === 0) {\n    return promiseVoid;\n  }\n\n  return new Promise((resolve, reject) => {\n    let handleAbort: () => void;\n    if (signal) {\n      handleAbort = () => {\n        clearTimeout(id);\n        reject(newAbortError());\n      };\n      signal.addEventListener('abort', handleAbort, {once: true});\n    }\n\n    const id = setTimeout(() => {\n      resolve();\n      signal?.removeEventListener('abort', handleAbort);\n    }, ms);\n  });\n}\n\n/**\n * Returns a pair of promises. The first promise resolves after `ms` milliseconds\n * unless the AbortSignal is aborted. The second promise resolves when the AbortSignal\n * is aborted.\n */\nexport function sleepWithAbort(\n  ms: number,\n  signal: AbortSignal,\n): [ok: Promise<void>, aborted: Promise<void>] {\n  if (ms === 0) {\n    return [promiseVoid, promiseNever];\n  }\n\n  const {promise: abortedPromise, resolve: abortedResolve} = resolver<void>();\n\n  const sleepPromise = new Promise<void>(resolve => {\n    const handleAbort = () => {\n      clearTimeout(id);\n      abortedResolve();\n    };\n\n    const id = setTimeout(() => {\n      resolve();\n      signal.removeEventListener('abort', handleAbort);\n    }, ms);\n\n    signal.addEventListener('abort', handleAbort, {once: true});\n  });\n\n  return [sleepPromise, abortedPromise];\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {AbortError} from '../../shared/src/abort-error.ts';\nimport {sleep} from '../../shared/src/sleep.ts';\n\nexport function initBgIntervalProcess(\n  processName: string,\n  process: () => Promise<unknown>,\n  delayMs: () => number,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  void runBgIntervalProcess(processName, process, delayMs, lc, signal);\n}\n\nasync function runBgIntervalProcess(\n  processName: string,\n  process: () => Promise<unknown>,\n  delayMs: () => number,\n  lc: LogContext,\n  signal: AbortSignal,\n): Promise<void> {\n  if (signal.aborted) {\n    return;\n  }\n  lc = lc.withContext('bgIntervalProcess', processName);\n  lc.debug?.('Starting');\n  while (!signal.aborted) {\n    try {\n      await sleep(delayMs(), signal);\n    } catch (e) {\n      if (!(e instanceof AbortError)) {\n        throw e;\n      }\n    }\n    if (!signal.aborted) {\n      lc.debug?.('Running');\n      try {\n        await process();\n      } catch (e) {\n        if (signal.aborted) {\n          lc.debug?.('Error running most likely due to close.', e);\n        } else {\n          lc.error?.('Error running.', e);\n        }\n      }\n    }\n  }\n  lc.debug?.('Stopping');\n}\n","import {assert, assertNumber} from '../../../shared/src/asserts.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport {skipGCAsserts} from '../config.ts';\nimport {type Hash, emptyHash} from '../hash.ts';\n\nexport type HeadChange = {\n  new: Hash | undefined;\n  old: Hash | undefined;\n};\n\ntype LoadedRefCountPromises = Map<Hash, Promise<number>>;\n\nexport interface RefCountUpdatesDelegate {\n  getRefCount: (hash: Hash) => MaybePromise<number | undefined>;\n  getRefs: (hash: Hash) => MaybePromise<readonly Hash[] | undefined>;\n  /**\n   * Should be implemented if the store lazily loads refs, returning whether\n   * or not the chunks refs have already been counted (i.e. are reflected\n   * in `getRefCount`).\n   *\n   * If defined then:\n   *  - `getRefs` should return undefined for refs that have not been loaded,\n   *    but should never return undefined for hashes in `putChunks`.\n   *  - it is assumed that chunks in `putChunks` may have been reachable before\n   *    the write, but may not have been counted.  This method is used to\n   *    determine if they have been counted or not.  If they have not been\n   *    counted, and are reachable with the write applied, the returned\n   *    ref count updates will include updates for counting them.\n   *\n   * If undefined then:\n   *  - `getRefs` should never return undefined\n   *  - it is assumed that the refs of any chunks which were reachable before\n   *    the write are already counted\n   */\n  areRefsCounted?: (hash: Hash) => boolean;\n}\n\n/**\n * Computes how ref counts should be updated when a dag write is committed.\n * Does not modify the dag store.\n * @param headChanges Heads that were changed by the dag write.\n * @param putChunks Chunks that were put by the dag write.\n * @param delegate Delegate used for getting ref information from the dag store.\n * @returns Map from chunk Hash to changed ref counts.  Chunks with a new ref\n * count of 0 should be deleted.  All hashes in `putChunks` will have an entry\n * (which will be zero if the newly put chunk is not reachable from any head).\n */\nexport function computeRefCountUpdates(\n  headChanges: Iterable<HeadChange>,\n  putChunks: ReadonlySet<Hash>,\n  delegate: RefCountUpdatesDelegate,\n): Promise<Map<Hash, number>> {\n  return new RefCountUpdates(headChanges, putChunks, delegate).compute();\n}\n\nclass RefCountUpdates {\n  readonly #newHeads: Hash[];\n  readonly #oldHeads: Hash[];\n  readonly #putChunks: ReadonlySet<Hash>;\n  readonly #delegate: RefCountUpdatesDelegate;\n  readonly #refsCounted: Set<Hash> | null;\n  readonly #refCountUpdates: Map<Hash, number>;\n  readonly #loadedRefCountPromises: LoadedRefCountPromises;\n  readonly #isLazyDelegate: boolean;\n\n  constructor(\n    headChanges: Iterable<HeadChange>,\n    putChunks: ReadonlySet<Hash>,\n    delegate: RefCountUpdatesDelegate,\n  ) {\n    const newHeads: Hash[] = [];\n    const oldHeads: Hash[] = [];\n    for (const changedHead of headChanges) {\n      if (changedHead.old !== changedHead.new) {\n        changedHead.old && oldHeads.push(changedHead.old);\n        changedHead.new && newHeads.push(changedHead.new);\n      }\n    }\n    this.#newHeads = newHeads;\n    this.#oldHeads = oldHeads;\n    this.#putChunks = putChunks;\n    this.#delegate = delegate;\n    this.#refCountUpdates = new Map();\n    // This map is used to ensure we do not load the ref count key more than once.\n    // Once it is loaded we only operate on a cache of the ref counts.\n    this.#loadedRefCountPromises = new Map();\n    this.#isLazyDelegate = delegate.areRefsCounted !== undefined;\n    this.#refsCounted = this.#isLazyDelegate ? new Set() : null;\n  }\n\n  async compute(): Promise<Map<Hash, number>> {\n    for (const n of this.#newHeads) {\n      await this.#changeRefCount(n, 1);\n    }\n\n    // Now go through the put chunks to ensure each has an entry in\n    // refCountUpdates (zero for new chunks which are not reachable from\n    // newHeads).\n    await Promise.all(\n      Array.from(this.#putChunks.values(), hash =>\n        this.#ensureRefCountLoaded(hash),\n      ),\n    );\n\n    if (this.#isLazyDelegate) {\n      assert(this.#delegate.areRefsCounted);\n      assert(this.#refsCounted);\n      let refCountsUpdated;\n      do {\n        refCountsUpdated = false;\n        for (const hash of this.#putChunks.values()) {\n          if (\n            !this.#delegate.areRefsCounted(hash) &&\n            !this.#refsCounted.has(hash) &&\n            this.#refCountUpdates.get(hash) !== 0\n          ) {\n            await this.#updateRefsCounts(hash, 1);\n            refCountsUpdated = true;\n            break;\n          }\n        }\n      } while (refCountsUpdated);\n    }\n\n    for (const o of this.#oldHeads) {\n      await this.#changeRefCount(o, -1);\n    }\n\n    if (!skipGCAsserts) {\n      for (const [hash, update] of this.#refCountUpdates) {\n        assert(\n          update >= 0,\n          `ref count update must be non-negative. ${hash}:${update}`,\n        );\n      }\n    }\n\n    return this.#refCountUpdates;\n  }\n\n  async #changeRefCount(hash: Hash, delta: number): Promise<void> {\n    // First make sure that we have the ref count in the cache. This is async\n    // because it might need to load the ref count from the store (via the delegate).\n    //\n    // Once we have loaded the ref count all the updates to it are sync to\n    // prevent race conditions.\n    await this.#ensureRefCountLoaded(hash);\n    if (this.#updateRefCount(hash, delta)) {\n      await this.#updateRefsCounts(hash, delta);\n    }\n  }\n\n  async #updateRefsCounts(hash: Hash, delta: number) {\n    if (hash === emptyHash) {\n      return;\n    }\n    const refs = await this.#delegate.getRefs(hash);\n    if (!skipGCAsserts) {\n      assert(\n        refs || (this.#isLazyDelegate && !this.#putChunks.has(hash)),\n        'refs must be defined',\n      );\n    }\n\n    if (refs !== undefined) {\n      this.#refsCounted?.add(hash);\n      const ps = refs.map(ref => this.#changeRefCount(ref, delta));\n      await Promise.all(ps);\n    }\n  }\n\n  #ensureRefCountLoaded(hash: Hash): Promise<number> {\n    // Only get the ref count once.\n    let p = this.#loadedRefCountPromises.get(hash);\n    if (p === undefined) {\n      p = (async () => {\n        const value = (await this.#delegate.getRefCount(hash)) || 0;\n        this.#refCountUpdates.set(hash, value);\n        return value;\n      })();\n      this.#loadedRefCountPromises.set(hash, p);\n    }\n    return p;\n  }\n\n  #updateRefCount(hash: Hash, delta: number): boolean {\n    const oldCount = this.#refCountUpdates.get(hash);\n    assertNumber(oldCount);\n    this.#refCountUpdates.set(hash, oldCount + delta);\n    return (oldCount === 0 && delta === 1) || (oldCount === 1 && delta === -1);\n  }\n}\n","import {type Hash, parse as parseHash} from '../hash.ts';\nimport * as KeyType from './key-type-enum.ts';\n\nexport function chunkDataKey(hash: Hash): string {\n  return `c/${hash}/d`;\n}\n\nexport function chunkMetaKey(hash: Hash): string {\n  return `c/${hash}/m`;\n}\n\nexport function chunkRefCountKey(hash: Hash): string {\n  return `c/${hash}/r`;\n}\n\nexport function headKey(name: string): string {\n  return `h/${name}`;\n}\n\nexport type Key =\n  | {\n      type: KeyType.ChunkData;\n      hash: Hash;\n    }\n  | {\n      type: KeyType.ChunkMeta;\n      hash: Hash;\n    }\n  | {\n      type: KeyType.ChunkRefCount;\n      hash: Hash;\n    }\n  | {\n      type: KeyType.Head;\n      name: string;\n    };\n\nexport function parse(key: string): Key {\n  const invalidKey = () => new Error(`Invalid key. Got \"${key}\"`);\n  const hash = () => parseHash(key.substring(2, key.length - 2));\n\n  // '/'\n  if (key.charCodeAt(1) === 47) {\n    switch (key.charCodeAt(0)) {\n      // c\n      case 99: {\n        if (key.length < 4 || key.charCodeAt(key.length - 2) !== 47) {\n          throw invalidKey();\n        }\n        switch (key.charCodeAt(key.length - 1)) {\n          case 100: // d\n            return {\n              type: KeyType.ChunkData,\n              hash: hash(),\n            };\n          case 109: // m\n            return {\n              type: KeyType.ChunkMeta,\n              hash: hash(),\n            };\n          case 114: // r\n            return {\n              type: KeyType.ChunkRefCount,\n              hash: hash(),\n            };\n        }\n        break;\n      }\n      case 104: // h\n        return {\n          type: KeyType.Head,\n          name: key.substring(2),\n        };\n    }\n  }\n  throw invalidKey();\n}\n","import {assertNumber} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {type Hash, assertHash} from '../hash.ts';\nimport type {\n  Read as KVRead,\n  Store as KVStore,\n  Write as KVWrite,\n} from '../kv/store.ts';\nimport {\n  Chunk,\n  type ChunkHasher,\n  type Refs,\n  assertRefs,\n  createChunk,\n} from './chunk.ts';\nimport {type RefCountUpdatesDelegate, computeRefCountUpdates} from './gc.ts';\nimport {chunkDataKey, chunkMetaKey, chunkRefCountKey, headKey} from './key.ts';\nimport {type Read, type Store, type Write, mustGetChunk} from './store.ts';\n\nexport class StoreImpl implements Store {\n  readonly #kv: KVStore;\n  readonly #chunkHasher: ChunkHasher;\n  readonly #assertValidHash: (hash: Hash) => void;\n\n  constructor(\n    kv: KVStore,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n  ) {\n    this.#kv = kv;\n    this.#chunkHasher = chunkHasher;\n    this.#assertValidHash = assertValidHash;\n  }\n\n  async read(): Promise<Read> {\n    return new ReadImpl(await this.#kv.read(), this.#assertValidHash);\n  }\n\n  async write(): Promise<Write> {\n    return new WriteImpl(\n      await this.#kv.write(),\n      this.#chunkHasher,\n      this.#assertValidHash,\n    );\n  }\n\n  close(): Promise<void> {\n    return this.#kv.close();\n  }\n}\n\nexport class ReadImpl implements Read {\n  protected readonly _tx: KVRead;\n  readonly assertValidHash: (hash: Hash) => void;\n\n  constructor(kv: KVRead, assertValidHash: (hash: Hash) => void) {\n    this._tx = kv;\n    this.assertValidHash = assertValidHash;\n  }\n\n  hasChunk(hash: Hash): Promise<boolean> {\n    return this._tx.has(chunkDataKey(hash));\n  }\n\n  async getChunk(hash: Hash): Promise<Chunk | undefined> {\n    const data = await this._tx.get(chunkDataKey(hash));\n    if (data === undefined) {\n      return undefined;\n    }\n\n    const refsVal = await this._tx.get(chunkMetaKey(hash));\n    let refs: Refs;\n    if (refsVal !== undefined) {\n      assertRefs(refsVal);\n      refs = refsVal;\n    } else {\n      refs = [];\n    }\n    return new Chunk(hash, data, refs);\n  }\n\n  mustGetChunk(hash: Hash): Promise<Chunk> {\n    return mustGetChunk(this, hash);\n  }\n\n  async getHead(name: string): Promise<Hash | undefined> {\n    const data = await this._tx.get(headKey(name));\n    if (data === undefined) {\n      return undefined;\n    }\n    assertHash(data);\n    return data;\n  }\n\n  release(): void {\n    this._tx.release();\n  }\n\n  get closed(): boolean {\n    return this._tx.closed;\n  }\n}\n\ntype HeadChange = {\n  new: Hash | undefined;\n  old: Hash | undefined;\n};\n\nexport class WriteImpl\n  extends ReadImpl\n  implements Write, RefCountUpdatesDelegate\n{\n  declare protected readonly _tx: KVWrite;\n  readonly #chunkHasher: ChunkHasher;\n\n  readonly #putChunks = new Set<Hash>();\n  readonly #changedHeads = new Map<string, HeadChange>();\n\n  constructor(\n    kvw: KVWrite,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n  ) {\n    super(kvw, assertValidHash);\n    this.#chunkHasher = chunkHasher;\n  }\n\n  createChunk = <V>(data: V, refs: Refs): Chunk<V> =>\n    createChunk(data, refs, this.#chunkHasher);\n\n  get kvWrite(): KVWrite {\n    return this._tx;\n  }\n\n  async putChunk(c: Chunk): Promise<void> {\n    const {hash, data, meta} = c;\n    // We never want to write temp hashes to the underlying store.\n    this.assertValidHash(hash);\n    const key = chunkDataKey(hash);\n    // Commit contains InternalValue and Hash which are opaque types.\n    const p1 = this._tx.put(key, data as ReadonlyJSONValue);\n    let p2;\n    if (meta.length > 0) {\n      for (const h of meta) {\n        this.assertValidHash(h);\n      }\n      p2 = this._tx.put(chunkMetaKey(hash), meta);\n    }\n    this.#putChunks.add(hash);\n    await p1;\n    await p2;\n  }\n\n  setHead(name: string, hash: Hash): Promise<void> {\n    return this.#setHead(name, hash);\n  }\n\n  removeHead(name: string): Promise<void> {\n    return this.#setHead(name, undefined);\n  }\n\n  async #setHead(name: string, hash: Hash | undefined): Promise<void> {\n    const oldHash = await this.getHead(name);\n    const hk = headKey(name);\n\n    let p1: Promise<void>;\n    if (hash === undefined) {\n      p1 = this._tx.del(hk);\n    } else {\n      p1 = this._tx.put(hk, hash);\n    }\n\n    const v = this.#changedHeads.get(name);\n    if (v === undefined) {\n      this.#changedHeads.set(name, {new: hash, old: oldHash});\n    } else {\n      // Keep old if existing\n      v.new = hash;\n    }\n\n    await p1;\n  }\n\n  async commit(): Promise<void> {\n    const refCountUpdates = await computeRefCountUpdates(\n      this.#changedHeads.values(),\n      this.#putChunks,\n      this,\n    );\n    await this.#applyRefCountUpdates(refCountUpdates);\n    await this._tx.commit();\n  }\n\n  async getRefCount(hash: Hash): Promise<number | undefined> {\n    const value = await this._tx.get(chunkRefCountKey(hash));\n    if (value === undefined) {\n      return undefined;\n    }\n    assertNumber(value);\n    if (value < 0 || value > 0xffff || value !== (value | 0)) {\n      throw new Error(\n        `Invalid ref count ${value}. We expect the value to be a Uint16`,\n      );\n    }\n    return value;\n  }\n\n  async getRefs(hash: Hash): Promise<readonly Hash[]> {\n    const meta = await this._tx.get(chunkMetaKey(hash));\n    if (meta === undefined) {\n      return [];\n    }\n    assertRefs(meta);\n    return meta;\n  }\n\n  async #applyRefCountUpdates(refCountCache: Map<Hash, number>): Promise<void> {\n    const ps: Promise<void>[] = [];\n    for (const [hash, count] of refCountCache) {\n      if (count === 0) {\n        ps.push(this.#removeAllRelatedKeys(hash));\n      } else {\n        const refCountKey = chunkRefCountKey(hash);\n        ps.push(this._tx.put(refCountKey, count));\n      }\n    }\n    await Promise.all(ps);\n  }\n\n  async #removeAllRelatedKeys(hash: Hash): Promise<void> {\n    await Promise.all([\n      this._tx.del(chunkDataKey(hash)),\n      this._tx.del(chunkMetaKey(hash)),\n      this._tx.del(chunkRefCountKey(hash)),\n    ]);\n\n    this.#putChunks.delete(hash);\n  }\n\n  release(): void {\n    this._tx.release();\n  }\n}\n","import * as v from '../../shared/src/valita.ts';\nimport type {Read, Write} from './dag/store.ts';\nimport {deepFreeze} from './frozen-json.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\n\n/**\n * We keep track of deleted clients in the {@linkcode DELETED_CLIENTS_HEAD_NAME}\n * head.\n */\nexport const DELETED_CLIENTS_HEAD_NAME = 'deleted-clients';\n\nexport const deletedClientsSchema = v.readonlyObject({\n  clientIDs: v.readonlyArray(v.string()),\n  clientGroupIDs: v.readonlyArray(v.string()),\n});\n\n// Before 11facd03a88b95667d1f171610548de5984dd928 this was an array of strings.\n// We need to allow reading that format.\nconst legacyDeletedClientsSchema = v.readonlyArray(v.string());\n\nexport type DeletedClients = v.Infer<typeof deletedClientsSchema>;\n\nexport async function setDeletedClients(\n  dagWrite: Write,\n  clientIDs: readonly ClientID[],\n  clientGroupIDs: readonly ClientGroupID[],\n): Promise<DeletedClients> {\n  // sort and dedupe\n\n  const data = {\n    clientIDs: normalize(clientIDs),\n    clientGroupIDs: normalize(clientGroupIDs),\n  };\n  const chunkData = deepFreeze(data);\n  const chunk = dagWrite.createChunk(chunkData, []);\n  await dagWrite.putChunk(chunk);\n  await dagWrite.setHead(DELETED_CLIENTS_HEAD_NAME, chunk.hash);\n  return data;\n}\n\nexport async function getDeletedClients(\n  dagRead: Read,\n): Promise<DeletedClients> {\n  const hash = await dagRead.getHead(DELETED_CLIENTS_HEAD_NAME);\n  if (hash === undefined) {\n    return {clientIDs: [], clientGroupIDs: []};\n  }\n  const chunk = await dagRead.mustGetChunk(hash);\n\n  // Try legacy schema\n  const res = v.test(chunk.data, legacyDeletedClientsSchema);\n  if (res.ok) {\n    return {clientIDs: res.value, clientGroupIDs: []};\n  }\n\n  return v.parse(chunk.data, deletedClientsSchema);\n}\n\n/**\n * Adds deleted clients to the {@linkcode DELETED_CLIENTS_HEAD_NAME} head.\n * @returns the new list of deleted clients (sorted and deduped).\n */\nexport async function addDeletedClients(\n  dagWrite: Write,\n  clientIDs: ClientID[],\n  clientGroupIDs: ClientGroupID[],\n): Promise<DeletedClients> {\n  const {clientIDs: oldClientIDs, clientGroupIDs: oldClientGroupIDs} =\n    await getDeletedClients(dagWrite);\n\n  return setDeletedClients(\n    dagWrite,\n    [...oldClientIDs, ...clientIDs],\n    [...oldClientGroupIDs, ...clientGroupIDs],\n  );\n}\n\nexport async function removeDeletedClients(\n  dagWrite: Write,\n  clientIDs: readonly ClientID[],\n  clientGroupIDs: readonly ClientGroupID[],\n): Promise<DeletedClients> {\n  const {clientIDs: oldClientIDs, clientGroupIDs: oldClientGroupIDs} =\n    await getDeletedClients(dagWrite);\n  const newDeletedClients = oldClientIDs.filter(\n    clientID => !clientIDs.includes(clientID),\n  );\n  const newDeletedClientGroups = oldClientGroupIDs.filter(\n    clientGroupID => !clientGroupIDs.includes(clientGroupID),\n  );\n  return setDeletedClients(dagWrite, newDeletedClients, newDeletedClientGroups);\n}\n\n/**\n * Sorts and dedupes the given array.\n */\nexport function normalize<T>(arr: readonly T[]): T[] {\n  return [...new Set(arr)].sort();\n}\n","type Navigator = {\n  onLine: boolean;\n  userAgent: string;\n  // add more as needed\n};\n\nconst localNavigator: Navigator | undefined =\n  typeof navigator !== 'undefined' ? navigator : undefined;\n\nexport {localNavigator as navigator};\n","import {RWLock} from '@rocicorp/lock';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {ReadImpl} from './read-impl.ts';\nimport type {Read, Store, Write} from './store.ts';\nimport {WriteImpl} from './write-impl.ts';\n\ntype StorageMap = Map<string, FrozenJSONValue>;\n\ntype Value = {readonly lock: RWLock; readonly map: StorageMap};\n\nconst stores = new Map<string, Value>();\n\nexport function clearAllNamedMemStoresForTesting(): void {\n  stores.clear();\n}\n\nexport function dropMemStore(name: string): Promise<void> {\n  stores.delete(name);\n  return promiseVoid;\n}\n\nexport function hasMemStore(name: string): boolean {\n  return stores.has(name);\n}\n\n/**\n * A named in-memory Store implementation.\n *\n * Two (or more) named memory stores with the same name will share the same\n * underlying storage. They will also share the same read/write locks, so that\n * only one write transaction can be running at the same time.\n *\n * @experimental This class is experimental and might be removed or changed\n * in the future without following semver versioning. Please be cautious.\n */\nexport class MemStore implements Store {\n  readonly #map: StorageMap;\n  readonly #rwLock: RWLock;\n  #closed = false;\n\n  constructor(name: string) {\n    const entry = stores.get(name);\n    let lock: RWLock;\n    let map: StorageMap;\n    if (entry) {\n      ({lock, map} = entry);\n    } else {\n      lock = new RWLock();\n      map = new Map();\n      stores.set(name, {lock, map});\n    }\n    this.#rwLock = lock;\n    this.#map = map;\n  }\n\n  async read(): Promise<Read> {\n    const release = await this.#rwLock.read();\n    return new ReadImpl(this.#map, release);\n  }\n\n  async write(): Promise<Write> {\n    const release = await this.#rwLock.write();\n    return new WriteImpl(this.#map, release);\n  }\n\n  close(): Promise<void> {\n    this.#closed = true;\n    return promiseVoid;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n}\n","import type {FrozenJSONValue} from '../frozen-json.ts';\nimport type {Read} from './store.ts';\n\nexport class ReadImpl implements Read {\n  readonly #map: Map<string, FrozenJSONValue>;\n  readonly #release: () => void;\n  #closed = false;\n\n  constructor(map: Map<string, FrozenJSONValue>, release: () => void) {\n    this.#map = map;\n    this.#release = release;\n  }\n\n  release() {\n    this.#release();\n    this.#closed = true;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  has(key: string): Promise<boolean> {\n    return Promise.resolve(this.#map.has(key));\n  }\n\n  get(key: string): Promise<FrozenJSONValue | undefined> {\n    return Promise.resolve(this.#map.get(key));\n  }\n}\n","import {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {ReadImpl} from './read-impl.ts';\nimport type {Write} from './store.ts';\nimport {deleteSentinel, WriteImplBase} from './write-impl-base.ts';\n\nexport class WriteImpl extends WriteImplBase implements Write {\n  readonly #map: Map<string, FrozenJSONValue>;\n\n  constructor(map: Map<string, FrozenJSONValue>, release: () => void) {\n    super(new ReadImpl(map, release));\n    this.#map = map;\n  }\n\n  commit(): Promise<void> {\n    // HOT. Do not allocate entry tuple and destructure.\n    this._pending.forEach((value, key) => {\n      if (value === deleteSentinel) {\n        this.#map.delete(key);\n      } else {\n        this.#map.set(key, value);\n      }\n    });\n    this._pending.clear();\n    this.release();\n    return promiseVoid;\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {navigator} from '../../../shared/src/navigator.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport {IDBStore} from './idb-store.ts';\nimport {MemStore, dropMemStore} from './mem-store.ts';\nimport type {Read, Store, Write} from './store.ts';\n\n/**\n * This store uses an {@link IDBStore} by default. If the {@link IDBStore} fails\n * to open the DB with an exception that matches\n * {@link isFirefoxPrivateBrowsingError} we switch out the implementation to use\n * a {@link MemStore} instead.\n *\n * The reason this is relatively complicated is that when {@link IDBStore} is\n * created, it calls `openDatabase` synchronously, but that returns a `Promise`\n * that will reject in the case of Firefox private browsing. We don't await this\n * promise until we call `read` or `write` so we cannot do the switch until\n * then.\n */\n\nexport class IDBStoreWithMemFallback implements Store {\n  readonly #lc: LogContext;\n  readonly #name: string;\n  #store: Store;\n  constructor(lc: LogContext, name: string) {\n    this.#lc = lc;\n    this.#name = name;\n    this.#store = new IDBStore(name);\n  }\n\n  read(): Promise<Read> {\n    return this.#withBrainTransplant(s => s.read());\n  }\n\n  write(): Promise<Write> {\n    return this.#withBrainTransplant(s => s.write());\n  }\n\n  async #withBrainTransplant<T extends Read>(\n    f: (store: Store) => Promise<T>,\n  ): Promise<T> {\n    try {\n      return await f(this.#store);\n    } catch (e) {\n      if (isFirefoxPrivateBrowsingError(e)) {\n        // It is possible that we end up with multiple pending read/write and\n        // they all reject. Make sure we only replace the implementation once.\n        if (this.#store instanceof IDBStore) {\n          this.#lc.info?.(\n            'Switching to MemStore because of Firefox private browsing error',\n          );\n          this.#store = new MemStore(this.#name);\n        }\n        return f(this.#store);\n      }\n      throw e;\n    }\n  }\n\n  close(): Promise<void> {\n    return this.#store.close();\n  }\n\n  get closed(): boolean {\n    return this.#store.closed;\n  }\n}\n\nfunction isFirefoxPrivateBrowsingError(e: unknown): e is DOMException {\n  return (\n    isFirefox() &&\n    e instanceof DOMException &&\n    e.name === 'InvalidStateError' &&\n    e.message ===\n      'A mutation operation was attempted on a database that did not allow mutations.'\n  );\n}\n\nfunction isFirefox(): boolean {\n  return navigator?.userAgent?.includes('Firefox') ?? false;\n}\n\nexport function newIDBStoreWithMemFallback(\n  lc: LogContext,\n  name: string,\n): Store {\n  if (isFirefox()) {\n    return new IDBStoreWithMemFallback(lc, name);\n  }\n  return new IDBStore(name);\n}\n\nexport function dropIDBStoreWithMemFallback(name: string): Promise<void> {\n  if (!isFirefox()) {\n    return dropIDBStore(name);\n  }\n  try {\n    return dropIDBStore(name);\n  } catch (e) {\n    if (isFirefoxPrivateBrowsingError(e)) {\n      return dropMemStore(name);\n    }\n  }\n  return promiseVoid;\n}\n\nfunction dropIDBStore(name: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.deleteDatabase(name);\n    req.onsuccess = () => resolve();\n    req.onerror = () => reject(req.error);\n  });\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {\n  dropIDBStoreWithMemFallback,\n  newIDBStoreWithMemFallback,\n} from './kv/idb-store-with-mem-fallback.ts';\nimport {dropMemStore, MemStore} from './kv/mem-store.ts';\nimport type {StoreProvider} from './kv/store.ts';\n\nexport function getKVStoreProvider(\n  lc: LogContext,\n  kvStore: 'mem' | 'idb' | StoreProvider | undefined,\n): StoreProvider {\n  switch (kvStore) {\n    case 'idb':\n    case undefined:\n      return {\n        create: name => newIDBStoreWithMemFallback(lc, name),\n        drop: dropIDBStoreWithMemFallback,\n      };\n    case 'mem':\n      return {\n        create: name => new MemStore(name),\n        drop: name => dropMemStore(name),\n      };\n    default:\n      return kvStore;\n  }\n}\n","import {\n  consoleLogSink,\n  LogContext,\n  TeeLogSink,\n  type Context,\n  type LogLevel,\n  type LogSink,\n} from '@rocicorp/logger';\n\n/**\n * Creates a LogContext\n * @param logLevel The log level to use. Default is `'info'`.\n * @param logSinks Destination for logs. Default is `[consoleLogSink]`.\n * @param context Optional: Additional information that can be associated with logs.\n * @returns A LogContext instance configured with the provided options.\n */\nexport function createLogContext(\n  logLevel: LogLevel = 'info',\n  logSinks: LogSink[] = [consoleLogSink],\n  context?: Context | undefined,\n): LogContext {\n  const logSink =\n    logSinks.length === 1 ? logSinks[0] : new TeeLogSink(logSinks);\n  return new LogContext(logLevel, context, logSink);\n}\n","import {randomUint64} from '../../../shared/src/random-uint64.ts';\nimport {dropIDBStoreWithMemFallback} from '../kv/idb-store-with-mem-fallback.ts';\n\nconst IDB_DATABASES_VERSION = 0;\nconst IDB_DATABASES_DB_NAME = 'replicache-dbs-v' + IDB_DATABASES_VERSION;\n\nlet testNamespace = '';\n\n/** Namespace db name in test to isolate tests' indexeddb state. */\nexport function setupForTest(): void {\n  testNamespace = randomUint64().toString(36);\n}\n\nexport function teardownForTest(): Promise<void> {\n  const idbDatabasesDBName = getIDBDatabasesDBName();\n  testNamespace = '';\n  return dropIDBStoreWithMemFallback(idbDatabasesDBName);\n}\n\nexport function getIDBDatabasesDBName(): string {\n  return testNamespace + IDB_DATABASES_DB_NAME;\n}\n","import {\n  assert,\n  assertNumber,\n  assertObject,\n  assertString,\n} from '../../../shared/src/asserts.ts';\nimport {deepFreeze} from '../frozen-json.ts';\nimport type {CreateStore, Read, Store} from '../kv/store.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {getIDBDatabasesDBName} from './idb-databases-store-db-name.ts';\nimport {makeClientID} from './make-client-id.ts';\n\nconst DBS_KEY = 'dbs';\nconst PROFILE_ID_KEY = 'profileId';\n\n// TODO: make an opaque type\nexport type IndexedDBName = string;\n\nexport type IndexedDBDatabase = {\n  readonly name: IndexedDBName;\n  readonly replicacheName: string;\n  readonly replicacheFormatVersion: number;\n  readonly schemaVersion: string;\n  readonly lastOpenedTimestampMS?: number;\n};\n\nexport type IndexedDBDatabaseRecord = {\n  readonly [name: IndexedDBName]: IndexedDBDatabase;\n};\n\nfunction assertIndexedDBDatabaseRecord(\n  value: unknown,\n): asserts value is IndexedDBDatabaseRecord {\n  assertObject(value);\n  for (const [name, db] of Object.entries(value)) {\n    assertString(name);\n    assertIndexedDBDatabase(db);\n    assert(name === db.name);\n  }\n}\n\nfunction assertIndexedDBDatabase(\n  value: unknown,\n): asserts value is IndexedDBDatabase {\n  assertObject(value);\n  assertString(value.name);\n  assertString(value.replicacheName);\n  assertNumber(value.replicacheFormatVersion);\n  assertString(value.schemaVersion);\n  if (value.lastOpenedTimestampMS !== undefined) {\n    assertNumber(value.lastOpenedTimestampMS);\n  }\n}\n\nexport class IDBDatabasesStore {\n  readonly #kvStore: Store;\n\n  constructor(createKVStore: CreateStore) {\n    this.#kvStore = createKVStore(getIDBDatabasesDBName());\n  }\n\n  putDatabase(db: IndexedDBDatabase): Promise<IndexedDBDatabaseRecord> {\n    return this.#putDatabase({...db, lastOpenedTimestampMS: Date.now()});\n  }\n\n  putDatabaseForTesting(\n    db: IndexedDBDatabase,\n  ): Promise<IndexedDBDatabaseRecord> {\n    return this.#putDatabase(db);\n  }\n\n  #putDatabase(db: IndexedDBDatabase): Promise<IndexedDBDatabaseRecord> {\n    return withWrite(this.#kvStore, async write => {\n      const oldDbRecord = await getDatabases(write);\n      const dbRecord = {\n        ...oldDbRecord,\n        [db.name]: db,\n      };\n      await write.put(DBS_KEY, dbRecord);\n      return dbRecord;\n    });\n  }\n\n  clearDatabases(): Promise<void> {\n    return withWrite(this.#kvStore, write => write.del(DBS_KEY));\n  }\n\n  deleteDatabases(names: Iterable<IndexedDBName>): Promise<void> {\n    return withWrite(this.#kvStore, async write => {\n      const oldDbRecord = await getDatabases(write);\n      const dbRecord = {\n        ...oldDbRecord,\n      };\n      for (const name of names) {\n        delete dbRecord[name];\n      }\n      await write.put(DBS_KEY, dbRecord);\n    });\n  }\n\n  getDatabases(): Promise<IndexedDBDatabaseRecord> {\n    return withRead(this.#kvStore, getDatabases);\n  }\n\n  close(): Promise<void> {\n    return this.#kvStore.close();\n  }\n\n  getProfileID(): Promise<string> {\n    return withWrite(this.#kvStore, async write => {\n      let profileId = await write.get(PROFILE_ID_KEY);\n      if (profileId === undefined) {\n        // Profile id is 'p' followed by a random number.\n        profileId = `p${makeClientID()}`;\n        await write.put(PROFILE_ID_KEY, profileId);\n      }\n      assertString(profileId);\n      return profileId;\n    });\n  }\n}\n\nasync function getDatabases(read: Read): Promise<IndexedDBDatabaseRecord> {\n  let dbRecord = await read.get(DBS_KEY);\n  if (!dbRecord) {\n    dbRecord = deepFreeze({});\n  }\n  assertIndexedDBDatabaseRecord(dbRecord);\n  return dbRecord;\n}\n","import type {LogContext, LogLevel, LogSink} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport {StoreImpl} from '../dag/store-impl.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  addDeletedClients,\n  getDeletedClients,\n  normalize,\n} from '../deleted-clients.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport {getKVStoreProvider} from '../get-kv-store-provider.ts';\nimport {assertHash, newRandomHash} from '../hash.ts';\nimport {IDBStore} from '../kv/idb-store.ts';\nimport type {DropStore, StoreProvider} from '../kv/store.ts';\nimport {createLogContext} from '../log-options.ts';\nimport type {ClientGroupID, ClientID} from '../sync/ids.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {\n  clientGroupHasPendingMutations,\n  getClientGroups,\n} from './client-groups.ts';\nimport type {OnClientsDeleted} from './clients.ts';\nimport {getClients} from './clients.ts';\nimport type {IndexedDBDatabase} from './idb-databases-store.ts';\nimport {IDBDatabasesStore} from './idb-databases-store.ts';\n\n/**\n * How frequently to try to collect\n */\nexport const COLLECT_IDB_INTERVAL = 12 * 60 * 60 * 1000; // 12 hours\n\n/**\n * We delay the initial collection to prevent doing it at startup.\n */\nexport const INITIAL_COLLECT_IDB_DELAY = 5 * 60 * 1000; // 5 minutes\n\nexport function initCollectIDBDatabases(\n  idbDatabasesStore: IDBDatabasesStore,\n  kvDropStore: DropStore,\n  collectInterval: number,\n  initialCollectDelay: number,\n  maxAge: number,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  let initial = true;\n  initBgIntervalProcess(\n    'CollectIDBDatabases',\n    async () => {\n      await collectIDBDatabases(\n        idbDatabasesStore,\n        Date.now(),\n        maxAge,\n        kvDropStore,\n        enableMutationRecovery,\n        onClientsDeleted,\n      );\n    },\n    () => {\n      if (initial) {\n        initial = false;\n        return initialCollectDelay;\n      }\n      return collectInterval;\n    },\n    lc,\n    signal,\n  );\n}\n\n/**\n * Collects IDB databases that are no longer needed.\n */\nexport async function collectIDBDatabases(\n  idbDatabasesStore: IDBDatabasesStore,\n  now: number,\n  maxAge: number,\n  kvDropStore: DropStore,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n  newDagStore = defaultNewDagStore,\n): Promise<void> {\n  const databases = await idbDatabasesStore.getDatabases();\n\n  const dbs = Object.values(databases) as IndexedDBDatabase[];\n  const collectResults = await Promise.all(\n    dbs.map(\n      async db =>\n        [\n          db.name,\n          await gatherDatabaseInfoForCollect(\n            db,\n            now,\n            maxAge,\n            enableMutationRecovery,\n            newDagStore,\n          ),\n        ] as const,\n    ),\n  );\n\n  const dbNamesToRemove: string[] = [];\n  const dbNamesToKeep: string[] = [];\n  const clientIDsToRemove: ClientID[] = [];\n  const clientGroupIDsToRemove: ClientGroupID[] = [];\n  for (const [\n    dbName,\n    [canCollect, clientIDs, clientGroupIDs],\n  ] of collectResults) {\n    if (canCollect) {\n      dbNamesToRemove.push(dbName);\n      clientIDsToRemove.push(...clientIDs);\n      clientGroupIDsToRemove.push(...clientGroupIDs);\n    } else {\n      dbNamesToKeep.push(dbName);\n    }\n  }\n\n  const {errors} = await dropDatabases(\n    idbDatabasesStore,\n    dbNamesToRemove,\n    kvDropStore,\n  );\n  if (errors.length) {\n    throw errors[0];\n  }\n\n  if (clientIDsToRemove.length || clientGroupIDsToRemove.length) {\n    // Add the deleted clients to all the dbs that survived the collection.\n    const newClientIDsToRemove: ClientID[] = clientIDsToRemove;\n    const newClientGroupIDsToRemove: ClientGroupID[] = clientGroupIDsToRemove;\n    for (const name of dbNamesToKeep) {\n      await withWrite(newDagStore(name), async dagWrite => {\n        const {clientIDs, clientGroupIDs} = await addDeletedClients(\n          dagWrite,\n          clientIDsToRemove,\n          clientGroupIDsToRemove,\n        );\n\n        newClientIDsToRemove.push(...clientIDs);\n        newClientGroupIDsToRemove.push(...clientGroupIDs);\n      });\n    }\n    // normalize and dedupe\n    onClientsDeleted(\n      normalize(newClientIDsToRemove),\n      normalize(newClientGroupIDsToRemove),\n    );\n  }\n}\n\nasync function dropDatabaseInternal(\n  name: string,\n  idbDatabasesStore: IDBDatabasesStore,\n  kvDropStore: DropStore,\n) {\n  await kvDropStore(name);\n  await idbDatabasesStore.deleteDatabases([name]);\n}\n\nasync function dropDatabases(\n  idbDatabasesStore: IDBDatabasesStore,\n  namesToRemove: string[],\n  kvDropStore: DropStore,\n): Promise<{dropped: string[]; errors: unknown[]}> {\n  // Try to remove the databases in parallel. Don't let a single reject fail the\n  // other ones. We will check for failures afterwards.\n  const dropStoreResults = await Promise.allSettled(\n    namesToRemove.map(async name => {\n      await dropDatabaseInternal(name, idbDatabasesStore, kvDropStore);\n      return name;\n    }),\n  );\n\n  const dropped: string[] = [];\n  const errors: unknown[] = [];\n  for (const result of dropStoreResults) {\n    if (result.status === 'fulfilled') {\n      dropped.push(result.value);\n    } else {\n      errors.push(result.reason);\n    }\n  }\n\n  return {dropped, errors};\n}\n\nfunction defaultNewDagStore(name: string): Store {\n  const perKvStore = new IDBStore(name);\n  return new StoreImpl(perKvStore, newRandomHash, assertHash);\n}\n\n/**\n * If the database is older than maxAge and there are no pending mutations we\n * return `true` and an array of the clientIDs in that db. If the database is\n * too new or there are pending mutations we return `[false]`.\n */\nfunction gatherDatabaseInfoForCollect(\n  db: IndexedDBDatabase,\n  now: number,\n  maxAge: number,\n  enableMutationRecovery: boolean,\n  newDagStore: typeof defaultNewDagStore,\n): MaybePromise<\n  | [canCollect: false]\n  | [\n      canCollect: true,\n      deletedClientIDs: ClientID[],\n      deletedClientGroupIDs: ClientGroupID[],\n    ]\n> {\n  if (db.replicacheFormatVersion > FormatVersion.Latest) {\n    return [false];\n  }\n\n  // 0 is used in testing\n  assert(db.lastOpenedTimestampMS !== undefined);\n\n  // - For DD31 we can delete the database if it is older than maxAge and\n  //   there are no pending mutations.\n  if (now - db.lastOpenedTimestampMS < maxAge) {\n    return [false];\n  }\n  // If increase the format version we need to decide how to deal with this\n  // logic.\n  assert(\n    db.replicacheFormatVersion === FormatVersion.DD31 ||\n      db.replicacheFormatVersion === FormatVersion.V6 ||\n      db.replicacheFormatVersion === FormatVersion.V7,\n  );\n  return canDatabaseBeCollectedAndGetDeletedClientIDs(\n    enableMutationRecovery,\n    newDagStore(db.name),\n  );\n}\n\n/**\n * Options for `dropDatabase` and `dropAllDatabases`.\n */\nexport type DropDatabaseOptions = {\n  /**\n   * Allows providing a custom implementation of the underlying storage layer.\n   * Default is `'idb'`.\n   */\n  kvStore?: 'idb' | 'mem' | StoreProvider | undefined;\n  /**\n   * Determines how much logging to do. When this is set to `'debug'`,\n   * Replicache will also log `'info'` and `'error'` messages. When set to\n   * `'info'` we log `'info'` and `'error'` but not `'debug'`. When set to\n   * `'error'` we only log `'error'` messages.\n   * Default is `'info'`.\n   */\n  logLevel?: LogLevel | undefined;\n  /**\n   * Enables custom handling of logs.\n   *\n   * By default logs are logged to the console.  If you would like logs to be\n   * sent elsewhere (e.g. to a cloud logging service like DataDog) you can\n   * provide an array of {@link LogSink}s.  Logs at or above\n   * {@link DropDatabaseOptions.logLevel} are sent to each of these {@link LogSink}s.\n   * If you would still like logs to go to the console, include\n   * `consoleLogSink` in the array.\n   *\n   * ```ts\n   * logSinks: [consoleLogSink, myCloudLogSink],\n   * ```\n   * Default is `[consoleLogSink]`.\n   */\n  logSinks?: LogSink[] | undefined;\n};\n\n/**\n * Drops the specified database.\n * @param dbName The name of the database to drop.\n * @param opts Options for dropping the database.\n */\nexport async function dropDatabase(\n  dbName: string,\n  opts?: DropDatabaseOptions | undefined,\n) {\n  const logContext = createLogContext(opts?.logLevel, opts?.logSinks, {\n    dropDatabase: undefined,\n  });\n  const kvStoreProvider = getKVStoreProvider(logContext, opts?.kvStore);\n  await dropDatabaseInternal(\n    dbName,\n    new IDBDatabasesStore(kvStoreProvider.create),\n    kvStoreProvider.drop,\n  );\n}\n\n/**\n * Deletes all IndexedDB data associated with Replicache.\n *\n * Returns an object with the names of the successfully dropped databases\n * and any errors encountered while dropping.\n */\nexport async function dropAllDatabases(\n  opts?: DropDatabaseOptions | undefined,\n): Promise<{\n  dropped: string[];\n  errors: unknown[];\n}> {\n  const logContext = createLogContext(opts?.logLevel, opts?.logSinks, {\n    dropAllDatabases: undefined,\n  });\n  const kvStoreProvider = getKVStoreProvider(logContext, opts?.kvStore);\n  const store = new IDBDatabasesStore(kvStoreProvider.create);\n  const databases = await store.getDatabases();\n  const dbNames = Object.values(databases).map(db => db.name);\n  const result = await dropDatabases(store, dbNames, kvStoreProvider.drop);\n  return result;\n}\n\n/**\n * Deletes all IndexedDB data associated with Replicache.\n *\n * Returns an object with the names of the successfully dropped databases\n * and any errors encountered while dropping.\n *\n * @deprecated Use `dropAllDatabases` instead.\n */\nexport function deleteAllReplicacheData(\n  opts?: DropDatabaseOptions | undefined,\n) {\n  return dropAllDatabases(opts);\n}\n\n/**\n * If the there are pending mutations in any of the clients in this db we return\n * `[false]`. Otherwise we return `true` and an array of the clientIDs to\n * remove.\n */\nfunction canDatabaseBeCollectedAndGetDeletedClientIDs(\n  enableMutationRecovery: boolean,\n  perdag: Store,\n): Promise<\n  | [canCollect: false]\n  | [\n      canCollect: true,\n      deletedClientIDs: ClientID[],\n      deletedClientGroupIDs: ClientGroupID[],\n    ]\n> {\n  return withRead(perdag, async read => {\n    // If mutation recovery is disabled we do not care if there are pending\n    // mutations when we decide if we can collect the database.\n    if (enableMutationRecovery) {\n      const clientGroups = await getClientGroups(read);\n      for (const clientGroup of clientGroups.values()) {\n        if (clientGroupHasPendingMutations(clientGroup)) {\n          return [false];\n        }\n      }\n    }\n\n    const clients = await getClients(read);\n    const {clientIDs, clientGroupIDs} = await getDeletedClients(read);\n    const newClientIDs: ClientID[] = [...clientIDs];\n    const newClientGroupIDs: ClientGroupID[] = [...clientGroupIDs];\n    for (const [clientID, client] of clients) {\n      newClientIDs.push(clientID);\n      newClientGroupIDs.push(client.clientGroupID);\n    }\n    // Deduping and sorting is done when storing\n    return [true, newClientIDs, newClientGroupIDs];\n  });\n}\n","/**\n * This error is thrown when you try to call methods on a closed transaction.\n */\nexport class TransactionClosedError extends Error {\n  constructor() {\n    super('Transaction is closed');\n  }\n}\n\nexport type Closed = {closed: boolean};\n\nexport function throwIfClosed(tx: Closed): void {\n  if (tx.closed) {\n    throw new TransactionClosedError();\n  }\n}\n\nexport function rejectIfClosed(tx: Closed): undefined | Promise<never> {\n  return tx.closed ? Promise.reject(new TransactionClosedError()) : undefined;\n}\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {astSchema} from './ast.ts';\n\nexport const transformRequestBodySchema = v.array(\n  v.object({\n    id: v.string(),\n    name: v.string(),\n    args: v.readonly(v.array(jsonSchema)),\n  }),\n);\nexport type TransformRequestBody = v.Infer<typeof transformRequestBodySchema>;\n\nexport const transformedQuerySchema = v.object({\n  id: v.string(),\n  name: v.string(),\n  ast: astSchema,\n});\n\nexport const appQueryErrorSchema = v.object({\n  error: v.literal('app'),\n  id: v.string(),\n  name: v.string(),\n  details: jsonSchema,\n});\n\nexport const zeroErrorSchema = v.object({\n  error: v.literal('zero'),\n  id: v.string(),\n  name: v.string(),\n  details: jsonSchema,\n});\n\nexport const httpQueryErrorSchema = v.object({\n  error: v.literal('http'),\n  id: v.string(),\n  name: v.string(),\n  status: v.number(),\n  details: jsonSchema,\n});\n\nexport const erroredQuerySchema = v.union(\n  appQueryErrorSchema,\n  httpQueryErrorSchema,\n  zeroErrorSchema,\n);\nexport type ErroredQuery = v.Infer<typeof erroredQuerySchema>;\nexport type AppQueryError = v.Infer<typeof appQueryErrorSchema>;\nexport type HttpQueryError = v.Infer<typeof httpQueryErrorSchema>;\n\nexport const transformResponseBodySchema = v.array(\n  v.union(transformedQuerySchema, erroredQuerySchema),\n);\nexport type TransformResponseBody = v.Infer<typeof transformResponseBodySchema>;\n\nexport const transformRequestMessageSchema = v.tuple([\n  v.literal('transform'),\n  transformRequestBodySchema,\n]);\nexport type TransformRequestMessage = v.Infer<\n  typeof transformRequestMessageSchema\n>;\nexport const transformErrorMessageSchema = v.tuple([\n  v.literal('transformError'),\n  v.array(erroredQuerySchema),\n]);\nexport type TransformErrorMessage = v.Infer<typeof transformErrorMessageSchema>;\n\nexport const transformResponseMessageSchema = v.tuple([\n  v.literal('transformed'),\n  transformResponseBodySchema,\n]);\nexport type TransformResponseMessage = v.Infer<\n  typeof transformResponseMessageSchema\n>;\n","/* eslint-disable @typescript-eslint/naming-convention */\n\n// Note: Metric names depend on these values,\n// so if you add or change on here a corresponding dashboard\n// change will likely be needed.\n\nexport const AuthInvalidated = 'AuthInvalidated';\nexport const ClientNotFound = 'ClientNotFound';\nexport const InvalidConnectionRequest = 'InvalidConnectionRequest';\nexport const InvalidConnectionRequestBaseCookie =\n  'InvalidConnectionRequestBaseCookie';\nexport const InvalidConnectionRequestLastMutationID =\n  'InvalidConnectionRequestLastMutationID';\nexport const InvalidConnectionRequestClientDeleted =\n  'InvalidConnectionRequestClientDeleted';\nexport const InvalidMessage = 'InvalidMessage';\nexport const InvalidPush = 'InvalidPush';\nexport const MutationFailed = 'MutationFailed';\nexport const MutationRateLimited = 'MutationRateLimited';\nexport const Rebalance = 'Rebalance';\nexport const Rehome = 'Rehome';\nexport const Unauthorized = 'Unauthorized';\nexport const VersionNotSupported = 'VersionNotSupported';\nexport const SchemaVersionNotSupported = 'SchemaVersionNotSupported';\nexport const ServerOverloaded = 'ServerOverloaded';\nexport const Internal = 'Internal';\n\nexport type AuthInvalidated = typeof AuthInvalidated;\nexport type ClientNotFound = typeof ClientNotFound;\nexport type InvalidConnectionRequest = typeof InvalidConnectionRequest;\nexport type InvalidConnectionRequestBaseCookie =\n  typeof InvalidConnectionRequestBaseCookie;\nexport type InvalidConnectionRequestLastMutationID =\n  typeof InvalidConnectionRequestLastMutationID;\nexport type InvalidConnectionRequestClientDeleted =\n  typeof InvalidConnectionRequestClientDeleted;\nexport type InvalidMessage = typeof InvalidMessage;\nexport type InvalidPush = typeof InvalidPush;\nexport type MutationFailed = typeof MutationFailed;\nexport type MutationRateLimited = typeof MutationRateLimited;\nexport type Rebalance = typeof Rebalance;\nexport type Rehome = typeof Rehome;\nexport type Unauthorized = typeof Unauthorized;\nexport type VersionNotSupported = typeof VersionNotSupported;\nexport type SchemaVersionNotSupported = typeof SchemaVersionNotSupported;\nexport type ServerOverloaded = typeof ServerOverloaded;\nexport type Internal = typeof Internal;\n","import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport type {SchemaValue, TableSchema} from '../table-schema.ts';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function table<TName extends string>(name: TName) {\n  return new TableBuilder({\n    name,\n    columns: {},\n    primaryKey: [] as any as PrimaryKey,\n  });\n}\n\nexport function string<T extends string = string>() {\n  return new ColumnBuilder({\n    type: 'string',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function number<T extends number = number>() {\n  return new ColumnBuilder({\n    type: 'number',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function boolean<T extends boolean = boolean>() {\n  return new ColumnBuilder({\n    type: 'boolean',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function json<T extends ReadonlyJSONValue = ReadonlyJSONValue>() {\n  return new ColumnBuilder({\n    type: 'json',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function enumeration<T extends string>() {\n  return new ColumnBuilder({\n    type: 'string',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport const column = {\n  string,\n  number,\n  boolean,\n  json,\n  enumeration,\n};\n\nexport class TableBuilder<TShape extends TableSchema> {\n  readonly #schema: TShape;\n  constructor(schema: TShape) {\n    this.#schema = schema;\n  }\n\n  from<ServerName extends string>(serverName: ServerName) {\n    return new TableBuilder<TShape>({\n      ...this.#schema,\n      // Strip the \"public.\" schema if specified, as tables in the upstream\n      // \"public\" schema are created without the schema prefix on the replica.\n      // See liteTableName() in zero-cache/src/types/names.ts\n      serverName: serverName.startsWith('public.')\n        ? serverName.substring('public.'.length)\n        : serverName,\n    });\n  }\n\n  columns<const TColumns extends Record<string, ColumnBuilder<SchemaValue>>>(\n    columns: TColumns,\n  ): TableBuilderWithColumns<{\n    name: TShape['name'];\n    columns: {[K in keyof TColumns]: TColumns[K]['schema']};\n    primaryKey: TShape['primaryKey'];\n  }> {\n    const columnSchemas = Object.fromEntries(\n      Object.entries(columns).map(([k, v]) => [k, v.schema]),\n    ) as {[K in keyof TColumns]: TColumns[K]['schema']};\n    return new TableBuilderWithColumns({\n      ...this.#schema,\n      columns: columnSchemas,\n    }) as any;\n  }\n}\n\nexport class TableBuilderWithColumns<TShape extends TableSchema> {\n  readonly #schema: TShape;\n\n  constructor(schema: TShape) {\n    this.#schema = schema;\n  }\n\n  primaryKey<TPKColNames extends (keyof TShape['columns'])[]>(\n    ...pkColumnNames: TPKColNames\n  ) {\n    return new TableBuilderWithColumns({\n      ...this.#schema,\n      primaryKey: pkColumnNames,\n    });\n  }\n\n  get schema() {\n    return this.#schema;\n  }\n\n  build() {\n    // We can probably get the type system to throw an error if primaryKey is not called\n    // before passing the schema to createSchema\n    // Till then --\n    if (this.#schema.primaryKey.length === 0) {\n      throw new Error(`Table \"${this.#schema.name}\" is missing a primary key`);\n    }\n    const names = new Set<string>();\n    for (const [col, {serverName}] of Object.entries(this.#schema.columns)) {\n      const name = serverName ?? col;\n      if (names.has(name)) {\n        throw new Error(\n          `Table \"${\n            this.#schema.name\n          }\" has multiple columns referencing \"${name}\"`,\n        );\n      }\n      names.add(name);\n    }\n    return this.#schema;\n  }\n}\n\nclass ColumnBuilder<TShape extends SchemaValue<any>> {\n  readonly #schema: TShape;\n  constructor(schema: TShape) {\n    this.#schema = schema;\n  }\n\n  from<ServerName extends string>(serverName: ServerName) {\n    return new ColumnBuilder<TShape & {serverName: string}>({\n      ...this.#schema,\n      serverName,\n    });\n  }\n\n  optional(): ColumnBuilder<Omit<TShape, 'optional'> & {optional: true}> {\n    return new ColumnBuilder({\n      ...this.#schema,\n      optional: true,\n    });\n  }\n\n  get schema() {\n    return this.#schema;\n  }\n}\n\nexport type {ColumnBuilder};\n","import {mapAllEntries} from '../../shared/src/objects.ts';\nimport * as v from '../../shared/src/valita.ts';\n\nexport type ValueType = 'string' | 'number' | 'boolean' | 'null' | 'json';\n\nexport const valueTypeSchema: v.Type<ValueType> = v.literalUnion(\n  'string',\n  'number',\n  'boolean',\n  'null',\n  'json',\n);\n\nexport const columnSchemaSchema = v.object({\n  type: valueTypeSchema,\n});\n\nexport type ColumnSchema = v.Infer<typeof columnSchemaSchema>;\n\nexport const tableSchemaSchema = v.object({\n  columns: v.record(columnSchemaSchema),\n});\n\nexport type TableSchema = v.Infer<typeof tableSchemaSchema>;\n\nexport const clientSchemaSchema = v.object({\n  tables: v.record(tableSchemaSchema),\n});\n\nexport type ClientSchema = v.Infer<typeof clientSchemaSchema>;\n\nconst keyCmp = ([a]: [a: string, _: unknown], [b]: [b: string, _: unknown]) =>\n  a < b ? -1 : a > b ? 1 : 0;\n\n/**\n * Returns a normalized schema (with the tables and columns sorted)\n * suitable for hashing.\n */\nexport function normalizeClientSchema(schema: ClientSchema): ClientSchema {\n  return {\n    tables: mapAllEntries(schema.tables, tables =>\n      tables\n        .sort(keyCmp)\n        .map(([name, table]) => [\n          name,\n          {columns: mapAllEntries(table.columns, e => e.sort(keyCmp))},\n        ]),\n    ),\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {h64} from '../../../shared/src/hash.ts';\nimport {mapEntries} from '../../../shared/src/objects.ts';\nimport {\n  normalizeClientSchema,\n  type ClientSchema,\n} from '../../../zero-protocol/src/client-schema.ts';\nimport type {\n  Relationship,\n  RelationshipsSchema,\n  TableSchema,\n} from '../table-schema.ts';\nimport type {Relationships} from './relationship-builder.ts';\nimport {type TableBuilderWithColumns} from './table-builder.ts';\n\nexport type Schema = {\n  readonly tables: {readonly [table: string]: TableSchema};\n  readonly relationships: {readonly [table: string]: RelationshipsSchema};\n  /**\n   * Enables legacy query support.\n   * When this is true, old-style queries that do not require server side implementations will be enabled.\n   * This will flip to false in the future and what we currently call \"custom queries\" will become \"queries\" and\n   * the only option for reading data.\n   * The default is true, but will flip to false in the future.\n   */\n  readonly enableLegacyQueries?: boolean | undefined;\n  /**\n   * Enables legacy mutator support.\n   * When this is true, old-style mutations that do not require server side implementations will be enabled.\n   * This will flip to false in the future and what we currently call \"custom mutations\" will become \"mutations\" and\n   * the only option for writing data.\n   * The default is true, but will flip to false in the future.\n   */\n  readonly enableLegacyMutators?: boolean | undefined;\n};\n\n/**\n * Note: the keys of the `tables` and `relationships` parameters do not matter.\n * You can assign them to any value you like. E.g.,\n *\n * ```ts\n * createSchema({rsdfgafg: table('users')...}, {sdfd: relationships(users, ...)})\n * ```\n */\nexport function createSchema<\n  const TTables extends readonly TableBuilderWithColumns<TableSchema>[],\n  const TRelationships extends readonly Relationships[],\n  const TEnableLegacyQueries extends boolean | undefined,\n  const TEnableLegacyMutators extends boolean | undefined,\n>(options: {\n  readonly tables: TTables;\n  readonly relationships?: TRelationships | undefined;\n  /** @see Schema.enableLegacyQueries */\n  readonly enableLegacyQueries?: TEnableLegacyQueries | undefined;\n  /** @see Schema.enableLegacyMutators */\n  readonly enableLegacyMutators?: TEnableLegacyMutators | undefined;\n}): {\n  tables: {\n    readonly [K in TTables[number]['schema']['name']]: Extract<\n      TTables[number]['schema'],\n      {name: K}\n    >;\n  };\n  relationships: {\n    readonly [K in TRelationships[number]['name']]: Extract<\n      TRelationships[number],\n      {name: K}\n    >['relationships'];\n  };\n  enableLegacyQueries: TEnableLegacyQueries;\n  enableLegacyMutators: TEnableLegacyMutators;\n} {\n  const retTables: Record<string, TableSchema> = {};\n  const retRelationships: Record<string, Record<string, Relationship>> = {};\n  const serverNames = new Set<string>();\n\n  options.tables.forEach(table => {\n    const {serverName = table.schema.name} = table.schema;\n    if (serverNames.has(serverName)) {\n      throw new Error(`Multiple tables reference the name \"${serverName}\"`);\n    }\n    serverNames.add(serverName);\n    if (retTables[table.schema.name]) {\n      throw new Error(\n        `Table \"${table.schema.name}\" is defined more than once in the schema`,\n      );\n    }\n    retTables[table.schema.name] = table.build();\n  });\n  options.relationships?.forEach(relationships => {\n    if (retRelationships[relationships.name]) {\n      throw new Error(\n        `Relationships for table \"${relationships.name}\" are defined more than once in the schema`,\n      );\n    }\n    retRelationships[relationships.name] = relationships.relationships;\n    checkRelationship(\n      relationships.relationships,\n      relationships.name,\n      retTables,\n    );\n  });\n\n  return {\n    tables: retTables,\n    relationships: retRelationships,\n    enableLegacyQueries: options.enableLegacyQueries,\n    enableLegacyMutators: options.enableLegacyMutators,\n  } as any;\n}\n\nfunction checkRelationship(\n  relationships: Record<string, Relationship>,\n  tableName: string,\n  tables: Record<string, TableSchema>,\n) {\n  // TS should be able to check this for us but something is preventing it from happening.\n  Object.entries(relationships).forEach(([name, rel]) => {\n    let source = tables[tableName];\n    if (source.columns[name] !== undefined) {\n      throw new Error(\n        `Relationship \"${tableName}\".\"${name}\" cannot have the same name as the column \"${name}\" on the the table \"${source.name}\"`,\n      );\n    }\n    rel.forEach(connection => {\n      if (!tables[connection.destSchema]) {\n        throw new Error(\n          `For relationship \"${tableName}\".\"${name}\", destination table \"${connection.destSchema}\" is missing in the schema`,\n        );\n      }\n      if (!source.columns[connection.sourceField[0]]) {\n        throw new Error(\n          `For relationship \"${tableName}\".\"${name}\", the source field \"${connection.sourceField[0]}\" is missing in the table schema \"${source.name}\"`,\n        );\n      }\n      source = tables[connection.destSchema];\n    });\n  });\n}\n\nexport function clientSchemaFrom(schema: Schema): {\n  clientSchema: ClientSchema;\n  hash: string;\n} {\n  const client = {\n    tables: mapEntries(schema.tables, (name, {serverName, columns}) => [\n      serverName ?? name,\n      {\n        columns: mapEntries(columns, (name, {serverName, type}) => [\n          serverName ?? name,\n          {type},\n        ]),\n      },\n    ]),\n  };\n  const clientSchema = normalizeClientSchema(client);\n  const hash = h64(JSON.stringify(clientSchema)).toString(36);\n  return {clientSchema, hash};\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * There is a new client group due to a another tab loading new code which\n * cannot sync locally with this tab until it updates to the new code. This tab\n * can still sync with the zero-cache.\n */\nexport const NewClientGroup = 'NewClientGroup';\nexport type NewClientGroup = typeof NewClientGroup;\n\n/**\n * This client was unable to connect to the zero-cache because it is using a\n * protocol version that the zero-cache does not support.\n */\nexport const VersionNotSupported = 'VersionNotSupported';\nexport type VersionNotSupported = typeof VersionNotSupported;\n\n/**\n * This client was unable to connect to the zero-cache because it is using a\n * schema version (see {@codelink Schema}) that the zero-cache does not support.\n */\nexport const SchemaVersionNotSupported = 'SchemaVersionNotSupported';\nexport type SchemaVersionNotSupported = typeof SchemaVersionNotSupported;\n","import {type LogLevel, type LogSink} from '@rocicorp/logger';\nimport {type Resolver, resolver} from '@rocicorp/resolver';\nimport {\n  ReplicacheImpl,\n  type ReplicacheImplOptions,\n} from '../../../replicache/src/impl.ts';\nimport {dropDatabase} from '../../../replicache/src/persist/collect-idb-databases.ts';\nimport type {Puller, PullerResult} from '../../../replicache/src/puller.ts';\nimport type {Pusher, PusherResult} from '../../../replicache/src/pusher.ts';\nimport type {ReplicacheOptions} from '../../../replicache/src/replicache-options.ts';\nimport type {\n  ClientGroupID,\n  ClientID,\n} from '../../../replicache/src/sync/ids.ts';\nimport type {PullRequest} from '../../../replicache/src/sync/pull.ts';\nimport type {PushRequest} from '../../../replicache/src/sync/push.ts';\nimport type {\n  MutatorDefs,\n  MutatorReturn,\n  UpdateNeededReason as ReplicacheUpdateNeededReason,\n} from '../../../replicache/src/types.ts';\nimport {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport {\n  getBrowserGlobal,\n  mustGetBrowserGlobal,\n} from '../../../shared/src/browser-env.ts';\nimport type {DeepMerge} from '../../../shared/src/deep-merge.ts';\nimport {getDocumentVisibilityWatcher} from '../../../shared/src/document-visible.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {navigator} from '../../../shared/src/navigator.ts';\nimport {sleep, sleepWithAbort} from '../../../shared/src/sleep.ts';\nimport {Subscribable} from '../../../shared/src/subscribable.ts';\nimport * as valita from '../../../shared/src/valita.ts';\nimport type {Writable} from '../../../shared/src/writable.ts';\nimport {type ClientSchema} from '../../../zero-protocol/src/client-schema.ts';\nimport type {\n  ConnectedMessage,\n  UserMutateParams,\n  UserQueryParams,\n} from '../../../zero-protocol/src/connect.ts';\nimport {encodeSecProtocols} from '../../../zero-protocol/src/connect.ts';\nimport type {DeleteClientsBody} from '../../../zero-protocol/src/delete-clients.ts';\nimport type {Downstream} from '../../../zero-protocol/src/down.ts';\nimport {downstreamSchema} from '../../../zero-protocol/src/down.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport type {ErrorMessage} from '../../../zero-protocol/src/error.ts';\nimport * as MutationType from '../../../zero-protocol/src/mutation-type-enum.ts';\nimport type {PingMessage} from '../../../zero-protocol/src/ping.ts';\nimport type {\n  PokeEndMessage,\n  PokePartMessage,\n  PokeStartMessage,\n} from '../../../zero-protocol/src/poke.ts';\nimport {PROTOCOL_VERSION} from '../../../zero-protocol/src/protocol-version.ts';\nimport type {\n  PullRequestMessage,\n  PullResponseBody,\n  PullResponseMessage,\n} from '../../../zero-protocol/src/pull.ts';\nimport type {\n  CRUDMutation,\n  CRUDMutationArg,\n  CustomMutation,\n  MutationID,\n  PushMessage,\n} from '../../../zero-protocol/src/push.ts';\nimport {CRUD_MUTATION_NAME, mapCRUD} from '../../../zero-protocol/src/push.ts';\nimport type {UpQueriesPatchOp} from '../../../zero-protocol/src/queries-patch.ts';\nimport type {Upstream} from '../../../zero-protocol/src/up.ts';\nimport type {NullableVersion} from '../../../zero-protocol/src/version.ts';\nimport {nullableVersionSchema} from '../../../zero-protocol/src/version.ts';\nimport {\n  type Schema,\n  clientSchemaFrom,\n} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {\n  type NameMapper,\n  clientToServer,\n} from '../../../zero-schema/src/name-mapper.ts';\nimport {customMutatorKey} from '../../../zql/src/mutate/custom.ts';\nimport {\n  type ClientMetricMap,\n  type MetricMap,\n  isClientMetric,\n} from '../../../zql/src/query/metrics-delegate.ts';\nimport type {QueryDelegate} from '../../../zql/src/query/query-delegate.ts';\nimport {\n  materialize,\n  newQuery,\n  type AnyQuery,\n} from '../../../zql/src/query/query-impl.ts';\nimport {\n  delegateSymbol,\n  type HumanReadable,\n  type MaterializeOptions,\n  type PreloadOptions,\n  type Query,\n  type QueryReturn,\n  type QueryTable,\n  type RunOptions,\n} from '../../../zql/src/query/query.ts';\nimport {nanoid} from '../util/nanoid.ts';\nimport {send} from '../util/socket.ts';\nimport {ActiveClientsManager} from './active-clients-manager.ts';\nimport * as ConnectionState from './connection-state-enum.ts';\nimport {ZeroContext} from './context.ts';\nimport {\n  type BatchMutator,\n  type CRUDMutator,\n  type DBMutator,\n  type WithCRUD,\n  makeCRUDMutate,\n  makeCRUDMutator,\n} from './crud.ts';\nimport type {\n  CustomMutatorDefs,\n  CustomMutatorImpl,\n  MakeCustomMutatorInterfaces,\n} from './custom.ts';\nimport {makeReplicacheMutator} from './custom.ts';\nimport {DeleteClientsManager} from './delete-clients-manager.ts';\nimport {shouldEnableAnalytics} from './enable-analytics.ts';\nimport {\n  type HTTPString,\n  type WSString,\n  appendPath,\n  toWSString,\n} from './http-string.ts';\nimport type {Inspector} from './inspector/types.ts';\nimport {IVMSourceBranch} from './ivm-branch.ts';\nimport {type LogOptions, createLogOptions} from './log-options.ts';\nimport {\n  DID_NOT_CONNECT_VALUE,\n  type DisconnectReason,\n  MetricManager,\n  REPORT_INTERVAL_MS,\n  type Series,\n  getLastConnectErrorValue,\n} from './metrics.ts';\nimport {MutationTracker} from './mutation-tracker.ts';\nimport type {OnErrorParameters} from './on-error.ts';\nimport type {UpdateNeededReason, ZeroOptions} from './options.ts';\nimport * as PingResult from './ping-result-enum.ts';\nimport {QueryManager} from './query-manager.ts';\nimport {\n  reloadScheduled,\n  reloadWithReason,\n  reportReloadReason,\n  resetBackoff,\n} from './reload-error-handler.ts';\nimport {\n  ServerError,\n  isAuthError,\n  isBackoffError,\n  isServerError,\n} from './server-error.ts';\nimport {getServer} from './server-option.ts';\nimport {version} from './version.ts';\nimport {ZeroLogContext} from './zero-log-context.ts';\nimport {PokeHandler} from './zero-poke-handler.ts';\nimport {ZeroRep} from './zero-rep.ts';\nimport type {ViewFactory} from '../../../zql/src/ivm/view.ts';\nimport type {TypedView} from '../../../zql/src/query/typed-view.ts';\nimport {emptyFunction} from '../../../shared/src/sentinels.ts';\n\ntype ConnectionState = Enum<typeof ConnectionState>;\ntype PingResult = Enum<typeof PingResult>;\n\nexport type NoRelations = Record<string, never>;\n\nexport type MakeEntityQueriesFromSchema<S extends Schema> = {\n  readonly [K in keyof S['tables'] & string]: Query<S, K>;\n};\n\ndeclare const TESTING: boolean;\n\nexport type TestingContext = {\n  puller: Puller;\n  pusher: Pusher;\n  setReload: (r: () => void) => void;\n  logOptions: LogOptions;\n  connectStart: () => number | undefined;\n  socketResolver: () => Resolver<WebSocket>;\n  connectionState: () => ConnectionState;\n};\n\nexport const onSetConnectionStateSymbol = Symbol();\nexport const exposedToTestingSymbol = Symbol();\nexport const createLogOptionsSymbol = Symbol();\n\ninterface TestZero {\n  [exposedToTestingSymbol]?: TestingContext;\n  [onSetConnectionStateSymbol]?: (state: ConnectionState) => void;\n  [createLogOptionsSymbol]?: (options: {\n    consoleLogLevel: LogLevel;\n    server: string | null;\n  }) => LogOptions;\n}\n\nfunction asTestZero<S extends Schema, MD extends CustomMutatorDefs | undefined>(\n  z: Zero<S, MD>,\n): TestZero {\n  return z as TestZero;\n}\n\nexport const RUN_LOOP_INTERVAL_MS = 5_000;\n\n/**\n * How frequently we should ping the server to keep the connection alive.\n */\nexport const PING_INTERVAL_MS = 5_000;\n\n/**\n * The amount of time we wait for a pong before we consider the ping timed out.\n */\nexport const PING_TIMEOUT_MS = 5_000;\n\n/**\n * The amount of time we wait for a pull response before we consider a pull\n * request timed out.\n */\nexport const PULL_TIMEOUT_MS = 5_000;\n\nexport const DEFAULT_DISCONNECT_HIDDEN_DELAY_MS = 5_000;\n\n/**\n * The amount of time we wait for a connection to be established before we\n * consider it timed out.\n */\nexport const CONNECT_TIMEOUT_MS = 10_000;\n\nconst CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY = 6;\n\nconst NULL_LAST_MUTATION_ID_SENT = {clientID: '', id: -1} as const;\n\nconst DEFAULT_QUERY_CHANGE_THROTTLE_MS = 10;\n\nfunction convertOnUpdateNeededReason(\n  reason: ReplicacheUpdateNeededReason,\n): UpdateNeededReason {\n  return {type: reason.type};\n}\n\nfunction updateNeededReloadReasonMessage(\n  reason: UpdateNeededReason,\n  serverErrMsg?: string | undefined,\n) {\n  const {type} = reason;\n  let reasonMsg = '';\n  switch (type) {\n    case 'NewClientGroup':\n      reasonMsg =\n        \"This client could not sync with a newer client. This is probably due to another tab loading a newer incompatible version of the app's code.\";\n      break;\n    case 'VersionNotSupported':\n      reasonMsg =\n        \"The server no longer supports this client's protocol version.\";\n      break;\n    case 'SchemaVersionNotSupported':\n      reasonMsg = 'Client and server schemas incompatible.';\n      break;\n    default:\n      unreachable(type);\n  }\n  if (serverErrMsg) {\n    reasonMsg += ' ' + serverErrMsg;\n  }\n  return reasonMsg;\n}\n\nconst serverAheadReloadReason = `Server reported that client is ahead of server. This probably happened because the server is in development mode and restarted. Currently when this happens, the dev server loses its state and on reconnect sees the client as ahead. If you see this in other cases, it may be a bug in Zero.`;\n\nfunction onClientStateNotFoundServerReason(serverErrMsg: string) {\n  return `Server could not find state needed to synchronize this client. ${serverErrMsg}`;\n}\nconst ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT =\n  'The local persistent state needed to synchronize this client has been garbage collected.';\n\n// Keep in sync with packages/replicache/src/replicache-options.ts\nexport interface ReplicacheInternalAPI {\n  lastMutationID(): number;\n}\n\nconst internalReplicacheImplMap = new WeakMap<object, ReplicacheImpl>();\n\nexport function getInternalReplicacheImplForTesting(\n  z: object,\n): ReplicacheImpl<MutatorDefs> {\n  assert(TESTING);\n  return must(internalReplicacheImplMap.get(z));\n}\n\nconst CLOSE_CODE_NORMAL = 1000;\nconst CLOSE_CODE_GOING_AWAY = 1001;\ntype CloseCode = typeof CLOSE_CODE_NORMAL | typeof CLOSE_CODE_GOING_AWAY;\n\nexport class Zero<\n  const S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> {\n  readonly version = version;\n\n  readonly #rep: ReplicacheImpl<WithCRUD<MutatorDefs>>;\n  readonly #server: HTTPString | null;\n  readonly userID: string;\n  readonly storageKey: string;\n\n  readonly #lc: ZeroLogContext;\n  readonly #logOptions: LogOptions;\n  readonly #enableAnalytics: boolean;\n  readonly #schema: S;\n  readonly #clientSchema: ClientSchema;\n\n  readonly #pokeHandler: PokeHandler;\n  readonly #queryManager: QueryManager;\n  readonly #ivmMain: IVMSourceBranch;\n  readonly #clientToServer: NameMapper;\n  readonly #deleteClientsManager: DeleteClientsManager;\n  readonly #mutationTracker: MutationTracker;\n\n  /**\n   * The queries we sent when inside the sec-protocol header when establishing a connection.\n   * More queries could be registered while we're waiting for the 'connected' message\n   * to come back from the server. To understand what queries we need to send\n   * to the server, we diff the `initConnectionQueries` with the current set of desired queries.\n   *\n   * If this is set to `undefined` that means no queries were sent inside the `sec-protocol` header\n   * and an `initConnection` message must be sent to the server after receiving the `connected` message.\n   */\n  #initConnectionQueries: Map<string, UpQueriesPatchOp> | undefined;\n\n  /**\n   * We try to send the deleted clients and (client groups) as part of the\n   * sec-protocol header. If we can't because the header would get too large we\n   * keep track of the deleted clients and send them after the connection is\n   * established.\n   */\n  #deletedClients: DeleteClientsBody | undefined;\n\n  #lastMutationIDSent: {clientID: string; id: number} =\n    NULL_LAST_MUTATION_ID_SENT;\n\n  #onPong: () => void = () => undefined;\n\n  readonly #onlineManager: OnlineManager;\n\n  readonly #onUpdateNeeded: (\n    reason: UpdateNeededReason,\n    serverErrorMsg?: string,\n  ) => void;\n  readonly #onClientStateNotFound: (reason?: string) => void;\n  // Last cookie used to initiate a connection\n  #connectCookie: NullableVersion = null;\n  // Total number of sockets successfully connected by this client\n  #connectedCount = 0;\n  // Number of messages received over currently connected socket.  Reset\n  // on disconnect.\n  #messageCount = 0;\n  #connectedAt = 0;\n  // Reset on successful connection.\n  #connectErrorCount = 0;\n\n  #abortPingTimeout = () => {\n    // intentionally empty\n  };\n\n  readonly #zeroContext: ZeroContext;\n  readonly queryDelegate: QueryDelegate;\n\n  #connectResolver = resolver<void>();\n  #pendingPullsByRequestID: Map<string, Resolver<PullResponseBody>> = new Map();\n  #lastMutationIDReceived = 0;\n\n  #socket: WebSocket | undefined = undefined;\n  #socketResolver = resolver<WebSocket>();\n\n  #connectionStateChangeResolver = resolver<ConnectionState>();\n\n  /**\n   * This resolver is only used for rejections. It is awaited in the connected\n   * state (including when waiting for a pong). It is rejected when we get an\n   * invalid message or an 'error' message.\n   */\n  #rejectMessageError: Resolver<never> | undefined = undefined;\n\n  #closeAbortController = new AbortController();\n\n  readonly #visibilityWatcher;\n\n  // We use an accessor pair to allow the subclass to override the setter.\n  #connectionState: ConnectionState = ConnectionState.Disconnected;\n  readonly #activeClientsManager: Promise<ActiveClientsManager>;\n\n  #setConnectionState(state: ConnectionState) {\n    if (state === this.#connectionState) {\n      return;\n    }\n\n    this.#connectionState = state;\n    this.#connectionStateChangeResolver.resolve(state);\n    this.#connectionStateChangeResolver = resolver<ConnectionState>();\n\n    if (TESTING) {\n      asTestZero(this)[onSetConnectionStateSymbol]?.(state);\n    }\n  }\n\n  #connectStart: number | undefined = undefined;\n  // Set on connect attempt if currently undefined.\n  // Reset to undefined when\n  // 1. client stops trying to connect because it is hidden\n  // 2. client encounters a connect error and canary request indicates\n  //    the client is offline\n  // 2. client successfully connects\n  #totalToConnectStart: number | undefined = undefined;\n\n  readonly #options: ZeroOptions<S, MD>;\n\n  readonly query: MakeEntityQueriesFromSchema<S>;\n\n  // TODO: Metrics needs to be rethought entirely as we're not going to\n  // send metrics to customer server.\n  #metrics: MetricManager;\n\n  // Store as field to allow test subclass to override. Web API doesn't allow\n  // overwriting location fields for security reasons.\n  #reload = () => getBrowserGlobal('location')?.reload();\n\n  /**\n   * Constructs a new Zero client.\n   */\n  constructor(options: ZeroOptions<S, MD>) {\n    const {\n      userID,\n      storageKey,\n      onOnlineChange,\n      onUpdateNeeded,\n      onClientStateNotFound,\n      hiddenTabDisconnectDelay = DEFAULT_DISCONNECT_HIDDEN_DELAY_MS,\n      schema,\n      batchViewUpdates = applyViewUpdates => applyViewUpdates(),\n      maxRecentQueries = 0,\n      slowMaterializeThreshold = 5_000,\n    } = options as ZeroOptions<S, MD>;\n    if (!userID) {\n      throw new Error('ZeroOptions.userID must not be empty.');\n    }\n    const server = getServer(options.server);\n    this.#enableAnalytics = shouldEnableAnalytics(\n      server,\n      false /*options.enableAnalytics,*/, // Reenable analytics\n    );\n\n    let {kvStore = 'idb'} = options as ZeroOptions<S, MD>;\n    if (kvStore === 'idb') {\n      if (!getBrowserGlobal('indexedDB')) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          'IndexedDB is not supported in this environment. Falling back to memory storage.',\n        );\n        kvStore = 'mem';\n      }\n    }\n\n    if (hiddenTabDisconnectDelay < 0) {\n      throw new Error(\n        'ZeroOptions.hiddenTabDisconnectDelay must not be negative.',\n      );\n    }\n\n    this.#onlineManager = new OnlineManager();\n\n    if (onOnlineChange) {\n      this.#onlineManager.subscribe(onOnlineChange);\n    }\n\n    this.#options = options;\n\n    this.#logOptions = this.#createLogOptions({\n      consoleLogLevel: options.logLevel ?? 'warn',\n      server: null, //server, // Reenable remote logging\n      enableAnalytics: this.#enableAnalytics,\n    });\n    const logOptions = this.#logOptions;\n\n    const {enableLegacyMutators = true, enableLegacyQueries = true} = schema;\n\n    const replicacheMutators: MutatorDefs & {\n      [CRUD_MUTATION_NAME]: CRUDMutator;\n    } = {\n      [CRUD_MUTATION_NAME]: enableLegacyMutators\n        ? makeCRUDMutator(schema)\n        : () =>\n            Promise.reject(new Error('Zero CRUD mutators are not enabled.')),\n    };\n    this.#ivmMain = new IVMSourceBranch(schema.tables);\n\n    function assertUnique(key: string) {\n      assert(\n        replicacheMutators[key] === undefined,\n        `A mutator, or mutator namespace, has already been defined for ${key}`,\n      );\n    }\n\n    // We create a special log sink that calls onError if defined instead of\n    // logging error messages.\n    const {onError} = options;\n    const sink = logOptions.logSink;\n    const logSink: LogSink<OnErrorParameters> = {\n      log(level, context, ...args) {\n        if (level === 'error' && onError) {\n          onError(...(args as OnErrorParameters));\n        } else {\n          sink.log(level, context, ...args);\n        }\n      },\n      async flush() {\n        await sink.flush?.();\n      },\n    };\n\n    const lc = new ZeroLogContext(logOptions.logLevel, {}, logSink);\n\n    this.#mutationTracker = new MutationTracker(lc, (upTo: MutationID) =>\n      this.#send(['ackMutationResponses', upTo]),\n    );\n    if (options.mutators) {\n      for (const [namespaceOrKey, mutatorOrMutators] of Object.entries(\n        options.mutators,\n      )) {\n        if (typeof mutatorOrMutators === 'function') {\n          const key = namespaceOrKey as string;\n          assertUnique(key);\n          replicacheMutators[key] = makeReplicacheMutator(\n            lc,\n            mutatorOrMutators,\n            schema,\n            // Replicache expects mutators to only be able to return JSON\n            // but Zero wraps the return with: `{server?: Promise<MutationResult>, client?: T}`\n          ) as () => MutatorReturn;\n          continue;\n        }\n        if (typeof mutatorOrMutators === 'object') {\n          for (const [name, mutator] of Object.entries(mutatorOrMutators)) {\n            const key = customMutatorKey(\n              namespaceOrKey as string,\n              name as string,\n            );\n            assertUnique(key);\n            replicacheMutators[key] = makeReplicacheMutator(\n              lc,\n              mutator as CustomMutatorImpl<S>,\n              schema,\n            ) as () => MutatorReturn;\n          }\n          continue;\n        }\n        unreachable(mutatorOrMutators);\n      }\n    }\n\n    this.storageKey = storageKey ?? '';\n\n    this.#schema = schema;\n    const {clientSchema, hash} = clientSchemaFrom(schema);\n    this.#clientSchema = clientSchema;\n\n    const replicacheOptions: ReplicacheOptions<WithCRUD<MutatorDefs>> = {\n      // The schema stored in IDB is dependent upon both the ClientSchema\n      // and the AST schema (i.e. PROTOCOL_VERSION).\n      schemaVersion: `${PROTOCOL_VERSION}.${hash}`,\n      logLevel: logOptions.logLevel,\n      logSinks: [logOptions.logSink],\n      mutators: replicacheMutators,\n      name: `zero-${userID}-${this.storageKey}`,\n      pusher: (req, reqID) => this.#pusher(req, reqID),\n      puller: (req, reqID) => this.#puller(req, reqID),\n      pushDelay: 0,\n      requestOptions: {\n        maxDelayMs: 0,\n        minDelayMs: 0,\n      },\n      licenseKey: 'zero-client-static-key',\n      kvStore,\n    };\n\n    this.#zeroContext = new ZeroContext(\n      lc,\n      this.#ivmMain,\n      (ast, ttl, gotCallback) => {\n        if (enableLegacyQueries) {\n          return this.#queryManager.addLegacy(ast, ttl, gotCallback);\n        }\n        // legacy queries are client side only. Do not track with the server\n        return emptyFunction;\n      },\n      (ast, customQueryID, ttl, gotCallback) =>\n        this.#queryManager.addCustom(ast, customQueryID, ttl, gotCallback),\n      (ast, ttl) => {\n        if (enableLegacyQueries) {\n          this.#queryManager.updateLegacy(ast, ttl);\n          return;\n        }\n        this.#queryManager.updateLegacy(ast, ttl);\n      },\n      (customQueryID, ttl) =>\n        this.#queryManager.updateCustom(customQueryID, ttl),\n      () => this.#queryManager.flushBatch(),\n      batchViewUpdates,\n      this.#addMetric,\n      assertValidRunOptions,\n    );\n    this.queryDelegate = this.#zeroContext;\n\n    const replicacheImplOptions: ReplicacheImplOptions = {\n      enableClientGroupForking: false,\n      enableMutationRecovery: false,\n      enablePullAndPushInOpen: false, // Zero calls push in its connection management code\n      onClientsDeleted: (clientIDs, clientGroupIDs) =>\n        this.#deleteClientsManager.onClientsDeleted(clientIDs, clientGroupIDs),\n      zero: new ZeroRep(\n        this.#zeroContext,\n        this.#ivmMain,\n        options.mutators !== undefined,\n        this.#mutationTracker,\n      ),\n    };\n\n    const rep = new ReplicacheImpl(replicacheOptions, replicacheImplOptions);\n    this.#rep = rep;\n\n    if (TESTING) {\n      internalReplicacheImplMap.set(this, rep);\n    }\n    this.#server = server;\n    this.userID = userID;\n    this.#lc = lc.withContext('clientID', rep.clientID);\n    this.#mutationTracker.setClientIDAndWatch(\n      rep.clientID,\n      rep.experimentalWatch.bind(rep),\n    );\n\n    this.#activeClientsManager = makeActiveClientsManager(\n      rep.clientGroupID,\n      this.clientID,\n      this.#closeAbortController.signal,\n      (clientID: string) =>\n        this.#deleteClientsManager.onClientsDeleted([clientID], []),\n    );\n\n    const onUpdateNeededCallback = (\n      reason: UpdateNeededReason,\n      serverErrorMsg?: string | undefined,\n    ) => {\n      if (onUpdateNeeded) {\n        onUpdateNeeded(reason);\n      } else {\n        reloadWithReason(\n          this.#lc,\n          this.#reload,\n          reason.type,\n          updateNeededReloadReasonMessage(reason, serverErrorMsg),\n        );\n      }\n    };\n    this.#onUpdateNeeded = onUpdateNeededCallback;\n    this.#rep.onUpdateNeeded = reason => {\n      onUpdateNeededCallback(convertOnUpdateNeededReason(reason));\n    };\n\n    const onClientStateNotFoundCallback =\n      onClientStateNotFound ??\n      ((reason?: string) => {\n        reloadWithReason(\n          this.#lc,\n          this.#reload,\n          ErrorKind.ClientNotFound,\n          reason ?? ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT,\n        );\n      });\n    this.#onClientStateNotFound = onClientStateNotFoundCallback;\n    this.#rep.onClientStateNotFound = onClientStateNotFoundCallback;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const {mutate, mutateBatch} = makeCRUDMutate<S>(schema, rep.mutate) as any;\n\n    if (options.mutators) {\n      for (const [namespaceOrKey, mutatorsOrMutator] of Object.entries(\n        options.mutators,\n      )) {\n        if (typeof mutatorsOrMutator === 'function') {\n          mutate[namespaceOrKey] = must(rep.mutate[namespaceOrKey as string]);\n          continue;\n        }\n\n        let existing = mutate[namespaceOrKey];\n        if (existing === undefined) {\n          existing = {};\n          mutate[namespaceOrKey] = existing;\n        }\n\n        for (const name of Object.keys(mutatorsOrMutator)) {\n          existing[name] = must(\n            rep.mutate[customMutatorKey(namespaceOrKey as string, name)],\n          );\n        }\n      }\n    }\n\n    this.mutate = mutate;\n    this.mutateBatch = mutateBatch;\n\n    this.#queryManager = new QueryManager(\n      this.#lc,\n      this.#mutationTracker,\n      rep.clientID,\n      schema.tables,\n      msg => this.#send(msg),\n      rep.experimentalWatch.bind(rep),\n      maxRecentQueries,\n      options.queryChangeThrottleMs ?? DEFAULT_QUERY_CHANGE_THROTTLE_MS,\n      slowMaterializeThreshold,\n    );\n    this.#clientToServer = clientToServer(schema.tables);\n\n    this.#deleteClientsManager = new DeleteClientsManager(\n      msg => this.#send(msg),\n      rep.perdag,\n      this.#lc,\n    );\n\n    this.query = this.#registerQueries(schema);\n\n    reportReloadReason(this.#lc);\n\n    this.#metrics = new MetricManager({\n      reportIntervalMs: REPORT_INTERVAL_MS,\n      host: getBrowserGlobal('location')?.host ?? '',\n      source: 'client',\n      reporter: this.#enableAnalytics\n        ? allSeries => this.#reportMetrics(allSeries)\n        : () => Promise.resolve(),\n      lc: this.#lc,\n    });\n    this.#metrics.tags.push(`version:${this.version}`);\n\n    this.#pokeHandler = new PokeHandler(\n      poke => this.#rep.poke(poke),\n      () => this.#onPokeError(),\n      rep.clientID,\n      schema,\n      this.#lc,\n      this.#mutationTracker,\n    );\n\n    this.#visibilityWatcher = getDocumentVisibilityWatcher(\n      getBrowserGlobal('document'),\n      hiddenTabDisconnectDelay,\n      this.#closeAbortController.signal,\n    );\n\n    void this.#runLoop();\n\n    this.#expose();\n\n    if (TESTING) {\n      asTestZero(this)[exposedToTestingSymbol] = {\n        puller: this.#puller,\n        pusher: this.#pusher,\n        setReload: (r: () => void) => {\n          this.#reload = r;\n        },\n        logOptions: this.#logOptions,\n        connectStart: () => this.#connectStart,\n        socketResolver: () => this.#socketResolver,\n        connectionState: () => this.#connectionState,\n      };\n    }\n  }\n\n  #expose() {\n    // Expose the Zero instance to the global scope.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const g = globalThis as any;\n    if (g.__zero === undefined) {\n      g.__zero = this;\n    } else if (g.__zero instanceof Zero) {\n      const prev = g.__zero;\n      g.__zero = {\n        [prev.clientID]: prev,\n        [this.clientID]: this,\n      };\n    } else {\n      g.__zero[this.clientID] = this;\n    }\n  }\n\n  #unexpose() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const g = globalThis as any;\n    assert(g.__zero !== undefined);\n    if (g.__zero instanceof Zero) {\n      assert(g.__zero === this);\n      delete g.__zero;\n    } else {\n      delete g.__zero[this.clientID];\n      if (Object.entries(g.__zero).length === 1) {\n        g.__zero = Object.values(g.__zero)[0];\n      }\n    }\n  }\n\n  #send(msg: Upstream): void {\n    if (this.#socket && this.#connectionState === ConnectionState.Connected) {\n      send(this.#socket, msg);\n    }\n  }\n\n  #createLogOptions(options: {\n    consoleLogLevel: LogLevel;\n    server: HTTPString | null;\n    enableAnalytics: boolean;\n  }): LogOptions {\n    if (TESTING) {\n      const testZero = asTestZero(this);\n      if (testZero[createLogOptionsSymbol]) {\n        return testZero[createLogOptionsSymbol](options);\n      }\n    }\n    return createLogOptions(options);\n  }\n\n  preload(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    query: Query<S, keyof S['tables'] & string, any>,\n    options?: PreloadOptions | undefined,\n  ) {\n    return query[delegateSymbol](this.#zeroContext).preload(options);\n  }\n\n  run<Q>(\n    query: Q,\n    runOptions?: RunOptions | undefined,\n  ): Promise<HumanReadable<QueryReturn<Q>>> {\n    return (\n      (query as AnyQuery)\n        // eslint-disable-next-line no-unexpected-multiline\n        [delegateSymbol](this.#zeroContext)\n        .run(runOptions) as Promise<HumanReadable<QueryReturn<Q>>>\n    );\n  }\n\n  materialize<Q>(\n    query: Q,\n    options?: MaterializeOptions | undefined,\n  ): TypedView<HumanReadable<QueryReturn<Q>>>;\n  materialize<T, Q>(\n    query: Q,\n    factory: ViewFactory<S, QueryTable<Q>, QueryReturn<Q>, T>,\n    options?: MaterializeOptions | undefined,\n  ): T;\n  materialize<T, Q>(\n    query: Q,\n    factoryOrOptions?:\n      | ViewFactory<S, QueryTable<Q>, QueryReturn<Q>, T>\n      | MaterializeOptions\n      | undefined,\n    maybeOptions?: MaterializeOptions | undefined,\n  ) {\n    return materialize(\n      query,\n      this.#zeroContext,\n      factoryOrOptions,\n      maybeOptions,\n    );\n  }\n\n  /**\n   * The server URL that this Zero instance is configured with.\n   */\n  get server(): HTTPString | null {\n    return this.#server;\n  }\n\n  /**\n   * The name of the IndexedDB database in which the data of this\n   * instance of Zero is stored.\n   */\n  get idbName(): string {\n    return this.#rep.idbName;\n  }\n\n  /**\n   * The schema version of the data understood by this application.\n   * See [[ZeroOptions.schemaVersion]].\n   */\n  get schemaVersion(): string {\n    return this.#rep.schemaVersion;\n  }\n\n  /**\n   * The client ID for this instance of Zero. Each instance\n   * gets a unique client ID.\n   */\n  get clientID(): ClientID {\n    return this.#rep.clientID;\n  }\n\n  get clientGroupID(): Promise<ClientGroupID> {\n    return this.#rep.clientGroupID;\n  }\n\n  /**\n   * Provides simple \"CRUD\" mutations for the tables in the schema.\n   *\n   * Each table has `create`, `set`, `update`, and `delete` methods.\n   *\n   * ```ts\n   * await zero.mutate.issue.create({id: '1', title: 'First issue', priority: 'high'});\n   * await zero.mutate.comment.create({id: '1', text: 'First comment', issueID: '1'});\n   * ```\n   *\n   * The `update` methods support partials. Unspecified or `undefined` fields\n   * are left unchanged:\n   *\n   * ```ts\n   * // Priority left unchanged.\n   * await zero.mutate.issue.update({id: '1', title: 'Updated title'});\n   * ```\n   */\n  readonly mutate: MD extends CustomMutatorDefs\n    ? S['enableLegacyMutators'] extends false\n      ? MakeCustomMutatorInterfaces<S, MD>\n      : DeepMerge<DBMutator<S>, MakeCustomMutatorInterfaces<S, MD>>\n    : DBMutator<S>;\n\n  /**\n   * Provides a way to batch multiple CRUD mutations together:\n   *\n   * ```ts\n   * await zero.mutateBatch(m => {\n   *   await m.issue.create({id: '1', title: 'First issue'});\n   *   await m.comment.create({id: '1', text: 'First comment', issueID: '1'});\n   * });\n   * ```\n   *\n   * Batch sends all mutations in a single transaction. If one fails, all are\n   * rolled back together. Batch can also be more efficient than making many\n   * individual mutations.\n   *\n   * `mutateBatch` is not allowed inside another `mutateBatch` call. Doing so\n   * will throw an error.\n   */\n  readonly mutateBatch: BatchMutator<S>;\n\n  /**\n   * Whether this Zero instance has been closed.\n   *\n   * Once a Zero instance has been closed it no longer syncs, you can no\n   * longer query or mutate data with it, and its query views stop updating.\n   */\n  get closed(): boolean {\n    return this.#rep.closed;\n  }\n\n  /**\n   * Closes this Zero instance.\n   *\n   * Once a Zero instance has been closed it no longer syncs, you can no\n   * longer query or mutate data with it, and its query views stop updating.\n   */\n  async close(): Promise<void> {\n    const lc = this.#lc.withContext('close');\n\n    lc.debug?.('Closing Zero instance. Stack:', new Error().stack);\n\n    this.#onlineManager.cleanup();\n\n    if (this.#connectionState !== ConnectionState.Disconnected) {\n      this.#disconnect(\n        lc,\n        {\n          client: 'ClientClosed',\n        },\n        CLOSE_CODE_NORMAL,\n      );\n    }\n    lc.debug?.('Aborting closeAbortController due to close()');\n    this.#closeAbortController.abort();\n    this.#metrics.stop();\n    const ret = await this.#rep.close();\n    this.#unexpose();\n    return ret;\n  }\n\n  #onMessage = (e: MessageEvent<string>) => {\n    const lc = this.#lc;\n    lc.debug?.('received message', e.data);\n    if (this.closed) {\n      lc.debug?.('ignoring message because already closed');\n      return;\n    }\n\n    const rejectInvalidMessage = (e?: unknown) =>\n      this.#rejectMessageError?.reject(\n        new Error(\n          `Invalid message received from server: ${\n            e instanceof Error ? e.message + '. ' : ''\n          }${data}`,\n        ),\n      );\n\n    let downMessage: Downstream;\n    const {data} = e;\n    try {\n      downMessage = valita.parse(\n        JSON.parse(data),\n        downstreamSchema,\n        'passthrough',\n      );\n    } catch (e) {\n      rejectInvalidMessage(e);\n      return;\n    }\n    this.#messageCount++;\n    const msgType = downMessage[0];\n    switch (msgType) {\n      case 'connected':\n        return this.#handleConnectedMessage(lc, downMessage);\n\n      case 'error':\n        return this.#handleErrorMessage(lc, downMessage);\n\n      case 'pong':\n        // Receiving a pong means that the connection is healthy, as the\n        // initial schema / versioning negotiations would produce an error\n        // before a ping-pong timeout.\n        resetBackoff();\n        return this.#onPong();\n\n      case 'pokeStart':\n        return this.#handlePokeStart(lc, downMessage);\n\n      case 'pokePart':\n        if (downMessage[1].rowsPatch) {\n          // Receiving row data indicates that the client is in a good state\n          // and can reset the reload backoff state.\n          resetBackoff();\n        }\n        return this.#handlePokePart(lc, downMessage);\n\n      case 'pokeEnd':\n        return this.#handlePokeEnd(lc, downMessage);\n\n      case 'pull':\n        return this.#handlePullResponse(lc, downMessage);\n\n      case 'deleteClients':\n        return this.#deleteClientsManager.clientsDeletedOnServer(\n          downMessage[1],\n        );\n\n      case 'pushResponse':\n        return this.#mutationTracker.processPushResponse(downMessage[1]);\n\n      case 'transformError':\n        // this.#queryManager.handleTransformError();\n        break;\n\n      case 'inspect':\n        // ignore at this layer.\n        break;\n\n      default:\n        msgType satisfies never;\n        rejectInvalidMessage();\n    }\n  };\n\n  #onOpen = () => {\n    const l = addWebSocketIDFromSocketToLogContext(this.#socket!, this.#lc);\n    if (this.#connectStart === undefined) {\n      l.error?.('Got open event but connect start time is undefined.');\n    } else {\n      const now = Date.now();\n      const timeToOpenMs = now - this.#connectStart;\n      l.info?.('Got socket open event', {\n        navigatorOnline: navigator?.onLine,\n        timeToOpenMs,\n      });\n    }\n  };\n\n  #onClose = (e: CloseEvent) => {\n    const lc = addWebSocketIDFromSocketToLogContext(this.#socket!, this.#lc);\n    const {code, reason, wasClean} = e;\n    if (code <= 1001) {\n      lc.info?.('Got socket close event', {code, reason, wasClean});\n    } else {\n      lc.error?.('Got unexpected socket close event', {\n        code,\n        reason,\n        wasClean,\n      });\n    }\n\n    const closeKind = wasClean ? 'CleanClose' : 'AbruptClose';\n    this.#connectResolver.reject(new CloseError(closeKind));\n    this.#disconnect(lc, {client: closeKind});\n  };\n\n  // An error on the connection is fatal for the connection.\n  async #handleErrorMessage(\n    lc: ZeroLogContext,\n    downMessage: ErrorMessage,\n  ): Promise<void> {\n    const [, {kind, message}] = downMessage;\n\n    // Rate limit errors are not fatal to the connection.\n    // We really don't want to disconnect and reconnect a rate limited user as\n    // it'll use more resources on the server\n    if (kind === ErrorKind.MutationRateLimited) {\n      this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;\n      lc.error?.(kind, 'Mutation rate limited', {message});\n      return;\n    }\n\n    lc.info?.(`${kind}: ${message}}`);\n    const error = new ServerError(downMessage[1]);\n\n    this.#rejectMessageError?.reject(error);\n    lc.debug?.('Rejecting connect resolver due to error', error);\n    this.#connectResolver.reject(error);\n    this.#disconnect(lc, {server: kind});\n\n    if (kind === ErrorKind.VersionNotSupported) {\n      this.#onUpdateNeeded?.({type: kind}, message);\n    } else if (kind === ErrorKind.SchemaVersionNotSupported) {\n      await this.#rep.disableClientGroup();\n      this.#onUpdateNeeded?.({type: 'SchemaVersionNotSupported'}, message);\n    } else if (kind === ErrorKind.ClientNotFound) {\n      await this.#rep.disableClientGroup();\n      this.#onClientStateNotFound?.(onClientStateNotFoundServerReason(message));\n    } else if (\n      kind === ErrorKind.InvalidConnectionRequestLastMutationID ||\n      kind === ErrorKind.InvalidConnectionRequestBaseCookie\n    ) {\n      await dropDatabase(this.#rep.idbName);\n      reloadWithReason(lc, this.#reload, kind, serverAheadReloadReason);\n    }\n  }\n\n  async #handleConnectedMessage(\n    lc: ZeroLogContext,\n    connectedMessage: ConnectedMessage,\n  ): Promise<void> {\n    const now = Date.now();\n    const [, connectBody] = connectedMessage;\n    lc = addWebSocketIDToLogContext(connectBody.wsid, lc);\n\n    if (this.#connectedCount === 0) {\n      this.#checkConnectivity('firstConnect');\n    } else if (this.#connectErrorCount > 0) {\n      this.#checkConnectivity('connectAfterError');\n    }\n    this.#connectedCount++;\n    this.#connectedAt = now;\n    this.#metrics.lastConnectError.clear();\n    const proceedingConnectErrorCount = this.#connectErrorCount;\n    this.#connectErrorCount = 0;\n\n    let timeToConnectMs: number | undefined;\n    let connectMsgLatencyMs: number | undefined;\n    if (this.#connectStart === undefined) {\n      lc.error?.('Got connected message but connect start time is undefined.');\n    } else {\n      timeToConnectMs = now - this.#connectStart;\n      this.#metrics.timeToConnectMs.set(timeToConnectMs);\n      connectMsgLatencyMs =\n        connectBody.timestamp !== undefined\n          ? now - connectBody.timestamp\n          : undefined;\n      this.#connectStart = undefined;\n    }\n    let totalTimeToConnectMs: number | undefined;\n    if (this.#totalToConnectStart === undefined) {\n      lc.error?.(\n        'Got connected message but total to connect start time is undefined.',\n      );\n    } else {\n      totalTimeToConnectMs = now - this.#totalToConnectStart;\n      this.#totalToConnectStart = undefined;\n    }\n\n    this.#metrics.setConnected(timeToConnectMs ?? 0, totalTimeToConnectMs ?? 0);\n\n    lc.info?.('Connected', {\n      navigatorOnline: navigator?.onLine,\n      timeToConnectMs,\n      totalTimeToConnectMs,\n      connectMsgLatencyMs,\n      connectedCount: this.#connectedCount,\n      proceedingConnectErrorCount,\n    });\n    this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;\n\n    lc.debug?.('Resolving connect resolver');\n    const socket = must(this.#socket);\n    const queriesPatch = await this.#rep.query(tx =>\n      this.#queryManager.getQueriesPatch(tx, this.#initConnectionQueries),\n    );\n\n    const hasDeletedClients = () =>\n      skipEmptyArray(this.#deletedClients?.clientIDs) ||\n      skipEmptyArray(this.#deletedClients?.clientGroupIDs);\n\n    const maybeSendDeletedClients = () => {\n      if (hasDeletedClients()) {\n        send(socket, ['deleteClients', this.#deletedClients!]);\n        this.#deletedClients = undefined;\n      }\n    };\n\n    if (queriesPatch.size > 0 && this.#initConnectionQueries !== undefined) {\n      maybeSendDeletedClients();\n      send(socket, [\n        'changeDesiredQueries',\n        {\n          desiredQueriesPatch: [...queriesPatch.values()],\n        },\n      ]);\n    } else if (this.#initConnectionQueries === undefined) {\n      // if #initConnectionQueries was undefined that means we never\n      // sent `initConnection` to the server inside the sec-protocol header.\n      const clientSchema = this.#clientSchema;\n      send(socket, [\n        'initConnection',\n        {\n          desiredQueriesPatch: [...queriesPatch.values()],\n          deleted: skipEmptyDeletedClients(this.#deletedClients),\n          // The clientSchema only needs to be sent for the very first request.\n          // Henceforth it is stored with the CVR and verified automatically.\n          ...(this.#connectCookie === null ? {clientSchema} : {}),\n          userPushParams: this.#options.mutate ?? this.#options.push,\n          userQueryParams: this.#options.query,\n        },\n      ]);\n      this.#deletedClients = undefined;\n    }\n    this.#initConnectionQueries = undefined;\n\n    maybeSendDeletedClients();\n\n    this.#setConnectionState(ConnectionState.Connected);\n    this.#connectResolver.resolve();\n  }\n\n  /**\n   * Starts a new connection. This will create the WebSocket that does the HTTP\n   * request to the server.\n   *\n   * {@link #connect} will throw an assertion error if the\n   * {@link #connectionState} is not {@link ConnectionState.Disconnected}.\n   * Callers MUST check the connection state before calling this method and log\n   * an error as needed.\n   *\n   * The function will resolve once the socket is connected. If you need to know\n   * when a connection has been established, as in we have received the\n   * {@link ConnectedMessage}, you should await the {@link #connectResolver}\n   * promise. The {@link #connectResolver} promise rejects if an error message\n   * is received before the connected message is received or if the connection\n   * attempt times out.\n   */\n  async #connect(\n    lc: ZeroLogContext,\n    additionalConnectParams: Record<string, string> | undefined,\n  ): Promise<void> {\n    assert(this.#server);\n\n    // All the callers check this state already.\n    assert(this.#connectionState === ConnectionState.Disconnected);\n\n    const wsid = nanoid();\n    lc = addWebSocketIDToLogContext(wsid, lc);\n    lc.info?.('Connecting...', {navigatorOnline: navigator?.onLine});\n\n    this.#setConnectionState(ConnectionState.Connecting);\n\n    // connect() called but connect start time is defined. This should not\n    // happen.\n    assert(this.#connectStart === undefined);\n\n    const now = Date.now();\n    this.#connectStart = now;\n    if (this.#totalToConnectStart === undefined) {\n      this.#totalToConnectStart = now;\n    }\n\n    if (this.closed) {\n      return;\n    }\n    this.#connectCookie = valita.parse(\n      await this.#rep.cookie,\n      nullableVersionSchema,\n      'passthrough',\n    );\n    if (this.closed) {\n      return;\n    }\n\n    // Reject connect after a timeout.\n    const timeoutID = setTimeout(() => {\n      lc.debug?.('Rejecting connect resolver due to timeout');\n      this.#connectResolver.reject(new TimedOutError('Connect'));\n      this.#disconnect(lc, {\n        client: 'ConnectTimeout',\n      });\n    }, CONNECT_TIMEOUT_MS);\n    const abortHandler = () => {\n      clearTimeout(timeoutID);\n    };\n    // signal.aborted cannot be true here because we checked for `this.closed` above.\n    this.#closeAbortController.signal.addEventListener('abort', abortHandler);\n\n    const [ws, initConnectionQueries, deletedClients] = await createSocket(\n      this.#rep,\n      this.#queryManager,\n      this.#deleteClientsManager,\n      toWSString(this.#server),\n      this.#connectCookie,\n      this.clientID,\n      await this.clientGroupID,\n      this.#clientSchema,\n      this.userID,\n      this.#rep.auth,\n      this.#lastMutationIDReceived,\n      wsid,\n      this.#options.logLevel === 'debug',\n      lc,\n      this.#options.mutate ?? this.#options.push,\n      this.#options.query,\n      this.#options.maxHeaderLength,\n      additionalConnectParams,\n      await this.#activeClientsManager,\n    );\n\n    if (this.closed) {\n      return;\n    }\n\n    this.#initConnectionQueries = initConnectionQueries;\n    this.#deletedClients = deletedClients;\n    ws.addEventListener('message', this.#onMessage);\n    ws.addEventListener('open', this.#onOpen);\n    ws.addEventListener('close', this.#onClose);\n    this.#socket = ws;\n    this.#socketResolver.resolve(ws);\n\n    try {\n      lc.debug?.('Waiting for connection to be acknowledged');\n      await this.#connectResolver.promise;\n      this.#mutationTracker.onConnected(this.#lastMutationIDReceived);\n      // push any outstanding mutations on reconnect.\n      this.#rep.push().catch(() => {});\n    } finally {\n      clearTimeout(timeoutID);\n      this.#closeAbortController.signal.removeEventListener(\n        'abort',\n        abortHandler,\n      );\n    }\n  }\n\n  #disconnect(\n    lc: ZeroLogContext,\n    reason: DisconnectReason,\n    closeCode?: CloseCode,\n  ): void {\n    if (this.#connectionState === ConnectionState.Connecting) {\n      this.#connectErrorCount++;\n    }\n    lc.info?.('disconnecting', {\n      navigatorOnline: navigator?.onLine,\n      reason,\n      connectStart: this.#connectStart,\n      totalToConnectStart: this.#totalToConnectStart,\n      connectedAt: this.#connectedAt,\n      connectionDuration: this.#connectedAt\n        ? Date.now() - this.#connectedAt\n        : 0,\n      messageCount: this.#messageCount,\n      connectionState: this.#connectionState,\n      connectErrorCount: this.#connectErrorCount,\n    });\n\n    switch (this.#connectionState) {\n      case ConnectionState.Connected: {\n        if (this.#connectStart !== undefined) {\n          lc.error?.(\n            'disconnect() called while connected but connect start time is defined.',\n          );\n          // this._connectStart reset below.\n        }\n\n        break;\n      }\n      case ConnectionState.Connecting: {\n        this.#metrics.lastConnectError.set(getLastConnectErrorValue(reason));\n        this.#metrics.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n        this.#metrics.setConnectError(reason);\n        if (\n          this.#connectErrorCount % CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY ===\n          1\n        ) {\n          this.#checkConnectivity(\n            `connectErrorCount=${this.#connectErrorCount}`,\n          );\n        }\n        // this._connectStart reset below.\n        if (this.#connectStart === undefined) {\n          lc.error?.(\n            'disconnect() called while connecting but connect start time is undefined.',\n          );\n        }\n\n        break;\n      }\n      case ConnectionState.Disconnected:\n        lc.error?.('disconnect() called while disconnected');\n        break;\n    }\n\n    this.#socketResolver = resolver();\n    lc.debug?.('Creating new connect resolver');\n    this.#connectResolver = resolver();\n    this.#setConnectionState(ConnectionState.Disconnected);\n    this.#messageCount = 0;\n    this.#connectStart = undefined; // don't reset this._totalToConnectStart\n    this.#connectedAt = 0;\n    this.#socket?.removeEventListener('message', this.#onMessage);\n    this.#socket?.removeEventListener('open', this.#onOpen);\n    this.#socket?.removeEventListener('close', this.#onClose);\n    this.#socket?.close(closeCode);\n    this.#socket = undefined;\n    this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;\n    this.#pokeHandler.handleDisconnect();\n  }\n\n  #handlePokeStart(_lc: ZeroLogContext, pokeMessage: PokeStartMessage): void {\n    this.#abortPingTimeout();\n    this.#pokeHandler.handlePokeStart(pokeMessage[1]);\n  }\n\n  #handlePokePart(_lc: ZeroLogContext, pokeMessage: PokePartMessage): void {\n    this.#abortPingTimeout();\n    const lastMutationIDChangeForSelf = this.#pokeHandler.handlePokePart(\n      pokeMessage[1],\n    );\n    if (lastMutationIDChangeForSelf !== undefined) {\n      this.#lastMutationIDReceived = lastMutationIDChangeForSelf;\n    }\n  }\n\n  #handlePokeEnd(_lc: ZeroLogContext, pokeMessage: PokeEndMessage): void {\n    this.#abortPingTimeout();\n    this.#pokeHandler.handlePokeEnd(pokeMessage[1]);\n  }\n\n  #onPokeError(): void {\n    const lc = this.#lc;\n    lc.info?.(\n      'poke error, disconnecting?',\n      this.#connectionState !== ConnectionState.Disconnected,\n    );\n\n    // It is theoretically possible that we get disconnected during the\n    // async poke above. Only disconnect if we are not already\n    // disconnected.\n    if (this.#connectionState !== ConnectionState.Disconnected) {\n      this.#disconnect(lc, {\n        client: 'UnexpectedBaseCookie',\n      });\n    }\n  }\n\n  #handlePullResponse(\n    lc: ZeroLogContext,\n    pullResponseMessage: PullResponseMessage,\n  ): void {\n    this.#abortPingTimeout();\n    const body = pullResponseMessage[1];\n    lc = lc.withContext('requestID', body.requestID);\n    lc.debug?.('Handling pull response', body);\n    const resolver = this.#pendingPullsByRequestID.get(body.requestID);\n    if (!resolver) {\n      // This can happen because resolvers are deleted\n      // from this._pendingPullsByRequestID when pulls timeout.\n      lc.debug?.('No resolver found');\n      return;\n    }\n    resolver.resolve(pullResponseMessage[1]);\n  }\n\n  async #pusher(req: PushRequest, requestID: string): Promise<PusherResult> {\n    // The deprecation of pushVersion 0 predates zero-client\n    assert(req.pushVersion === 1);\n    // If we are connecting we wait until we are connected.\n    await this.#connectResolver.promise;\n    const lc = this.#lc.withContext('requestID', requestID);\n    lc.debug?.(`pushing ${req.mutations.length} mutations`);\n    const socket = this.#socket;\n    assert(socket);\n\n    const isMutationRecoveryPush =\n      req.clientGroupID !== (await this.clientGroupID);\n    const start = isMutationRecoveryPush\n      ? 0\n      : req.mutations.findIndex(\n          m =>\n            m.clientID === this.#lastMutationIDSent.clientID &&\n            m.id === this.#lastMutationIDSent.id,\n        ) + 1;\n    lc.debug?.(\n      isMutationRecoveryPush ? 'pushing for recovery' : 'pushing',\n      req.mutations.length - start,\n      'mutations of',\n      req.mutations.length,\n      'mutations.',\n    );\n    const now = Date.now();\n    for (let i = start; i < req.mutations.length; i++) {\n      const m = req.mutations[i];\n      const timestamp = now - Math.round(performance.now() - m.timestamp);\n      const zeroM =\n        m.name === CRUD_MUTATION_NAME\n          ? ({\n              type: MutationType.CRUD,\n              timestamp,\n              id: m.id,\n              clientID: m.clientID,\n              name: m.name,\n              args: [mapCRUD(m.args as CRUDMutationArg, this.#clientToServer)],\n            } satisfies CRUDMutation)\n          : ({\n              type: MutationType.Custom,\n              timestamp,\n              id: m.id,\n              clientID: m.clientID,\n              name: m.name,\n              args: [m.args],\n            } satisfies CustomMutation);\n      const msg: PushMessage = [\n        'push',\n        {\n          timestamp: now,\n          clientGroupID: req.clientGroupID,\n          mutations: [zeroM],\n          pushVersion: req.pushVersion,\n          requestID,\n        },\n      ];\n      send(socket, msg);\n      if (!isMutationRecoveryPush) {\n        this.#lastMutationIDSent = {clientID: m.clientID, id: m.id};\n      }\n    }\n    return {\n      httpRequestInfo: {\n        errorMessage: '',\n        httpStatusCode: 200,\n      },\n    };\n  }\n\n  async #updateAuthToken(\n    lc: ZeroLogContext,\n    error?: 'invalid-token',\n  ): Promise<void> {\n    const {auth: authOption} = this.#options;\n    const auth = await (typeof authOption === 'function'\n      ? authOption(error)\n      : authOption);\n    if (auth) {\n      lc.debug?.('Got auth token');\n      this.#rep.auth = auth;\n    }\n  }\n\n  async #runLoop() {\n    this.#lc.info?.(`Starting Zero version: ${this.version}`);\n\n    if (this.#server === null) {\n      this.#lc.info?.('No socket origin provided, not starting connect loop.');\n      return;\n    }\n\n    let runLoopCounter = 0;\n    const bareLogContext = this.#lc;\n    const getLogContext = () => {\n      let lc = bareLogContext;\n      if (this.#socket) {\n        lc = addWebSocketIDFromSocketToLogContext(this.#socket, lc);\n      }\n      return lc.withContext('runLoopCounter', runLoopCounter);\n    };\n\n    await this.#updateAuthToken(bareLogContext);\n\n    let needsReauth = false;\n    let gotError = false;\n    let backoffMs = RUN_LOOP_INTERVAL_MS;\n    let additionalConnectParams: Record<string, string> | undefined;\n\n    while (!this.closed) {\n      runLoopCounter++;\n      let lc = getLogContext();\n      backoffMs = RUN_LOOP_INTERVAL_MS;\n\n      try {\n        switch (this.#connectionState) {\n          case ConnectionState.Disconnected: {\n            if (this.#visibilityWatcher.visibilityState === 'hidden') {\n              this.#metrics.setDisconnectedWaitingForVisible();\n              // reset this._totalToConnectStart since this client\n              // is no longer trying to connect due to being hidden.\n              this.#totalToConnectStart = undefined;\n            }\n            // If hidden, we wait for the tab to become visible before trying again.\n            await this.#visibilityWatcher.waitForVisible();\n\n            // If we got an auth error we try to get a new auth token before reconnecting.\n            if (needsReauth) {\n              await this.#updateAuthToken(lc, 'invalid-token');\n            }\n\n            // If a reload is pending, do not try to reconnect.\n            if (reloadScheduled()) {\n              break;\n            }\n\n            await this.#connect(lc, additionalConnectParams);\n            additionalConnectParams = undefined;\n            if (this.closed) {\n              break;\n            }\n\n            // Now we have a new socket, update lc with the new wsid.\n            assert(this.#socket);\n            lc = getLogContext();\n\n            lc.debug?.('Connected successfully');\n            gotError = false;\n            needsReauth = false;\n            this.#setOnline(true);\n            break;\n          }\n\n          case ConnectionState.Connecting:\n            // Can't get here because Disconnected waits for Connected or\n            // rejection.\n            lc.error?.('unreachable');\n            gotError = true;\n            break;\n\n          case ConnectionState.Connected: {\n            // When connected we wait for whatever happens first out of:\n            // - After PING_INTERVAL_MS we send a ping\n            // - We get disconnected\n            // - We get a message\n            // - We get an error (rejectMessageError rejects)\n            // - The tab becomes hidden (with a delay)\n\n            const controller = new AbortController();\n            this.#abortPingTimeout = () => controller.abort();\n            const [pingTimeoutPromise, pingTimeoutAborted] = sleepWithAbort(\n              PING_INTERVAL_MS,\n              controller.signal,\n            );\n\n            this.#rejectMessageError = resolver();\n\n            const PING = 0;\n            const HIDDEN = 2;\n\n            const raceResult = await promiseRace([\n              pingTimeoutPromise,\n              pingTimeoutAborted,\n              this.#visibilityWatcher.waitForHidden(),\n              this.#connectionStateChangeResolver.promise,\n              this.#rejectMessageError.promise,\n            ]);\n\n            if (this.closed) {\n              this.#rejectMessageError = undefined;\n              break;\n            }\n\n            switch (raceResult) {\n              case PING: {\n                const pingResult = await this.#ping(\n                  lc,\n                  this.#rejectMessageError.promise,\n                );\n                if (pingResult === PingResult.TimedOut) {\n                  gotError = true;\n                }\n                break;\n              }\n              case HIDDEN:\n                this.#disconnect(lc, {\n                  client: 'Hidden',\n                });\n                this.#setOnline(false);\n                break;\n            }\n\n            this.#rejectMessageError = undefined;\n          }\n        }\n      } catch (ex) {\n        if (this.#connectionState !== ConnectionState.Connected) {\n          const level = isAuthError(ex) ? 'warn' : 'error';\n          const kind = isServerError(ex) ? ex.kind : 'Unknown Error';\n          lc[level]?.('Failed to connect', ex, kind, {\n            lmid: this.#lastMutationIDReceived,\n            baseCookie: this.#connectCookie,\n          });\n        }\n\n        lc.debug?.(\n          'Got an exception in the run loop',\n          'state:',\n          this.#connectionState,\n          'exception:',\n          ex,\n        );\n\n        if (isAuthError(ex)) {\n          if (!needsReauth) {\n            needsReauth = true;\n            // First auth error, try right away without waiting.\n            continue;\n          }\n          needsReauth = true;\n        }\n\n        if (\n          isServerError(ex) ||\n          ex instanceof TimedOutError ||\n          ex instanceof CloseError\n        ) {\n          gotError = true;\n        }\n\n        const backoffError = isBackoffError(ex);\n        if (backoffError) {\n          if (backoffError.minBackoffMs !== undefined) {\n            backoffMs = Math.max(backoffMs, backoffError.minBackoffMs);\n          }\n          if (backoffError.maxBackoffMs !== undefined) {\n            backoffMs = Math.min(backoffMs, backoffError.maxBackoffMs);\n          }\n          additionalConnectParams = backoffError.reconnectParams;\n        }\n      }\n\n      // Only authentication errors are retried immediately the first time they\n      // occur. All other errors wait a few seconds before retrying the first\n      // time. We specifically do not use a backoff for consecutive errors\n      // because it's a bad experience to wait many seconds for reconnection.\n\n      if (gotError) {\n        this.#setOnline(false);\n        //\n        // let cfGetCheckSucceeded = false;\n        // const cfGetCheckURL = new URL(this.#server);\n        // cfGetCheckURL.pathname = '/api/canary/v0/get';\n        // cfGetCheckURL.searchParams.set('id', nanoid());\n        // const cfGetCheckController = new AbortController();\n        // fetch(cfGetCheckURL, {signal: cfGetCheckController.signal})\n        //   .then(_ => {\n        //     cfGetCheckSucceeded = true;\n        //   })\n        //   .catch(_ => {\n        //     cfGetCheckSucceeded = false;\n        //   });\n        lc.debug?.(\n          'Sleeping',\n          backoffMs,\n          'ms before reconnecting due to error, state:',\n          this.#connectionState,\n        );\n        await sleep(backoffMs);\n        // cfGetCheckController.abort();\n        // if (!cfGetCheckSucceeded) {\n        //   lc.info?.(\n        //     'Canary request failed, resetting total time to connect start time.',\n        //   );\n        //   this.#totalToConnectStart = undefined;\n        // }\n      }\n    }\n  }\n\n  async #puller(req: PullRequest, requestID: string): Promise<PullerResult> {\n    // The deprecation of pushVersion 0 predates zero-client\n    assert(req.pullVersion === 1);\n    const lc = this.#lc.withContext('requestID', requestID);\n    lc.debug?.('Pull', req);\n    // Pull request for this instance's client group.  A no-op response is\n    // returned as pulls for this client group are handled via poke over the\n    // socket.\n    if (req.clientGroupID === (await this.clientGroupID)) {\n      return {\n        httpRequestInfo: {\n          errorMessage: '',\n          httpStatusCode: 200,\n        },\n      };\n    }\n\n    // If we are connecting we wait until we are connected.\n    await this.#connectResolver.promise;\n    const socket = this.#socket;\n    assert(socket);\n    // Mutation recovery pull.\n    lc.debug?.('Pull is for mutation recovery');\n    const cookie = valita.parse(\n      req.cookie,\n      nullableVersionSchema,\n      'passthrough',\n    );\n    const pullRequestMessage: PullRequestMessage = [\n      'pull',\n      {\n        clientGroupID: req.clientGroupID,\n        cookie,\n        requestID,\n      },\n    ];\n    send(socket, pullRequestMessage);\n    const pullResponseResolver: Resolver<PullResponseBody> = resolver();\n    this.#pendingPullsByRequestID.set(requestID, pullResponseResolver);\n    try {\n      const TIMEOUT = 0;\n      const RESPONSE = 1;\n\n      const raceResult = await promiseRace([\n        sleep(PULL_TIMEOUT_MS),\n        pullResponseResolver.promise,\n      ]);\n      switch (raceResult) {\n        case TIMEOUT:\n          lc.debug?.('Mutation recovery pull timed out');\n          throw new Error('Pull timed out');\n        case RESPONSE: {\n          lc.debug?.('Returning mutation recovery pull response');\n          const response = await pullResponseResolver.promise;\n          return {\n            response: {\n              cookie: response.cookie,\n              lastMutationIDChanges: response.lastMutationIDChanges,\n              patch: [],\n            },\n            httpRequestInfo: {\n              errorMessage: '',\n              httpStatusCode: 200,\n            },\n          };\n        }\n        default:\n          unreachable();\n      }\n    } finally {\n      pullResponseResolver.reject('timed out');\n      this.#pendingPullsByRequestID.delete(requestID);\n    }\n  }\n\n  #setOnline(online: boolean): void {\n    this.#onlineManager.setOnline(online);\n  }\n\n  /**\n   * A rough heuristic for whether the client is currently online and\n   * authenticated.\n   */\n  get online(): boolean {\n    return this.#onlineManager.online;\n  }\n\n  /**\n   * Subscribe to online status changes.\n   *\n   * This is useful when you want to update state based on the online status.\n   *\n   * @param listener - The listener to subscribe to.\n   * @returns A function to unsubscribe the listener.\n   */\n  onOnline = (listener: (online: boolean) => void): (() => void) =>\n    this.#onlineManager.subscribe(listener);\n\n  /**\n   * Starts a ping and waits for a pong.\n   *\n   * If it takes too long to get a pong we disconnect and this returns\n   * {@linkcode PingResult.TimedOut}.\n   */\n  async #ping(\n    lc: ZeroLogContext,\n    messageErrorRejectionPromise: Promise<never>,\n  ): Promise<PingResult> {\n    lc.debug?.('pinging');\n    const {promise, resolve} = resolver();\n    this.#onPong = resolve;\n    const pingMessage: PingMessage = ['ping', {}];\n    const t0 = performance.now();\n    assert(this.#socket);\n    send(this.#socket, pingMessage);\n\n    const connected =\n      (await promiseRace([\n        promise,\n        sleep(PING_TIMEOUT_MS),\n        messageErrorRejectionPromise,\n      ])) === 0;\n\n    const delta = performance.now() - t0;\n    if (!connected) {\n      lc.info?.('ping failed in', delta, 'ms - disconnecting');\n      this.#disconnect(lc, {\n        client: 'PingTimeout',\n      });\n      return PingResult.TimedOut;\n    }\n\n    lc.debug?.('ping succeeded in', delta, 'ms');\n    return PingResult.Success;\n  }\n\n  // Sends a set of metrics to the server. Throws unless the server\n  // returns 200.\n  // TODO: Reenable metrics reporting\n  async #reportMetrics(_allSeries: Series[]) {\n    // if (this.#server === null) {\n    //   this.#lc.info?.('Skipping metrics report, socketOrigin is null');\n    //   return;\n    // }\n    // const body = JSON.stringify({series: allSeries});\n    // const url = new URL('/api/metrics/v0/report', this.#server);\n    // url.searchParams.set('clientID', this.clientID);\n    // url.searchParams.set('clientGroupID', await this.clientGroupID);\n    // url.searchParams.set('userID', this.userID);\n    // url.searchParams.set('requestID', nanoid());\n    // const res = await fetch(url.toString(), {\n    //   method: 'POST',\n    //   body,\n    //   keepalive: true,\n    // });\n    // if (!res.ok) {\n    //   const maybeBody = await res.text();\n    //   throw new Error(\n    //     `unexpected response: ${res.status} ${res.statusText} body: ${maybeBody}`,\n    //   );\n    // }\n  }\n\n  #checkConnectivity(reason: string) {\n    void this.#checkConnectivityAsync(reason);\n  }\n\n  #checkConnectivityAsync(_reason: string) {\n    // skipping connectivity checks for now - the server doesn't respond to\n    // them so it just creates noise.\n    // assert(this.#server);\n    // if (this.closed) {\n    //   return;\n    // }\n    // try {\n    //   await checkConnectivity(\n    //     reason,\n    //     this.#server,\n    //     this.#lc,\n    //     this.#closeAbortController.signal,\n    //     this.#enableAnalytics,\n    //   );\n    // } catch (e) {\n    //   this.#lc.info?.('Error checking connectivity for', reason, e);\n    // }\n  }\n\n  #registerQueries(schema: Schema): MakeEntityQueriesFromSchema<S> {\n    const rv = {} as Record<string, Query<Schema, string>>;\n    const context = this.#zeroContext;\n    // Not using parse yet\n    for (const name of Object.keys(schema.tables)) {\n      rv[name] = newQuery(context, schema, name);\n    }\n\n    return rv as MakeEntityQueriesFromSchema<S>;\n  }\n\n  /**\n   * `inspect` returns an object that can be used to inspect the state of the\n   * queries a Zero instance uses. It is intended for debugging purposes.\n   */\n  async inspect(): Promise<Inspector> {\n    // We use esbuild dropLabels to strip this code when we build the code for the bundle size dashboard.\n    // https://esbuild.github.io/api/#ignore-annotations\n    // /packages/zero/tool/build.ts\n\n    // eslint-disable-next-line no-unused-labels\n    BUNDLE_SIZE: {\n      const m = await import('./inspector/inspector.ts');\n      // Wait for the web socket to be available\n      return m.newInspector(\n        this.#rep,\n        this.#queryManager,\n        this.#schema,\n        async () => {\n          await this.#connectResolver.promise;\n          return this.#socket!;\n        },\n      );\n    }\n  }\n\n  #addMetric: <K extends keyof MetricMap>(\n    metric: K,\n    value: number,\n    ...args: MetricMap[K]\n  ) => void = (metric, value, ...args) => {\n    assert(isClientMetric(metric), `Invalid metric: ${metric}`);\n    this.#queryManager.addMetric(\n      metric as keyof ClientMetricMap,\n      value,\n      ...(args as ClientMetricMap[keyof ClientMetricMap]),\n    );\n  };\n}\n\nexport class OnlineManager extends Subscribable<boolean> {\n  #online = false;\n\n  setOnline(online: boolean): void {\n    if (this.#online === online) {\n      return;\n    }\n    this.#online = online;\n    this.notify(online);\n  }\n\n  get online(): boolean {\n    return this.#online;\n  }\n}\n\nexport async function createSocket(\n  rep: ReplicacheImpl,\n  queryManager: QueryManager,\n  deleteClientsManager: DeleteClientsManager,\n  socketOrigin: WSString,\n  baseCookie: NullableVersion,\n  clientID: string,\n  clientGroupID: string,\n  clientSchema: ClientSchema,\n  userID: string,\n  auth: string | undefined,\n  lmid: number,\n  wsid: string,\n  debugPerf: boolean,\n  lc: ZeroLogContext,\n  userPushParams: UserMutateParams | undefined,\n  userQueryParams: UserQueryParams | undefined,\n  maxHeaderLength = 1024 * 8,\n  additionalConnectParams: Record<string, string> | undefined,\n  activeClientsManager: Pick<ActiveClientsManager, 'activeClients'>,\n): Promise<\n  [\n    WebSocket,\n    Map<string, UpQueriesPatchOp> | undefined,\n    DeleteClientsBody | undefined,\n  ]\n> {\n  const url = new URL(\n    appendPath(socketOrigin, `/sync/v${PROTOCOL_VERSION}/connect`),\n  );\n  const {searchParams} = url;\n  searchParams.set('clientID', clientID);\n  searchParams.set('clientGroupID', clientGroupID);\n  searchParams.set('userID', userID);\n  searchParams.set('baseCookie', baseCookie === null ? '' : String(baseCookie));\n  searchParams.set('ts', String(performance.now()));\n  searchParams.set('lmid', String(lmid));\n  searchParams.set('wsid', wsid);\n  if (debugPerf) {\n    searchParams.set('debugPerf', true.toString());\n  }\n  if (additionalConnectParams) {\n    for (const k in additionalConnectParams) {\n      if (searchParams.has(k)) {\n        lc.warn?.(`skipping conflicting parameter ${k}`);\n      } else {\n        searchParams.set(k, additionalConnectParams[k]);\n      }\n    }\n  }\n\n  lc.info?.('Connecting to', url.toString());\n\n  // Pass auth to the server via the `Sec-WebSocket-Protocol` header by passing\n  // it as a `protocol` to the `WebSocket` constructor.  The empty string is an\n  // invalid `protocol`, and will result in an exception, so pass undefined\n  // instead.  encodeURIComponent to ensure it only contains chars allowed\n  // for a `protocol`.\n  const WS = mustGetBrowserGlobal('WebSocket');\n  const queriesPatchP = rep.query(tx => queryManager.getQueriesPatch(tx));\n  let deletedClients: DeleteClientsBody | undefined =\n    await deleteClientsManager.getDeletedClients();\n  let queriesPatch: Map<string, UpQueriesPatchOp> | undefined =\n    await queriesPatchP;\n  const {activeClients} = activeClientsManager;\n\n  let secProtocol = encodeSecProtocols(\n    [\n      'initConnection',\n      {\n        desiredQueriesPatch: [...queriesPatch.values()],\n        deleted: skipEmptyDeletedClients(deletedClients),\n        // The clientSchema only needs to be sent for the very first request.\n        // Henceforth it is stored with the CVR and verified automatically.\n        ...(baseCookie === null ? {clientSchema} : {}),\n        userPushParams,\n        userQueryParams,\n        activeClients: [...activeClients],\n      },\n    ],\n    auth,\n  );\n  if (secProtocol.length > maxHeaderLength) {\n    secProtocol = encodeSecProtocols(undefined, auth);\n    if (secProtocol.length > maxHeaderLength) {\n      lc.warn?.(\n        `Encoded auth token length (${secProtocol.length}) exceeds ` +\n          `ZeroOptions.maxHeaderLength (${maxHeaderLength}). This may ` +\n          `cause connection failures.`,\n      );\n    }\n    queriesPatch = undefined;\n  } else {\n    deletedClients = undefined;\n  }\n  return [\n    new WS(\n      // toString() required for RN URL polyfill.\n      url.toString(),\n      secProtocol,\n    ),\n    queriesPatch,\n    skipEmptyDeletedClients(deletedClients),\n  ];\n}\n\nfunction skipEmptyArray<T>(\n  arr: readonly T[] | undefined,\n): readonly T[] | undefined {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n\nfunction skipEmptyDeletedClients(\n  deletedClients: DeleteClientsBody | undefined,\n): DeleteClientsBody | undefined {\n  if (!deletedClients) {\n    return undefined;\n  }\n  const {clientIDs, clientGroupIDs} = deletedClients;\n  if (\n    (!clientIDs || clientIDs.length === 0) &&\n    (!clientGroupIDs || clientGroupIDs.length === 0)\n  ) {\n    return undefined;\n  }\n  const data: Writable<DeleteClientsBody> = {};\n  data.clientIDs = skipEmptyArray(clientIDs);\n  data.clientGroupIDs = skipEmptyArray(clientGroupIDs);\n  return data;\n}\n\n/**\n * Adds the wsid query parameter to the log context. If the URL does not\n * have a wsid we use a randomID instead.\n */\nfunction addWebSocketIDFromSocketToLogContext(\n  {url}: {url: string},\n  lc: ZeroLogContext,\n): ZeroLogContext {\n  const wsid = new URL(url).searchParams.get('wsid') ?? nanoid();\n  return addWebSocketIDToLogContext(wsid, lc);\n}\n\nfunction addWebSocketIDToLogContext(\n  wsid: string,\n  lc: ZeroLogContext,\n): ZeroLogContext {\n  return lc.withContext('wsid', wsid);\n}\n\n/**\n * Like Promise.race but returns the index of the first promise that resolved.\n */\nfunction promiseRace(ps: Promise<unknown>[]): Promise<number> {\n  return Promise.race(ps.map((p, i) => p.then(() => i)));\n}\n\nclass TimedOutError extends Error {\n  constructor(m: string) {\n    super(`${m} timed out`);\n  }\n}\n\nclass CloseError extends Error {}\n\nfunction assertValidRunOptions(_options?: RunOptions | undefined): void {}\n\nasync function makeActiveClientsManager(\n  clientGroupID: Promise<string>,\n  clientID: string,\n  signal: AbortSignal,\n  onDelete: ActiveClientsManager['onDelete'],\n): Promise<ActiveClientsManager> {\n  const manager = await ActiveClientsManager.create(\n    await clientGroupID,\n    clientID,\n    signal,\n  );\n  manager.onDelete = onDelete;\n  return manager;\n}\n","import {Lock} from '@rocicorp/lock';\nimport {consoleLogSink, LogContext} from '@rocicorp/logger';\nimport {resolver} from '@rocicorp/resolver';\nimport {AbortError} from '../../shared/src/abort-error.ts';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {getBrowserGlobal} from '../../shared/src/browser-env.ts';\nimport {getDocumentVisibilityWatcher} from '../../shared/src/document-visible.ts';\nimport type {JSONValue, ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport type {MaybePromise} from '../../shared/src/types.ts';\nimport {PullDelegate, PushDelegate} from './connection-loop-delegates.ts';\nimport {ConnectionLoop, MAX_DELAY_MS, MIN_DELAY_MS} from './connection-loop.ts';\nimport {assertCookie, type Cookie} from './cookies.ts';\nimport {LazyStore} from './dag/lazy-store.ts';\nimport {StoreImpl} from './dag/store-impl.ts';\nimport {ChunkNotFoundError, mustGetHeadHash, type Store} from './dag/store.ts';\nimport {\n  baseSnapshotFromHash,\n  DEFAULT_HEAD_NAME,\n  isLocalMetaDD31,\n  type LocalMeta,\n} from './db/commit.ts';\nimport {readFromDefaultHead} from './db/read.ts';\nimport {rebaseMutationAndCommit} from './db/rebase.ts';\nimport {newWriteLocal} from './db/write.ts';\nimport {\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n  type VersionNotSupportedResponse,\n} from './error-responses.ts';\nimport * as FormatVersion from './format-version-enum.ts';\nimport {deepFreeze} from './frozen-json.ts';\nimport {getDefaultPuller, isDefaultPuller} from './get-default-puller.ts';\nimport {getDefaultPusher, isDefaultPusher} from './get-default-pusher.ts';\nimport {getKVStoreProvider} from './get-kv-store-provider.ts';\nimport {assertHash, emptyHash, type Hash, newRandomHash} from './hash.ts';\nimport type {HTTPRequestInfo} from './http-request-info.ts';\nimport {httpStatusUnauthorized} from './http-status-unauthorized.ts';\nimport type {IndexDefinitions} from './index-defs.ts';\nimport type {StoreProvider} from './kv/store.ts';\nimport {createLogContext} from './log-options.ts';\nimport {makeIDBName} from './make-idb-name.ts';\nimport {MutationRecovery} from './mutation-recovery.ts';\nimport {initNewClientChannel} from './new-client-channel.ts';\nimport {\n  initOnPersistChannel,\n  type OnPersist,\n  type PersistInfo,\n} from './on-persist-channel.ts';\nimport {\n  type PendingMutation,\n  pendingMutationsForAPI,\n} from './pending-mutations.ts';\nimport {\n  CLIENT_MAX_INACTIVE_TIME,\n  GC_INTERVAL,\n  initClientGC,\n} from './persist/client-gc.ts';\nimport {initClientGroupGC} from './persist/client-group-gc.ts';\nimport {disableClientGroup} from './persist/client-groups.ts';\nimport {\n  ClientStateNotFoundError,\n  initClientV6,\n  type OnClientsDeleted,\n  hasClientState as persistHasClientState,\n} from './persist/clients.ts';\nimport {\n  COLLECT_IDB_INTERVAL,\n  initCollectIDBDatabases,\n  INITIAL_COLLECT_IDB_DELAY,\n} from './persist/collect-idb-databases.ts';\nimport {HEARTBEAT_INTERVAL, startHeartbeats} from './persist/heartbeat.ts';\nimport {\n  IDBDatabasesStore,\n  type IndexedDBDatabase,\n} from './persist/idb-databases-store.ts';\nimport {makeClientID} from './persist/make-client-id.ts';\nimport {persistDD31} from './persist/persist.ts';\nimport {refresh} from './persist/refresh.ts';\nimport {ProcessScheduler} from './process-scheduler.ts';\nimport type {Puller} from './puller.ts';\nimport {type Pusher, PushError} from './pusher.ts';\nimport type {\n  MutationTrackingData,\n  ReplicacheOptions,\n  ZeroOption,\n} from './replicache-options.ts';\nimport {ReportError} from './report-error.ts';\nimport {setIntervalWithSignal} from './set-interval-with-signal.ts';\nimport {\n  type SubscribeOptions,\n  SubscriptionImpl,\n  type SubscriptionsManager,\n  SubscriptionsManagerImpl,\n  type WatchCallback,\n  type WatchCallbackForOptions,\n  type WatchNoIndexCallback,\n  type WatchOptions,\n  WatchSubscription,\n} from './subscriptions.ts';\nimport type {DiffsMap} from './sync/diff.ts';\nimport * as HandlePullResponseResultEnum from './sync/handle-pull-response-result-type-enum.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\nimport {PullError} from './sync/pull-error.ts';\nimport {beginPullV1, handlePullResponseV1, maybeEndPull} from './sync/pull.ts';\nimport {push, PUSH_VERSION_DD31} from './sync/push.ts';\nimport {newRequestID} from './sync/request-id.ts';\nimport {SYNC_HEAD_NAME} from './sync/sync-head-name.ts';\nimport {throwIfClosed} from './transaction-closed-error.ts';\nimport type {ReadTransaction, WriteTransaction} from './transactions.ts';\nimport {ReadTransactionImpl, WriteTransactionImpl} from './transactions.ts';\nimport type {\n  BeginPullResult,\n  MakeMutator,\n  MakeMutators,\n  MutatorDefs,\n  MutatorReturn,\n  PokeInternal,\n  QueryInternal,\n  RequestOptions,\n  UpdateNeededReason,\n} from './types.ts';\nimport {version} from './version.ts';\nimport {\n  withRead,\n  withWrite,\n  withWriteNoImplicitCommit,\n} from './with-transactions.ts';\n\ndeclare const TESTING: boolean;\n\ndeclare const process: {\n  env: {\n    ['DISABLE_MUTATION_RECOVERY']?: string | undefined;\n  };\n};\n\n/**\n * The maximum number of time to call out to getAuth before giving up\n * and throwing an error.\n */\nconst MAX_REAUTH_TRIES = 8;\n\nconst PERSIST_IDLE_TIMEOUT_MS = 1000;\nconst REFRESH_IDLE_TIMEOUT_MS = 1000;\n\nconst PERSIST_THROTTLE_MS = 500;\nconst REFRESH_THROTTLE_MS = 500;\n\nconst LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT = 100 * 2 ** 20; // 100 MB\n\nconst RECOVER_MUTATIONS_INTERVAL_MS = 5 * 60 * 1000; // 5 mins\n\nconst noop = () => {\n  // noop\n};\n\nconst updateNeededReasonNewClientGroup: UpdateNeededReason = {\n  type: 'NewClientGroup',\n} as const;\n\n/** @deprecated Not used any more */\nexport interface MakeSubscriptionsManager {\n  (queryInternal: QueryInternal, lc: LogContext): SubscriptionsManager;\n}\n\nexport interface ReplicacheImplOptions {\n  /**\n   * Defaults to true.\n   */\n  enableMutationRecovery?: boolean | undefined;\n\n  /**\n   * Defaults to true.\n   */\n  enableScheduledPersist?: boolean | undefined;\n\n  /**\n   * Defaults to true.\n   */\n  enableScheduledRefresh?: boolean | undefined;\n\n  /**\n   * Defaults to true.\n   */\n  enablePullAndPushInOpen?: boolean | undefined;\n\n  /**\n   * @deprecated Not used anymore.\n   */\n  makeSubscriptionsManager?: unknown;\n\n  /**\n   * Default is `true`.  If `false` if an exact match client group\n   * is not found, a new client group is always made instead of forking\n   * from an existing client group.\n   */\n  enableClientGroupForking?: boolean | undefined;\n\n  /**\n   * Callback for when Replicache has deleted clients.\n   */\n  onClientsDeleted?: OnClientsDeleted | undefined;\n\n  /**\n   * Internal option used by Zero.\n   * Replicache will call this to and, if zero is enabled, will\n   * invoke various hooks to allow Zero the keep IVM in sync with Replicache's b-trees.\n   */\n  zero?: ZeroOption | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class ReplicacheImpl<MD extends MutatorDefs = {}> {\n  /** The URL to use when doing a pull request. */\n  pullURL: string;\n\n  /** The URL to use when doing a push request. */\n  pushURL: string;\n\n  /** The authorization token used when doing a push request. */\n  #auth: string;\n\n  /** The name of the Replicache database. Populated by {@link ReplicacheOptions#name}. */\n  readonly name: string;\n\n  readonly #subscriptions: SubscriptionsManager;\n  readonly #mutationRecovery: MutationRecovery | undefined;\n\n  /**\n   * Client groups gets disabled when the server does not know about it.\n   * A disabled client group prevents the client from pushing and pulling.\n   */\n  isClientGroupDisabled = false;\n\n  readonly #kvStoreProvider: StoreProvider;\n\n  lastMutationID: number = 0;\n\n  /**\n   * This is the name Replicache uses for the IndexedDB database where data is\n   * stored.\n   */\n  get idbName(): string {\n    return makeIDBName(this.name, this.schemaVersion);\n  }\n\n  set auth(auth: string) {\n    if (this.#zero) {\n      this.#zero.auth = auth;\n    }\n\n    this.#auth = auth;\n  }\n\n  get auth() {\n    return this.#auth;\n  }\n\n  /** The schema version of the data understood by this application. */\n  readonly schemaVersion: string;\n\n  get #idbDatabase(): IndexedDBDatabase {\n    return {\n      name: this.idbName,\n      replicacheName: this.name,\n      replicacheFormatVersion: FormatVersion.Latest,\n      schemaVersion: this.schemaVersion,\n    };\n  }\n  #closed = false;\n  #online = true;\n  readonly #clientID = makeClientID();\n  readonly #ready: Promise<void>;\n  readonly #profileIDPromise: Promise<string>;\n  readonly #clientGroupIDPromise: Promise<string>;\n  readonly #mutatorRegistry: MutatorDefs = {};\n\n  /**\n   * The mutators that was registered in the constructor.\n   */\n  readonly mutate: MakeMutators<MD>;\n\n  // Number of pushes/pulls at the moment.\n  #pushCounter = 0;\n  #pullCounter = 0;\n\n  #pullConnectionLoop: ConnectionLoop;\n  #pushConnectionLoop: ConnectionLoop;\n\n  /**\n   * The duration between each periodic {@link pull}. Setting this to `null`\n   * disables periodic pull completely. Pull will still happen if you call\n   * {@link pull} manually.\n   */\n  pullInterval: number | null;\n\n  /**\n   * The delay between when a change is made to Replicache and when Replicache\n   * attempts to push that change.\n   */\n  pushDelay: number;\n\n  readonly #requestOptions: Required<RequestOptions>;\n\n  /**\n   * The function to use to pull data from the server.\n   */\n  puller: Puller;\n\n  /**\n   * The function to use to push data to the server.\n   */\n  pusher: Pusher;\n\n  readonly memdag: LazyStore;\n  readonly perdag: Store;\n  readonly #idbDatabases: IDBDatabasesStore;\n  readonly #lc: LogContext;\n  readonly #zero: ZeroOption | undefined;\n\n  readonly #closeAbortController = new AbortController();\n\n  readonly #persistLock = new Lock();\n  readonly #enableScheduledPersist: boolean;\n  readonly #enableScheduledRefresh: boolean;\n  readonly #enablePullAndPushInOpen: boolean;\n  #persistScheduler = new ProcessScheduler(\n    () => this.persist(),\n    PERSIST_IDLE_TIMEOUT_MS,\n    PERSIST_THROTTLE_MS,\n    this.#closeAbortController.signal,\n  );\n  readonly #onPersist: OnPersist;\n  #refreshScheduler = new ProcessScheduler(\n    () => this.refresh(),\n    REFRESH_IDLE_TIMEOUT_MS,\n    REFRESH_THROTTLE_MS,\n    this.#closeAbortController.signal,\n  );\n\n  /**\n   * The options used to control the {@link pull} and push request behavior. This\n   * object is live so changes to it will affect the next pull or push call.\n   */\n  get requestOptions(): Required<RequestOptions> {\n    return this.#requestOptions;\n  }\n\n  /**\n   * `onSync(true)` is called when Replicache transitions from no push or pull\n   * happening to at least one happening. `onSync(false)` is called in the\n   * opposite case: when Replicache transitions from at least one push or pull\n   * happening to none happening.\n   *\n   * This can be used in a React like app by doing something like the following:\n   *\n   * ```js\n   * const [syncing, setSyncing] = useState(false);\n   * useEffect(() => {\n   *   rep.onSync = setSyncing;\n   * }, [rep]);\n   * ```\n   */\n  onSync: ((syncing: boolean) => void) | null = null;\n\n  /**\n   * `onClientStateNotFound` is called when the persistent client has been\n   * garbage collected. This can happen if the client has no pending mutations\n   * and has not been used for a while.\n   *\n   * The default behavior is to reload the page (using `location.reload()`). Set\n   * this to `null` or provide your own function to prevent the page from\n   * reloading automatically.\n   */\n  onClientStateNotFound: (() => void) | null = reload;\n\n  /**\n   * `onUpdateNeeded` is called when a code update is needed.\n   *\n   * A code update can be needed because:\n   * - the server no longer supports the {@link pushVersion},\n   *   {@link pullVersion} or {@link schemaVersion} of the current code.\n   * - a new Replicache client has created a new client group, because its code\n   *   has different mutators, indexes, schema version and/or format version\n   *   from this Replicache client. This is likely due to the new client having\n   *   newer code. A code update is needed to be able to locally sync with this\n   *   new Replicache client (i.e. to sync while offline, the clients can still\n   *   sync with each other via the server).\n   *\n   * The default behavior is to reload the page (using `location.reload()`). Set\n   * this to `null` or provide your own function to prevent the page from\n   * reloading automatically. You may want to provide your own function to\n   * display a toast to inform the end user there is a new version of your app\n   * available and prompting them to refresh.\n   */\n  onUpdateNeeded: ((reason: UpdateNeededReason) => void) | null = reload;\n\n  /**\n   * This gets called when we get an HTTP unauthorized (401) response from the\n   * push or pull endpoint. Set this to a function that will ask your user to\n   * reauthenticate.\n   */\n  getAuth: (() => MaybePromise<string | null | undefined>) | null | undefined =\n    null;\n\n  // These three are used for testing\n  onPushInvoked = () => undefined;\n  onBeginPull = () => undefined;\n  onRecoverMutations = (r: Promise<boolean>) => r;\n\n  constructor(\n    options: ReplicacheOptions<MD>,\n    implOptions: ReplicacheImplOptions = {},\n  ) {\n    validateOptions(options);\n    const {\n      name,\n      logLevel = 'info',\n      logSinks = [consoleLogSink],\n      pullURL = '',\n      auth,\n      pushDelay = 10,\n      pushURL = '',\n      schemaVersion = '',\n      pullInterval = 60000,\n      mutators = {} as MD,\n      requestOptions = {},\n      puller,\n      pusher,\n      indexes = {},\n      clientMaxAgeMs = CLIENT_MAX_INACTIVE_TIME,\n    } = options;\n    const {\n      enableMutationRecovery = true,\n      enableScheduledPersist = true,\n      enableScheduledRefresh = true,\n      enablePullAndPushInOpen = true,\n      enableClientGroupForking = true,\n      onClientsDeleted = () => {},\n    } = implOptions;\n    this.#zero = implOptions.zero;\n    this.#auth = auth ?? '';\n    this.pullURL = pullURL;\n    this.pushURL = pushURL;\n    this.name = name;\n    this.schemaVersion = schemaVersion;\n    this.pullInterval = pullInterval;\n    this.pushDelay = pushDelay;\n    this.puller = puller ?? getDefaultPuller(this);\n    this.pusher = pusher ?? getDefaultPusher(this);\n\n    this.#enableScheduledPersist = enableScheduledPersist;\n    this.#enableScheduledRefresh = enableScheduledRefresh;\n    this.#enablePullAndPushInOpen = enablePullAndPushInOpen;\n\n    this.#lc = createLogContext(logLevel, logSinks, {name});\n    this.#lc.debug?.('Constructing Replicache', {\n      name,\n      'replicache version': version,\n    });\n\n    this.#subscriptions = new SubscriptionsManagerImpl(\n      this.#queryInternal,\n      this.#lc,\n      this.#closeAbortController.signal,\n    );\n\n    const kvStoreProvider = getKVStoreProvider(this.#lc, options.kvStore);\n    this.#kvStoreProvider = kvStoreProvider;\n\n    const perKVStore = kvStoreProvider.create(this.idbName);\n\n    this.#idbDatabases = new IDBDatabasesStore(kvStoreProvider.create);\n    this.perdag = new StoreImpl(perKVStore, newRandomHash, assertHash);\n    this.memdag = new LazyStore(\n      this.perdag,\n      LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT,\n      newRandomHash,\n      assertHash,\n    );\n\n    // Use a promise-resolve pair so that we have a promise to use even before\n    // we call the Open RPC.\n    const readyResolver = resolver<void>();\n    this.#ready = readyResolver.promise;\n\n    const {minDelayMs = MIN_DELAY_MS, maxDelayMs = MAX_DELAY_MS} =\n      requestOptions;\n    this.#requestOptions = {maxDelayMs, minDelayMs};\n\n    const visibilityWatcher = getDocumentVisibilityWatcher(\n      getBrowserGlobal('document'),\n      0,\n      this.#closeAbortController.signal,\n    );\n\n    this.#pullConnectionLoop = new ConnectionLoop(\n      this.#lc.withContext('PULL'),\n      new PullDelegate(this, () => this.#invokePull()),\n      visibilityWatcher,\n    );\n\n    this.#pushConnectionLoop = new ConnectionLoop(\n      this.#lc.withContext('PUSH'),\n      new PushDelegate(this, () => this.#invokePush()),\n    );\n\n    this.mutate = this.#registerMutators(mutators);\n\n    const profileIDResolver = resolver<string>();\n    this.#profileIDPromise = profileIDResolver.promise;\n    const clientGroupIDResolver = resolver<string>();\n    this.#clientGroupIDPromise = clientGroupIDResolver.promise;\n\n    if (!process.env.DISABLE_MUTATION_RECOVERY) {\n      this.#mutationRecovery = new MutationRecovery({\n        delegate: this,\n        lc: this.#lc,\n        enableMutationRecovery,\n        wrapInOnlineCheck: this.#wrapInOnlineCheck.bind(this),\n        wrapInReauthRetries: this.#wrapInReauthRetries.bind(this),\n        isPullDisabled: this.#isPullDisabled.bind(this),\n        isPushDisabled: this.#isPushDisabled.bind(this),\n        clientGroupIDPromise: this.#clientGroupIDPromise,\n      });\n    }\n\n    this.#onPersist = initOnPersistChannel(\n      this.name,\n      this.#closeAbortController.signal,\n      persistInfo => {\n        void this.#handlePersist(persistInfo);\n      },\n    );\n\n    void this.#open(\n      indexes,\n      enableClientGroupForking,\n      enableMutationRecovery,\n      clientMaxAgeMs,\n      profileIDResolver.resolve,\n      clientGroupIDResolver.resolve,\n      readyResolver.resolve,\n      onClientsDeleted,\n    );\n  }\n\n  async #open(\n    indexes: IndexDefinitions,\n    enableClientGroupForking: boolean,\n    enableMutationRecovery: boolean,\n    clientMaxAgeMs: number,\n    profileIDResolver: (profileID: string) => void,\n    resolveClientGroupID: (clientGroupID: ClientGroupID) => void,\n    resolveReady: () => void,\n    onClientsDeleted: OnClientsDeleted,\n  ): Promise<void> {\n    const {clientID} = this;\n    // If we are currently closing a Replicache instance with the same name,\n    // wait for it to finish closing.\n    await closingInstances.get(this.name);\n    await this.#idbDatabases.getProfileID().then(profileIDResolver);\n    await this.#idbDatabases.putDatabase(this.#idbDatabase);\n    const [client, headHash, , isNewClientGroup] = await initClientV6(\n      clientID,\n      this.#lc,\n      this.perdag,\n      Object.keys(this.#mutatorRegistry),\n      indexes,\n      FormatVersion.Latest,\n      enableClientGroupForking,\n    );\n\n    resolveClientGroupID(client.clientGroupID);\n    await withWrite(this.memdag, write =>\n      write.setHead(DEFAULT_HEAD_NAME, headHash),\n    );\n\n    // Now we have a profileID, a clientID, a clientGroupID and DB!\n    await this.#zero?.init(headHash, this.memdag);\n    resolveReady();\n\n    if (this.#enablePullAndPushInOpen) {\n      this.pull().catch(noop);\n      this.push().catch(noop);\n    }\n\n    const {signal} = this.#closeAbortController;\n\n    startHeartbeats(\n      clientID,\n      this.perdag,\n      () => {\n        this.#clientStateNotFoundOnClient(clientID);\n      },\n      HEARTBEAT_INTERVAL,\n      this.#lc,\n      signal,\n    );\n    initClientGC(\n      clientID,\n      this.perdag,\n      clientMaxAgeMs,\n      GC_INTERVAL,\n      onClientsDeleted,\n      this.#lc,\n      signal,\n    );\n    initCollectIDBDatabases(\n      this.#idbDatabases,\n      this.#kvStoreProvider.drop,\n      COLLECT_IDB_INTERVAL,\n      INITIAL_COLLECT_IDB_DELAY,\n      2 * clientMaxAgeMs,\n      enableMutationRecovery,\n      onClientsDeleted,\n      this.#lc,\n      signal,\n    );\n    initClientGroupGC(\n      this.perdag,\n      enableMutationRecovery,\n      onClientsDeleted,\n      this.#lc,\n      signal,\n    );\n    initNewClientChannel(\n      this.name,\n      this.idbName,\n      signal,\n      client.clientGroupID,\n      isNewClientGroup,\n      () => {\n        this.#fireOnUpdateNeeded(updateNeededReasonNewClientGroup);\n      },\n      this.perdag,\n    );\n\n    setIntervalWithSignal(\n      () => this.recoverMutations(),\n      RECOVER_MUTATIONS_INTERVAL_MS,\n      signal,\n    );\n    void this.recoverMutations();\n\n    getBrowserGlobal('document')?.addEventListener(\n      'visibilitychange',\n      this.#onVisibilityChange,\n    );\n  }\n\n  #onVisibilityChange = async () => {\n    if (this.#closed) {\n      return;\n    }\n\n    // In case of running in a worker, we don't have a document.\n    if (getBrowserGlobal('document')?.visibilityState !== 'visible') {\n      return;\n    }\n\n    await this.#checkForClientStateNotFoundAndCallHandler();\n  };\n\n  async #checkForClientStateNotFoundAndCallHandler(): Promise<boolean> {\n    const {clientID} = this;\n    const hasClientState = await withRead(this.perdag, read =>\n      persistHasClientState(clientID, read),\n    );\n    if (!hasClientState) {\n      this.#clientStateNotFoundOnClient(clientID);\n    }\n    return !hasClientState;\n  }\n\n  /**\n   * The browser profile ID for this browser profile. Every instance of Replicache\n   * browser-profile-wide shares the same profile ID.\n   */\n  get profileID(): Promise<string> {\n    return this.#profileIDPromise;\n  }\n\n  /**\n   * The client ID for this instance of Replicache. Each instance of Replicache\n   * gets a unique client ID.\n   */\n  get clientID(): string {\n    return this.#clientID;\n  }\n\n  /**\n   * The client group ID for this instance of Replicache. Instances of\n   * Replicache will have the same client group ID if and only if they have\n   * the same name, mutators, indexes, schema version, format version, and\n   * browser profile.\n   */\n  get clientGroupID(): Promise<string> {\n    return this.#clientGroupIDPromise;\n  }\n\n  /**\n   * `onOnlineChange` is called when the {@link online} property changes. See\n   * {@link online} for more details.\n   */\n  onOnlineChange: ((online: boolean) => void) | null = null;\n\n  /**\n   * A rough heuristic for whether the client is currently online. Note that\n   * there is no way to know for certain whether a client is online - the next\n   * request can always fail. This property returns true if the last sync attempt succeeded,\n   * and false otherwise.\n   */\n  get online(): boolean {\n    return this.#online;\n  }\n\n  /**\n   * Whether the Replicache database has been closed. Once Replicache has been\n   * closed it no longer syncs and you can no longer read or write data out of\n   * it. After it has been closed it is pretty much useless and should not be\n   * used any more.\n   */\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  /**\n   * Closes this Replicache instance.\n   *\n   * When closed all subscriptions end and no more read or writes are allowed.\n   */\n  async close(): Promise<void> {\n    this.#closed = true;\n    const {promise, resolve} = resolver();\n    closingInstances.set(this.name, promise);\n\n    this.#closeAbortController.abort();\n\n    getBrowserGlobal('document')?.removeEventListener(\n      'visibilitychange',\n      this.#onVisibilityChange,\n    );\n\n    await this.#ready;\n    const closingPromises = [\n      this.memdag.close(),\n      this.perdag.close(),\n      this.#idbDatabases.close(),\n    ];\n\n    this.#pullConnectionLoop.close();\n    this.#pushConnectionLoop.close();\n\n    this.#subscriptions.clear();\n\n    await Promise.all(closingPromises);\n    closingInstances.delete(this.name);\n    resolve();\n  }\n\n  async maybeEndPull(syncHead: Hash, requestID: string): Promise<void> {\n    for (;;) {\n      if (this.#closed) {\n        return;\n      }\n\n      await this.#ready;\n      const {clientID} = this;\n      const lc = this.#lc\n        .withContext('maybeEndPull')\n        .withContext('requestID', requestID);\n      const {replayMutations, diffs, oldMainHead, mainHead} =\n        await maybeEndPull<LocalMeta>(\n          this.memdag,\n          lc,\n          syncHead,\n          clientID,\n          this.#subscriptions,\n          FormatVersion.Latest,\n        );\n\n      if (!replayMutations || replayMutations.length === 0) {\n        // All done.\n        this.#zero?.advance(oldMainHead, mainHead, diffs.get('') ?? []);\n        await this.#subscriptions.fire(diffs);\n        void this.#schedulePersist();\n        return;\n      }\n\n      // Replay.\n      const zeroData = await this.#zero?.getTxData?.(syncHead);\n      for (const mutation of replayMutations) {\n        // TODO(greg): I'm not sure why this was in Replicache#_mutate...\n        // Ensure that we run initial pending subscribe functions before starting a\n        // write transaction.\n        if (this.#subscriptions.hasPendingSubscriptionRuns) {\n          await Promise.resolve();\n        }\n        const {meta} = mutation;\n        syncHead = await withWriteNoImplicitCommit(this.memdag, dagWrite =>\n          rebaseMutationAndCommit(\n            mutation,\n            dagWrite,\n            syncHead,\n            SYNC_HEAD_NAME,\n            this.#mutatorRegistry,\n            lc,\n            isLocalMetaDD31(meta) ? meta.clientID : clientID,\n            FormatVersion.Latest,\n            zeroData,\n          ),\n        );\n      }\n    }\n  }\n\n  #invokePull(): Promise<boolean> {\n    if (this.#isPullDisabled()) {\n      return Promise.resolve(true);\n    }\n\n    return this.#wrapInOnlineCheck(async () => {\n      try {\n        this.#changeSyncCounters(0, 1);\n        const {syncHead, requestID, ok} = await this.beginPull();\n        if (!ok) {\n          return false;\n        }\n        if (syncHead !== emptyHash) {\n          await this.maybeEndPull(syncHead, requestID);\n        }\n      } catch (e) {\n        throw await this.#convertToClientStateNotFoundError(e);\n      } finally {\n        this.#changeSyncCounters(0, -1);\n      }\n      return true;\n    }, 'Pull');\n  }\n\n  #isPullDisabled() {\n    return (\n      this.isClientGroupDisabled ||\n      (this.pullURL === '' && isDefaultPuller(this.puller))\n    );\n  }\n\n  async #wrapInOnlineCheck(\n    f: () => Promise<boolean>,\n    name: string,\n  ): Promise<boolean> {\n    let online = true;\n\n    try {\n      return await f();\n    } catch (e) {\n      // The error paths of beginPull and maybeEndPull need to be reworked.\n      //\n      // We want to distinguish between:\n      // a) network requests failed -- we're offline basically\n      // b) sync was aborted because one's already in progress\n      // c) oh noes - something unexpected happened\n      //\n      // Right now, all of these come out as errors. We distinguish (b) with a\n      // hacky string search. (a) and (c) are not distinguishable currently\n      // because repc doesn't provide sufficient information, so we treat all\n      // errors that aren't (b) as (a).\n      if (e instanceof PushError || e instanceof PullError) {\n        online = false;\n        this.#lc.debug?.(`${name} threw:\\n`, e, '\\nwith cause:\\n', e.causedBy);\n      } else if (e instanceof ReportError) {\n        this.#lc.error?.(e);\n      } else {\n        this.#lc.info?.(`${name} threw:\\n`, e);\n      }\n      return false;\n    } finally {\n      if (this.#online !== online) {\n        this.#online = online;\n        this.onOnlineChange?.(online);\n        if (online) {\n          void this.recoverMutations();\n        }\n      }\n    }\n  }\n\n  async #wrapInReauthRetries<R>(\n    f: (\n      requestID: string,\n      requestLc: LogContext,\n    ) => Promise<{\n      httpRequestInfo: HTTPRequestInfo | undefined;\n      result: R;\n    }>,\n    verb: string,\n    lc: LogContext,\n    preAuth: () => MaybePromise<void> = noop,\n    postAuth: () => MaybePromise<void> = noop,\n  ): Promise<{\n    result: R;\n    authFailure: boolean;\n  }> {\n    const {clientID} = this;\n    let reauthAttempts = 0;\n    let lastResult;\n    lc = lc.withContext(verb);\n    do {\n      const requestID = newRequestID(clientID);\n      const requestLc = lc.withContext('requestID', requestID);\n      const {httpRequestInfo, result} = await f(requestID, requestLc);\n      lastResult = result;\n      if (!httpRequestInfo) {\n        return {\n          result,\n          authFailure: false,\n        };\n      }\n      const {errorMessage, httpStatusCode} = httpRequestInfo;\n\n      if (errorMessage || httpStatusCode !== 200) {\n        // TODO(arv): Maybe we should not log the server URL when the error comes\n        // from a Pusher/Puller?\n        requestLc.error?.(\n          `Got a non 200 response doing ${verb}: ${httpStatusCode}` +\n            (errorMessage ? `: ${errorMessage}` : ''),\n        );\n      }\n      if (httpStatusCode !== httpStatusUnauthorized) {\n        return {\n          result,\n          authFailure: false,\n        };\n      }\n      if (!this.getAuth) {\n        return {\n          result,\n          authFailure: true,\n        };\n      }\n      let auth;\n      try {\n        await preAuth();\n        auth = await this.getAuth();\n      } finally {\n        await postAuth();\n      }\n      if (auth === null || auth === undefined) {\n        return {\n          result,\n          authFailure: true,\n        };\n      }\n      this.auth = auth;\n      reauthAttempts++;\n    } while (reauthAttempts < MAX_REAUTH_TRIES);\n    lc.info?.('Tried to reauthenticate too many times');\n    return {\n      result: lastResult,\n      authFailure: true,\n    };\n  }\n\n  #isPushDisabled() {\n    return (\n      this.isClientGroupDisabled ||\n      (this.pushURL === '' && isDefaultPusher(this.pusher))\n    );\n  }\n\n  async #invokePush(): Promise<boolean> {\n    if (TESTING) {\n      this.onPushInvoked();\n    }\n    if (this.#isPushDisabled()) {\n      return true;\n    }\n\n    await this.#ready;\n    const profileID = await this.#profileIDPromise;\n    const {clientID} = this;\n    const clientGroupID = await this.#clientGroupIDPromise;\n    return this.#wrapInOnlineCheck(async () => {\n      const {result: pusherResult} = await this.#wrapInReauthRetries(\n        async (requestID: string, requestLc: LogContext) => {\n          try {\n            this.#changeSyncCounters(1, 0);\n            const pusherResult = await push(\n              requestID,\n              this.memdag,\n              requestLc,\n              profileID,\n              clientGroupID,\n              clientID,\n              this.pusher,\n              this.schemaVersion,\n              PUSH_VERSION_DD31,\n            );\n            return {\n              result: pusherResult,\n              httpRequestInfo: pusherResult?.httpRequestInfo,\n            };\n          } finally {\n            this.#changeSyncCounters(-1, 0);\n          }\n        },\n        'push',\n        this.#lc,\n      );\n\n      if (pusherResult === undefined) {\n        // No pending mutations.\n        return true;\n      }\n\n      const {response, httpRequestInfo} = pusherResult;\n\n      if (isVersionNotSupportedResponse(response)) {\n        this.#handleVersionNotSupportedResponse(response);\n      } else if (isClientStateNotFoundResponse(response)) {\n        await this.#clientStateNotFoundOnServer();\n      }\n\n      // No pushResponse means we didn't do a push because there were no\n      // pending mutations.\n      return httpRequestInfo.httpStatusCode === 200;\n    }, 'Push');\n  }\n\n  #handleVersionNotSupportedResponse(response: VersionNotSupportedResponse) {\n    const reason: UpdateNeededReason = {\n      type: response.error,\n    };\n    if (response.versionType) {\n      reason.versionType = response.versionType;\n    }\n    this.#fireOnUpdateNeeded(reason);\n  }\n\n  /**\n   * Push pushes pending changes to the {@link pushURL}.\n   *\n   * You do not usually need to manually call push. If {@link pushDelay} is\n   * non-zero (which it is by default) pushes happen automatically shortly after\n   * mutations.\n   *\n   * If the server endpoint fails push will be continuously retried with an\n   * exponential backoff.\n   *\n   * @param [now=false] If true, push will happen immediately and ignore\n   *   {@link pushDelay}, {@link RequestOptions.minDelayMs} as well as the\n   *   exponential backoff in case of errors.\n   * @returns A promise that resolves when the next push completes. In case of\n   * errors the first error will reject the returned promise. Subsequent errors\n   * will not be reflected in the promise.\n   */\n  push({now = false} = {}): Promise<void> {\n    return throwIfError(this.#pushConnectionLoop.send(now));\n  }\n\n  /**\n   * Pull pulls changes from the {@link pullURL}. If there are any changes local\n   * changes will get replayed on top of the new server state.\n   *\n   * If the server endpoint fails pull will be continuously retried with an\n   * exponential backoff.\n   *\n   * @param [now=false] If true, pull will happen immediately and ignore\n   *   {@link RequestOptions.minDelayMs} as well as the exponential backoff in\n   *   case of errors.\n   * @returns A promise that resolves when the next pull completes. In case of\n   * errors the first error will reject the returned promise. Subsequent errors\n   * will not be reflected in the promise.\n   */\n  pull({now = false} = {}): Promise<void> {\n    return throwIfError(this.#pullConnectionLoop.send(now));\n  }\n\n  /**\n   * Applies an update from the server to Replicache.\n   * Throws an error if cookie does not match. In that case the server thinks\n   * this client has a different cookie than it does; the caller should disconnect\n   * from the server and re-register, which transmits the cookie the client actually\n   * has.\n   *\n   * @experimental This method is under development and its semantics will change.\n   */\n  async poke(poke: PokeInternal): Promise<void> {\n    await this.#ready;\n    // TODO(MP) Previously we created a request ID here and included it with the\n    // PullRequest to the server so we could tie events across client and server\n    // together. Since the direction is now reversed, creating and adding a request ID\n    // here is kind of silly. We should consider creating the request ID\n    // on the *server* and passing it down in the poke for inclusion here in the log\n    // context\n    const {clientID} = this;\n    const requestID = newRequestID(clientID);\n    const lc = this.#lc\n      .withContext('handlePullResponse')\n      .withContext('requestID', requestID);\n\n    const {pullResponse} = poke;\n\n    if (isVersionNotSupportedResponse(pullResponse)) {\n      this.#handleVersionNotSupportedResponse(pullResponse);\n      return;\n    }\n\n    if (isClientStateNotFoundResponse(pullResponse)) {\n      await this.#clientStateNotFoundOnServer();\n      return;\n    }\n\n    const result = await handlePullResponseV1(\n      lc,\n      this.memdag,\n      deepFreeze(poke.baseCookie),\n      pullResponse,\n      clientID,\n      FormatVersion.Latest,\n    );\n\n    switch (result.type) {\n      case HandlePullResponseResultEnum.Applied:\n        await this.maybeEndPull(result.syncHead, requestID);\n        break;\n      case HandlePullResponseResultEnum.CookieMismatch:\n        throw new Error(\n          'unexpected base cookie for poke: ' + JSON.stringify(poke),\n        );\n      case HandlePullResponseResultEnum.NoOp:\n        break;\n    }\n  }\n\n  async beginPull(): Promise<BeginPullResult> {\n    if (TESTING) {\n      this.onBeginPull();\n    }\n    await this.#ready;\n    const profileID = await this.profileID;\n    const {clientID} = this;\n    const clientGroupID = await this.#clientGroupIDPromise;\n    const {\n      result: {beginPullResponse, requestID},\n    } = await this.#wrapInReauthRetries(\n      async (requestID: string, requestLc: LogContext) => {\n        const beginPullResponse = await beginPullV1(\n          profileID,\n          clientID,\n          clientGroupID,\n          this.schemaVersion,\n          this.puller,\n          requestID,\n          this.memdag,\n          FormatVersion.Latest,\n          requestLc,\n        );\n        return {\n          result: {beginPullResponse, requestID},\n          httpRequestInfo: beginPullResponse.httpRequestInfo,\n        };\n      },\n      'pull',\n      this.#lc,\n      () => this.#changeSyncCounters(0, -1),\n      () => this.#changeSyncCounters(0, 1),\n    );\n\n    const {pullResponse} = beginPullResponse;\n    if (isVersionNotSupportedResponse(pullResponse)) {\n      this.#handleVersionNotSupportedResponse(pullResponse);\n    } else if (isClientStateNotFoundResponse(beginPullResponse.pullResponse)) {\n      await this.#clientStateNotFoundOnServer();\n    }\n\n    const {syncHead, httpRequestInfo} = beginPullResponse;\n    return {requestID, syncHead, ok: httpRequestInfo.httpStatusCode === 200};\n  }\n\n  persist(): Promise<void> {\n    // Prevent multiple persist calls from running at the same time.\n    return this.#persistLock.withLock(async () => {\n      const {clientID} = this;\n      await this.#ready;\n      if (this.#closed) {\n        return;\n      }\n      try {\n        await persistDD31(\n          this.#lc,\n          clientID,\n          this.memdag,\n          this.perdag,\n          this.#mutatorRegistry,\n          () => this.#closed,\n          FormatVersion.Latest,\n          this.#zero?.getTxData,\n        );\n      } catch (e) {\n        if (e instanceof ClientStateNotFoundError) {\n          this.#clientStateNotFoundOnClient(clientID);\n        } else if (this.#closed) {\n          this.#lc.debug?.('Exception persisting during close', e);\n        } else {\n          throw e;\n        }\n      }\n\n      const clientGroupID = await this.#clientGroupIDPromise;\n      assert(clientGroupID);\n      this.#onPersist({clientID, clientGroupID});\n    });\n  }\n\n  async refresh(): Promise<void> {\n    await this.#ready;\n    const {clientID} = this;\n    if (this.#closed) {\n      return;\n    }\n    let refreshResult: Awaited<ReturnType<typeof refresh>>;\n    try {\n      refreshResult = await refresh(\n        this.#lc,\n        this.memdag,\n        this.perdag,\n        clientID,\n        this.#mutatorRegistry,\n        this.#subscriptions,\n        () => this.closed,\n        FormatVersion.Latest,\n        this.#zero,\n      );\n    } catch (e) {\n      if (e instanceof ClientStateNotFoundError) {\n        this.#clientStateNotFoundOnClient(clientID);\n      } else if (this.#closed) {\n        this.#lc.debug?.('Exception refreshing during close', e);\n      } else {\n        throw e;\n      }\n    }\n    if (refreshResult !== undefined) {\n      await this.#subscriptions.fire(refreshResult.diffs);\n    }\n  }\n\n  #fireOnClientStateNotFound() {\n    this.onClientStateNotFound?.();\n  }\n\n  #clientStateNotFoundOnClient(clientID: ClientID) {\n    this.#lc.error?.(`Client state not found on client, clientID: ${clientID}`);\n    this.#fireOnClientStateNotFound();\n  }\n\n  async #clientStateNotFoundOnServer() {\n    const clientGroupID = await this.#clientGroupIDPromise;\n    this.#lc.error?.(\n      `Client state not found on server, clientGroupID: ${clientGroupID}`,\n    );\n    await this.disableClientGroup();\n    this.#fireOnClientStateNotFound();\n  }\n\n  async disableClientGroup(): Promise<void> {\n    const clientGroupID = await this.#clientGroupIDPromise;\n    assert(clientGroupID);\n    this.isClientGroupDisabled = true;\n    await withWrite(this.perdag, dagWrite =>\n      disableClientGroup(clientGroupID, dagWrite),\n    );\n  }\n\n  #fireOnUpdateNeeded(reason: UpdateNeededReason) {\n    this.#lc.debug?.(`Update needed, reason: ${reason}`);\n    this.onUpdateNeeded?.(reason);\n  }\n\n  async #schedulePersist(): Promise<void> {\n    if (!this.#enableScheduledPersist) {\n      return;\n    }\n    await this.#schedule('persist', this.#persistScheduler);\n  }\n\n  async #handlePersist(persistInfo: PersistInfo): Promise<void> {\n    this.#lc.debug?.('Handling persist', persistInfo);\n    const clientGroupID = await this.#clientGroupIDPromise;\n    if (persistInfo.clientGroupID === clientGroupID) {\n      void this.#scheduleRefresh();\n    }\n  }\n\n  async #scheduleRefresh(): Promise<void> {\n    if (!this.#enableScheduledRefresh) {\n      return;\n    }\n    await this.#schedule('refresh from storage', this.#refreshScheduler);\n  }\n\n  async #schedule(name: string, scheduler: ProcessScheduler): Promise<void> {\n    try {\n      await scheduler.schedule();\n    } catch (e) {\n      if (e instanceof AbortError) {\n        this.#lc.debug?.(`Scheduled ${name} did not complete before close.`);\n      } else {\n        this.#lc.error?.(`Error during ${name}`, e);\n      }\n    }\n  }\n\n  #changeSyncCounters(pushDelta: 0, pullDelta: 1 | -1): void;\n  #changeSyncCounters(pushDelta: 1 | -1, pullDelta: 0): void;\n  #changeSyncCounters(pushDelta: number, pullDelta: number): void {\n    this.#pushCounter += pushDelta;\n    this.#pullCounter += pullDelta;\n    const delta = pushDelta + pullDelta;\n    const counter = this.#pushCounter + this.#pullCounter;\n    if ((delta === 1 && counter === 1) || counter === 0) {\n      const syncing = counter > 0;\n      // Run in a new microtask.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      Promise.resolve().then(() => this.onSync?.(syncing));\n    }\n  }\n\n  /**\n   * Subscribe to the result of a {@link query}. The `body` function is\n   * evaluated once and its results are returned via `onData`.\n   *\n   * Thereafter, each time the the result of `body` changes, `onData` is fired\n   * again with the new result.\n   *\n   * `subscribe()` goes to significant effort to avoid extraneous work\n   * re-evaluating subscriptions:\n   *\n   * 1. subscribe tracks the keys that `body` accesses each time it runs. `body`\n   *    is only re-evaluated when those keys change.\n   * 2. subscribe only re-fires `onData` in the case that a result changes by\n   *    way of the `isEqual` option which defaults to doing a deep JSON value\n   *    equality check.\n   *\n   * Because of (1), `body` must be a pure function of the data in Replicache.\n   * `body` must not access anything other than the `tx` parameter passed to it.\n   *\n   * Although subscribe is as efficient as it can be, it is somewhat constrained\n   * by the goal of returning an arbitrary computation of the cache. For even\n   * better performance (but worse dx), see {@link experimentalWatch}.\n   *\n   * If an error occurs in the `body` the `onError` function is called if\n   * present. Otherwise, the error is logged at log level 'error'.\n   *\n   * To cancel the subscription, call the returned function.\n   *\n   * @param body The function to evaluate to get the value to pass into\n   *    `onData`.\n   * @param options Options is either a function or an object. If it is a\n   *    function it is equivalent to passing it as the `onData` property of an\n   *    object.\n   */\n  subscribe<R>(\n    body: (tx: ReadTransaction) => Promise<R>,\n    options: SubscribeOptions<R> | ((result: R) => void),\n  ): () => void {\n    if (typeof options === 'function') {\n      options = {onData: options};\n    }\n\n    const {onData, onError, onDone, isEqual} = options;\n    return this.#subscriptions.add(\n      new SubscriptionImpl(body, onData, onError, onDone, isEqual),\n    );\n  }\n\n  /**\n   * Watches Replicache for changes.\n   *\n   * The `callback` gets called whenever the underlying data changes and the\n   * `key` changes matches the `prefix` of {@link ExperimentalWatchIndexOptions} or\n   * {@link ExperimentalWatchNoIndexOptions} if present. If a change\n   * occurs to the data but the change does not impact the key space the\n   * callback is not called. In other words, the callback is never called with\n   * an empty diff.\n   *\n   * This gets called after commit (a mutation or a rebase).\n   *\n   * @experimental This method is under development and its semantics will\n   * change.\n   */\n  experimentalWatch(callback: WatchNoIndexCallback): () => void;\n  experimentalWatch<Options extends WatchOptions>(\n    callback: WatchCallbackForOptions<Options>,\n    options?: Options,\n  ): () => void;\n  experimentalWatch<Options extends WatchOptions>(\n    callback: WatchCallbackForOptions<Options>,\n    options?: Options,\n  ): () => void {\n    return this.#subscriptions.add(\n      new WatchSubscription(callback as WatchCallback, options),\n    );\n  }\n\n  /**\n   * Query is used for read transactions. It is recommended to use transactions\n   * to ensure you get a consistent view across multiple calls to `get`, `has`\n   * and `scan`.\n   */\n  query<R>(body: (tx: ReadTransaction) => Promise<R> | R): Promise<R> {\n    return this.#queryInternal(body);\n  }\n\n  get cookie(): Promise<Cookie> {\n    return this.#ready.then(() =>\n      withRead(this.memdag, async dagRead => {\n        const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n        if (!mainHeadHash) {\n          throw new Error('Internal no main head found');\n        }\n        const baseSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);\n        const baseSnapshotMeta = baseSnapshot.meta;\n        const cookie = baseSnapshotMeta.cookieJSON;\n        assertCookie(cookie);\n        return cookie;\n      }),\n    );\n  }\n\n  #queryInternal: QueryInternal = async body => {\n    await this.#ready;\n    const {clientID} = this;\n    return withRead(this.memdag, async dagRead => {\n      try {\n        const dbRead = await readFromDefaultHead(dagRead, FormatVersion.Latest);\n        const tx = new ReadTransactionImpl(clientID, dbRead, this.#lc);\n        return await body(tx);\n      } catch (ex) {\n        throw await this.#convertToClientStateNotFoundError(ex);\n      }\n    });\n  };\n\n  #register<Return extends ReadonlyJSONValue | void, Args extends JSONValue>(\n    name: string,\n    mutatorImpl: (tx: WriteTransaction, args?: Args) => MaybePromise<Return>,\n  ): (\n    args?: Args,\n  ) => Promise<Return> | {client: Promise<Return>; server: Promise<unknown>} {\n    this.#mutatorRegistry[name] = mutatorImpl as (\n      tx: WriteTransaction,\n      args: JSONValue | undefined,\n    ) => Promise<void | JSONValue>;\n\n    return (\n      args?: Args,\n    ):\n      | Promise<Return>\n      | {client: Promise<Return>; server: Promise<unknown>} => {\n      // DO NOT track CRUD mutations as they do not receive responses from\n      // the server.\n      const trackingData =\n        name === '_zero_crud' ? undefined : this.#zero?.trackMutation();\n\n      const result = this.#mutate(\n        trackingData,\n        name,\n        mutatorImpl,\n        args,\n        performance.now(),\n      );\n\n      if (trackingData) {\n        return {\n          client: result,\n          server: trackingData.serverPromise,\n          then: (onFulfilled, onRejected) => {\n            this.#lc.warn?.(\n              'Awaiting the mutator result directly is being deprecated.' +\n                ' Please use `await z.mutate[mutatorName].client` or `await result.mutate[mutatorName].server`',\n            );\n            return result.then(onFulfilled, onRejected);\n          },\n        };\n      }\n\n      return result;\n    };\n  }\n\n  #registerMutators<\n    M extends {\n      [key: string]: (\n        tx: WriteTransaction,\n        args?: ReadonlyJSONValue,\n      ) => MutatorReturn;\n    },\n  >(regs: M): MakeMutators<M> {\n    type Mut = MakeMutators<M>;\n    const rv: Partial<Mut> = Object.create(null);\n    for (const k in regs) {\n      rv[k] = this.#register(k, regs[k]) as MakeMutator<M[typeof k]>;\n    }\n    return rv as Mut;\n  }\n\n  async #mutate<\n    R extends ReadonlyJSONValue | void,\n    A extends ReadonlyJSONValue,\n  >(\n    trackingData: MutationTrackingData | undefined,\n    name: string,\n    mutatorImpl: (tx: WriteTransaction, args?: A) => MaybePromise<R>,\n    args: A | undefined,\n    timestamp: number,\n  ): Promise<R> {\n    const frozenArgs = deepFreeze(args ?? null);\n\n    // Ensure that we run initial pending subscribe functions before starting a\n    // write transaction.\n    if (this.#subscriptions.hasPendingSubscriptionRuns) {\n      await Promise.resolve();\n    }\n\n    await this.#ready;\n    const {clientID} = this;\n    return withWriteNoImplicitCommit(this.memdag, async dagWrite => {\n      try {\n        let result: R;\n        let newHead: Hash;\n        let diffs: DiffsMap;\n        let headHash: Hash;\n        try {\n          headHash = await mustGetHeadHash(DEFAULT_HEAD_NAME, dagWrite);\n          const originalHash = null;\n\n          const dbWrite = await newWriteLocal(\n            headHash,\n            name,\n            frozenArgs,\n            originalHash,\n            dagWrite,\n            timestamp,\n            clientID,\n            FormatVersion.Latest,\n          );\n\n          const mutationID = await dbWrite.getMutationID();\n          const tx = new WriteTransactionImpl(\n            clientID,\n            mutationID,\n            'initial',\n            await this.#zero?.getTxData(headHash, {\n              openLazyRead: dagWrite,\n            }),\n            dbWrite,\n            this.#lc,\n          );\n\n          if (trackingData) {\n            this.#zero?.mutationIDAssigned(\n              trackingData.ephemeralID,\n              mutationID,\n            );\n          }\n\n          result = await mutatorImpl(tx, args);\n\n          throwIfClosed(dbWrite);\n          const lastMutationID = await dbWrite.getMutationID();\n          [newHead, diffs] = await dbWrite.commitWithDiffs(\n            DEFAULT_HEAD_NAME,\n            this.#subscriptions,\n          );\n\n          // Update this after the commit in case the commit fails.\n          this.lastMutationID = lastMutationID;\n        } catch (e) {\n          // If we threw before we could persist the mutation\n          // then we need to reject the mutation.\n          if (trackingData) {\n            this.#zero?.rejectMutation(trackingData.ephemeralID, e);\n          }\n          throw e;\n        }\n\n        this.#zero?.advance(headHash, newHead, diffs.get('') ?? []);\n\n        // Send is not supposed to reject\n        this.#pushConnectionLoop.send(false).catch(() => void 0);\n        await this.#subscriptions.fire(diffs);\n        void this.#schedulePersist();\n        return result;\n      } catch (ex) {\n        throw await this.#convertToClientStateNotFoundError(ex);\n      }\n    });\n  }\n\n  /**\n   * In the case we get a ChunkNotFoundError we check if the client got garbage\n   * collected and if so change the error to a ClientStateNotFoundError instead\n   */\n  async #convertToClientStateNotFoundError(ex: unknown): Promise<unknown> {\n    if (\n      ex instanceof ChunkNotFoundError &&\n      (await this.#checkForClientStateNotFoundAndCallHandler())\n    ) {\n      return new ClientStateNotFoundError(this.clientID);\n    }\n\n    return ex;\n  }\n\n  recoverMutations(): Promise<boolean> | void {\n    if (!process.env.DISABLE_MUTATION_RECOVERY) {\n      const result = this.#mutationRecovery!.recoverMutations(\n        this.#ready,\n        this.perdag,\n        this.#idbDatabase,\n        this.#idbDatabases,\n        this.#kvStoreProvider.create,\n      );\n      if (TESTING) {\n        void this.onRecoverMutations(result);\n      }\n      return result;\n    }\n  }\n\n  /**\n   * List of pending mutations. The order of this is from oldest to newest.\n   *\n   * Gives a list of local mutations that have `mutationID` >\n   * `syncHead.mutationID` that exists on the main client group.\n   *\n   * @experimental This method is experimental and may change in the future.\n   */\n  experimentalPendingMutations(): Promise<readonly PendingMutation[]> {\n    return withRead(this.memdag, pendingMutationsForAPI);\n  }\n}\n\n// This map is used to keep track of closing instances of Replicache. When an\n// instance is opening we wait for any currently closing instances.\nconst closingInstances: Map<string, Promise<unknown>> = new Map();\n\nasync function throwIfError(p: Promise<undefined | {error: unknown}>) {\n  const res = await p;\n  if (res) {\n    throw res.error;\n  }\n}\n\nfunction reload(): void {\n  if (typeof location !== 'undefined') {\n    location.reload();\n  }\n}\n\nfunction validateOptions<MD extends MutatorDefs>(\n  options: ReplicacheOptions<MD>,\n): void {\n  const {name, clientMaxAgeMs} = options;\n  if (typeof name !== 'string' || !name) {\n    throw new TypeError('name is required and must be non-empty');\n  }\n\n  if (clientMaxAgeMs !== undefined) {\n    const min = Math.max(GC_INTERVAL, HEARTBEAT_INTERVAL);\n    if (typeof clientMaxAgeMs !== 'number' || clientMaxAgeMs <= min) {\n      throw new TypeError(\n        `clientAgeMaxMs must be a number larger than ${min}ms`,\n      );\n    }\n  }\n}\n","import {resolver} from '@rocicorp/resolver';\n\ntype PartialDocument = Pick<\n  Document,\n  'visibilityState' | 'addEventListener' | 'removeEventListener'\n>;\n\nexport function getDocumentVisibilityWatcher(\n  doc: PartialDocument | undefined,\n  hiddenIntervalMS: number,\n  signal: AbortSignal,\n): DocumentVisibilityWatcher {\n  return doc\n    ? new DocumentVisibilityWatcherImpl(doc, hiddenIntervalMS, signal)\n    : new DocumentVisibilityWatcherNoDoc();\n}\n\nexport interface DocumentVisibilityWatcher {\n  readonly visibilityState: DocumentVisibilityState;\n  waitForVisible(): Promise<unknown>;\n  waitForHidden(): Promise<unknown>;\n}\n\nclass DocumentVisibilityWatcherImpl implements DocumentVisibilityWatcher {\n  readonly #doc: PartialDocument;\n  readonly #hiddenIntervalMS: number;\n  #timeoutID: ReturnType<typeof setTimeout> | 0 = 0;\n\n  // This trails doc.visibilityState by hiddenIntervalMS when being hidden. This\n  // is because we want to wait for the tab to be hidden for a while before\n  // considering as hidden.\n  visibilityState: DocumentVisibilityState;\n\n  readonly #promises = new Set<{\n    resolve: () => void;\n    state: DocumentVisibilityState;\n  }>();\n\n  constructor(\n    doc: PartialDocument,\n    hiddenIntervalMS: number,\n    signal: AbortSignal,\n  ) {\n    this.#doc = doc;\n    this.#hiddenIntervalMS = hiddenIntervalMS;\n    this.visibilityState = doc.visibilityState;\n    // Safari got support for abort signal in addEventListener in version\n    // 15 (Released 2021-09-20)\n    this.#doc.addEventListener('visibilitychange', this.#onVisibilityChange, {\n      signal,\n    });\n  }\n\n  #onVisibilityChange = () => {\n    if (this.#doc.visibilityState === 'visible') {\n      clearTimeout(this.#timeoutID);\n      this.#setVisibilityState('visible');\n    } else {\n      this.#timeoutID = setTimeout(() => {\n        this.#setVisibilityState('hidden');\n      }, this.#hiddenIntervalMS);\n    }\n  };\n\n  #setVisibilityState(visibilityState: DocumentVisibilityState) {\n    if (visibilityState === this.visibilityState) {\n      return;\n    }\n    this.visibilityState = visibilityState;\n    for (const entry of this.#promises) {\n      const {resolve, state} = entry;\n      if (state === visibilityState) {\n        resolve();\n        this.#promises.delete(entry);\n      }\n    }\n  }\n\n  waitForVisible(): Promise<unknown> {\n    return this.#waitFor('visible');\n  }\n\n  waitForHidden(): Promise<unknown> {\n    return this.#waitFor('hidden');\n  }\n\n  #waitFor(state: DocumentVisibilityState): Promise<unknown> {\n    if (this.visibilityState === state) {\n      return Promise.resolve();\n    }\n\n    const {promise, resolve} = resolver();\n    this.#promises.add({resolve, state});\n    return promise;\n  }\n}\n\nconst resolvedPromise = Promise.resolve();\nconst promiseThatNeverResolves = new Promise(() => undefined);\n\nclass DocumentVisibilityWatcherNoDoc implements DocumentVisibilityWatcher {\n  readonly visibilityState: DocumentVisibilityState = 'visible';\n  waitForVisible(): Promise<unknown> {\n    return resolvedPromise;\n  }\n\n  waitForHidden(): Promise<unknown> {\n    return promiseThatNeverResolves;\n  }\n}\n","import type {ConnectionLoopDelegate} from './connection-loop.ts';\nimport type {ReplicacheImpl} from './replicache-impl.ts';\n\nclass ConnectionLoopDelegateImpl {\n  readonly rep: ReplicacheImpl;\n  readonly invokeSend: () => Promise<boolean>;\n\n  // TODO: Remove the ability to have more than one concurrent connection and update tests.\n  // Bug: https://github.com/rocicorp/replicache-internal/issues/303\n  readonly maxConnections = 1;\n\n  constructor(rep: ReplicacheImpl, invokeSend: () => Promise<boolean>) {\n    this.rep = rep;\n    this.invokeSend = invokeSend;\n  }\n\n  get maxDelayMs(): number {\n    return this.rep.requestOptions.maxDelayMs;\n  }\n\n  get minDelayMs(): number {\n    return this.rep.requestOptions.minDelayMs;\n  }\n}\n\nexport class PullDelegate\n  extends ConnectionLoopDelegateImpl\n  implements ConnectionLoopDelegate\n{\n  readonly debounceDelay = 0;\n\n  get watchdogTimer(): number | null {\n    return this.rep.pullInterval;\n  }\n}\n\nexport class PushDelegate\n  extends ConnectionLoopDelegateImpl\n  implements ConnectionLoopDelegate\n{\n  get debounceDelay(): number {\n    return this.rep.pushDelay;\n  }\n\n  watchdogTimer = null;\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {resolver} from '@rocicorp/resolver';\nimport type {DocumentVisibilityWatcher} from '../../shared/src/document-visible.ts';\nimport {sleep} from '../../shared/src/sleep.ts';\n\nexport const DEBOUNCE_DELAY_MS = 10;\n\nexport const MIN_DELAY_MS = 30;\nexport const MAX_DELAY_MS = 60_000;\n\ntype SendRecord = {duration: number; ok: boolean};\n\nexport interface ConnectionLoopDelegate {\n  invokeSend(): Promise<boolean>;\n  debounceDelay: number;\n  // If null, no watchdog timer is used.\n  watchdogTimer: number | null;\n  maxConnections: number;\n  maxDelayMs: number;\n  minDelayMs: number;\n}\n\nexport class ConnectionLoop {\n  // ConnectionLoop runs a loop sending network requests (either pushes or\n  // pulls) to the server. Our goal, generally, is to send requests as fast as\n  // we can, but to adjust in case of slowness, network errors, etc. We will\n  // send requests in parallel if the server supports it. We also debounce\n  // pushes since they frequently happen in series very near to one another\n  // (e.g., during drag'n drops).\n  //\n  // The loop flows through the following states forever, until it is closed:\n  //\n  // Pending: Wait for event or watchdog\n  //          |\n  //          v\n  // Debounce: Wait for more events (we debounce pushes)\n  //          |\n  //          v\n  // Wait for available connection (we limit number of parallel requests\n  // allowed)\n  //          |\n  //          v\n  // Wait to send (if requests are taking too long, we will slow down)\n  //          |\n  //          v\n  // Send (asynchronously, wrt the loop)\n  //          |\n  //          v\n  // Back to the pending!\n\n  // Controls whether the next iteration of the loop will wait at the pending\n  // state.\n  #pendingResolver = resolver<void>();\n\n  /**\n   * This resolver is used to allow us to skip sleeps when we do send(true)\n   */\n  #skipSleepsResolver = resolver<void>();\n\n  /**\n   * Resolver for the next send. Never rejects. Returns an error instead since\n   * this resolver is used in cases where they might not be someone waiting,\n   * and we don't want an unhandled promise rejection in that case.\n   */\n  #sendResolver = resolver<undefined | {error: unknown}>();\n\n  readonly #delegate: ConnectionLoopDelegate;\n  #closed = false;\n\n  /**\n   * Number of pending send calls.\n   *\n   * We keep track of this because if close happens while we are waiting for the\n   * send to resolve we should reject the send promise.\n   */\n  #sendCounter = 0;\n  readonly #lc: LogContext;\n  readonly #visibilityWatcher: DocumentVisibilityWatcher | undefined;\n\n  constructor(\n    lc: LogContext,\n    delegate: ConnectionLoopDelegate,\n    visibilityWatcher?: DocumentVisibilityWatcher,\n  ) {\n    this.#lc = lc;\n    this.#delegate = delegate;\n    this.#visibilityWatcher = visibilityWatcher;\n    void this.run();\n  }\n\n  close(): void {\n    this.#closed = true;\n    if (this.#sendCounter > 0) {\n      this.#sendResolver.resolve({error: closeError()});\n    }\n  }\n\n  /**\n   *\n   * @returns Returns undefined if ok, otherwise it return the error that caused\n   * the send to fail.\n   */\n  async send(now: boolean): Promise<undefined | {error: unknown}> {\n    if (this.#closed) {\n      return {error: closeError()};\n    }\n    this.#sendCounter++;\n    this.#lc.debug?.('send', now);\n    if (now) {\n      this.#skipSleepsResolver.resolve();\n    } else {\n      await this.#visibilityWatcher?.waitForVisible();\n    }\n\n    this.#pendingResolver.resolve();\n\n    const result = await this.#sendResolver.promise;\n    this.#sendCounter--;\n    return result;\n  }\n\n  async run(): Promise<void> {\n    const sendRecords: SendRecord[] = [];\n\n    let recoverResolver = resolver();\n    let lastSendTime;\n\n    // The number of active connections.\n    let counter = 0;\n    const delegate = this.#delegate;\n    const {debug} = this.#lc;\n    let delay = 0;\n\n    debug?.('Starting connection loop');\n\n    const sleepMaybeSkip: typeof sleep = ms =>\n      Promise.race([this.#skipSleepsResolver.promise, sleep(ms)]);\n\n    while (!this.#closed) {\n      debug?.(\n        didLastSendRequestFail(sendRecords)\n          ? 'Last request failed. Trying again'\n          : 'Waiting for a send',\n      );\n\n      // Wait until send is called or until the watchdog timer fires.\n      const races = [this.#pendingResolver.promise];\n      const t = delegate.watchdogTimer;\n      if (t !== null) {\n        races.push(sleep(t));\n      }\n      await Promise.race(races);\n      if (this.#closed) break;\n\n      debug?.('Waiting for debounce');\n      await sleepMaybeSkip(delegate.debounceDelay);\n      if (this.#closed) break;\n      debug?.('debounced');\n\n      // This resolver is used to wait for incoming push calls.\n      this.#pendingResolver = resolver();\n\n      if (counter >= delegate.maxConnections) {\n        debug?.('Too many request in flight. Waiting until one finishes...');\n        await this.#waitUntilAvailableConnection();\n        if (this.#closed) break;\n        debug?.('...finished');\n      }\n\n      // We need to delay the next request even if there are no active requests\n      // in case of error.\n      if (counter > 0 || didLastSendRequestFail(sendRecords)) {\n        delay = computeDelayAndUpdateDurations(delay, delegate, sendRecords);\n        debug?.(\n          didLastSendRequestFail(sendRecords)\n            ? 'Last connection errored. Sleeping for'\n            : 'More than one outstanding connection (' +\n                counter +\n                '). Sleeping for',\n          delay,\n          'ms',\n        );\n      } else {\n        // We set this to 0 here in case minDelayMs is mutated to a lower value\n        // than the old delay so that we still get minDelayMs. This can happen\n        // if we get an error during a run where minDelayMs is larger than the\n        // current value of minDelayMs.\n        delay = 0;\n      }\n\n      const clampedDelay = Math.min(\n        delegate.maxDelayMs,\n        Math.max(delegate.minDelayMs, delay),\n      );\n      if (lastSendTime !== undefined) {\n        const timeSinceLastSend = Date.now() - lastSendTime;\n        if (clampedDelay > timeSinceLastSend) {\n          await Promise.race([\n            sleepMaybeSkip(clampedDelay - timeSinceLastSend),\n            recoverResolver.promise,\n          ]);\n          if (this.#closed) break;\n        }\n      }\n\n      counter++;\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (async () => {\n        const start = Date.now();\n        let ok: boolean;\n        let error: unknown;\n        try {\n          lastSendTime = start;\n          debug?.('Sending request');\n          this.#skipSleepsResolver = resolver();\n          ok = await delegate.invokeSend();\n          debug?.('Send returned', ok);\n        } catch (e) {\n          debug?.('Send failed', e);\n          error = e;\n          ok = false;\n        }\n        if (this.#closed) {\n          debug?.('Closed after invokeSend');\n          return;\n        }\n        debug?.('Request done', {duration: Date.now() - start, ok});\n        sendRecords.push({duration: Date.now() - start, ok});\n        if (recovered(sendRecords)) {\n          recoverResolver.resolve();\n          recoverResolver = resolver();\n        }\n        counter--;\n        this.#connectionAvailable();\n        const sendResolver = this.#sendResolver;\n        this.#sendResolver = resolver();\n        if (error) {\n          sendResolver.resolve({error});\n        } else {\n          sendResolver.resolve(undefined);\n        }\n        if (!ok) {\n          // Keep trying\n          this.#pendingResolver.resolve();\n        }\n      })();\n    }\n  }\n\n  #waitingConnectionResolve: (() => void) | undefined = undefined;\n\n  #connectionAvailable() {\n    if (this.#waitingConnectionResolve) {\n      const resolve = this.#waitingConnectionResolve;\n      this.#waitingConnectionResolve = undefined;\n      resolve();\n    }\n  }\n\n  #waitUntilAvailableConnection() {\n    const {promise, resolve} = resolver();\n    this.#waitingConnectionResolve = resolve;\n    return promise;\n  }\n}\n\n// Number of connections to remember when computing the new delay.\nconst CONNECTION_MEMORY_COUNT = 9;\n\nfunction closeError() {\n  return new Error('Closed');\n}\n\n// Computes a new delay based on the previous requests. We use the median of the\n// previous successful request divided by `maxConnections`. When we get errors\n// we do exponential backoff. As soon as we recover from an error we reset back\n// to delegate.minDelayMs.\nfunction computeDelayAndUpdateDurations(\n  delay: number,\n  delegate: ConnectionLoopDelegate,\n  sendRecords: SendRecord[],\n): number {\n  const {length} = sendRecords;\n  if (length === 0) {\n    return delay;\n  }\n\n  const {ok} = sendRecords[sendRecords.length - 1];\n  const {maxConnections, minDelayMs} = delegate;\n\n  if (!ok) {\n    return delay === 0 ? minDelayMs : delay * 2;\n  }\n\n  if (length > 1) {\n    // length > 1\n    const previous: SendRecord = sendRecords[sendRecords.length - 2];\n\n    // Prune\n    while (sendRecords.length > CONNECTION_MEMORY_COUNT) {\n      sendRecords.shift();\n    }\n\n    if (ok && !previous.ok) {\n      // Recovered\n      return minDelayMs;\n    }\n  }\n\n  const med = median(\n    sendRecords.filter(({ok}) => ok).map(({duration}) => duration),\n  );\n\n  return (med / maxConnections) | 0;\n}\n\nfunction median(values: number[]) {\n  values.sort();\n  const {length} = values;\n  const half = length >> 1;\n  if (length % 2 === 1) {\n    return values[half];\n  }\n  return (values[half - 1] + values[half]) / 2;\n}\n\nfunction didLastSendRequestFail(sendRecords: SendRecord[]) {\n  return sendRecords.length > 0 && !sendRecords[sendRecords.length - 1].ok;\n}\n\nfunction recovered(sendRecords: SendRecord[]) {\n  return (\n    sendRecords.length > 1 &&\n    !sendRecords[sendRecords.length - 2].ok &&\n    sendRecords[sendRecords.length - 1].ok\n  );\n}\n","import {RWLock} from '@rocicorp/lock';\nimport {joinIterables} from '../../../shared/src/iterables.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport type {Hash} from '../hash.ts';\nimport {getSizeOfValue} from '../size-of-value.ts';\nimport {Chunk, type ChunkHasher, type Refs, createChunk} from './chunk.ts';\nimport {\n  type HeadChange,\n  type RefCountUpdatesDelegate,\n  computeRefCountUpdates,\n} from './gc.ts';\nimport {type Read, type Store, type Write, mustGetChunk} from './store.ts';\n\n/**\n * Dag Store which lazily loads values from a source store and then caches\n * them in an LRU cache.  The memory cache for chunks from the source store\n * size is limited to `sourceCacheSizeLimit` bytes, and values are evicted in an\n * LRU fashion.  The purpose of this store is to avoid holding the entire client\n * view (i.e. the source store's content) in each tab's JavaScript heap.\n *\n * This store's heads are independent from the heads of source store, and are\n * only stored in memory.\n *\n * Chunks which are created via this store's {@link Write} transaction's\n * {@link createChunk} method are assumed to not be persisted to the source\n * store and thus are cached separately from the source store chunks.  These\n * memory-only chunks will not be evicted, and their sizes are not counted\n * towards the source chunk cache size.  A memory-only chunk will be deleted if\n * it is no longer reachable from one of this store's heads.\n *\n * Writes only manipulate the in memory state of this store and do not alter the\n * source store.  Thus values must be written to the source store through a\n * separate process (see {@link persist}).\n *\n * Intended use:\n * 1. source store is the 'perdag', a slower persistent store (i.e.\n *    dag.StoreImpl using a kv.IDBStore)\n * 2. this store's 'main' head is initialized to the hash of a chunk containing\n *    a commit in the source store\n * 3. reads lazily read chunks from the source store and cache them\n * 3. writes are initially made to this store with memory-only chunks\n * 4. writes are asynchronously persisted to the source store through a separate\n *    process (see {@link persist}}. This process gathers memory-only chunks\n *    from this store and then writes them to the source store.  It then informs\n *    this store that these chunks are no longer memory-only by calling\n *    {@link chunksPersisted}, which move these chunks\n *    to this store's LRU cache of source chunks (making them eligible for\n *    eviction).\n *\n * @param sourceStore Store to lazy load and cache values from.\n * @param sourceCacheSizeLimit Size limit in bytes for cache of chunks loaded\n * from `sourceStore`.  This size of a value is determined using\n * `getSizeOfValue`.  Keys do not count towards cache size.  Memory-only chunks\n * do not count towards cache size.\n * @param getSizeOfValue Function for measuring the size in bytes of a value.\n */\nexport class LazyStore implements Store {\n  /**\n   * This lock is used to ensure correct isolation of Reads and Writes.\n   * Multiple Reads are allowed in parallel but only a single Write.  Reads and\n   * Writes see an isolated view of the store (corresponding to the Serializable\n   * level of transaction isolation defined in the SQL standard).\n   *\n   * To ensure these semantics the read lock must be acquired when a Read is\n   * created and held til it is closed, and a Write lock must be acquired when a\n   * Write is created and held til it is committed or closed.\n   *\n   * Code must have a read or write lock to\n   * - read `_heads`\n   * - read `_memOnlyChunks`\n   * - read `_sourceStore`\n   * - read and write `_sourceChunksCache`\n   * - read and write `_refCounts`\n   * - read and write `_refs`\n   * and must have a write lock to\n   * - write `_heads`\n   * - write `_memOnlyChunks`\n   */\n  readonly #rwLock = new RWLock();\n  readonly #heads = new Map<string, Hash>();\n  readonly #sourceStore: Store;\n  readonly #chunkHasher: ChunkHasher;\n  readonly #assertValidHash: (hash: Hash) => void;\n\n  /** The following are protected so testing subclass can access. */\n  protected readonly _memOnlyChunks = new Map<Hash, Chunk>();\n  protected readonly _sourceChunksCache: ChunksCache;\n  /**\n   * Ref counts are maintained so that chunks which are unreachable\n   * from this stores heads can be eagerly and deterministically deleted from\n   * `this._memOnlyChunks` and `this._sourceChunksCache`.\n   *\n   * These ref counts are independent from `this._sourceStore`'s ref counts.\n   * These ref counts are based on reachability from `this._heads`.\n   * A chunk is deleted from `this._memOnlyChunks` or\n   * `this._sourceChunksCache` (which ever it is in) when its ref count becomes\n   * zero.\n   * These ref counts count the refs in `this._heads` and `this._refs`.\n   *\n   * Not all reachable chunk's refs are included in `this._refs`, because this\n   * would require loading all chunks reachable in the source store in a\n   * non-lazy manner. `this._refs` contains the refs of all currently reachable\n   * chunks that were ever in `this._memOnlyChunks` or\n   * `this._sourceChunksCache` (even if they have been evicted).  A\n   * chunk's ref information is lazily discovered and stored in `this._refs` and\n   * counted in `this._refCounts`. A chunk's entries in `this._refs` and\n   * `this._refCounts` are only deleted when a chunk is deleted due to it\n   * becoming unreachable (it is not deleted if the chunk is evicted from the\n   * source-store cache).\n   *\n   * The major implication of this lazy discovery of source store refs, is that\n   * a reachable source store chunk may not be cached when loaded, because it is\n   * not known to be reachable because some of the pertinent refs have not been\n   * discovered.  However, in practice chunks are read by traversing the graph\n   * starting from a head, and all pertinent refs are discovered as part of the\n   * traversal.\n   *\n   * These ref counts can be changed in two ways:\n   * 1. A LazyRead has a cache miss and loads a chunk from the source store that\n   * is reachable from this._heads.  If this chunk's refs are not currently\n   * counted, it will not have an entry in `this._refs`.  In this case, the\n   * chunks refs will be put in `this._refs` and `this._refCounts` will be\n   * updated to count them.\n   * 2. A LazyWrite commit updates a head (which can result in increasing or\n   * decreasing ref count) or puts a reachable chunk (either a `memory-only` or\n   * `source` chunk) that references this hash (increasing ref count).  The\n   * computation of these ref count changes is delegated to the\n   * `computeRefCountUpdates` shared with dag.StoreImpl.  In order to\n   * delegate determining reachability to `computeRefCountUpdates` and defer\n   * this determination until commit time, LazyWrite treats cache misses\n   * as a 'put' of the lazily-loaded chunk.\n   *\n   * A chunk's hash may have an entry in `this._refCounts` without that\n   * chunk have ever been in `this._memOnlyChunks` or `this._sourceChunksCache`.\n   * This is the case when a head or a reachable chunk that was ever in\n   * `this._memOnlyChunks` or `this._sourceChunksCache` references a chunk\n   * which is not currently cached (either because it has not been read, or\n   * because it has been evicted).\n   */\n  protected readonly _refCounts = new Map<Hash, number>();\n  protected readonly _refs = new Map<Hash, readonly Hash[]>();\n\n  constructor(\n    sourceStore: Store,\n    sourceCacheSizeLimit: number,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n    getSizeOfChunk: (chunk: Chunk) => number = getSizeOfValue,\n  ) {\n    this._sourceChunksCache = new ChunksCache(\n      sourceCacheSizeLimit,\n      getSizeOfChunk,\n      this._refCounts,\n      this._refs,\n    );\n    this.#sourceStore = sourceStore;\n    this.#chunkHasher = chunkHasher;\n    this.#assertValidHash = assertValidHash;\n  }\n\n  async read(sourceRead?: Read): Promise<LazyRead> {\n    const release = await this.#rwLock.read();\n    return new LazyRead(\n      this.#heads,\n      this._memOnlyChunks,\n      this._sourceChunksCache,\n      this.#sourceStore,\n      release,\n      this.#assertValidHash,\n      sourceRead,\n    );\n  }\n\n  async write(): Promise<LazyWrite> {\n    const release = await this.#rwLock.write();\n    return new LazyWrite(\n      this.#heads,\n      this._memOnlyChunks,\n      this._sourceChunksCache,\n      this.#sourceStore,\n      this._refCounts,\n      this._refs,\n      release,\n      this.#chunkHasher,\n      this.#assertValidHash,\n    );\n  }\n\n  close(): Promise<void> {\n    return promiseVoid;\n  }\n\n  /**\n   * Does not acquire any lock on the store.\n   */\n  isCached(chunkHash: Hash): boolean {\n    return (\n      this._sourceChunksCache.getWithoutUpdatingLRU(chunkHash) !== undefined\n    );\n  }\n\n  withSuspendedSourceCacheEvictsAndDeletes<T>(\n    fn: () => MaybePromise<T>,\n  ): Promise<T> {\n    return this._sourceChunksCache.withSuspendedEvictsAndDeletes(fn);\n  }\n}\n\nexport class LazyRead implements Read {\n  protected readonly _heads: Map<string, Hash>;\n  protected readonly _memOnlyChunks: Map<Hash, Chunk>;\n  protected readonly _sourceChunksCache: ChunksCache;\n  protected readonly _sourceStore: Store;\n  #sourceRead: Promise<Read> | undefined = undefined;\n  readonly #release: () => void;\n  #closed = false;\n  readonly assertValidHash: (hash: Hash) => void;\n  readonly #sourceReadOwnedByCaller: boolean;\n\n  constructor(\n    heads: Map<string, Hash>,\n    memOnlyChunks: Map<Hash, Chunk>,\n    sourceChunksCache: ChunksCache,\n    sourceStore: Store,\n    release: () => void,\n    assertValidHash: (hash: Hash) => void,\n    // If the lazyRead is being run in the context of an existing\n    // read, or write, from the perdag then we must use _that_\n    // transaction's read. Trying to open our own `sourceRead` will\n    // cause the outer transaction to auto-commit.\n    sourceRead?: Read | undefined,\n  ) {\n    this._heads = heads;\n    this._memOnlyChunks = memOnlyChunks;\n    this._sourceChunksCache = sourceChunksCache;\n    this._sourceStore = sourceStore;\n    this.#release = release;\n    this.assertValidHash = assertValidHash;\n    this.#sourceRead =\n      sourceRead !== undefined ? Promise.resolve(sourceRead) : undefined;\n    this.#sourceReadOwnedByCaller = sourceRead !== undefined;\n  }\n\n  isMemOnlyChunkHash(hash: Hash): boolean {\n    return this._memOnlyChunks.has(hash);\n  }\n\n  async hasChunk(hash: Hash): Promise<boolean> {\n    return (await this.getChunk(hash)) !== undefined;\n  }\n\n  async getChunk(hash: Hash): Promise<Chunk | undefined> {\n    const memOnlyChunk = this._memOnlyChunks.get(hash);\n    if (memOnlyChunk !== undefined) {\n      return memOnlyChunk;\n    }\n    let chunk = this._sourceChunksCache.get(hash);\n    if (chunk === undefined) {\n      chunk = await (await this._getSourceRead()).getChunk(hash);\n      if (chunk !== undefined) {\n        this._sourceChunksCache.put(chunk);\n      }\n    }\n    return chunk;\n  }\n\n  mustGetChunk(hash: Hash): Promise<Chunk> {\n    return mustGetChunk(this, hash);\n  }\n\n  getHead(name: string): Promise<Hash | undefined> {\n    return Promise.resolve(this._heads.get(name));\n  }\n\n  release(): void {\n    if (!this.#closed) {\n      this.#release();\n      if (!this.#sourceReadOwnedByCaller) {\n        this.#sourceRead\n          ?.then(read => read.release())\n          // If creation of the read failed there is nothing to release.\n          // Catch to avoid `Uncaught (in promise)` errors being reported.\n          // eslint-disable-next-line @typescript-eslint/no-empty-function\n          .catch(_ => {});\n      }\n      this.#closed = true;\n    }\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  protected _getSourceRead(): Promise<Read> {\n    if (!this.#sourceRead) {\n      this.#sourceRead = this._sourceStore.read();\n    }\n    return this.#sourceRead;\n  }\n}\n\nexport class LazyWrite\n  extends LazyRead\n  implements Write, RefCountUpdatesDelegate\n{\n  readonly #refCounts: Map<Hash, number>;\n  readonly #refs: Map<Hash, readonly Hash[]>;\n  readonly #chunkHasher: ChunkHasher;\n  protected readonly _pendingHeadChanges = new Map<string, HeadChange>();\n  protected readonly _pendingMemOnlyChunks = new Map<Hash, Chunk>();\n  protected readonly _pendingCachedChunks = new Map<\n    Hash,\n    {chunk: Chunk; size: number}\n  >();\n  readonly #createdChunks = new Set<Hash>();\n\n  constructor(\n    heads: Map<string, Hash>,\n    memOnlyChunks: Map<Hash, Chunk>,\n    sourceChunksCache: ChunksCache,\n    sourceStore: Store,\n    refCounts: Map<Hash, number>,\n    refs: Map<Hash, readonly Hash[]>,\n    release: () => void,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n  ) {\n    super(\n      heads,\n      memOnlyChunks,\n      sourceChunksCache,\n      sourceStore,\n      release,\n      assertValidHash,\n    );\n    this.#refCounts = refCounts;\n    this.#refs = refs;\n    this.#chunkHasher = chunkHasher;\n  }\n\n  createChunk = <V>(data: V, refs: Refs): Chunk<V> => {\n    const chunk = createChunk(data, refs, this.#chunkHasher);\n    this.#createdChunks.add(chunk.hash);\n    return chunk;\n  };\n\n  putChunk<V>(c: Chunk<V>, size?: number): Promise<void> {\n    const {hash, meta} = c;\n    this.assertValidHash(hash);\n    if (meta.length > 0) {\n      for (const h of meta) {\n        this.assertValidHash(h);\n      }\n    }\n    if (this.#createdChunks.has(hash) || this.isMemOnlyChunkHash(hash)) {\n      this._pendingMemOnlyChunks.set(hash, c);\n    } else {\n      this._pendingCachedChunks.set(hash, {chunk: c, size: size ?? -1});\n    }\n    return promiseVoid;\n  }\n\n  async setHead(name: string, hash: Hash): Promise<void> {\n    await this.#setHead(name, hash);\n  }\n\n  async removeHead(name: string): Promise<void> {\n    await this.#setHead(name, undefined);\n  }\n\n  async #setHead(name: string, hash: Hash | undefined): Promise<void> {\n    const oldHash = await this.getHead(name);\n    const v = this._pendingHeadChanges.get(name);\n    if (v === undefined) {\n      this._pendingHeadChanges.set(name, {new: hash, old: oldHash});\n    } else {\n      // Keep old if existing\n      v.new = hash;\n    }\n  }\n\n  override isMemOnlyChunkHash(hash: Hash): boolean {\n    return (\n      this._pendingMemOnlyChunks.has(hash) || super.isMemOnlyChunkHash(hash)\n    );\n  }\n\n  override async getChunk(hash: Hash): Promise<Chunk | undefined> {\n    const pendingMemOnlyChunk = this._pendingMemOnlyChunks.get(hash);\n    if (pendingMemOnlyChunk !== undefined) {\n      return pendingMemOnlyChunk;\n    }\n    const memOnlyChunk = this._memOnlyChunks.get(hash);\n    if (memOnlyChunk !== undefined) {\n      return memOnlyChunk;\n    }\n    // In order to delegate determining reachability to `computeRefCountUpdates`\n    // and defer this determination until commit time, treat cache misses\n    // as a 'put' of the lazily-loaded chunk.\n    const pendingCachedChunk = this._pendingCachedChunks.get(hash);\n    if (pendingCachedChunk !== undefined) {\n      return pendingCachedChunk.chunk;\n    }\n    let chunk = this._sourceChunksCache.get(hash);\n    if (chunk === undefined) {\n      chunk = await (await this._getSourceRead()).getChunk(hash);\n      if (chunk !== undefined) {\n        this._pendingCachedChunks.set(chunk.hash, {chunk, size: -1});\n      }\n    }\n    return chunk;\n  }\n\n  override getHead(name: string): Promise<Hash | undefined> {\n    const headChange = this._pendingHeadChanges.get(name);\n    if (headChange) {\n      return Promise.resolve(headChange.new);\n    }\n    return super.getHead(name);\n  }\n\n  async commit(): Promise<void> {\n    const pendingChunks = new Set(\n      joinIterables(\n        this._pendingMemOnlyChunks.keys(),\n        this._pendingCachedChunks.keys(),\n      ),\n    );\n    const refCountUpdates = await computeRefCountUpdates(\n      this._pendingHeadChanges.values(),\n      pendingChunks,\n      this,\n    );\n\n    for (const [hash, count] of refCountUpdates) {\n      if (this.isMemOnlyChunkHash(hash)) {\n        if (count === 0) {\n          this.#refCounts.delete(hash);\n          this._memOnlyChunks.delete(hash);\n          this.#refs.delete(hash);\n        } else {\n          this.#refCounts.set(hash, count);\n          const chunk = this._pendingMemOnlyChunks.get(hash);\n          if (chunk) {\n            this.#refs.set(hash, chunk.meta);\n            this._memOnlyChunks.set(hash, chunk);\n          }\n        }\n        refCountUpdates.delete(hash);\n      }\n    }\n\n    this._sourceChunksCache.updateForCommit(\n      this._pendingCachedChunks,\n      refCountUpdates,\n    );\n\n    for (const [name, headChange] of this._pendingHeadChanges) {\n      if (headChange.new) {\n        this._heads.set(name, headChange.new);\n      } else {\n        this._heads.delete(name);\n      }\n    }\n\n    this._pendingMemOnlyChunks.clear();\n    this._pendingCachedChunks.clear();\n    this._pendingHeadChanges.clear();\n    this.release();\n  }\n\n  getRefCount(hash: Hash): number | undefined {\n    return this.#refCounts.get(hash);\n  }\n\n  getRefs(hash: Hash): readonly Hash[] | undefined {\n    const pendingMemOnlyChunk = this._pendingMemOnlyChunks.get(hash);\n    if (pendingMemOnlyChunk) {\n      return pendingMemOnlyChunk.meta;\n    }\n    const memOnlyChunk = this._memOnlyChunks.get(hash);\n    if (memOnlyChunk) {\n      return memOnlyChunk.meta;\n    }\n    const pendingCachedChunk = this._pendingCachedChunks.get(hash);\n    if (pendingCachedChunk !== undefined) {\n      return pendingCachedChunk.chunk.meta;\n    }\n    return this.#refs.get(hash);\n  }\n\n  areRefsCounted(hash: Hash): boolean {\n    return this.#refs.has(hash);\n  }\n\n  chunksPersisted(chunkHashes: readonly Hash[]): void {\n    const chunksToCache = [];\n    for (const chunkHash of chunkHashes) {\n      const chunk = this._memOnlyChunks.get(chunkHash);\n      if (chunk) {\n        this._memOnlyChunks.delete(chunkHash);\n        chunksToCache.push(chunk);\n      }\n    }\n    this._sourceChunksCache.persisted(chunksToCache);\n  }\n}\n\ntype CacheEntry = {\n  chunk: Chunk;\n  size: number;\n};\n\nclass ChunksCache {\n  readonly #cacheSizeLimit: number;\n  readonly #getSizeOfChunk: (chunk: Chunk) => number;\n  readonly #refCounts: Map<Hash, number>;\n  readonly #refs: Map<Hash, readonly Hash[]>;\n  #size = 0;\n  #evictsAndDeletesSuspended = false;\n  readonly #suspendedDeletes: Hash[] = [];\n\n  /**\n   * Iteration order is from least to most recently used.\n   *\n   * Public so that testing subclass can access.\n   */\n  readonly cacheEntries = new Map<Hash, CacheEntry>();\n\n  constructor(\n    cacheSizeLimit: number,\n    getSizeOfChunk: (v: Chunk) => number,\n    refCounts: Map<Hash, number>,\n    refs: Map<Hash, readonly Hash[]>,\n  ) {\n    this.#cacheSizeLimit = cacheSizeLimit;\n    this.#getSizeOfChunk = getSizeOfChunk;\n    this.#refCounts = refCounts;\n    this.#refs = refs;\n  }\n\n  get(hash: Hash): Chunk | undefined {\n    const cacheEntry = this.cacheEntries.get(hash);\n    if (cacheEntry) {\n      // Update order in map for LRU tracking.\n      this.cacheEntries.delete(hash);\n      this.cacheEntries.set(hash, cacheEntry);\n    }\n    return cacheEntry?.chunk;\n  }\n\n  getWithoutUpdatingLRU(hash: Hash): Chunk | undefined {\n    return this.cacheEntries.get(hash)?.chunk;\n  }\n\n  put(chunk: Chunk): void {\n    const {hash} = chunk;\n    // If there is an existing cache entry then the cached value must be\n    // equivalent.  Update order in map for LRU tracking and early return.\n    const oldCacheEntry = this.cacheEntries.get(hash);\n    if (oldCacheEntry) {\n      this.cacheEntries.delete(hash);\n      this.cacheEntries.set(hash, oldCacheEntry);\n      return;\n    }\n\n    // Only cache if there is a ref from a head to this chunk\n    const refCount = this.#refCounts.get(hash);\n    if (refCount === undefined || refCount < 1) {\n      return;\n    }\n    if (!this.#cacheChunk(chunk)) {\n      return;\n    }\n    if (!this.#refs.has(hash)) {\n      for (const refHash of chunk.meta) {\n        this.#refCounts.set(refHash, (this.#refCounts.get(refHash) || 0) + 1);\n      }\n      this.#refs.set(hash, chunk.meta);\n    }\n\n    this.#ensureCacheSizeLimit();\n  }\n\n  #ensureCacheSizeLimit() {\n    if (this.#evictsAndDeletesSuspended) {\n      return;\n    }\n    for (const entry of this.cacheEntries.values()) {\n      if (this.#size <= this.#cacheSizeLimit) {\n        break;\n      }\n      this.#evict(entry);\n    }\n  }\n\n  #cacheChunk(chunk: Chunk, size?: number): boolean {\n    const chunkSize = size ?? this.#getSizeOfChunk(chunk);\n    if (chunkSize > this.#cacheSizeLimit) {\n      // This value cannot be cached due to its size exceeding the\n      // cache size limit, don't evict other entries to try to make\n      // room for it.\n      return false;\n    }\n    this.#size += chunkSize;\n    this.cacheEntries.set(chunk.hash, {chunk, size: chunkSize});\n    return true;\n  }\n\n  #evict(cacheEntry: CacheEntry): void {\n    const {hash} = cacheEntry.chunk;\n    this.#size -= cacheEntry.size;\n    this.cacheEntries.delete(hash);\n  }\n\n  #deleteEntryByHash(hash: Hash): void {\n    this.#refCounts.delete(hash);\n    this.#refs.delete(hash);\n    const cacheEntry = this.cacheEntries.get(hash);\n    if (cacheEntry) {\n      this.#size -= cacheEntry.size;\n      this.cacheEntries.delete(hash);\n    }\n  }\n\n  updateForCommit(\n    chunksToPut: Map<Hash, {chunk: Chunk; size: number}>,\n    refCountUpdates: Map<Hash, number>,\n  ): void {\n    for (const [hash, count] of refCountUpdates) {\n      if (count === 0) {\n        if (!this.#evictsAndDeletesSuspended) {\n          this.#deleteEntryByHash(hash);\n        } else {\n          this.#refCounts.set(hash, 0);\n          this.#suspendedDeletes.push(hash);\n        }\n      } else {\n        this.#refCounts.set(hash, count);\n        const chunkAndSize = chunksToPut.get(hash);\n        if (chunkAndSize) {\n          const {chunk, size} = chunkAndSize;\n          const oldCacheEntry = this.cacheEntries.get(hash);\n          if (oldCacheEntry) {\n            // If there is an existing cache entry then the cached value must be\n            // equivalent.  Update order in map for LRU tracking but avoid\n            // recomputing size and creating a new cache entry.\n            this.cacheEntries.delete(hash);\n            this.cacheEntries.set(hash, oldCacheEntry);\n          } else {\n            this.#cacheChunk(chunk, size !== -1 ? size : undefined);\n            this.#refs.set(hash, chunk.meta);\n          }\n        }\n      }\n    }\n    this.#ensureCacheSizeLimit();\n  }\n\n  persisted(chunks: Iterable<Chunk>) {\n    for (const chunk of chunks) {\n      this.#cacheChunk(chunk);\n    }\n    this.#ensureCacheSizeLimit();\n  }\n\n  async withSuspendedEvictsAndDeletes<T>(\n    fn: () => MaybePromise<T>,\n  ): Promise<T> {\n    this.#evictsAndDeletesSuspended = true;\n    try {\n      return await fn();\n    } finally {\n      this.#evictsAndDeletesSuspended = false;\n      for (const hash of this.#suspendedDeletes) {\n        if (this.#refCounts.get(hash) === 0) {\n          this.#deleteEntryByHash(hash);\n        }\n      }\n      this.#ensureCacheSizeLimit();\n    }\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {greaterThan} from 'compare-utf8';\nimport type {JSONValue, ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {type IndexKey, decodeIndexKey} from './db/index.ts';\nimport type {Read} from './db/read.ts';\nimport type {Write} from './db/write.ts';\nimport {deepFreeze} from './frozen-json.ts';\nimport type {IndexDefinition} from './index-defs.ts';\nimport type {ScanResult} from './scan-iterator.ts';\nimport {ScanResultImpl, fromKeyForIndexScanInternal} from './scan-iterator.ts';\nimport {\n  type KeyTypeForScanOptions,\n  type ScanIndexOptions,\n  type ScanNoIndexOptions,\n  type ScanOptions,\n  isScanIndexOptions,\n  toDbScanOptions,\n} from './scan-options.ts';\nimport type {ScanSubscriptionInfo} from './subscriptions.ts';\nimport type {ClientID} from './sync/ids.ts';\nimport {rejectIfClosed, throwIfClosed} from './transaction-closed-error.ts';\nimport type {ZeroTxData} from './replicache-options.ts';\n\nexport type TransactionEnvironment = 'client' | 'server';\nexport type TransactionLocation = TransactionEnvironment;\nexport type TransactionReason = 'initial' | 'rebase' | 'authoritative';\n\n/**\n * Basic deep readonly type. It works for {@link JSONValue}.\n */\nexport type DeepReadonly<T> = T extends\n  | null\n  | boolean\n  | string\n  | number\n  | undefined\n  ? T\n  : DeepReadonlyObject<T>;\n\nexport type DeepReadonlyObject<T> = {\n  readonly [K in keyof T]: DeepReadonly<T[K]>;\n};\n\n/**\n * ReadTransactions are used with {@link Replicache.query} and\n * {@link Replicache.subscribe} and allows read operations on the\n * database.\n */\nexport interface ReadTransaction {\n  readonly clientID: ClientID;\n  /** @deprecated Use {@link ReadTransaction.location} instead. */\n  readonly environment: TransactionLocation;\n  readonly location: TransactionLocation;\n\n  /**\n   * Get a single value from the database. If the `key` is not present this\n   * returns `undefined`.\n   *\n   * Important: The returned JSON is readonly and should not be modified. This\n   * is only enforced statically by TypeScript and there are no runtime checks\n   * for performance reasons. If you mutate the return value you will get\n   * undefined behavior.\n   */\n\n  get(key: string): Promise<ReadonlyJSONValue | undefined>;\n  get<T extends JSONValue>(key: string): Promise<DeepReadonly<T> | undefined>;\n\n  /** Determines if a single `key` is present in the database. */\n  has(key: string): Promise<boolean>;\n\n  /** Whether the database is empty. */\n  isEmpty(): Promise<boolean>;\n\n  /**\n   * Gets many values from the database. This returns a {@link ScanResult} which\n   * implements `AsyncIterable`. It also has methods to iterate over the\n   * {@link ScanResult.keys | keys} and {@link ScanResult.entries | entries}.\n   *\n   * If `options` has an `indexName`, then this does a scan over an index with\n   * that name. A scan over an index uses a tuple for the key consisting of\n   * `[secondary: string, primary: string]`.\n   *\n   * If the {@link ScanResult} is used after the `ReadTransaction` has been closed\n   * it will throw a {@link TransactionClosedError}.\n   *\n   * Important: The returned JSON is readonly and should not be modified. This\n   * is only enforced statically by TypeScript and there are no runtime checks\n   * for performance reasons. If you mutate the return value you will get\n   * undefined behavior.\n   */\n  scan(options: ScanIndexOptions): ScanResult<IndexKey, ReadonlyJSONValue>;\n  scan(options?: ScanNoIndexOptions): ScanResult<string, ReadonlyJSONValue>;\n  scan(options?: ScanOptions): ScanResult<IndexKey | string, ReadonlyJSONValue>;\n\n  scan<V extends ReadonlyJSONValue>(\n    options: ScanIndexOptions,\n  ): ScanResult<IndexKey, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanNoIndexOptions,\n  ): ScanResult<string, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, DeepReadonly<V>>;\n}\n\nlet transactionIDCounter = 0;\n\nexport class ReadTransactionImpl implements ReadTransaction {\n  readonly clientID: ClientID;\n  readonly dbtx: Read;\n  protected readonly _lc: LogContext;\n\n  /**\n   * The location in which this transaction is being used. This is either `client` or `server`.\n   */\n  readonly location: TransactionLocation;\n  /** @deprecated Use {@link ReadTransaction.location} instead. */\n  readonly environment: TransactionLocation;\n\n  constructor(\n    clientID: ClientID,\n    dbRead: Read,\n    lc: LogContext,\n    rpcName = 'openReadTransaction',\n  ) {\n    this.clientID = clientID;\n    this.dbtx = dbRead;\n    this._lc = lc\n      .withContext(rpcName)\n      .withContext('txid', transactionIDCounter++);\n    this.environment = 'client';\n    this.location = 'client';\n  }\n\n  get(key: string): Promise<ReadonlyJSONValue | undefined>;\n  get<V extends JSONValue>(key: string): Promise<DeepReadonly<V> | undefined> {\n    return (\n      rejectIfClosed(this.dbtx) ||\n      (this.dbtx.get(key) as Promise<DeepReadonly<V> | undefined>)\n    );\n  }\n\n  // eslint-disable-next-line require-await\n  async has(key: string): Promise<boolean> {\n    throwIfClosed(this.dbtx);\n    return this.dbtx.has(key);\n  }\n\n  // eslint-disable-next-line require-await\n  async isEmpty(): Promise<boolean> {\n    throwIfClosed(this.dbtx);\n    return this.dbtx.isEmpty();\n  }\n\n  scan(options: ScanIndexOptions): ScanResult<IndexKey, ReadonlyJSONValue>;\n  scan(options?: ScanNoIndexOptions): ScanResult<string, ReadonlyJSONValue>;\n  scan(options?: ScanOptions): ScanResult<IndexKey | string, ReadonlyJSONValue>;\n\n  scan<V extends ReadonlyJSONValue>(\n    options: ScanIndexOptions,\n  ): ScanResult<IndexKey, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanNoIndexOptions,\n  ): ScanResult<string, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, DeepReadonly<V>>;\n\n  scan(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, ReadonlyJSONValue> {\n    return scan(options, this.dbtx, noop);\n  }\n}\n\nfunction noop(_: unknown): void {\n  // empty\n}\n\nfunction scan<Options extends ScanOptions, V extends JSONValue>(\n  options: Options | undefined,\n  dbRead: Read,\n  onLimitKey: (inclusiveLimitKey: string) => void,\n): ScanResult<KeyTypeForScanOptions<Options>, V> {\n  const iter = getScanIterator<Options, V>(dbRead, options);\n  return makeScanResultFromScanIteratorInternal(\n    iter,\n    options ?? ({} as Options),\n    dbRead,\n    onLimitKey,\n  );\n}\n\n// An implementation of ReadTransaction that keeps track of `keys` and `scans`\n// for use with Subscriptions.\nexport class SubscriptionTransactionWrapper implements ReadTransaction {\n  readonly #keys: Set<string> = new Set();\n  readonly #scans: ScanSubscriptionInfo[] = [];\n  readonly #tx: ReadTransactionImpl;\n\n  constructor(tx: ReadTransactionImpl) {\n    this.#tx = tx;\n  }\n\n  get environment(): TransactionLocation {\n    return this.#tx.location;\n  }\n\n  get location(): TransactionLocation {\n    return this.#tx.location;\n  }\n\n  get clientID(): string {\n    return this.#tx.clientID;\n  }\n\n  isEmpty(): Promise<boolean> {\n    // Any change to the subscription requires rerunning it.\n    this.#scans.push({options: {}});\n    return this.#tx.isEmpty();\n  }\n\n  get(key: string): Promise<ReadonlyJSONValue | undefined>;\n  get<T extends JSONValue>(key: string): Promise<DeepReadonly<T> | undefined> {\n    this.#keys.add(key);\n    return this.#tx.get(key) as Promise<DeepReadonly<T> | undefined>;\n  }\n\n  has(key: string): Promise<boolean> {\n    this.#keys.add(key);\n    return this.#tx.has(key);\n  }\n\n  scan(options: ScanIndexOptions): ScanResult<IndexKey, ReadonlyJSONValue>;\n  scan(options?: ScanNoIndexOptions): ScanResult<string, ReadonlyJSONValue>;\n  scan(options?: ScanOptions): ScanResult<IndexKey | string, ReadonlyJSONValue>;\n\n  scan<V extends ReadonlyJSONValue>(\n    options: ScanIndexOptions,\n  ): ScanResult<IndexKey, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanNoIndexOptions,\n  ): ScanResult<string, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, DeepReadonly<V>>;\n\n  scan(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, ReadonlyJSONValue> {\n    const scanInfo: ScanSubscriptionInfo = {\n      options: toDbScanOptions(options),\n      inclusiveLimitKey: undefined,\n    };\n    this.#scans.push(scanInfo);\n    return scan(options, this.#tx.dbtx, inclusiveLimitKey => {\n      scanInfo.inclusiveLimitKey = inclusiveLimitKey;\n    });\n  }\n\n  get keys(): ReadonlySet<string> {\n    return this.#keys;\n  }\n\n  get scans(): ScanSubscriptionInfo[] {\n    return this.#scans;\n  }\n}\n\n/**\n * WriteTransactions are used with *mutators* which are registered using\n * {@link ReplicacheOptions.mutators} and allows read and write operations on the\n * database.\n */\nexport interface WriteTransaction extends ReadTransaction {\n  /**\n   * The ID of the mutation that is being applied.\n   */\n  readonly mutationID: number;\n\n  /**\n   * The reason for the transaction. This can be `initial`, `rebase` or `authoriative`.\n   */\n  readonly reason: TransactionReason;\n\n  /**\n   * Sets a single `value` in the database. The value will be frozen (using\n   * `Object.freeze`) in debug mode.\n   */\n  set(key: string, value: ReadonlyJSONValue): Promise<void>;\n\n  /**\n   * @deprecated Use {@link WriteTransaction.set} instead.\n   */\n  put(key: string, value: ReadonlyJSONValue): Promise<void>;\n\n  /**\n   * Removes a `key` and its value from the database. Returns `true` if there was a\n   * `key` to remove.\n   */\n  del(key: string): Promise<boolean>;\n}\n\n// Internal symbol, not exported by Replicache\n// but accessible to Zero.\nexport const zeroData = Symbol();\n\nexport class WriteTransactionImpl\n  extends ReadTransactionImpl\n  implements WriteTransaction\n{\n  // use `declare` to specialize the type.\n  declare readonly dbtx: Write;\n  readonly reason: TransactionReason;\n  readonly mutationID: number;\n  readonly [zeroData]: ZeroTxData | undefined;\n\n  constructor(\n    clientID: ClientID,\n    mutationID: number,\n    reason: TransactionReason,\n    zData: ZeroTxData | undefined,\n    dbWrite: Write,\n    lc: LogContext,\n    rpcName = 'openWriteTransaction',\n  ) {\n    super(clientID, dbWrite, lc, rpcName);\n    this.mutationID = mutationID;\n    this.reason = reason;\n    this[zeroData] = zData;\n  }\n\n  put(key: string, value: ReadonlyJSONValue): Promise<void> {\n    return this.set(key, value);\n  }\n\n  async set(key: string, value: ReadonlyJSONValue): Promise<void> {\n    throwIfClosed(this.dbtx);\n    await this.dbtx.put(this._lc, key, deepFreeze(value));\n  }\n\n  del(key: string): Promise<boolean> {\n    return rejectIfClosed(this.dbtx) ?? this.dbtx.del(this._lc, key);\n  }\n}\n\nexport type CreateIndexDefinition = IndexDefinition & {name: string};\n\ntype Entry<Key, Value> = readonly [key: Key, value: Value];\n\ntype IndexKeyEntry<Value> = Entry<IndexKey, Value>;\n\ntype StringKeyEntry<Value> = Entry<string, Value>;\n\nexport type EntryForOptions<\n  Options extends ScanOptions,\n  V,\n> = Options extends ScanIndexOptions ? IndexKeyEntry<V> : StringKeyEntry<V>;\n\nfunction getScanIterator<Options extends ScanOptions, V>(\n  dbRead: Read,\n  options: Options | undefined,\n): AsyncIterable<EntryForOptions<Options, V>> {\n  if (options && isScanIndexOptions(options)) {\n    return getScanIteratorForIndexMap(dbRead, options) as AsyncIterable<\n      EntryForOptions<Options, V>\n    >;\n  }\n\n  return dbRead.map.scan(fromKeyForNonIndexScan(options)) as AsyncIterable<\n    EntryForOptions<Options, V>\n  >;\n}\n\nexport function fromKeyForNonIndexScan(\n  options: ScanNoIndexOptions | undefined,\n): string {\n  if (!options) {\n    return '';\n  }\n\n  const {prefix = '', start} = options;\n  if (start && greaterThan(start.key, prefix)) {\n    return start.key;\n  }\n  return prefix;\n}\n\nfunction makeScanResultFromScanIteratorInternal<\n  Options extends ScanOptions,\n  V extends JSONValue,\n>(\n  iter: AsyncIterable<EntryForOptions<Options, V>>,\n  options: Options,\n  dbRead: Read,\n  onLimitKey: (inclusiveLimitKey: string) => void,\n): ScanResult<KeyTypeForScanOptions<Options>, V> {\n  return new ScanResultImpl(iter, options, dbRead, onLimitKey);\n}\n\nasync function* getScanIteratorForIndexMap(\n  dbRead: Read,\n  options: ScanIndexOptions,\n): AsyncIterable<IndexKeyEntry<ReadonlyJSONValue>> {\n  const map = dbRead.getMapForIndex(options.indexName);\n  for await (const entry of map.scan(fromKeyForIndexScanInternal(options))) {\n    yield [decodeIndexKey(entry[0]), entry[1]];\n  }\n}\n","import {greaterThan} from 'compare-utf8';\nimport type {ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {asyncIterableToArray} from './async-iterable-to-array.ts';\nimport {type IndexKey, encodeIndexScanKey} from './db/index.ts';\nimport type {IterableUnion} from './iterable-union.ts';\nimport {\n  type KeyTypeForScanOptions,\n  type ScanIndexOptions,\n  type ScanOptionIndexedStartKey,\n  type ScanOptions,\n  isScanIndexOptions,\n  normalizeScanOptionIndexedStartKey,\n} from './scan-options.ts';\nimport {type Closed, throwIfClosed} from './transaction-closed-error.ts';\nimport {type EntryForOptions, fromKeyForNonIndexScan} from './transactions.ts';\n\ntype ScanKey = string | IndexKey;\n\ntype ToValue<Options extends ScanOptions, Value> = (\n  entry: EntryForOptions<Options, ReadonlyJSONValue>,\n) => Value;\n\n/**\n * This class is used for the results of {@link ReadTransaction.scan | scan}. It\n * implements `AsyncIterable<JSONValue>` which allows you to use it in a `for\n * await` loop. There are also methods to iterate over the {@link keys},\n * {@link entries} or {@link values}.\n */\nexport class ScanResultImpl<Options extends ScanOptions, V>\n  implements ScanResult<KeyTypeForScanOptions<Options>, V>\n{\n  readonly #iter: AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>;\n  readonly #options: Options;\n  readonly #dbDelegateOptions: Closed;\n  readonly #onLimitKey: (inclusiveLimitKey: string) => void;\n\n  constructor(\n    iter: AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>,\n    options: Options,\n    dbDelegateOptions: Closed,\n    onLimitKey: (inclusiveLimitKey: string) => void,\n  ) {\n    this.#iter = iter;\n    this.#options = options;\n    this.#dbDelegateOptions = dbDelegateOptions;\n    this.#onLimitKey = onLimitKey;\n  }\n\n  /** The default AsyncIterable. This is the same as {@link values}. */\n  [Symbol.asyncIterator](): AsyncIterableIteratorToArray<V> {\n    return this.values();\n  }\n\n  /** Async iterator over the values of the {@link ReadTransaction.scan | scan} call. */\n  values(): AsyncIterableIteratorToArray<V> {\n    return new AsyncIterableIteratorToArrayWrapperImpl(\n      this.#newIterator(e => e[1] as V),\n    );\n  }\n\n  /**\n   * Async iterator over the keys of the {@link ReadTransaction.scan | scan}\n   * call. If the {@link ReadTransaction.scan | scan} is over an index the key\n   * is a tuple of `[secondaryKey: string, primaryKey]`\n   */\n  keys(): AsyncIterableIteratorToArray<KeyTypeForScanOptions<Options>> {\n    type K = KeyTypeForScanOptions<Options>;\n    return new AsyncIterableIteratorToArrayWrapperImpl<K>(\n      this.#newIterator<K>(e => e[0] as K),\n    );\n  }\n\n  /**\n   * Async iterator over the entries of the {@link ReadTransaction.scan | scan}\n   * call. An entry is a tuple of key values. If the\n   * {@link ReadTransaction.scan | scan} is over an index the key is a tuple of\n   * `[secondaryKey: string, primaryKey]`\n   */\n  entries(): AsyncIterableIteratorToArray<\n    readonly [KeyTypeForScanOptions<Options>, V]\n  > {\n    type Key = KeyTypeForScanOptions<Options>;\n    type Entry = readonly [Key, V];\n    return new AsyncIterableIteratorToArrayWrapperImpl(\n      this.#newIterator<Entry>(e => [e[0] as Key, e[1] as V]),\n    );\n  }\n\n  /** Returns all the values as an array. Same as `values().toArray()` */\n  toArray(): Promise<V[]> {\n    return this.values().toArray();\n  }\n\n  #newIterator<T>(toValue: ToValue<Options, T>): AsyncIterableIterator<T> {\n    return scanIterator(\n      toValue,\n      this.#iter,\n      this.#options,\n      this.#dbDelegateOptions,\n      this.#onLimitKey,\n    );\n  }\n}\n\nexport interface ScanResult<K extends ScanKey, V> extends AsyncIterable<V> {\n  /** The default AsyncIterable. This is the same as {@link values}. */\n  [Symbol.asyncIterator](): AsyncIterableIteratorToArray<V>;\n\n  /** Async iterator over the values of the {@link ReadTransaction.scan | scan} call. */\n  values(): AsyncIterableIteratorToArray<V>;\n\n  /**\n   * Async iterator over the keys of the {@link ReadTransaction.scan | scan}\n   * call. If the {@link ReadTransaction.scan | scan} is over an index the key\n   * is a tuple of `[secondaryKey: string, primaryKey]`\n   */\n  keys(): AsyncIterableIteratorToArray<K>;\n\n  /**\n   * Async iterator over the entries of the {@link ReadTransaction.scan | scan}\n   * call. An entry is a tuple of key values. If the\n   * {@link ReadTransaction.scan | scan} is over an index the key is a tuple of\n   * `[secondaryKey: string, primaryKey]`\n   */\n  entries(): AsyncIterableIteratorToArray<readonly [K, V]>;\n\n  /** Returns all the values as an array. Same as `values().toArray()` */\n  toArray(): Promise<V[]>;\n}\n\n/**\n * An interface that adds a {@link toArray} method to `AsyncIterableIterator`.\n *\n * Usage:\n *\n * ```ts\n * const keys: string[] = await rep.scan().keys().toArray();\n * ```\n */\nexport interface AsyncIterableIteratorToArray<V>\n  extends AsyncIterableIterator<V> {\n  toArray(): Promise<V[]>;\n}\n\nclass AsyncIterableIteratorToArrayWrapperImpl<V>\n  implements AsyncIterableIterator<V>\n{\n  readonly #it: AsyncIterableIterator<V>;\n\n  constructor(it: AsyncIterableIterator<V>) {\n    this.#it = it;\n  }\n\n  next() {\n    return this.#it.next();\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<V> {\n    return this.#it[Symbol.asyncIterator]();\n  }\n\n  toArray(): Promise<V[]> {\n    return asyncIterableToArray(this.#it);\n  }\n}\n\nasync function* scanIterator<Options extends ScanOptions, Value>(\n  toValue: ToValue<Options, Value>,\n  iter: AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>,\n  options: Options,\n  closed: Closed,\n  onLimitKey: (inclusiveLimitKey: string) => void,\n): AsyncIterableIterator<Value> {\n  throwIfClosed(closed);\n\n  let {limit = Infinity} = options;\n  const {prefix = ''} = options;\n  let exclusive = options.start?.exclusive;\n\n  const isIndexScan = isScanIndexOptions(options);\n\n  // iter has already been moved to the first entry\n  for await (const entry of iter) {\n    const key = entry[0];\n    const keyToMatch: string = isIndexScan ? key[0] : (key as string);\n    if (!keyToMatch.startsWith(prefix)) {\n      return;\n    }\n\n    if (exclusive) {\n      exclusive = true;\n      if (isIndexScan) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (shouldSkipIndexScan(key as IndexKey, options.start!.key)) {\n          continue;\n        }\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (shouldSkipNonIndexScan(key as string, options.start!.key)) {\n          continue;\n        }\n      }\n    }\n\n    yield toValue(entry);\n\n    if (--limit === 0) {\n      // We do not do the limit optimization for index scans in subscriptions.\n      if (!isIndexScan) {\n        onLimitKey(key as string);\n      }\n      return;\n    }\n  }\n}\n\nfunction shouldSkipIndexScan(\n  key: IndexKey,\n  startKey: ScanOptionIndexedStartKey,\n): boolean {\n  const [secondaryStartKey, primaryStartKey] =\n    normalizeScanOptionIndexedStartKey(startKey);\n  const [secondaryKey, primaryKey] = normalizeScanOptionIndexedStartKey(key);\n  if (secondaryKey !== secondaryStartKey) {\n    return false;\n  }\n  if (primaryStartKey === undefined) {\n    return true;\n  }\n  return primaryKey === primaryStartKey;\n}\n\nfunction shouldSkipNonIndexScan(key: string, startKey: string): boolean {\n  return key === startKey;\n}\n\nexport type Entry<V> = readonly [key: string, value: V];\n\n/**\n * This is called when doing a {@link ReadTransaction.scan | scan} without an\n * `indexName`.\n *\n * @param fromKey The `fromKey` is computed by `scan` and is the key of the\n * first entry to return in the iterator. It is based on `prefix` and\n * `start.key` of the {@link ScanNoIndexOptions}.\n */\nexport type GetScanIterator = (\n  fromKey: string,\n) => IterableUnion<Entry<ReadonlyJSONValue>>;\n\n/**\n * When using {@link makeScanResult} this is the type used for the function called when doing a {@link ReadTransaction.scan | scan} with an\n * `indexName`.\n *\n * @param indexName The name of the index we are scanning over.\n * @param fromSecondaryKey The `fromSecondaryKey` is computed by `scan` and is\n * the secondary key of the first entry to return in the iterator. It is based\n * on `prefix` and `start.key` of the {@link ScanIndexOptions}.\n * @param fromPrimaryKey The `fromPrimaryKey` is computed by `scan` and is the\n * primary key of the first entry to return in the iterator. It is based on\n * `prefix` and `start.key` of the {@link ScanIndexOptions}.\n */\nexport type GetIndexScanIterator = (\n  indexName: string,\n  fromSecondaryKey: string,\n  fromPrimaryKey: string | undefined,\n) => IterableUnion<readonly [key: IndexKey, value: ReadonlyJSONValue]>;\n\n/**\n * A helper function that makes it easier to implement {@link ReadTransaction.scan}\n * with a custom backend.\n *\n * If you are implementing a custom backend and have an in memory pending async\n * iterable we provide two helper functions to make it easier to merge these\n * together. {@link mergeAsyncIterables} and {@link filterAsyncIterable}.\n *\n * For example:\n *\n * ```ts\n * const scanResult = makeScanResult(\n *   options,\n *   options.indexName\n *     ? () => {\n *         throw Error('not implemented');\n *       }\n *     : fromKey => {\n *         const persisted: AsyncIterable<Entry<ReadonlyJSONValue>> = ...;\n *         const pending: AsyncIterable<Entry<ReadonlyJSONValue | undefined>> = ...;\n *         const iter = await mergeAsyncIterables(persisted, pending);\n *         const filteredIter = await filterAsyncIterable(\n *           iter,\n *           entry => entry[1] !== undefined,\n *         );\n *         return filteredIter;\n *       },\n * );\n * ```\n */\nexport function makeScanResult<Options extends ScanOptions>(\n  options: Options,\n  getScanIterator: Options extends ScanIndexOptions\n    ? GetIndexScanIterator\n    : GetScanIterator,\n): ScanResult<KeyTypeForScanOptions<Options>, ReadonlyJSONValue> {\n  type AsyncIter = AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>;\n\n  if (isScanIndexOptions(options)) {\n    const [fromSecondaryKey, fromPrimaryKey] = fromKeyForIndexScan(options);\n    return new ScanResultImpl(\n      (getScanIterator as GetIndexScanIterator)(\n        options.indexName,\n        fromSecondaryKey,\n        fromPrimaryKey,\n      ) as AsyncIter,\n      options,\n      {closed: false},\n      _ => {\n        // noop\n      },\n    );\n  }\n  const fromKey = fromKeyForNonIndexScan(options);\n  return new ScanResultImpl(\n    (getScanIterator as GetScanIterator)(fromKey) as AsyncIter,\n    options,\n    {closed: false},\n    _ => {\n      // noop\n    },\n  );\n}\n\nexport function fromKeyForIndexScan(\n  options: ScanIndexOptions,\n): readonly [secondary: string, primary?: string | undefined] {\n  const {prefix, start} = options;\n  const prefixNormalized: [secondary: string, primary?: string | undefined] = [\n    prefix ?? '',\n    undefined,\n  ];\n\n  if (!start) {\n    return prefixNormalized;\n  }\n\n  const startKeyNormalized = normalizeScanOptionIndexedStartKey(start.key);\n  if (greaterThan(startKeyNormalized[0], prefixNormalized[0])) {\n    return startKeyNormalized;\n  }\n  if (\n    startKeyNormalized[0] === prefixNormalized[0] &&\n    startKeyNormalized[1] !== undefined\n  ) {\n    return startKeyNormalized;\n  }\n\n  return prefixNormalized;\n}\n\nexport function fromKeyForIndexScanInternal(options: ScanIndexOptions): string {\n  const {prefix, start} = options;\n  let prefix2 = '';\n  if (prefix !== undefined) {\n    prefix2 = encodeIndexScanKey(prefix, undefined);\n  }\n  if (!start) {\n    return prefix2;\n  }\n\n  const {key} = start;\n  const [secondary, primary] = normalizeScanOptionIndexedStartKey(key);\n  const startKey = encodeIndexScanKey(secondary, primary);\n\n  if (greaterThan(startKey, prefix2)) {\n    return startKey;\n  }\n\n  return prefix2;\n}\n","import type {IndexKey} from './db/index.ts';\nimport type {ScanOptions as DbScanOptions} from './db/scan.ts';\n\n/**\n * Options for {@link ReadTransaction.scan | scan}\n */\nexport type ScanOptions = ScanIndexOptions | ScanNoIndexOptions;\n\n/**\n * Options for {@link ReadTransaction.scan | scan} when scanning over the entire key\n * space.\n */\nexport type ScanNoIndexOptions = {\n  /** Only include keys starting with `prefix`. */\n  prefix?: string | undefined;\n\n  /** Only include up to `limit` results. */\n  limit?: number | undefined;\n\n  /** When provided the scan starts at this key. */\n  start?:\n    | {\n        key: string;\n\n        /** Whether the `key` is exclusive or inclusive. */\n        exclusive?: boolean | undefined;\n      }\n    | undefined;\n};\n\n/**\n * Options for {@link ReadTransaction.scan | scan} when scanning over an index. When\n * scanning over and index you need to provide the `indexName` and the `start`\n * `key` is now a tuple consisting of secondary and primary key\n */\nexport type ScanIndexOptions = {\n  /** Only include results starting with the *secondary* keys starting with `prefix`. */\n  prefix?: string | undefined;\n\n  /** Only include up to `limit` results. */\n  limit?: number | undefined;\n\n  /** Do a {@link ReadTransaction.scan | scan} over a named index. The `indexName` is\n   * the name of an index defined when creating the {@link Replicache} instance using\n   * {@link ReplicacheOptions.indexes}. */\n  indexName: string;\n\n  /** When provided the scan starts at this key. */\n  start?:\n    | {\n        key: ScanOptionIndexedStartKey;\n\n        /** Whether the `key` is exclusive or inclusive. */\n        exclusive?: boolean | undefined;\n      }\n    | undefined;\n};\n\n/**\n * Type narrowing of {@link ScanOptions}.\n */\nexport function isScanIndexOptions(\n  options: ScanOptions,\n): options is ScanIndexOptions {\n  return (options as ScanIndexOptions).indexName !== undefined;\n}\n\n/**\n * If the options contains an `indexName` then the key type is a tuple of\n * secondary and primary.\n */\nexport type KeyTypeForScanOptions<O extends ScanOptions> =\n  O extends ScanIndexOptions ? IndexKey : string;\n\n/**\n * The key to start scanning at.\n *\n * If you are scanning the primary index (i.e., you did not specify\n * `indexName`), then pass a single string for this field, which is the key in\n * the primary index to scan at.\n *\n * If you are scanning a secondary index (i.e., you specified `indexName`), then\n * use the tuple form. In that case, `secondary` is the secondary key to start\n * scanning at, and `primary` (if any) is the primary key to start scanning at.\n */\nexport type ScanOptionIndexedStartKey =\n  | readonly [secondary: string, primary?: string | undefined]\n  | string;\n\nexport function normalizeScanOptionIndexedStartKey(\n  startKey: string | readonly [secondary: string, primary?: string | undefined],\n): readonly [secondary: string, primary?: string | undefined] {\n  if (typeof startKey === 'string') {\n    return [startKey];\n  }\n  return startKey;\n}\n\nexport function toDbScanOptions(options?: ScanOptions): DbScanOptions {\n  if (!options) {\n    return {};\n  }\n  let key: string | ScanOptionIndexedStartKey | undefined;\n  let exclusive: boolean | undefined;\n  let primary: string | undefined;\n  let secondary: string | undefined;\n  type MaybeIndexName = {indexName?: string};\n  if (options.start) {\n    ({key, exclusive} = options.start);\n    if ((options as MaybeIndexName).indexName) {\n      if (typeof key === 'string') {\n        secondary = key;\n      } else {\n        secondary = key[0];\n        primary = key[1];\n      }\n    } else {\n      primary = key as string;\n    }\n  }\n\n  return {\n    prefix: options.prefix,\n    startSecondaryKey: secondary,\n    startKey: primary,\n    startExclusive: exclusive,\n    limit: options.limit,\n    indexName: (options as MaybeIndexName).indexName,\n  };\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport type {Write as DagWrite} from '../dag/store.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {WriteTransactionImpl} from '../transactions.ts';\nimport type {MutatorDefs} from '../types.ts';\nimport {\n  Commit,\n  type LocalMeta,\n  type LocalMetaDD31,\n  type Meta,\n  assertLocalMetaDD31,\n  commitFromHash,\n  isLocalMetaDD31,\n} from './commit.ts';\nimport {Write, newWriteLocal} from './write.ts';\nimport type {ZeroTxData} from '../replicache-options.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nasync function rebaseMutation(\n  mutation: Commit<LocalMetaDD31>,\n  dagWrite: DagWrite,\n  basisHash: Hash,\n  mutators: MutatorDefs,\n  lc: LogContext,\n  mutationClientID: ClientID,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Write> {\n  const localMeta = mutation.meta;\n  const name = localMeta.mutatorName;\n  if (isLocalMetaDD31(localMeta)) {\n    assert(\n      localMeta.clientID === mutationClientID,\n      'mutationClientID must match clientID of LocalMeta',\n    );\n  }\n  const maybeMutatorImpl = mutators[name];\n  if (!maybeMutatorImpl) {\n    // Developers must not remove mutator names from code deployed with the\n    // same schemaVersion because Replicache needs to be able to replay\n    // mutations during pull.\n    //\n    // If we detect that this has happened, stub in a no-op mutator so that at\n    // least sync can move forward. Note that the server-side mutation will\n    // still get sent. This doesn't remove the queued local mutation, it just\n    // removes its visible effects.\n    lc.error?.(`Cannot rebase unknown mutator ${name}`);\n  }\n  const mutatorImpl =\n    maybeMutatorImpl ||\n    (async () => {\n      // no op\n    });\n\n  const args = localMeta.mutatorArgsJSON;\n\n  const basisCommit = await commitFromHash(basisHash, dagWrite);\n  const nextMutationID = await basisCommit.getNextMutationID(\n    mutationClientID,\n    dagWrite,\n  );\n  if (nextMutationID !== localMeta.mutationID) {\n    throw new Error(\n      `Inconsistent mutation ID: original: ${localMeta.mutationID}, next: ${nextMutationID} - mutationClientID: ${mutationClientID} mutatorName: ${name}`,\n    );\n  }\n\n  if (formatVersion >= FormatVersion.DD31) {\n    assertLocalMetaDD31(localMeta);\n  }\n\n  const dbWrite = await newWriteLocal(\n    basisHash,\n    name,\n    args,\n    mutation.chunk.hash,\n    dagWrite,\n    localMeta.timestamp,\n    mutationClientID,\n    formatVersion,\n  );\n\n  const tx = new WriteTransactionImpl(\n    mutationClientID,\n    await dbWrite.getMutationID(),\n    'rebase',\n    zeroData,\n    dbWrite,\n    lc,\n  );\n  await mutatorImpl(tx, args);\n  return dbWrite;\n}\n\nexport async function rebaseMutationAndPutCommit(\n  mutation: Commit<LocalMeta>,\n  dagWrite: DagWrite,\n  basis: Hash,\n  mutators: MutatorDefs,\n  lc: LogContext,\n  // TODO(greg): mutationClientID can be retrieved from mutation if LocalMeta\n  // is a LocalMetaDD31.  As part of DD31 cleanup we can remove this arg.\n  mutationClientID: ClientID,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Commit<Meta>> {\n  const tx = await rebaseMutation(\n    mutation,\n    dagWrite,\n    basis,\n    mutators,\n    lc,\n    mutationClientID,\n    formatVersion,\n    zeroData,\n  );\n  return tx.putCommit();\n}\n\nexport async function rebaseMutationAndCommit(\n  mutation: Commit<LocalMeta>,\n  dagWrite: DagWrite,\n  basis: Hash,\n  headName: string,\n  mutators: MutatorDefs,\n  lc: LogContext,\n  // TODO(greg): mutationClientID can be retrieved from mutation if LocalMeta\n  // is a LocalMetaDD31.  As part of DD31 cleanup we can remove this arg.\n  mutationClientID: ClientID,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Hash> {\n  const dbWrite = await rebaseMutation(\n    mutation,\n    dagWrite,\n    basis,\n    mutators,\n    lc,\n    mutationClientID,\n    formatVersion,\n    zeroData,\n  );\n  return dbWrite.commit(headName);\n}\n","import {callDefaultFetch} from './call-default-fetch.ts';\nimport {\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n} from './error-responses.ts';\nimport type {Pusher, PusherResult} from './pusher.ts';\nimport type {PushRequest} from './sync/push.ts';\n\n/**\n * This creates a default pusher which uses HTTP POST to send the push request.\n */\nexport function getDefaultPusher(rep: {pushURL: string; auth: string}): Pusher {\n  async function pusher(\n    requestBody: PushRequest,\n    requestID: string,\n  ): Promise<PusherResult> {\n    const [response, httpRequestInfo] = await callDefaultFetch(\n      rep.pushURL,\n      rep.auth,\n      requestID,\n      requestBody,\n    );\n    if (!response) {\n      return {httpRequestInfo};\n    }\n\n    const rv: PusherResult = {\n      httpRequestInfo,\n    };\n\n    let result;\n    try {\n      result = await response.json();\n    } catch {\n      // Ignore JSON parse errors. It is valid to return a non-JSON response.\n      return rv;\n    }\n\n    if (\n      isClientStateNotFoundResponse(result) ||\n      isVersionNotSupportedResponse(result)\n    ) {\n      rv.response = result;\n    }\n\n    return rv;\n  }\n\n  defaultPushers.add(pusher);\n  return pusher;\n}\n\nconst defaultPushers = new WeakSet();\n\nexport function isDefaultPusher(pusher: Pusher): boolean {\n  return defaultPushers.has(pusher);\n}\n","export const httpStatusUnauthorized = 401;\n","/**\n * Wrapper error class that should be reported as error (logger.error)\n */\nexport class ReportError extends Error {}\n","export function toError(e: unknown): Error {\n  if (e instanceof Error) {\n    return e;\n  }\n  return new Error(String(e));\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const Applied = 0;\nexport const NoOp = 1;\nexport const CookieMismatch = 2;\n\nexport type Applied = typeof Applied;\nexport type NoOp = typeof NoOp;\nexport type CookieMismatch = typeof CookieMismatch;\n","import type {LogContext} from '@rocicorp/logger';\nimport {assertObject} from '../../../shared/src/asserts.ts';\nimport type {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from '../../../shared/src/json.ts';\nimport type {Write} from '../db/write.ts';\nimport {\n  type FrozenJSONObject,\n  type FrozenJSONValue,\n  deepFreeze,\n} from '../frozen-json.ts';\nimport type {PatchOperationInternal} from '../patch-operation.ts';\nimport type {DiffOperation} from '../btree/node.ts';\n\nexport type Diff =\n  | DiffOperation<string>\n  | {\n      op: 'clear';\n    };\n\nexport async function apply(\n  lc: LogContext,\n  dbWrite: Write,\n  patch: readonly PatchOperationInternal[],\n): Promise<void> {\n  for (const p of patch) {\n    switch (p.op) {\n      case 'put': {\n        const frozen = deepFreeze(p.value);\n        await dbWrite.put(lc, p.key, frozen);\n        break;\n      }\n      case 'update': {\n        const existing = await dbWrite.get(p.key);\n        const entries: [\n          string,\n          FrozenJSONValue | ReadonlyJSONValue | undefined,\n        ][] = [];\n        const addToEntries = (toAdd: FrozenJSONObject | ReadonlyJSONObject) => {\n          for (const [key, value] of Object.entries(toAdd)) {\n            if (\n              !p.constrain ||\n              p.constrain.length === 0 ||\n              p.constrain.indexOf(key) > -1\n            ) {\n              entries.push([key, value]);\n            }\n          }\n        };\n        if (existing !== undefined) {\n          assertObject(existing);\n          addToEntries(existing);\n        }\n        if (p.merge) {\n          addToEntries(p.merge);\n        }\n        const frozen = deepFreeze(Object.fromEntries(entries));\n        await dbWrite.put(lc, p.key, frozen);\n\n        break;\n      }\n      case 'del': {\n        const existing = await dbWrite.get(p.key);\n        if (existing === undefined) {\n          continue;\n        }\n        await dbWrite.del(lc, p.key);\n        break;\n      }\n      case 'clear':\n        await dbWrite.clear();\n        break;\n    }\n  }\n}\n","/**\n * This error is thrown when the puller fails for any reason.\n */\n\nexport class PullError extends Error {\n  name = 'PullError';\n  // causedBy is used instead of cause, because while cause has been proposed as a\n  // JavaScript language standard for this purpose (see\n  // https://github.com/tc39/proposal-error-cause) current browser behavior is\n  // inconsistent.\n  causedBy?: Error | undefined;\n  constructor(causedBy?: Error) {\n    super('Failed to pull');\n    this.causedBy = causedBy;\n  }\n}\n","export const SYNC_HEAD_NAME = 'sync';\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport {deepEqual} from '../../../shared/src/json.ts';\nimport {diff} from '../btree/diff.ts';\nimport {BTreeRead} from '../btree/read.ts';\nimport {compareCookies, type Cookie} from '../cookies.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  assertSnapshotMetaDD31,\n  baseSnapshotFromHash,\n  Commit,\n  commitFromHash,\n  commitIsLocalDD31,\n  DEFAULT_HEAD_NAME,\n  type LocalMeta,\n  localMutations as localMutations_1,\n  snapshotMetaParts,\n} from '../db/commit.ts';\nimport {newWriteSnapshotDD31} from '../db/write.ts';\nimport {isErrorResponse} from '../error-responses.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport {deepFreeze, type FrozenJSONValue} from '../frozen-json.ts';\nimport {assertPullerResultV1} from '../get-default-puller.ts';\nimport {emptyHash, type Hash} from '../hash.ts';\nimport type {HTTPRequestInfo} from '../http-request-info.ts';\nimport type {\n  Puller,\n  PullerResult,\n  PullerResultV1,\n  PullResponseOKV1Internal,\n  PullResponseV1,\n} from '../puller.ts';\nimport {ReportError} from '../report-error.ts';\nimport {toError} from '../to-error.ts';\nimport {withRead, withWriteNoImplicitCommit} from '../with-transactions.ts';\nimport {\n  addDiffsForIndexes,\n  type DiffComputationConfig,\n  DiffsMap,\n} from './diff.ts';\nimport * as HandlePullResponseResultType from './handle-pull-response-result-type-enum.ts';\nimport type {ClientGroupID, ClientID} from './ids.ts';\nimport * as patch from './patch.ts';\nimport {PullError} from './pull-error.ts';\nimport {SYNC_HEAD_NAME} from './sync-head-name.ts';\n\ntype FormatVersion = (typeof FormatVersion)[keyof typeof FormatVersion];\n\nexport const PULL_VERSION_SDD = 0;\nexport const PULL_VERSION_DD31 = 1;\n\n/**\n * The JSON value used as the body when doing a POST to the [pull\n * endpoint](/reference/server-pull).\n */\nexport type PullRequest = PullRequestV1;\n\n/**\n * The JSON value used as the body when doing a POST to the [pull\n * endpoint](/reference/server-pull).\n */\nexport type PullRequestV1 = {\n  pullVersion: 1;\n  // schemaVersion can optionally be used by the customer's app\n  // to indicate to the data layer what format of Client View the\n  // app understands.\n  schemaVersion: string;\n  profileID: string;\n  cookie: Cookie;\n\n  clientGroupID: ClientGroupID;\n};\n\nexport function isPullRequestV1(pr: PullRequest): pr is PullRequestV1 {\n  return pr.pullVersion === PULL_VERSION_DD31;\n}\n\nexport type BeginPullResponseV1 = {\n  httpRequestInfo: HTTPRequestInfo;\n  pullResponse?: PullResponseV1;\n  syncHead: Hash;\n};\n\nexport async function beginPullV1(\n  profileID: string,\n  clientID: ClientID,\n  clientGroupID: ClientGroupID,\n  schemaVersion: string,\n  puller: Puller,\n  requestID: string,\n  store: Store,\n  formatVersion: FormatVersion,\n  lc: LogContext,\n  createSyncBranch = true,\n): Promise<BeginPullResponseV1> {\n  const baseCookie = await withRead(store, async dagRead => {\n    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (!mainHeadHash) {\n      throw new Error('Internal no main head found');\n    }\n    const baseSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);\n    const baseSnapshotMeta = baseSnapshot.meta;\n    assertSnapshotMetaDD31(baseSnapshotMeta);\n    return baseSnapshotMeta.cookieJSON;\n  });\n\n  const pullReq: PullRequestV1 = {\n    profileID,\n    clientGroupID,\n    cookie: baseCookie,\n    pullVersion: PULL_VERSION_DD31,\n    schemaVersion,\n  };\n\n  const {response, httpRequestInfo} = (await callPuller(\n    lc,\n    puller,\n    pullReq,\n    requestID,\n  )) as PullerResultV1;\n\n  // If Puller did not get a pull response we still want to return the HTTP\n  // request info.\n  if (!response) {\n    return {\n      httpRequestInfo,\n      syncHead: emptyHash,\n    };\n  }\n\n  if (!createSyncBranch || isErrorResponse(response)) {\n    return {\n      httpRequestInfo,\n      pullResponse: response,\n      syncHead: emptyHash,\n    };\n  }\n\n  const result = await handlePullResponseV1(\n    lc,\n    store,\n    baseCookie,\n    response,\n    clientID,\n    formatVersion,\n  );\n\n  return {\n    httpRequestInfo,\n    pullResponse: response,\n    syncHead:\n      result.type === HandlePullResponseResultType.Applied\n        ? result.syncHead\n        : emptyHash,\n  };\n}\n\nasync function callPuller(\n  lc: LogContext,\n  puller: Puller,\n  pullReq: PullRequest,\n  requestID: string,\n): Promise<PullerResult> {\n  lc.debug?.('Starting pull...');\n  const pullStart = Date.now();\n  let pullerResult: PullerResult;\n  try {\n    pullerResult = await puller(pullReq, requestID);\n    lc.debug?.(\n      `...Pull ${pullerResult.response ? 'complete' : 'failed'} in `,\n      Date.now() - pullStart,\n      'ms',\n    );\n  } catch (e) {\n    throw new PullError(toError(e));\n  }\n  try {\n    assertPullerResultV1(pullerResult);\n    return pullerResult;\n  } catch (e) {\n    throw new ReportError('Invalid puller result', toError(e));\n  }\n}\n\ntype HandlePullResponseResult =\n  | {\n      type: HandlePullResponseResultType.Applied;\n      syncHead: Hash;\n    }\n  | {\n      type:\n        | HandlePullResponseResultType.NoOp\n        | HandlePullResponseResultType.CookieMismatch;\n    };\n\nfunction badOrderMessage(\n  name: string,\n  receivedValue: string,\n  lastSnapshotValue: string,\n) {\n  return `Received ${name} ${receivedValue} is < than last snapshot ${name} ${lastSnapshotValue}; ignoring client view`;\n}\n\nexport function handlePullResponseV1(\n  lc: LogContext,\n  store: Store,\n  expectedBaseCookie: FrozenJSONValue,\n  response: PullResponseOKV1Internal,\n  clientID: ClientID,\n  formatVersion: FormatVersion,\n): Promise<HandlePullResponseResult> {\n  // It is possible that another sync completed while we were pulling. Ensure\n  // that is not the case by re-checking the base snapshot.\n  return withWriteNoImplicitCommit(store, async dagWrite => {\n    const dagRead = dagWrite;\n    const mainHead = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (mainHead === undefined) {\n      throw new Error('Main head disappeared');\n    }\n    const baseSnapshot = await baseSnapshotFromHash(mainHead, dagRead);\n    const baseSnapshotMeta = baseSnapshot.meta;\n    assertSnapshotMetaDD31(baseSnapshotMeta);\n    const baseCookie = baseSnapshotMeta.cookieJSON;\n\n    // TODO(MP) Here we are using whether the cookie has changed as a proxy for whether\n    // the base snapshot changed, which is the check we used to do. I don't think this\n    // is quite right. We need to firm up under what conditions we will/not accept an\n    // update from the server: https://github.com/rocicorp/replicache/issues/713.\n    // In DD31 this is expected to happen if a refresh occurs during a pull.\n    if (!deepEqual(expectedBaseCookie, baseCookie)) {\n      lc.debug?.(\n        'handlePullResponse: cookie mismatch, response is not applicable',\n      );\n      return {\n        type: HandlePullResponseResultType.CookieMismatch,\n      };\n    }\n\n    // Check that the lastMutationIDs are not going backwards.\n    for (const [clientID, lmidChange] of Object.entries(\n      response.lastMutationIDChanges,\n    )) {\n      const lastMutationID = baseSnapshotMeta.lastMutationIDs[clientID];\n      if (lastMutationID !== undefined && lmidChange < lastMutationID) {\n        throw new Error(\n          badOrderMessage(\n            `${clientID} lastMutationID`,\n            String(lmidChange),\n            String(lastMutationID),\n          ),\n        );\n      }\n    }\n\n    const frozenResponseCookie = deepFreeze(response.cookie);\n    if (compareCookies(frozenResponseCookie, baseCookie) < 0) {\n      throw new Error(\n        badOrderMessage(\n          'cookie',\n          JSON.stringify(frozenResponseCookie),\n          JSON.stringify(baseCookie),\n        ),\n      );\n    }\n\n    if (deepEqual(frozenResponseCookie, baseCookie)) {\n      if (response.patch.length > 0) {\n        lc.error?.(\n          `handlePullResponse: cookie ${JSON.stringify(\n            baseCookie,\n          )} did not change, but patch is not empty`,\n        );\n      }\n      if (Object.keys(response.lastMutationIDChanges).length > 0) {\n        lc.error?.(\n          `handlePullResponse: cookie ${JSON.stringify(\n            baseCookie,\n          )} did not change, but lastMutationIDChanges is not empty`,\n        );\n      }\n      // If the cookie doesn't change, it's a nop.\n      return {\n        type: HandlePullResponseResultType.NoOp,\n      };\n    }\n\n    const dbWrite = await newWriteSnapshotDD31(\n      baseSnapshot.chunk.hash,\n      {...baseSnapshotMeta.lastMutationIDs, ...response.lastMutationIDChanges},\n      frozenResponseCookie,\n      dagWrite,\n      clientID,\n      formatVersion,\n    );\n\n    await patch.apply(lc, dbWrite, response.patch);\n\n    return {\n      type: HandlePullResponseResultType.Applied,\n      syncHead: await dbWrite.commit(SYNC_HEAD_NAME),\n    };\n  });\n}\n\nexport function maybeEndPull<M extends LocalMeta>(\n  store: Store,\n  lc: LogContext,\n  expectedSyncHead: Hash,\n  clientID: ClientID,\n  diffConfig: DiffComputationConfig,\n  formatVersion: FormatVersion,\n): Promise<{\n  syncHead: Hash;\n  mainHead: Hash;\n  oldMainHead: Hash;\n  replayMutations: Commit<M>[];\n  diffs: DiffsMap;\n}> {\n  return withWriteNoImplicitCommit(store, async dagWrite => {\n    const dagRead = dagWrite;\n    // Ensure sync head is what the caller thinks it is.\n    const syncHeadHash = await dagRead.getHead(SYNC_HEAD_NAME);\n    if (syncHeadHash === undefined) {\n      throw new Error('Missing sync head');\n    }\n    if (syncHeadHash !== expectedSyncHead) {\n      lc.error?.(\n        'maybeEndPull, Wrong sync head. Expecting:',\n        expectedSyncHead,\n        'got:',\n        syncHeadHash,\n      );\n      throw new Error('Wrong sync head');\n    }\n\n    // Ensure another sync has not landed a new snapshot on the main chain.\n    // TODO: In DD31, it is expected that a newer snapshot might have appeared\n    // on the main chain. In that case, we just abort this pull.\n    const syncSnapshot = await baseSnapshotFromHash(syncHeadHash, dagRead);\n    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (mainHeadHash === undefined) {\n      throw new Error('Missing main head');\n    }\n    const mainSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);\n\n    const {meta} = syncSnapshot;\n    const syncSnapshotBasis = meta.basisHash;\n    if (syncSnapshot === null) {\n      throw new Error('Sync snapshot with no basis');\n    }\n    if (syncSnapshotBasis !== mainSnapshot.chunk.hash) {\n      throw new Error('Overlapping syncs');\n    }\n\n    // Collect pending commits from the main chain and determine which\n    // of them if any need to be replayed.\n    const syncHead = await commitFromHash(syncHeadHash, dagRead);\n    const pending: Commit<M>[] = [];\n    const localMutations = await localMutations_1(mainHeadHash, dagRead);\n    for (const commit of localMutations) {\n      let cid = clientID;\n      assert(commitIsLocalDD31(commit));\n      cid = commit.meta.clientID;\n\n      if (\n        (await commit.getMutationID(cid, dagRead)) >\n        (await syncHead.getMutationID(cid, dagRead))\n      ) {\n        // We know that the dag can only contain either LocalMetaSDD or LocalMetaDD31\n        pending.push(commit as Commit<M>);\n      }\n    }\n    // pending() gave us the pending mutations in sync-head-first order whereas\n    // caller wants them in the order to replay (lower mutation ids first).\n    pending.reverse();\n\n    // We return the keys that changed due to this pull. This is used by\n    // subscriptions in the JS API when there are no more pending mutations.\n    const diffsMap = new DiffsMap();\n\n    // Return replay commits if any.\n    if (pending.length > 0) {\n      return {\n        syncHead: syncHeadHash,\n        oldMainHead: mainHeadHash,\n        mainHead: mainHeadHash,\n        replayMutations: pending,\n        // The changed keys are not reported when further replays are\n        // needed. The diffs will be reported at the end when there\n        // are no more mutations to be replay and then it will be reported\n        // relative to DEFAULT_HEAD_NAME.\n        diffs: diffsMap,\n      };\n    }\n\n    // TODO check invariants\n\n    // Compute diffs (changed keys) for value map and index maps.\n    const mainHead = await commitFromHash(mainHeadHash, dagRead);\n    if (diffConfig.shouldComputeDiffs()) {\n      const mainHeadMap = new BTreeRead(\n        dagRead,\n        formatVersion,\n        mainHead.valueHash,\n      );\n      const syncHeadMap = new BTreeRead(\n        dagRead,\n        formatVersion,\n        syncHead.valueHash,\n      );\n      const valueDiff = await diff(mainHeadMap, syncHeadMap);\n      diffsMap.set('', valueDiff);\n      await addDiffsForIndexes(\n        mainHead,\n        syncHead,\n        dagRead,\n        diffsMap,\n        diffConfig,\n        formatVersion,\n      );\n    }\n\n    // No mutations to replay so set the main head to the sync head and sync complete!\n    await Promise.all([\n      dagWrite.setHead(DEFAULT_HEAD_NAME, syncHeadHash),\n      dagWrite.removeHead(SYNC_HEAD_NAME),\n    ]);\n    await dagWrite.commit();\n    // main head was set to sync head\n    const newMainHeadHash = syncHeadHash;\n\n    if (lc.debug) {\n      const [oldLastMutationID, oldCookie] = snapshotMetaParts(\n        mainSnapshot,\n        clientID,\n      );\n      const [newLastMutationID, newCookie] = snapshotMetaParts(\n        syncSnapshot,\n        clientID,\n      );\n      lc.debug(\n        `Successfully pulled new snapshot with lastMutationID:`,\n        newLastMutationID,\n        `(prev:`,\n        oldLastMutationID,\n        `), cookie: `,\n        newCookie,\n        `(prev:`,\n        oldCookie,\n        `), sync head hash:`,\n        syncHeadHash,\n        ', main head hash:',\n        mainHeadHash,\n        `, valueHash:`,\n        syncHead.valueHash,\n        `(prev:`,\n        mainSnapshot.valueHash,\n      );\n    }\n\n    return {\n      syncHead: syncHeadHash,\n      oldMainHead: mainHeadHash,\n      mainHead: newMainHeadHash,\n      replayMutations: [],\n      diffs: diffsMap,\n    };\n  });\n}\n","import {assertObject} from '../../shared/src/asserts.ts';\nimport {\n  assertVersionNotSupportedResponse,\n  type ClientStateNotFoundResponse,\n  isClientStateNotFoundResponse,\n  type VersionNotSupportedResponse,\n} from './error-responses.ts';\nimport {\n  assertHTTPRequestInfo,\n  type HTTPRequestInfo,\n} from './http-request-info.ts';\nimport type {PushRequest} from './sync/push.ts';\n\nexport type PusherResult = {\n  response?: PushResponse | undefined;\n  httpRequestInfo: HTTPRequestInfo;\n};\n\n/**\n * The response from a push can contain information about error conditions.\n */\nexport type PushResponse =\n  | ClientStateNotFoundResponse\n  | VersionNotSupportedResponse;\n\nexport function assertPusherResult(v: unknown): asserts v is PusherResult {\n  assertObject(v);\n  assertHTTPRequestInfo(v.httpRequestInfo);\n  if (v.response !== undefined) {\n    assertPushResponse(v.response);\n  }\n}\n\nfunction assertPushResponse(v: unknown): asserts v is PushResponse {\n  if (isClientStateNotFoundResponse(v)) {\n    return;\n  }\n  assertVersionNotSupportedResponse(v);\n}\n\n/**\n * Pusher is the function type used to do the fetch part of a push. The request\n * is a POST request where the body is JSON with the type {@link PushRequest}.\n *\n * The return value should either be a {@link HTTPRequestInfo} or a\n * {@link PusherResult}. The reason for the two different return types is that\n * we didn't use to care about the response body of the push request. The\n * default pusher implementation checks if the response body is JSON and if it\n * matches the type {@link PusherResponse}. If it does, it is included in the\n * return value.\n */\nexport type Pusher = (\n  requestBody: PushRequest,\n  requestID: string,\n) => Promise<PusherResult>;\n\n/**\n * This error is thrown when the pusher fails for any reason.\n */\nexport class PushError extends Error {\n  name = 'PushError';\n  // causedBy is used instead of cause, because while cause has been proposed as a\n  // JavaScript language standard for this purpose (see\n  // https://github.com/tc39/proposal-error-cause) current browser behavior is\n  // inconsistent.\n  causedBy?: Error | undefined;\n  constructor(causedBy?: Error) {\n    super('Failed to push');\n    this.causedBy = causedBy;\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport {jsonSchema} from '../../../shared/src/json-schema.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport * as valita from '../../../shared/src/valita.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  DEFAULT_HEAD_NAME,\n  type LocalMetaDD31,\n  commitIsLocalDD31,\n  localMutations,\n} from '../db/commit.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {\n  PushError,\n  type Pusher,\n  type PusherResult,\n  assertPusherResult,\n} from '../pusher.ts';\nimport {ReportError} from '../report-error.ts';\nimport {toError} from '../to-error.ts';\nimport {withRead} from '../with-transactions.ts';\nimport {\n  type ClientGroupID,\n  type ClientID,\n  clientGroupIDSchema,\n  clientIDSchema,\n} from './ids.ts';\n\nexport const PUSH_VERSION_SDD = 0;\nexport const PUSH_VERSION_DD31 = 1;\n\n/**\n * Mutation describes a single mutation done on the client.\n */\nexport type MutationV1 = {\n  readonly id: number;\n  readonly name: string;\n  readonly args: ReadonlyJSONValue;\n  readonly timestamp: number;\n  readonly clientID: ClientID;\n};\n\nexport type Mutation = MutationV1;\n\nconst mutationV1Schema: valita.Type<MutationV1> = valita.readonlyObject({\n  id: valita.number(),\n  name: valita.string(),\n  args: jsonSchema,\n  timestamp: valita.number(),\n  clientID: clientIDSchema,\n});\n\n/**\n * The JSON value used as the body when doing a POST to the [push\n * endpoint](/reference/server-push).\n */\nexport type PushRequestV1 = {\n  pushVersion: 1;\n  /**\n   * `schemaVersion` can optionally be used to specify to the push endpoint\n   * version information about the mutators the app is using (e.g., format of\n   * mutator args).\n   */\n  schemaVersion: string;\n  profileID: string;\n\n  clientGroupID: ClientGroupID;\n  mutations: MutationV1[];\n};\n\nconst pushRequestV1Schema = valita.object({\n  pushVersion: valita.literal(1),\n  schemaVersion: valita.string(),\n  profileID: valita.string(),\n  clientGroupID: clientGroupIDSchema,\n  mutations: valita.array(mutationV1Schema),\n});\n\nexport type PushRequest = PushRequestV1;\n\nexport function assertPushRequestV1(\n  value: unknown,\n): asserts value is PushRequestV1 {\n  valita.assert(value, pushRequestV1Schema);\n}\n\n/**\n * Mutation describes a single mutation done on the client.\n */\ntype FrozenMutationV1 = {\n  readonly id: number;\n  readonly name: string;\n  readonly args: FrozenJSONValue;\n  readonly timestamp: number;\n  readonly clientID: ClientID;\n};\n\nfunction convertDD31(lm: LocalMetaDD31): FrozenMutationV1 {\n  return {\n    id: lm.mutationID,\n    name: lm.mutatorName,\n    args: lm.mutatorArgsJSON,\n    timestamp: lm.timestamp,\n    clientID: lm.clientID,\n  };\n}\n\nexport async function push(\n  requestID: string,\n  store: Store,\n  lc: LogContext,\n  profileID: string,\n  clientGroupID: ClientGroupID | undefined,\n  _clientID: ClientID,\n  pusher: Pusher,\n  schemaVersion: string,\n  pushVersion: typeof PUSH_VERSION_SDD | typeof PUSH_VERSION_DD31,\n): Promise<PusherResult | undefined> {\n  // Find pending commits between the base snapshot and the main head and push\n  // them to the data layer.\n  const pending = await withRead(store, async dagRead => {\n    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (!mainHeadHash) {\n      throw new Error('Internal no main head');\n    }\n    return localMutations(mainHeadHash, dagRead);\n    // Important! Don't hold the lock through an HTTP request!\n  });\n\n  if (pending.length === 0) {\n    return undefined;\n  }\n\n  // Commit.pending gave us commits in head-first order; the bindings\n  // want tail first (in mutation id order).\n  pending.reverse();\n\n  assert(pushVersion === PUSH_VERSION_DD31);\n\n  const pushMutations: FrozenMutationV1[] = [];\n  for (const commit of pending) {\n    if (commitIsLocalDD31(commit)) {\n      pushMutations.push(convertDD31(commit.meta));\n    } else {\n      throw new Error('Internal non local pending commit');\n    }\n  }\n  assert(clientGroupID);\n  const pushReq: PushRequestV1 = {\n    profileID,\n    clientGroupID,\n    mutations: pushMutations,\n    pushVersion: PUSH_VERSION_DD31,\n    schemaVersion,\n  };\n\n  lc.debug?.('Starting push...');\n  const pushStart = Date.now();\n  const pusherResult = await callPusher(pusher, pushReq, requestID);\n  lc.debug?.('...Push complete in ', Date.now() - pushStart, 'ms');\n  return pusherResult;\n}\n\nasync function callPusher(\n  pusher: Pusher,\n  body: PushRequestV1,\n  requestID: string,\n): Promise<PusherResult> {\n  let pusherResult: PusherResult;\n  try {\n    pusherResult = await pusher(body, requestID);\n  } catch (e) {\n    throw new PushError(toError(e));\n  }\n  try {\n    assertPusherResult(pusherResult);\n    return pusherResult;\n  } catch (e) {\n    throw new ReportError('Invalid pusher result', toError(e));\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert, assertNotUndefined} from '../../shared/src/asserts.ts';\nimport type {Enum} from '../../shared/src/enum.ts';\nimport type {MaybePromise} from '../../shared/src/types.ts';\nimport {throwChunkHasher} from './dag/chunk.ts';\nimport {LazyStore} from './dag/lazy-store.ts';\nimport {StoreImpl} from './dag/store-impl.ts';\nimport type {Store} from './dag/store.ts';\nimport {DEFAULT_HEAD_NAME} from './db/commit.ts';\nimport {\n  type ClientStateNotFoundResponse,\n  type VersionNotSupportedResponse,\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n} from './error-responses.ts';\nimport * as FormatVersion from './format-version-enum.ts';\nimport {parseReplicacheFormatVersion as parseFormatVersion} from './format-version.ts';\nimport {assertHash, newRandomHash} from './hash.ts';\nimport type {HTTPRequestInfo} from './http-request-info.ts';\nimport type {CreateStore} from './kv/store.ts';\nimport {\n  type ClientGroup,\n  type ClientGroupMap,\n  getClientGroups,\n  disableClientGroup as persistDisableClientGroup,\n  setClientGroups,\n} from './persist/client-groups.ts';\nimport type {\n  IDBDatabasesStore,\n  IndexedDBDatabase,\n} from './persist/idb-databases-store.ts';\nimport type {PullResponseOKV1, PullResponseV1, Puller} from './puller.ts';\nimport type {PushResponse, Pusher} from './pusher.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\nimport {beginPullV1} from './sync/pull.ts';\nimport {PUSH_VERSION_DD31, push} from './sync/push.ts';\nimport {withRead, withWrite} from './with-transactions.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nconst MUTATION_RECOVERY_LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT = 10 * 2 ** 20; // 10 MB\n\ninterface ReplicacheDelegate {\n  clientID: ClientID;\n  closed: boolean;\n  idbName: string;\n  name: string;\n  online: boolean;\n  profileID: Promise<string>;\n  puller: Puller;\n  pusher: Pusher;\n}\n\ninterface MutationRecoveryOptions {\n  delegate: ReplicacheDelegate;\n  readonly wrapInOnlineCheck: (\n    f: () => Promise<boolean>,\n    name: string,\n  ) => Promise<boolean>;\n  readonly wrapInReauthRetries: <R>(\n    f: (\n      requestID: string,\n      requestLc: LogContext,\n    ) => Promise<{\n      httpRequestInfo: HTTPRequestInfo | undefined;\n      result: R;\n    }>,\n    verb: string,\n    lc: LogContext,\n    preAuth?: () => MaybePromise<void>,\n    postAuth?: () => MaybePromise<void>,\n  ) => Promise<{\n    result: R;\n    authFailure: boolean;\n  }>;\n  readonly isPushDisabled: () => boolean;\n  readonly isPullDisabled: () => boolean;\n  readonly lc: LogContext;\n  readonly enableMutationRecovery: boolean;\n  readonly clientGroupIDPromise: Promise<ClientGroupID | undefined>;\n}\n\nexport class MutationRecovery {\n  #recoveringMutations = false;\n  readonly #options: MutationRecoveryOptions;\n\n  constructor(options: MutationRecoveryOptions) {\n    this.#options = options;\n  }\n\n  async recoverMutations(\n    ready: Promise<unknown>,\n    perdag: Store,\n    idbDatabase: IndexedDBDatabase,\n    idbDatabases: IDBDatabasesStore,\n    createStore: CreateStore,\n  ): Promise<boolean> {\n    const {lc, enableMutationRecovery, isPushDisabled, delegate} =\n      this.#options;\n\n    if (\n      !enableMutationRecovery ||\n      this.#recoveringMutations ||\n      !delegate.online ||\n      delegate.closed ||\n      isPushDisabled()\n    ) {\n      return false;\n    }\n    const stepDescription = 'Recovering mutations.';\n    lc.debug?.('Start:', stepDescription);\n    try {\n      this.#recoveringMutations = true;\n      await ready;\n      await recoverMutationsFromPerdag(idbDatabase, this.#options, perdag);\n      for (const database of Object.values(await idbDatabases.getDatabases())) {\n        if (delegate.closed) {\n          lc.debug?.('Exiting early due to close:', stepDescription);\n          return true;\n        }\n        if (\n          database.replicacheName === delegate.name &&\n          database.name !== delegate.idbName\n        ) {\n          switch (database.replicacheFormatVersion) {\n            case FormatVersion.SDD:\n            case FormatVersion.DD31:\n            case FormatVersion.V6:\n            case FormatVersion.V7:\n              await recoverMutationsWithNewPerdag(\n                database,\n                this.#options,\n                createStore,\n              );\n          }\n        }\n      }\n    } catch (e) {\n      logMutationRecoveryError(e, lc, stepDescription, delegate);\n    } finally {\n      lc.debug?.('End:', stepDescription);\n      this.#recoveringMutations = false;\n    }\n    return true;\n  }\n}\n\nfunction logMutationRecoveryError(\n  e: unknown,\n  lc: LogContext,\n  stepDescription: string,\n  closedDelegate: {closed: boolean},\n) {\n  if (closedDelegate.closed) {\n    lc.debug?.(\n      `Mutation recovery error likely due to close during:\\n${stepDescription}\\nError:\\n`,\n      e,\n    );\n  } else {\n    lc.error?.(\n      `Mutation recovery error during:\\n${stepDescription}\\nError:\\n`,\n      e,\n    );\n  }\n}\n\nasync function recoverMutationsWithNewPerdag(\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  createStore: CreateStore,\n) {\n  const perKvStore = createStore(database.name);\n  const perdag = new StoreImpl(perKvStore, newRandomHash, assertHash);\n  try {\n    await recoverMutationsFromPerdag(database, options, perdag);\n  } finally {\n    await perdag.close();\n  }\n}\n\nfunction recoverMutationsFromPerdag(\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  perdag: Store,\n): Promise<void> {\n  assert(database.replicacheFormatVersion >= FormatVersion.DD31);\n  return recoverMutationsFromPerdagDD31(database, options, perdag);\n}\n\nasync function recoverMutationsFromPerdagDD31(\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  perdag: Store,\n): Promise<void> {\n  const {delegate, lc} = options;\n  const stepDescription = `Recovering mutations from db ${database.name}.`;\n  lc.debug?.('Start:', stepDescription);\n  try {\n    const formatVersion = parseFormatVersion(database.replicacheFormatVersion);\n    let clientGroups: ClientGroupMap | undefined = await withRead(\n      perdag,\n      read => getClientGroups(read),\n    );\n    const clientGroupIDsVisited = new Set<ClientGroupID>();\n    while (clientGroups) {\n      let newClientGroups: ClientGroupMap | undefined;\n      for (const [clientGroupID, clientGroup] of clientGroups) {\n        if (delegate.closed) {\n          lc.debug?.('Exiting early due to close:', stepDescription);\n          return;\n        }\n        if (!clientGroupIDsVisited.has(clientGroupID)) {\n          clientGroupIDsVisited.add(clientGroupID);\n          newClientGroups = await recoverMutationsOfClientGroupDD31(\n            clientGroup,\n            clientGroupID,\n            perdag,\n            database,\n            options,\n            formatVersion,\n          );\n          if (newClientGroups) {\n            break;\n          }\n        }\n      }\n      clientGroups = newClientGroups;\n    }\n  } catch (e) {\n    logMutationRecoveryError(e, lc, stepDescription, delegate);\n  }\n  lc.debug?.('End:', stepDescription);\n}\n\nfunction isResponseThatShouldDisableClientGroup(\n  response: PushResponse | PullResponseV1 | undefined,\n): response is ClientStateNotFoundResponse | VersionNotSupportedResponse {\n  return (\n    isClientStateNotFoundResponse(response) ||\n    isVersionNotSupportedResponse(response)\n  );\n}\n\nasync function disableClientGroup(\n  lc: LogContext,\n  selfClientGroupID: string,\n  clientGroupID: string,\n  response: ClientStateNotFoundResponse | VersionNotSupportedResponse,\n  perdag: Store,\n) {\n  if (isClientStateNotFoundResponse(response)) {\n    lc.debug?.(\n      `Client group ${selfClientGroupID} cannot recover mutations for client group ${clientGroupID}. The client group is unknown on the server. Marking it as disabled.`,\n    );\n  } else if (isVersionNotSupportedResponse(response)) {\n    lc.debug?.(\n      `Client group ${selfClientGroupID} cannot recover mutations for client group ${clientGroupID}. The client group's version is not supported on the server. versionType: ${response.versionType}. Marking it as disabled.`,\n    );\n  }\n  // The client group is not the main client group so we do not need the\n  // Replicache instance to update its internal _isClientGroupDisabled\n  // property.\n  await withWrite(perdag, perdagWrite =>\n    persistDisableClientGroup(clientGroupID, perdagWrite),\n  );\n}\n\n/**\n * @returns When mutations are recovered the resulting updated client group map.\n *   Otherwise undefined, which can be because there were no mutations to\n *   recover, or because an error occurred when trying to recover the mutations.\n */\nasync function recoverMutationsOfClientGroupDD31(\n  clientGroup: ClientGroup,\n  clientGroupID: ClientGroupID,\n  perdag: Store,\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  formatVersion: FormatVersion,\n): Promise<ClientGroupMap | undefined> {\n  assert(database.replicacheFormatVersion >= FormatVersion.DD31);\n\n  const {\n    delegate,\n    lc,\n    wrapInOnlineCheck,\n    wrapInReauthRetries,\n    isPushDisabled,\n    isPullDisabled,\n    clientGroupIDPromise,\n  } = options;\n\n  const selfClientGroupID = await clientGroupIDPromise;\n  assertNotUndefined(selfClientGroupID);\n  if (selfClientGroupID === clientGroupID) {\n    return;\n  }\n\n  let clientID: ClientID | undefined;\n\n  // If all local mutations have been applied then exit.\n  let allAckd = true;\n  for (const [cid, mutationID] of Object.entries(clientGroup.mutationIDs)) {\n    // if not present then the server has not acknowledged this client's mutations.\n    if (\n      !clientGroup.lastServerAckdMutationIDs[cid] ||\n      clientGroup.lastServerAckdMutationIDs[cid] < mutationID\n    ) {\n      clientID = cid;\n      allAckd = false;\n      break;\n    }\n  }\n  if (allAckd) {\n    return;\n  }\n\n  if (clientGroup.disabled) {\n    lc.debug?.(\n      `Not recovering mutations for client group ${clientGroupID} because group is disabled.`,\n    );\n    return;\n  }\n\n  const stepDescription = `Recovering mutations for client group ${clientGroupID}.`;\n  lc.debug?.('Start:', stepDescription);\n  const lazyDagForOtherClientGroup = new LazyStore(\n    perdag,\n    MUTATION_RECOVERY_LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT,\n    throwChunkHasher,\n    assertHash,\n  );\n  try {\n    await withWrite(lazyDagForOtherClientGroup, write =>\n      write.setHead(DEFAULT_HEAD_NAME, clientGroup.headHash),\n    );\n\n    if (isPushDisabled()) {\n      lc.debug?.(\n        `Cannot recover mutations for client group ${clientGroupID} because push is disabled.`,\n      );\n      return;\n    }\n\n    const {pusher} = delegate;\n\n    const pushDescription = 'recoveringMutationsPush';\n    const pushSucceeded = await wrapInOnlineCheck(async () => {\n      const {result: pusherResult} = await wrapInReauthRetries(\n        async (requestID: string, requestLc: LogContext) => {\n          assert(clientID);\n          assert(lazyDagForOtherClientGroup);\n          const pusherResult = await push(\n            requestID,\n            lazyDagForOtherClientGroup,\n            requestLc,\n            await delegate.profileID,\n            clientGroupID,\n            // TODO(DD31): clientID is not needed in DD31. It is currently kept for debugging purpose.\n            clientID,\n            pusher,\n            database.schemaVersion,\n            PUSH_VERSION_DD31,\n          );\n          return {\n            result: pusherResult,\n            httpRequestInfo: pusherResult?.httpRequestInfo,\n          };\n        },\n        pushDescription,\n        lc,\n      );\n      if (!pusherResult) {\n        return false;\n      }\n      const pusherResponse = pusherResult.response;\n      if (isResponseThatShouldDisableClientGroup(pusherResponse)) {\n        await disableClientGroup(\n          lc,\n          selfClientGroupID,\n          clientGroupID,\n          pusherResponse,\n          perdag,\n        );\n        return false;\n      }\n      return pusherResult.httpRequestInfo.httpStatusCode === 200;\n    }, pushDescription);\n    if (!pushSucceeded) {\n      lc.debug?.(\n        `Failed to recover mutations for client ${clientGroupID} due to a push error.`,\n      );\n      return;\n    }\n\n    if (isPullDisabled()) {\n      lc.debug?.(\n        `Cannot confirm mutations were recovered for client ${clientGroupID} ` +\n          `because pull is disabled.`,\n      );\n      return;\n    }\n    const {puller} = delegate;\n\n    const pullDescription = 'recoveringMutationsPull';\n    let okPullResponse: PullResponseOKV1 | undefined;\n    const pullSucceeded = await wrapInOnlineCheck(async () => {\n      const {result: beginPullResponse} = await wrapInReauthRetries(\n        async (requestID: string, requestLc: LogContext) => {\n          assert(clientID);\n          const beginPullResponse = await beginPullV1(\n            await delegate.profileID,\n            clientID,\n            clientGroupID,\n            database.schemaVersion,\n            puller,\n            requestID,\n            lazyDagForOtherClientGroup,\n            formatVersion,\n            requestLc,\n            false,\n          );\n          return {\n            result: beginPullResponse,\n            httpRequestInfo: beginPullResponse.httpRequestInfo,\n          };\n        },\n        pullDescription,\n        lc,\n      );\n      const {pullResponse} = beginPullResponse;\n      if (isResponseThatShouldDisableClientGroup(pullResponse)) {\n        await disableClientGroup(\n          lc,\n          selfClientGroupID,\n          clientGroupID,\n          pullResponse,\n          perdag,\n        );\n        return false;\n      }\n      if (\n        !pullResponse ||\n        beginPullResponse.httpRequestInfo.httpStatusCode !== 200\n      ) {\n        return false;\n      }\n      okPullResponse = pullResponse;\n      return true;\n    }, pullDescription);\n    if (!pullSucceeded) {\n      lc.debug?.(\n        `Failed to recover mutations for client ${clientGroupID} due to a pull error.`,\n      );\n      return;\n    }\n\n    // TODO(arv): Refactor to make pullResponse a const.\n    // pullResponse must be non undefined because pullSucceeded is true.\n    assert(okPullResponse);\n    lc.debug?.(\n      `Client group ${selfClientGroupID} recovered mutations for client group ${clientGroupID}.  Details`,\n      {\n        mutationIDs: clientGroup.mutationIDs,\n        lastServerAckdMutationIDs: clientGroup.lastServerAckdMutationIDs,\n        lastMutationIDChanges: okPullResponse.lastMutationIDChanges,\n      },\n    );\n\n    return await withWrite(perdag, async dagWrite => {\n      const clientGroups = await getClientGroups(dagWrite);\n      const clientGroupToUpdate = clientGroups.get(clientGroupID);\n      if (!clientGroupToUpdate) {\n        return clientGroups;\n      }\n\n      assert(okPullResponse);\n      const lastServerAckdMutationIDsUpdates: Record<ClientID, number> = {};\n      let anyMutationIDsUpdated = false;\n      for (const [clientID, lastMutationIDChange] of Object.entries(\n        okPullResponse.lastMutationIDChanges,\n      )) {\n        if (\n          (clientGroupToUpdate.lastServerAckdMutationIDs[clientID] ?? 0) <\n          lastMutationIDChange\n        ) {\n          lastServerAckdMutationIDsUpdates[clientID] = lastMutationIDChange;\n          anyMutationIDsUpdated = true;\n        }\n      }\n      if (!anyMutationIDsUpdated) {\n        return clientGroups;\n      }\n\n      const newClientGroups = new Map(clientGroups).set(clientGroupID, {\n        ...clientGroupToUpdate,\n        lastServerAckdMutationIDs: {\n          ...clientGroupToUpdate.lastServerAckdMutationIDs,\n          ...lastServerAckdMutationIDsUpdates,\n        },\n      });\n      await setClientGroups(newClientGroups, dagWrite);\n      return newClientGroups;\n    });\n  } catch (e) {\n    logMutationRecoveryError(e, lc, stepDescription, delegate);\n  } finally {\n    await lazyDagForOtherClientGroup.close();\n    lc.debug?.('End:', stepDescription);\n  }\n  return;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nclass NoopBroadcastChannel implements BroadcastChannel {\n  readonly name: string;\n\n  onmessage: ((this: BroadcastChannel, ev: MessageEvent<any>) => any) | null =\n    null;\n\n  onmessageerror:\n    | ((this: BroadcastChannel, ev: MessageEvent<any>) => any)\n    | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  addEventListener(): void {\n    // noop\n  }\n  removeEventListener(): void {\n    // noop\n  }\n  dispatchEvent(): boolean {\n    return false;\n  }\n\n  close(): void {\n    // noop\n  }\n\n  postMessage(): void {\n    // noop\n  }\n}\n\nconst bc: typeof BroadcastChannel =\n  typeof BroadcastChannel === 'undefined'\n    ? NoopBroadcastChannel\n    : BroadcastChannel;\n\nexport {bc as BroadcastChannel};\n","import {BroadcastChannel} from '../../shared/src/broadcast-channel.ts';\nimport type {Read, Store} from './dag/store.ts';\nimport {getClientGroup} from './persist/client-groups.ts';\nimport {withRead} from './with-transactions.ts';\n\n// Older clients (<= replicache@13.0.1), listened on this channel name\n// and *asserted* that the messages received were an array containing exactly\n// one string.\nfunction makeChannelNameV0(replicacheName: string): string {\n  return `replicache-new-client-group:${replicacheName}`;\n}\n\n// This channel name was introduced when we first needed to change the message\n// format.  The design of the messages sent on this channel allows for\n// the message content to be extended in the future in a way that is\n// forward and backwards compatible.  The message format can be extended\n// by adding new *optional* fields.\nfunction makeChannelNameV1(replicacheName: string): string {\n  return `replicache-new-client-group-v1:${replicacheName}`;\n}\n\nexport {\n  makeChannelNameV0 as makeChannelNameV0ForTesting,\n  makeChannelNameV1 as makeChannelNameV1ForTesting,\n};\n\n// This message type can be extended with optional properties.\ntype NewClientChannelMessageV1 = {clientGroupID: string; idbName: string};\n\nfunction isNewClientChannelMessageV1(\n  message: unknown,\n): message is NewClientChannelMessageV1 {\n  return (\n    typeof message === 'object' &&\n    typeof (message as {clientGroupID: unknown}).clientGroupID === 'string' &&\n    typeof (message as {idbName: unknown}).idbName === 'string'\n  );\n}\n\nexport function initNewClientChannel(\n  replicacheName: string,\n  idbName: string,\n  signal: AbortSignal,\n  clientGroupID: string,\n  isNewClientGroup: boolean,\n  onUpdateNeeded: () => void,\n  perdag: Store,\n) {\n  if (signal.aborted) {\n    return;\n  }\n\n  const channelV1 = new BroadcastChannel(makeChannelNameV1(replicacheName));\n  if (isNewClientGroup) {\n    channelV1.postMessage({clientGroupID, idbName});\n    // Send expected format to V0 channel for old clients.\n    const channelV0 = new BroadcastChannel(makeChannelNameV0(replicacheName));\n    channelV0.postMessage([clientGroupID]);\n    channelV0.close();\n  }\n\n  channelV1.onmessage = async (e: MessageEvent) => {\n    const {data} = e;\n    if (isNewClientChannelMessageV1(data)) {\n      const {clientGroupID: newClientGroupID, idbName: newClientIDBName} = data;\n      if (newClientGroupID !== clientGroupID) {\n        if (newClientIDBName === idbName) {\n          // Check if this client can see the new client's newClientGroupID in its\n          // perdag. It should be able to if the clients share persistent\n          // storage. However, with `ReplicacheOption.kvStore`\n          // and `IDBStoreWithMemFallback` clients may not actually share\n          // persistent storage.  If storage is not shared, then there is no point\n          // in updating, since clients cannot sync locally.  If clients do update\n          // in this case, they can continually cause each other to update, since\n          // on each update the clients get assigned a new client group.\n          const updateNeeded = await withRead(\n            perdag,\n            async (perdagRead: Read) =>\n              (await getClientGroup(newClientGroupID, perdagRead)) !==\n              undefined,\n          );\n          if (updateNeeded) {\n            onUpdateNeeded();\n          }\n        } else {\n          // Idb name is different, indicating new schema or format version.\n          // Update to get assigned to newClientIDBName, and hopefully\n          // newClientGroupID.\n          // If storage is not actually shared (i.e. due to\n          // `ReplicacheOption.kvStore`\n          // or `IDBStoreWithMemFallback`) the new client will not\n          // get assigned to newClientGroupID, but should get the\n          // newClientIDBName.\n          // Note: we don't try to read from newClientIDBName to see\n          // if this client shares storage with the new client, because\n          // the newClientIDBName may have a format version this client\n          // cannot read.\n          onUpdateNeeded();\n          return;\n        }\n      }\n    }\n  };\n\n  signal.addEventListener('abort', () => channelV1.close(), {once: true});\n}\n","import {assertObject, assertString} from '../../shared/src/asserts.ts';\nimport {BroadcastChannel} from '../../shared/src/broadcast-channel.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\n\nfunction makeChannelName(replicacheName: string): string {\n  return `replicache-on-persist:${replicacheName}`;\n}\n\nexport type PersistInfo = {\n  clientGroupID: ClientGroupID;\n  clientID: ClientID;\n};\n\nexport type OnPersist = (persistInfo: PersistInfo) => void;\n\ntype HandlePersist = OnPersist;\n\nfunction assertPersistInfo(value: unknown): asserts value is PersistInfo {\n  assertObject(value);\n  assertString(value.clientGroupID);\n  assertString(value.clientID);\n}\n\nexport function initOnPersistChannel(\n  replicacheName: string,\n  signal: AbortSignal,\n  handlePersist: HandlePersist,\n): OnPersist {\n  if (signal.aborted) {\n    return () => undefined;\n  }\n  const channel = new BroadcastChannel(makeChannelName(replicacheName));\n\n  channel.onmessage = e => {\n    const {data} = e;\n    assertPersistInfo(data);\n    handlePersist({\n      clientGroupID: data.clientGroupID,\n      clientID: data.clientID,\n    });\n  };\n\n  signal.addEventListener('abort', () => channel.close(), {once: true});\n\n  return (persistInfo: PersistInfo) => {\n    if (signal.aborted) {\n      return;\n    }\n    channel.postMessage(persistInfo);\n    handlePersist(persistInfo);\n  };\n}\n","import type {ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {mustGetHeadHash, type Read} from './dag/store.ts';\nimport {DEFAULT_HEAD_NAME, localMutationsDD31} from './db/commit.ts';\nimport type {ClientID} from './sync/ids.ts';\n\nexport type PendingMutation = {\n  readonly name: string;\n  readonly id: number;\n  readonly args: ReadonlyJSONValue;\n  readonly clientID: ClientID;\n};\n\n/**\n * This returns the pending changes with the oldest mutations first.\n */\nexport async function pendingMutationsForAPI(\n  dagRead: Read,\n): Promise<readonly PendingMutation[]> {\n  const mainHeadHash = await mustGetHeadHash(DEFAULT_HEAD_NAME, dagRead);\n  const pending = await localMutationsDD31(mainHeadHash, dagRead);\n  return pending\n    .map(p => ({\n      id: p.meta.mutationID,\n      name: p.meta.mutatorName,\n      args: p.meta.mutatorArgsJSON,\n      clientID: p.meta.clientID,\n    }))\n    .reverse();\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport type {Store} from '../dag/store.ts';\nimport {addDeletedClients} from '../deleted-clients.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport type {Client, OnClientsDeleted} from './clients.ts';\nimport {type ClientMap, getClients, setClients} from './clients.ts';\n\n/**\n * The maximum time a client can be inactive before it is garbage collected.\n * This means that this is the maximum time a tab can be in the background\n * (frozen) and still be able to sync when it comes back to the foreground.\n */\nexport const CLIENT_MAX_INACTIVE_TIME = 24 * 60 * 60 * 1000; // 24 hours\n\n/**\n * How frequently to try to garbage collect clients.\n */\nexport const GC_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\nlet latestGCUpdate: Promise<ClientMap> | undefined;\nexport function getLatestGCUpdate(): Promise<ClientMap> | undefined {\n  return latestGCUpdate;\n}\n\nexport function initClientGC(\n  clientID: ClientID,\n  dagStore: Store,\n  clientMaxInactiveTime: number,\n  gcInterval: number,\n  onClientsDeleted: OnClientsDeleted,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  initBgIntervalProcess(\n    'ClientGC',\n    () => {\n      latestGCUpdate = gcClients(\n        clientID,\n        dagStore,\n        clientMaxInactiveTime,\n        onClientsDeleted,\n      );\n      return latestGCUpdate;\n    },\n    () => gcInterval,\n    lc,\n    signal,\n  );\n}\n\nfunction gcClients(\n  clientID: ClientID,\n  dagStore: Store,\n  clientMaxInactiveTime: number,\n  onClientsDeleted: OnClientsDeleted,\n): Promise<ClientMap> {\n  return withWrite(dagStore, async dagWrite => {\n    const now = Date.now();\n    const clients = await getClients(dagWrite);\n    const deletedClients: ClientID[] = [];\n    const newClients: Map<ClientID, Client> = new Map();\n    for (const [id, client] of clients) {\n      if (\n        id === clientID /* never collect ourself */ ||\n        now - client.heartbeatTimestampMs <= clientMaxInactiveTime\n      ) {\n        newClients.set(id, client);\n      } else {\n        deletedClients.push(id);\n      }\n    }\n\n    if (newClients.size === clients.size) {\n      return clients;\n    }\n    await setClients(newClients, dagWrite);\n    const {clientIDs, clientGroupIDs} = await addDeletedClients(\n      dagWrite,\n      deletedClients,\n      // gcClients does not delete client groups\n      [],\n    );\n    onClientsDeleted(clientIDs, clientGroupIDs);\n    return newClients;\n  });\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport type {Store} from '../dag/store.ts';\nimport type {ClientGroupID} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport {\n  clientGroupHasPendingMutations,\n  getClientGroups,\n  setClientGroups,\n  type ClientGroupMap,\n} from './client-groups.ts';\nimport {getClients, type OnClientsDeleted} from './clients.ts';\n\nconst GC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes\n\nlet latestGCUpdate: Promise<ClientGroupMap> | undefined;\nexport function getLatestGCUpdate(): Promise<ClientGroupMap> | undefined {\n  return latestGCUpdate;\n}\n\nexport function initClientGroupGC(\n  dagStore: Store,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  initBgIntervalProcess(\n    'ClientGroupGC',\n    () => {\n      latestGCUpdate = gcClientGroups(\n        dagStore,\n        enableMutationRecovery,\n        onClientsDeleted,\n      );\n      return latestGCUpdate;\n    },\n    () => GC_INTERVAL_MS,\n    lc,\n    signal,\n  );\n}\n\n/**\n * This removes client groups that have no clients and no pending mutations.\n * If {@linkcode enableMutationRecovery} is true, it will keep client groups with\n * pending mutations. If it is false, it will remove client groups even when they\n * have pending mutations.\n */\nexport function gcClientGroups(\n  dagStore: Store,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n): Promise<ClientGroupMap> {\n  return withWrite(dagStore, async tx => {\n    const clients = await getClients(tx);\n    const clientGroupIDs = new Set();\n    for (const client of clients.values()) {\n      clientGroupIDs.add(client.clientGroupID);\n    }\n    const clientGroups = new Map();\n    const removeClientGroups: Set<ClientGroupID> = new Set();\n    for (const [clientGroupID, clientGroup] of await getClientGroups(tx)) {\n      if (\n        clientGroupIDs.has(clientGroupID) ||\n        (enableMutationRecovery && clientGroupHasPendingMutations(clientGroup))\n      ) {\n        clientGroups.set(clientGroupID, clientGroup);\n      } else {\n        removeClientGroups.add(clientGroupID);\n      }\n    }\n    await setClientGroups(clientGroups, tx);\n    onClientsDeleted([], [...removeClientGroups].sort());\n    return clientGroups;\n  });\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport type {Store} from '../dag/store.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport {\n  type ClientMap,\n  ClientStateNotFoundError,\n  getClients,\n  setClients,\n} from './clients.ts';\n\nexport const HEARTBEAT_INTERVAL = 60 * 1000;\n\nexport let latestHeartbeatUpdate: Promise<ClientMap> | undefined;\n\nexport function startHeartbeats(\n  clientID: ClientID,\n  dagStore: Store,\n  onClientStateNotFound: () => void,\n  heartbeatIntervalMs: number,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  initBgIntervalProcess(\n    'Heartbeat',\n    async () => {\n      latestHeartbeatUpdate = writeHeartbeat(clientID, dagStore);\n      try {\n        return await latestHeartbeatUpdate;\n      } catch (e) {\n        if (e instanceof ClientStateNotFoundError) {\n          onClientStateNotFound();\n          return;\n        }\n        throw e;\n      }\n    },\n    () => heartbeatIntervalMs,\n    lc,\n    signal,\n  );\n}\n\nexport function writeHeartbeat(\n  clientID: ClientID,\n  dagStore: Store,\n): Promise<ClientMap> {\n  return withWrite(dagStore, async dagWrite => {\n    const clients = await getClients(dagWrite);\n    const client = clients.get(clientID);\n    if (!client) {\n      throw new ClientStateNotFoundError(clientID);\n    }\n\n    const newClient = {\n      ...client,\n      heartbeatTimestampMs: Date.now(),\n    };\n    const newClients = new Map(clients).set(clientID, newClient);\n\n    await setClients(newClients, dagWrite);\n    return newClients;\n  });\n}\n","import type {Hash} from '../hash.ts';\nimport type {Chunk} from './chunk.ts';\nimport type {MustGetChunk} from './store.ts';\n\n/**\n * A visitor walks the DAG starting at a given root and visits each chunk.\n */\nexport class Visitor {\n  #seen: Set<Hash> = new Set();\n  #dagRead: MustGetChunk;\n\n  constructor(dagRead: MustGetChunk) {\n    this.#dagRead = dagRead;\n  }\n\n  async visit(h: Hash) {\n    if (this.#seen.has(h)) {\n      return;\n    }\n    this.#seen.add(h);\n    const chunk = await this.#dagRead.mustGetChunk(h);\n    await this.visitChunk(chunk);\n  }\n\n  async visitChunk(chunk: Chunk<unknown>) {\n    await Promise.all(chunk.meta.map(ref => this.visit(ref)));\n  }\n}\n","import {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {Chunk} from '../dag/chunk.ts';\nimport type {LazyRead} from '../dag/lazy-store.ts';\nimport {Visitor} from '../dag/visitor.ts';\nimport type {Hash} from '../hash.ts';\n\nexport class GatherMemoryOnlyVisitor extends Visitor {\n  readonly #gatheredChunks: Map<Hash, Chunk> = new Map();\n  readonly #lazyRead: LazyRead;\n\n  constructor(dagRead: LazyRead) {\n    super(dagRead);\n    this.#lazyRead = dagRead;\n  }\n\n  get gatheredChunks(): ReadonlyMap<Hash, Chunk> {\n    return this.#gatheredChunks;\n  }\n\n  override visit(h: Hash): Promise<void> {\n    if (!this.#lazyRead.isMemOnlyChunkHash(h)) {\n      // Not a memory-only hash, no need to visit anything else.\n      return promiseVoid;\n    }\n    return super.visit(h);\n  }\n\n  override visitChunk(chunk: Chunk): Promise<void> {\n    this.#gatheredChunks.set(chunk.hash, chunk);\n    return super.visitChunk(chunk);\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport type {Chunk} from '../dag/chunk.ts';\nimport type {LazyStore} from '../dag/lazy-store.ts';\nimport type {Read, Store, Write} from '../dag/store.ts';\nimport {\n  Commit,\n  DEFAULT_HEAD_NAME,\n  type LocalMetaDD31,\n  type Meta,\n  assertSnapshotCommitDD31,\n  baseSnapshotFromCommit,\n  commitFromHash,\n  commitFromHead,\n  compareCookiesForSnapshots,\n  localMutationsDD31,\n  localMutationsGreaterThan,\n} from '../db/commit.ts';\nimport {rebaseMutationAndPutCommit} from '../db/rebase.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\nimport type {ClientGroupID, ClientID} from '../sync/ids.ts';\nimport type {MutatorDefs} from '../types.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {\n  type ClientGroup,\n  getClientGroup,\n  setClientGroup,\n} from './client-groups.ts';\nimport {\n  assertClientV6,\n  assertHasClientState,\n  getClientGroupIDForClient,\n  mustGetClient,\n  setClient,\n} from './clients.ts';\nimport {GatherMemoryOnlyVisitor} from './gather-mem-only-visitor.ts';\nimport type {ZeroOption, ZeroTxData} from '../replicache-options.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\n/**\n * Persists the client's memdag state to the client's perdag client group.\n *\n * Persists the base snapshot from memdag to the client's perdag client group,\n * but only if its newer than the client's perdag client groups base snapshot.\n * The base snapshot is persisted by gathering all memory-only chunks in the dag\n * subgraph rooted at the base snapshot's commit and writing them to the perdag.\n * Once the base snapshot is persisted, rebases onto this new base snapshot all\n * local commits from the client's perdag client group that are not already\n * reflected in the base snapshot.\n *\n * Whether or not the base snapshot is persisted, rebases onto the client's\n * perdag client group all memdag local commits not already in the client's\n * perdag client group's history.\n *\n * Also updates the `lastMutationIDs` and `lastServerAckdMutationIDs` properties\n * of the client's client group's entry in the `ClientGroupMap`.\n */\nexport async function persistDD31(\n  lc: LogContext,\n  clientID: ClientID,\n  memdag: LazyStore,\n  perdag: Store,\n  mutators: MutatorDefs,\n  closed: () => boolean,\n  formatVersion: FormatVersion,\n  getZeroData: ZeroOption['getTxData'] | undefined,\n  onGatherMemOnlyChunksForTest = () => Promise.resolve(),\n): Promise<void> {\n  if (closed()) {\n    return;\n  }\n\n  const [perdagLMID, perdagBaseSnapshot, mainClientGroupID] = await withRead(\n    perdag,\n    async perdagRead => {\n      await assertHasClientState(clientID, perdagRead);\n      const mainClientGroupID = await getClientGroupIDForClient(\n        clientID,\n        perdagRead,\n      );\n      assert(\n        mainClientGroupID,\n        `No main client group for clientID: ${clientID}`,\n      );\n      const [, perdagMainClientGroupHeadCommit] = await getClientGroupInfo(\n        perdagRead,\n        mainClientGroupID,\n      );\n      const perdagLMID = await perdagMainClientGroupHeadCommit.getMutationID(\n        clientID,\n        perdagRead,\n      );\n      const perdagBaseSnapshot = await baseSnapshotFromCommit(\n        perdagMainClientGroupHeadCommit,\n        perdagRead,\n      );\n      assertSnapshotCommitDD31(perdagBaseSnapshot);\n      return [perdagLMID, perdagBaseSnapshot, mainClientGroupID];\n    },\n  );\n\n  if (closed()) {\n    return;\n  }\n  const [newMemdagMutations, memdagBaseSnapshot, gatheredChunks] =\n    await withRead(memdag, async memdagRead => {\n      const memdagHeadCommit = await commitFromHead(\n        DEFAULT_HEAD_NAME,\n        memdagRead,\n      );\n      const newMutations = await localMutationsGreaterThan(\n        memdagHeadCommit,\n        {[clientID]: perdagLMID || 0},\n        memdagRead,\n      );\n      const memdagBaseSnapshot = await baseSnapshotFromCommit(\n        memdagHeadCommit,\n        memdagRead,\n      );\n      assertSnapshotCommitDD31(memdagBaseSnapshot);\n\n      let gatheredChunks: ReadonlyMap<Hash, Chunk> | undefined;\n      if (\n        compareCookiesForSnapshots(memdagBaseSnapshot, perdagBaseSnapshot) > 0\n      ) {\n        await onGatherMemOnlyChunksForTest();\n        // Might need to persist snapshot, we will have to double check\n        // after gathering the snapshot chunks from memdag\n        const memdagBaseSnapshotHash = memdagBaseSnapshot.chunk.hash;\n        // Gather all memory only chunks from base snapshot on the memdag.\n        const visitor = new GatherMemoryOnlyVisitor(memdagRead);\n        await visitor.visit(memdagBaseSnapshotHash);\n        gatheredChunks = visitor.gatheredChunks;\n      }\n\n      return [newMutations, memdagBaseSnapshot, gatheredChunks];\n    });\n\n  if (closed()) {\n    return;\n  }\n\n  let memdagBaseSnapshotPersisted = false;\n  const zeroDataForMemdagBaseSnapshot =\n    getZeroData && (await getZeroData(memdagBaseSnapshot.chunk.hash));\n\n  await withWrite(perdag, async perdagWrite => {\n    const [mainClientGroup, latestPerdagMainClientGroupHeadCommit] =\n      await getClientGroupInfo(perdagWrite, mainClientGroupID);\n\n    // These initial values for newMainClientGroupHeadHash, mutationIDs,\n    // lastServerAckdMutationIDs are correct for the case where the memdag\n    // snapshot is *not* persisted.  If the memdag snapshot is persisted\n    // these values are overwritten appropriately.\n    let newMainClientGroupHeadHash: Hash =\n      latestPerdagMainClientGroupHeadCommit.chunk.hash;\n    let mutationIDs: Record<ClientID, number> = {\n      ...mainClientGroup.mutationIDs,\n    };\n    let {lastServerAckdMutationIDs} = mainClientGroup;\n\n    if (gatheredChunks) {\n      // check if memdag snapshot still newer than perdag snapshot\n\n      const client = await mustGetClient(clientID, perdagWrite);\n      assertClientV6(client);\n\n      const latestPerdagBaseSnapshot = await baseSnapshotFromCommit(\n        latestPerdagMainClientGroupHeadCommit,\n        perdagWrite,\n      );\n      assertSnapshotCommitDD31(latestPerdagBaseSnapshot);\n\n      // check if memdag snapshot still newer than perdag snapshot\n      if (\n        compareCookiesForSnapshots(\n          memdagBaseSnapshot,\n          latestPerdagBaseSnapshot,\n        ) > 0\n      ) {\n        // still newer, persist memdag snapshot by writing chunks\n        memdagBaseSnapshotPersisted = true;\n        await Promise.all(\n          Array.from(gatheredChunks.values(), c => perdagWrite.putChunk(c)),\n        );\n\n        await setClient(\n          clientID,\n          {\n            ...client,\n            persistHash: memdagBaseSnapshot.chunk.hash,\n          },\n          perdagWrite,\n        );\n        // Rebase local mutations from perdag main client group onto new\n        // snapshot\n        newMainClientGroupHeadHash = memdagBaseSnapshot.chunk.hash;\n        const mainClientGroupLocalMutations = await localMutationsDD31(\n          mainClientGroup.headHash,\n          perdagWrite,\n        );\n\n        lastServerAckdMutationIDs = memdagBaseSnapshot.meta.lastMutationIDs;\n        mutationIDs = {...lastServerAckdMutationIDs};\n\n        newMainClientGroupHeadHash = await rebase(\n          mainClientGroupLocalMutations,\n          newMainClientGroupHeadHash,\n          perdagWrite,\n          mutators,\n          mutationIDs,\n          lc,\n          formatVersion,\n          zeroDataForMemdagBaseSnapshot,\n        );\n      }\n    }\n\n    let zeroDataForPerdagHeadCommit: ZeroTxData | undefined;\n    if (!memdagBaseSnapshotPersisted) {\n      zeroDataForPerdagHeadCommit =\n        getZeroData &&\n        (await getZeroData(newMainClientGroupHeadHash, {\n          openLazySourceRead: perdagWrite,\n        }));\n    }\n\n    // rebase new memdag mutations onto perdag\n    newMainClientGroupHeadHash = await rebase(\n      newMemdagMutations,\n      newMainClientGroupHeadHash,\n      perdagWrite,\n      mutators,\n      mutationIDs,\n      lc,\n      formatVersion,\n      zeroDataForPerdagHeadCommit ?? zeroDataForMemdagBaseSnapshot,\n    );\n\n    const newMainClientGroup = {\n      ...mainClientGroup,\n      headHash: newMainClientGroupHeadHash,\n      mutationIDs,\n      lastServerAckdMutationIDs,\n    };\n\n    await setClientGroup(mainClientGroupID, newMainClientGroup, perdagWrite);\n  });\n\n  if (gatheredChunks && memdagBaseSnapshotPersisted) {\n    await withWrite(memdag, memdagWrite =>\n      memdagWrite.chunksPersisted([...gatheredChunks.keys()]),\n    );\n  }\n}\n\nasync function getClientGroupInfo(\n  perdagRead: Read,\n  clientGroupID: ClientGroupID,\n): Promise<[ClientGroup, Commit<Meta>]> {\n  const clientGroup = await getClientGroup(clientGroupID, perdagRead);\n  assert(clientGroup, `No client group for clientGroupID: ${clientGroupID}`);\n  return [clientGroup, await commitFromHash(clientGroup.headHash, perdagRead)];\n}\n\nasync function rebase(\n  mutations: Commit<LocalMetaDD31>[],\n  basis: Hash,\n  write: Write,\n  mutators: MutatorDefs,\n  mutationIDs: Record<ClientID, number>,\n  lc: LogContext,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Hash> {\n  for (let i = mutations.length - 1; i >= 0; i--) {\n    const mutationCommit = mutations[i];\n    const {meta} = mutationCommit;\n    const newMainHead = await commitFromHash(basis, write);\n    if (\n      (await mutationCommit.getMutationID(meta.clientID, write)) >\n      (await newMainHead.getMutationID(meta.clientID, write))\n    ) {\n      mutationIDs[meta.clientID] = meta.mutationID;\n      basis = (\n        await rebaseMutationAndPutCommit(\n          mutationCommit,\n          write,\n          basis,\n          mutators,\n          lc,\n          meta.clientID,\n          formatVersion,\n          zeroData,\n        )\n      ).chunk.hash;\n    }\n  }\n  return basis;\n}\n","import {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {Chunk} from '../dag/chunk.ts';\nimport type {LazyStore} from '../dag/lazy-store.ts';\nimport type {Read} from '../dag/store.ts';\nimport {Visitor} from '../dag/visitor.ts';\nimport type {Hash} from '../hash.ts';\nimport {getSizeOfValue} from '../size-of-value.ts';\n\nexport type ChunkWithSize = {chunk: Chunk; size: number};\n\nexport class GatherNotCachedVisitor extends Visitor {\n  readonly #gatheredChunks: Map<Hash, ChunkWithSize> = new Map();\n  #gatheredChunksTotalSize = 0;\n  readonly #lazyStore: LazyStore;\n  readonly #gatherSizeLimit: number;\n  readonly #getSizeOfChunk: (chunk: Chunk) => number;\n\n  constructor(\n    dagRead: Read,\n    lazyStore: LazyStore,\n    gatherSizeLimit: number,\n    getSizeOfChunk: (chunk: Chunk) => number = getSizeOfValue,\n  ) {\n    super(dagRead);\n    this.#lazyStore = lazyStore;\n    this.#gatherSizeLimit = gatherSizeLimit;\n    this.#getSizeOfChunk = getSizeOfChunk;\n  }\n\n  get gatheredChunks(): ReadonlyMap<Hash, ChunkWithSize> {\n    return this.#gatheredChunks;\n  }\n\n  override visit(h: Hash): Promise<void> {\n    if (\n      this.#gatheredChunksTotalSize >= this.#gatherSizeLimit ||\n      this.#lazyStore.isCached(h)\n    ) {\n      return promiseVoid;\n    }\n    return super.visit(h);\n  }\n\n  override visitChunk(chunk: Chunk): Promise<void> {\n    if (this.#gatheredChunksTotalSize < this.#gatherSizeLimit) {\n      const size = this.#getSizeOfChunk(chunk);\n      this.#gatheredChunks.set(chunk.hash, {chunk, size});\n      this.#gatheredChunksTotalSize += size;\n    }\n\n    return super.visitChunk(chunk);\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {sleep} from '../../../shared/src/sleep.ts';\nimport type {LazyStore} from '../dag/lazy-store.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  Commit,\n  DEFAULT_HEAD_NAME,\n  type SnapshotMetaDD31,\n  assertSnapshotCommitDD31,\n  baseSnapshotFromCommit,\n  baseSnapshotFromHash,\n  baseSnapshotFromHead,\n  commitFromHash,\n  commitFromHead,\n  compareCookiesForSnapshots,\n  localMutationsGreaterThan,\n} from '../db/commit.ts';\nimport {rebaseMutationAndPutCommit} from '../db/rebase.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\nimport {\n  type DiffComputationConfig,\n  DiffsMap,\n  diffCommits,\n} from '../sync/diff.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport type {MutatorDefs} from '../types.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {\n  ClientStateNotFoundError,\n  type ClientV6,\n  assertClientV6,\n  getClientGroupForClient,\n  mustGetClient,\n  setClient,\n} from './clients.ts';\nimport {\n  type ChunkWithSize,\n  GatherNotCachedVisitor,\n} from './gather-not-cached-visitor.ts';\nimport type {ZeroOption} from '../replicache-options.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nconst GATHER_SIZE_LIMIT = 5 * 2 ** 20; // 5 MB\nconst DELAY_MS = 300;\n\ntype RefreshResult =\n  | {\n      type: 'aborted';\n      refreshHashesForRevert?: readonly Hash[] | undefined;\n    }\n  | {\n      type: 'complete';\n      diffs: DiffsMap;\n      newPerdagClientHeadHash: Hash;\n      oldHead: Hash;\n      newHead: Hash;\n    };\n\n/**\n * This returns the diff between the state of the btree before and after\n * refresh. It returns `undefined` if the refresh was aborted.\n */\nexport async function refresh(\n  lc: LogContext,\n  memdag: LazyStore,\n  perdag: Store,\n  clientID: ClientID,\n  mutators: MutatorDefs,\n  diffConfig: DiffComputationConfig,\n  closed: () => boolean,\n  formatVersion: FormatVersion,\n  zero: ZeroOption | undefined,\n): Promise<{oldHead: Hash; newHead: Hash; diffs: DiffsMap} | undefined> {\n  if (closed()) {\n    return;\n  }\n  const memdagBaseSnapshot = await withRead(memdag, memdagRead =>\n    baseSnapshotFromHead(DEFAULT_HEAD_NAME, memdagRead),\n  );\n  assertSnapshotCommitDD31(memdagBaseSnapshot);\n\n  type PerdagWriteResult = [\n    perdagClientGroupHeadHash: Hash,\n    perdagClientGroupBaseSnapshot: Commit<SnapshotMetaDD31>,\n    perdagLmid: number,\n    gatheredChunks: ReadonlyMap<Hash, ChunkWithSize>,\n    refreshHashesForRevert: readonly Hash[],\n  ];\n\n  // Suspend eviction and deletion of chunks cached by the lazy store\n  // to prevent cache misses.  If eviction and deletion are not suspended\n  // some chunks that are not gathered due to already being cached, may be\n  // evicted or deleted by the time the write lock is acquired on the memdag,\n  // which can lead to cache misses when performing the rebase and diff.\n  // It is important to avoid these cache misses because they often create jank\n  // because they block local mutations, pulls and queries on reading from idb.\n  // Cache misses can still happen during the rebase and diff, but only\n  // if the gather step hits its size limit.\n  const result: RefreshResult =\n    await memdag.withSuspendedSourceCacheEvictsAndDeletes(async () => {\n      const perdagWriteResult: PerdagWriteResult | undefined = await withWrite(\n        perdag,\n        async perdagWrite => {\n          const clientGroup = await getClientGroupForClient(\n            clientID,\n            perdagWrite,\n          );\n          if (!clientGroup) {\n            throw new ClientStateNotFoundError(clientID);\n          }\n\n          const perdagClientGroupHeadHash = clientGroup.headHash;\n          const perdagClientGroupHeadCommit = await commitFromHash(\n            perdagClientGroupHeadHash,\n            perdagWrite,\n          );\n          const perdagLmid = await perdagClientGroupHeadCommit.getMutationID(\n            clientID,\n            perdagWrite,\n          );\n\n          // Need to pull this head into memdag, but can't have it disappear if\n          // perdag moves forward while we're rebasing in memdag. Can't change\n          // client headHash until our rebase in memdag is complete, because if\n          // rebase fails, then nothing is keeping client's chunks alive in\n          // perdag.\n          const client = await mustGetClient(clientID, perdagWrite);\n          assertClientV6(client);\n          const perdagClientGroupBaseSnapshot = await baseSnapshotFromHash(\n            perdagClientGroupHeadHash,\n            perdagWrite,\n          );\n          assertSnapshotCommitDD31(perdagClientGroupBaseSnapshot);\n          if (\n            shouldAbortRefresh(\n              memdagBaseSnapshot,\n              perdagClientGroupBaseSnapshot,\n              perdagClientGroupHeadHash,\n            )\n          ) {\n            return undefined;\n          }\n\n          // To avoid pulling the entire perdag graph into the memdag\n          // the amount of chunk data gathered is limited by size.\n          const visitor = new GatherNotCachedVisitor(\n            perdagWrite,\n            memdag,\n            GATHER_SIZE_LIMIT,\n          );\n          await visitor.visit(perdagClientGroupHeadHash);\n          const {gatheredChunks} = visitor;\n\n          const refreshHashesSet = new Set(client.refreshHashes);\n          refreshHashesSet.add(perdagClientGroupHeadHash);\n\n          const newClient: ClientV6 = {\n            ...client,\n            refreshHashes: [...refreshHashesSet],\n          };\n\n          await setClient(clientID, newClient, perdagWrite);\n          return [\n            perdagClientGroupHeadHash,\n            perdagClientGroupBaseSnapshot,\n            perdagLmid,\n            gatheredChunks,\n            client.refreshHashes,\n          ];\n        },\n      );\n\n      if (closed() || !perdagWriteResult) {\n        return {\n          type: 'aborted',\n        } as const;\n      }\n      // pull/poke and refresh are racing to see who gets to update\n      // the memdag (the one with the newer base snapshot cookie wins)\n      // pull/poke updates are preferable so delay refresh slightly to\n      // make pull/poke the winner except when pull/pokes are slow.\n      // This is especially important for pokes, as refresh winning\n      // will result in the next poke's cookie not matching necessitating\n      // a disconnect/reconnect.\n      await sleep(DELAY_MS);\n      if (closed()) {\n        return {\n          type: 'aborted',\n        };\n      }\n\n      const [\n        perdagClientGroupHeadHash,\n        perdagClientGroupBaseSnapshot,\n        perdagLmid,\n        gatheredChunks,\n        refreshHashesForRevert,\n      ] = perdagWriteResult;\n      return withWrite(memdag, async memdagWrite => {\n        const memdagHeadCommit = await commitFromHead(\n          DEFAULT_HEAD_NAME,\n          memdagWrite,\n        );\n        const memdagBaseSnapshot = await baseSnapshotFromCommit(\n          memdagHeadCommit,\n          memdagWrite,\n        );\n        assertSnapshotCommitDD31(memdagBaseSnapshot);\n        if (\n          shouldAbortRefresh(\n            memdagBaseSnapshot,\n            perdagClientGroupBaseSnapshot,\n            perdagClientGroupHeadHash,\n          )\n        ) {\n          return {\n            type: 'aborted',\n            refreshHashesForRevert,\n          };\n        }\n\n        const newMemdagMutations = await localMutationsGreaterThan(\n          memdagHeadCommit,\n          {[clientID]: perdagLmid},\n          memdagWrite,\n        );\n        const ps = [];\n        for (const {chunk, size} of gatheredChunks.values()) {\n          ps.push(memdagWrite.putChunk(chunk, size));\n        }\n        await Promise.all(ps);\n\n        let newMemdagHeadHash = perdagClientGroupHeadHash;\n        if (newMemdagMutations.length > 0) {\n          const zeroData = await zero?.getTxData?.(newMemdagHeadHash, {\n            openLazyRead: memdagWrite,\n          });\n          for (let i = newMemdagMutations.length - 1; i >= 0; i--) {\n            newMemdagHeadHash = (\n              await rebaseMutationAndPutCommit(\n                newMemdagMutations[i],\n                memdagWrite,\n                newMemdagHeadHash,\n                mutators,\n                lc,\n                newMemdagMutations[i].meta.clientID,\n                formatVersion,\n                zeroData,\n              )\n            ).chunk.hash;\n          }\n        }\n\n        const newMemdagHeadCommit = await commitFromHash(\n          newMemdagHeadHash,\n          memdagWrite,\n        );\n        const diffs = await diffCommits(\n          memdagHeadCommit,\n          newMemdagHeadCommit,\n          memdagWrite,\n          diffConfig,\n          formatVersion,\n        );\n\n        await memdagWrite.setHead(DEFAULT_HEAD_NAME, newMemdagHeadHash);\n        return {\n          type: 'complete',\n          diffs,\n          oldHead: memdagHeadCommit.chunk.hash,\n          newHead: newMemdagHeadHash,\n          newPerdagClientHeadHash: perdagClientGroupHeadHash,\n        } as const;\n      });\n    });\n\n  if (closed()) {\n    return;\n  }\n\n  const setRefreshHashes = (refreshHashes: readonly Hash[]) =>\n    withWrite(perdag, async perdagWrite => {\n      const client = await mustGetClient(clientID, perdagWrite);\n      const newClient = {\n        ...client,\n        refreshHashes,\n      };\n\n      // If this cleanup never happens, it's no big deal, some data will stay\n      // alive longer but next refresh will fix it.\n      await setClient(clientID, newClient, perdagWrite);\n    });\n\n  if (result.type === 'aborted') {\n    if (result.refreshHashesForRevert) {\n      await setRefreshHashes(result.refreshHashesForRevert);\n    }\n    return undefined;\n  }\n\n  // Advance zero here before setting refresh hashes\n  // since we must advance before delegating control of the microtask\n  // loop.\n  zero?.advance(result.oldHead, result.newHead, result.diffs.get('') ?? []);\n  await setRefreshHashes([result.newPerdagClientHeadHash]);\n  return {\n    oldHead: result.oldHead,\n    newHead: result.newHead,\n    diffs: result.diffs,\n  };\n}\n\nfunction shouldAbortRefresh(\n  memdagBaseSnapshot: Commit<SnapshotMetaDD31>,\n  perdagClientGroupBaseSnapshot: Commit<SnapshotMetaDD31>,\n  perdagClientGroupHeadHash: Hash,\n): boolean {\n  const baseSnapshotCookieCompareResult = compareCookiesForSnapshots(\n    memdagBaseSnapshot,\n    perdagClientGroupBaseSnapshot,\n  );\n  return (\n    baseSnapshotCookieCompareResult > 0 ||\n    (baseSnapshotCookieCompareResult === 0 &&\n      perdagClientGroupHeadHash === perdagClientGroupBaseSnapshot.chunk.hash)\n  );\n}\n","import {type Resolver, resolver} from '@rocicorp/resolver';\nimport {AbortError} from '../../shared/src/abort-error.ts';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {sleep} from '../../shared/src/sleep.ts';\nimport {requestIdle as defaultRequestIdle} from './request-idle.ts';\n\nexport class ProcessScheduler {\n  readonly #process: () => Promise<void>;\n  readonly #idleTimeoutMs: number;\n  readonly #throttleMs: number;\n  readonly #abortSignal: AbortSignal;\n  readonly #requestIdle: typeof defaultRequestIdle;\n  #scheduledResolver: Resolver<void> | undefined = undefined;\n  #runResolver: Resolver<void> | undefined = undefined;\n  #runPromise = Promise.resolve();\n  #throttlePromise = Promise.resolve();\n\n  /**\n   * Supports scheduling a `process` to be run with certain constraints.\n   *  - Process runs are never concurrent.\n   *  - Multiple calls to schedule will be fulfilled by a single process\n   *    run started after the call to schedule.  A call is never fulfilled by an\n   *    already running process run.  This can be thought of as debouncing.\n   *  - Process runs are throttled so that the process runs at most once every\n   *    `throttleMs`.\n   *  - Process runs try to run during an idle period, but will delay at most\n   *    `idleTimeoutMs`.\n   *  - Scheduled runs which have not completed when `abortSignal` is aborted\n   *    will reject with an `AbortError`.\n   */\n  constructor(\n    process: () => Promise<void>,\n    idleTimeoutMs: number,\n    throttleMs: number,\n    abortSignal: AbortSignal,\n    requestIdle = defaultRequestIdle,\n  ) {\n    this.#process = process;\n    this.#idleTimeoutMs = idleTimeoutMs;\n    this.#throttleMs = throttleMs;\n    this.#abortSignal = abortSignal;\n    this.#requestIdle = requestIdle;\n    this.#abortSignal.addEventListener(\n      'abort',\n      () => {\n        const abortError = new AbortError('Aborted');\n        this.#runResolver?.reject(abortError);\n        this.#scheduledResolver?.reject(abortError);\n        this.#runResolver = undefined;\n        this.#scheduledResolver = undefined;\n      },\n      {once: true},\n    );\n  }\n\n  schedule(): Promise<void> {\n    if (this.#abortSignal.aborted) {\n      return Promise.reject(new AbortError('Aborted'));\n    }\n    if (this.#scheduledResolver) {\n      return this.#scheduledResolver.promise;\n    }\n    this.#scheduledResolver = resolver();\n    void this.#scheduleInternal();\n    return this.#scheduledResolver.promise;\n  }\n\n  async #scheduleInternal(): Promise<void> {\n    try {\n      await this.#runPromise;\n      // Prevent errors thrown by process from cancelling scheduled runs.\n      // this._runPromise is also awaited below and errors are explicitly\n      // propagated to promises returned from schedule.\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n    await this.#throttlePromise;\n    if (!this.#scheduledResolver) {\n      return;\n    }\n    await this.#requestIdle(this.#idleTimeoutMs);\n    if (!this.#scheduledResolver) {\n      return;\n    }\n    this.#throttlePromise = throttle(this.#throttleMs, this.#abortSignal);\n    this.#runResolver = this.#scheduledResolver;\n    this.#scheduledResolver = undefined;\n    try {\n      this.#runPromise = this.#process();\n      await this.#runPromise;\n      this.#runResolver?.resolve();\n    } catch (e) {\n      this.#runResolver?.reject(e);\n    }\n    this.#runResolver = undefined;\n  }\n}\n\nasync function throttle(\n  timeMs: number,\n  abortSignal: AbortSignal,\n): Promise<void> {\n  try {\n    await sleep(timeMs, abortSignal);\n  } catch (e) {\n    assert(e instanceof AbortError);\n  }\n}\n","// TODO(arv): Remove workaround once docs/ builds cleanly without this.\ndeclare function requestIdleCallback(\n  callback: () => void,\n  options?: {timeout?: number},\n): number;\n\n/**\n * A Promise wrapper for requestIdleCallback with fallback to setTimeout for\n * browsers without support (aka Safari)\n */\nexport function requestIdle(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    if (typeof requestIdleCallback === 'function') {\n      requestIdleCallback(() => resolve(), {timeout});\n    } else {\n      setTimeout(() => resolve(), timeout);\n    }\n  });\n}\n","export function setIntervalWithSignal(\n  fn: () => void,\n  ms: number,\n  signal: AbortSignal,\n): void {\n  if (!signal.aborted) {\n    const interval = setInterval(fn, ms);\n    signal.addEventListener('abort', () => {\n      clearInterval(interval);\n    });\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {compareUTF8, greaterThan, lessThan, lessThanEq} from 'compare-utf8';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {binarySearch} from '../../shared/src/binary-search.ts';\nimport type {Enum} from '../../shared/src/enum.ts';\nimport {deepEqual} from '../../shared/src/json.ts';\nimport type {\n  Diff,\n  DiffOperation,\n  IndexDiff,\n  InternalDiff,\n  InternalDiffOperation,\n  NoIndexDiff,\n} from './btree/node.ts';\nimport type {IndexKey} from './db/index.ts';\nimport {decodeIndexKey} from './db/index.ts';\nimport type {ScanOptions} from './db/scan.ts';\nimport * as InvokeKind from './invoke-kind-enum.ts';\nimport type {DiffComputationConfig, DiffsMap} from './sync/diff.ts';\nimport {\n  type ReadTransaction,\n  SubscriptionTransactionWrapper,\n} from './transactions.ts';\nimport type {QueryInternal} from './types.ts';\n\ntype InvokeKind = Enum<typeof InvokeKind>;\n\nexport interface Subscription<R> {\n  hasIndexSubscription(indexName: string): boolean;\n\n  invoke(\n    tx: ReadTransaction,\n    kind: InvokeKind,\n    diffs: DiffsMap | undefined,\n  ): Promise<R>;\n\n  matches(diffs: DiffsMap): boolean;\n\n  updateDeps(\n    keys: ReadonlySet<string>,\n    scans: ReadonlyArray<Readonly<ScanSubscriptionInfo>>,\n  ): void;\n\n  readonly onData: (result: R) => void;\n  readonly onError: ((error: unknown) => void) | undefined;\n  readonly onDone: (() => void) | undefined;\n}\n\nconst emptySet: ReadonlySet<string> = new Set();\n\nconst unitializedLastValue = Symbol();\ntype UnitializedLastValue = typeof unitializedLastValue;\n\nexport class SubscriptionImpl<R> implements Subscription<R> {\n  readonly #body: (tx: ReadTransaction) => Promise<R>;\n  readonly #onData: (result: R) => void;\n  #lastValue: R | UnitializedLastValue = unitializedLastValue;\n  #keys = emptySet;\n  #scans: readonly Readonly<ScanSubscriptionInfo>[] = [];\n\n  readonly onError: ((error: unknown) => void) | undefined;\n  readonly onDone: (() => void) | undefined;\n  readonly #isEqual: (a: R, b: R) => boolean;\n\n  constructor(\n    body: (tx: ReadTransaction) => Promise<R>,\n    onData: (result: R) => void,\n    onError: ((error: unknown) => void) | undefined,\n    onDone: (() => void) | undefined,\n    // deepEqual operates on any JSON value but argument might be more specific.\n    isEqual: (a: R, b: R) => boolean = deepEqual as (a: R, b: R) => boolean,\n  ) {\n    this.#body = body;\n    this.#onData = onData;\n    this.onError = onError;\n    this.onDone = onDone;\n    this.#isEqual = isEqual;\n  }\n\n  hasIndexSubscription(indexName: string): boolean {\n    for (const scan of this.#scans) {\n      if (scan.options.indexName === indexName) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  invoke(\n    tx: ReadTransaction,\n    _kind: InvokeKind,\n    _diffs: DiffsMap | undefined,\n  ): Promise<R> {\n    return this.#body(tx);\n  }\n\n  matches(diffs: DiffsMap): boolean {\n    for (const [indexName, diff] of diffs) {\n      if (diffMatchesSubscription(this.#keys, this.#scans, indexName, diff)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  updateDeps(\n    keys: ReadonlySet<string>,\n    scans: readonly Readonly<ScanSubscriptionInfo>[],\n  ): void {\n    this.#keys = keys;\n    this.#scans = scans;\n  }\n\n  onData(result: R): void {\n    if (\n      this.#lastValue === unitializedLastValue ||\n      !this.#isEqual(this.#lastValue, result)\n    ) {\n      this.#lastValue = result;\n      this.#onData(result);\n    }\n  }\n}\n\nexport {SubscriptionImpl as SubscriptionImplForTesting};\n\n/**\n * Function that gets passed into {@link Replicache.experimentalWatch} and gets\n * called when the data in Replicache changes.\n *\n * @experimental This type is experimental and may change in the future.\n */\nexport type WatchNoIndexCallback = (diff: NoIndexDiff) => void;\n\nexport type WatchCallbackForOptions<Options extends WatchOptions> =\n  Options extends WatchIndexOptions ? WatchIndexCallback : WatchNoIndexCallback;\n\n/**\n * Function that gets passed into {@link Replicache.experimentalWatch} when doing a\n * watch on a secondary index map and gets called when the data in Replicache\n * changes.\n *\n * @experimental This type is experimental and may change in the future.\n */\nexport type WatchIndexCallback = (diff: IndexDiff) => void;\n\n/**\n * Options for {@link Replicache.experimentalWatch}.\n *\n * @experimental This interface is experimental and may change in the future.\n */\nexport type WatchOptions = WatchIndexOptions | WatchNoIndexOptions;\n\n/**\n * Options object passed to {@link Replicache.experimentalWatch}. This is for an\n * index watch.\n */\nexport type WatchIndexOptions = WatchNoIndexOptions & {\n  /**\n   * When provided, the `watch` is limited to the changes that apply to the index map.\n   */\n  indexName: string;\n};\n\n/**\n * Options object passed to {@link Replicache.experimentalWatch}. This is for a non\n * index watch.\n */\nexport type WatchNoIndexOptions = {\n  /**\n   * When provided, the `watch` is limited to changes where the `key` starts\n   * with `prefix`.\n   */\n  prefix?: string | undefined;\n\n  /**\n   * When this is set to `true` (default is `false`), the `watch` callback will\n   * be called once asynchronously when watch is called. The arguments in that\n   * case is a diff where we consider all the existing values in Replicache as\n   * being added.\n   */\n  initialValuesInFirstDiff?: boolean | undefined;\n};\n\nexport type WatchCallback = (diff: Diff) => void;\n\nexport class WatchSubscription implements Subscription<Diff | undefined> {\n  readonly #callback: WatchCallback;\n  readonly #prefix: string;\n  readonly #indexName: string | undefined;\n  readonly #initialValuesInFirstDiff: boolean;\n\n  readonly onError: ((error: unknown) => void) | undefined = undefined;\n  readonly onDone: (() => void) | undefined = undefined;\n\n  constructor(callback: WatchCallback, options?: WatchOptions) {\n    this.#callback = callback;\n    this.#prefix = options?.prefix ?? '';\n    this.#indexName = (options as WatchIndexOptions)?.indexName;\n    this.#initialValuesInFirstDiff = options?.initialValuesInFirstDiff ?? false;\n  }\n\n  hasIndexSubscription(indexName: string): boolean {\n    return this.#indexName === indexName;\n  }\n\n  onData(result: Diff | undefined): void {\n    if (result !== undefined) {\n      this.#callback(result);\n    }\n  }\n\n  invoke(\n    tx: ReadTransaction,\n    kind: InvokeKind,\n    diffs: DiffsMap | undefined,\n  ): Promise<Diff | undefined> {\n    const invoke = async <Key extends IndexKey | string>(\n      indexName: string | undefined,\n      prefix: string,\n      compareKey: (diff: DiffOperation<Key>) => string,\n      convertInternalDiff: (\n        diff: InternalDiff,\n      ) => readonly DiffOperation<Key>[],\n    ): Promise<readonly DiffOperation<Key>[] | undefined> => {\n      let diff: readonly DiffOperation<Key>[];\n      if (kind === InvokeKind.InitialRun) {\n        if (!this.#initialValuesInFirstDiff) {\n          // We are using `undefined` here as a sentinel value to indicate that we\n          // should not call the callback in `onDone`.\n          return undefined;\n        }\n\n        // For the initial run, we need to get the \"diffs\" for the whole tree.\n        assert(diffs === undefined);\n\n        const newDiff: DiffOperation<Key>[] = [];\n        for await (const entry of tx.scan({prefix, indexName}).entries()) {\n          newDiff.push({\n            op: 'add',\n            key: entry[0] as Key,\n            newValue: entry[1],\n          });\n        }\n        diff = newDiff;\n      } else {\n        assert(diffs);\n        const maybeDiff = diffs.get(indexName ?? '') ?? [];\n        diff = convertInternalDiff(maybeDiff);\n      }\n      const newDiff: DiffOperation<Key>[] = [];\n      const {length} = diff;\n      for (\n        let i = diffBinarySearch(diff, prefix, compareKey);\n        i < length;\n        i++\n      ) {\n        if (compareKey(diff[i]).startsWith(prefix)) {\n          newDiff.push(diff[i]);\n        } else {\n          break;\n        }\n      }\n\n      // For initial run we should always return something.\n      return kind === InvokeKind.InitialRun || newDiff.length > 0\n        ? newDiff\n        : undefined;\n    };\n\n    if (this.#indexName) {\n      return invoke<IndexKey>(\n        this.#indexName,\n        this.#prefix,\n        diff => diff.key[0],\n        internalDiff => convertDiffValues(internalDiff, decodeIndexKey),\n      );\n    }\n\n    return invoke<string>(\n      undefined,\n      this.#prefix,\n      diff => diff.key,\n      internalDiff => convertDiffValues(internalDiff, k => k),\n    );\n  }\n\n  matches(diffs: DiffsMap): boolean {\n    const diff = diffs.get(this.#indexName ?? '');\n    if (diff === undefined) {\n      return false;\n    }\n\n    return watcherMatchesDiff(diff, this.#prefix, this.#indexName);\n  }\n\n  updateDeps(\n    _keys: ReadonlySet<string>,\n    _scans: readonly Readonly<ScanSubscriptionInfo>[],\n  ): void {\n    // not used\n  }\n}\n\nfunction convertDiffValues<Key>(\n  diff: InternalDiff,\n  convertKey: (k: string) => Key,\n): DiffOperation<Key>[] {\n  return diff.map(op => {\n    const key = convertKey(op.key);\n    switch (op.op) {\n      case 'add':\n        return {\n          op: 'add',\n          key,\n          newValue: op.newValue,\n        };\n      case 'change':\n        return {\n          op: 'change',\n          key,\n          oldValue: op.oldValue,\n          newValue: op.newValue,\n        };\n      case 'del':\n        return {\n          op: 'del',\n          key,\n          oldValue: op.oldValue,\n        };\n    }\n  });\n}\n\n/**\n * The options passed to {@link Replicache.subscribe}.\n */\nexport interface SubscribeOptions<R> {\n  /**\n   * Called when the return value of the body function changes.\n   */\n  onData: (result: R) => void;\n\n  /**\n   * If present, called when an error occurs.\n   */\n  onError?: ((error: unknown) => void) | undefined;\n\n  /**\n   * If present, called when the subscription is removed/done.\n   */\n  onDone?: (() => void) | undefined;\n\n  /**\n   * If present this function is used to determine if the value returned by the\n   * body function has changed. If not provided a JSON deep equality check is\n   * used.\n   */\n  isEqual?: ((a: R, b: R) => boolean) | undefined;\n}\n\nexport type UnknownSubscription = Subscription<unknown>;\n\ntype SubscriptionSet = Set<UnknownSubscription>;\n\nexport interface SubscriptionsManager extends DiffComputationConfig {\n  clear(): void;\n  fire(diffs: DiffsMap): Promise<void>;\n  hasPendingSubscriptionRuns: boolean;\n  add<R>(subscription: Subscription<R>): () => void;\n}\n\nexport class SubscriptionsManagerImpl implements SubscriptionsManager {\n  readonly #subscriptions: SubscriptionSet = new Set();\n  readonly #pendingSubscriptions: SubscriptionSet = new Set();\n  readonly #queryInternal: QueryInternal;\n  readonly #lc: LogContext;\n  hasPendingSubscriptionRuns = false;\n  readonly #signal: AbortSignal;\n\n  constructor(\n    queryInternal: QueryInternal,\n    lc: LogContext,\n    signal: AbortSignal,\n  ) {\n    this.#queryInternal = queryInternal;\n    this.#lc = lc;\n    this.#signal = signal;\n  }\n\n  add<R>(subscription: Subscription<R>): () => void {\n    this.#subscriptions.add(subscription as UnknownSubscription);\n    void this.#scheduleInitialSubscriptionRun(\n      subscription as UnknownSubscription,\n    );\n    return () =>\n      this.#subscriptions.delete(subscription as UnknownSubscription);\n  }\n\n  clear(): void {\n    for (const subscription of this.#subscriptions) {\n      subscription.onDone?.();\n    }\n    this.#subscriptions.clear();\n  }\n\n  fire(diffs: DiffsMap): Promise<void> {\n    const subscriptions = subscriptionsForDiffs(this.#subscriptions, diffs);\n    return this.#fireSubscriptions(subscriptions, InvokeKind.Regular, diffs);\n  }\n\n  async #fireSubscriptions(\n    subscriptions: Iterable<UnknownSubscription>,\n    kind: InvokeKind,\n    diffs: DiffsMap | undefined,\n  ) {\n    if (this.#signal.aborted) {\n      return;\n    }\n\n    const subs = [...subscriptions] as readonly Subscription<unknown>[];\n    if (subs.length === 0) {\n      return;\n    }\n\n    // Use allSettled to gather fulfilled and rejected promises.\n    const results = await this.#queryInternal(tx =>\n      Promise.allSettled(\n        subs.map(async s => {\n          const stx = new SubscriptionTransactionWrapper(tx);\n          try {\n            return await s.invoke(stx, kind, diffs);\n          } finally {\n            // We need to keep track of the subscription keys even if there was an\n            // exception because changes to the keys can make the subscription\n            // body succeed.\n            s.updateDeps(stx.keys, stx.scans);\n          }\n        }),\n      ),\n    );\n\n    this.callCallbacks(subs, results);\n  }\n\n  // Public method so that ZQL can wrap it in a transaction.\n  callCallbacks(\n    subs: readonly Subscription<unknown>[],\n    results: PromiseSettledResult<unknown>[],\n  ) {\n    for (let i = 0; i < subs.length; i++) {\n      const s = subs[i];\n      const result = results[i];\n      if (result.status === 'fulfilled') {\n        s.onData(result.value);\n      } else {\n        if (s.onError) {\n          s.onError(result.reason);\n        } else {\n          this.#lc.error?.('Error in subscription body:', result.reason);\n        }\n      }\n    }\n  }\n\n  async #scheduleInitialSubscriptionRun(s: UnknownSubscription) {\n    this.#pendingSubscriptions.add(s);\n\n    if (!this.hasPendingSubscriptionRuns) {\n      this.hasPendingSubscriptionRuns = true;\n      await Promise.resolve();\n      this.hasPendingSubscriptionRuns = false;\n      const subscriptions = [...this.#pendingSubscriptions];\n      this.#pendingSubscriptions.clear();\n      await this.#fireSubscriptions(\n        subscriptions,\n        InvokeKind.InitialRun,\n        undefined,\n      );\n    }\n  }\n\n  shouldComputeDiffs(): boolean {\n    return this.#subscriptions.size > 0;\n  }\n\n  shouldComputeDiffsForIndex(indexName: string): boolean {\n    for (const s of this.#subscriptions) {\n      if (s.hasIndexSubscription(indexName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport type ScanSubscriptionInfo = {\n  options: ScanOptions;\n  inclusiveLimitKey?: string | undefined;\n};\n\nfunction diffMatchesSubscription(\n  keys: ReadonlySet<string>,\n  scans: Iterable<Readonly<ScanSubscriptionInfo>>,\n  indexName: string,\n  diff: InternalDiff,\n): boolean {\n  // Keys can only match for non index scans.\n  if (indexName === '') {\n    for (const diffEntry of diff) {\n      if (keys.has(diffEntry.key)) {\n        return true;\n      }\n    }\n  }\n\n  for (const scanInfo of scans) {\n    if (scanInfoMatchesDiff(scanInfo, indexName, diff)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction scanInfoMatchesDiff(\n  scanInfo: ScanSubscriptionInfo,\n  changeIndexName: string,\n  diff: InternalDiff,\n): boolean {\n  // TODO(arv): Use binary search\n  for (const diffEntry of diff) {\n    if (scanInfoMatchesKey(scanInfo, changeIndexName, diffEntry.key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function scanInfoMatchesKey(\n  scanInfo: ScanSubscriptionInfo,\n  changeIndexName: string,\n  changedKey: string,\n): boolean {\n  const {\n    indexName = '',\n    limit,\n    prefix,\n    startKey,\n    startExclusive,\n    startSecondaryKey,\n  } = scanInfo.options;\n\n  if (changeIndexName !== indexName) {\n    return false;\n  }\n\n  if (!indexName) {\n    // A scan with limit <= 0 can have no matches\n    if (limit !== undefined && limit <= 0) {\n      return false;\n    }\n\n    // No prefix and no start. Must recompute the subscription because all keys\n    // will have an effect on the subscription.\n    if (!prefix && !startKey) {\n      return true;\n    }\n\n    if (\n      prefix &&\n      (!changedKey.startsWith(prefix) ||\n        isKeyPastInclusiveLimit(scanInfo, changedKey))\n    ) {\n      return false;\n    }\n\n    if (\n      startKey &&\n      ((startExclusive && lessThanEq(changedKey, startKey)) ||\n        lessThan(changedKey, startKey) ||\n        isKeyPastInclusiveLimit(scanInfo, changedKey))\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // No prefix and no start. Must recompute the subscription because all keys\n  // will have an effect on the subscription.\n  if (!prefix && !startKey && !startSecondaryKey) {\n    return true;\n  }\n\n  const [changedKeySecondary, changedKeyPrimary] = decodeIndexKey(changedKey);\n\n  if (prefix) {\n    if (!changedKeySecondary.startsWith(prefix)) {\n      return false;\n    }\n  }\n\n  if (\n    startSecondaryKey &&\n    ((startExclusive && lessThanEq(changedKeySecondary, startSecondaryKey)) ||\n      lessThan(changedKeySecondary, startSecondaryKey))\n  ) {\n    return false;\n  }\n\n  if (\n    startKey &&\n    ((startExclusive && lessThanEq(changedKeyPrimary, startKey)) ||\n      lessThan(changedKeyPrimary, startKey))\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isKeyPastInclusiveLimit(\n  scanInfo: ScanSubscriptionInfo,\n  changedKey: string,\n): boolean {\n  const {inclusiveLimitKey} = scanInfo;\n  return (\n    scanInfo.options.limit !== undefined &&\n    inclusiveLimitKey !== undefined &&\n    greaterThan(changedKey, inclusiveLimitKey)\n  );\n}\n\nfunction* subscriptionsForDiffs<V>(\n  subscriptions: Set<Subscription<V>>,\n  diffs: DiffsMap,\n): Generator<Subscription<V>> {\n  for (const subscription of subscriptions) {\n    if (subscription.matches(diffs)) {\n      yield subscription;\n    }\n  }\n}\n\nfunction watcherMatchesDiff(\n  diff: InternalDiff,\n  prefix: string,\n  indexName: string | undefined,\n): boolean {\n  if (prefix === '') {\n    return true;\n  }\n\n  const compareKey = indexName\n    ? (diffOp: InternalDiffOperation) => decodeIndexKey(diffOp.key)[0]\n    : (diffOp: InternalDiffOperation) => diffOp.key;\n  const i = diffBinarySearch(diff, prefix, compareKey);\n  return i < diff.length && compareKey(diff[i]).startsWith(prefix);\n}\n\nexport function diffBinarySearch<Key, Value>(\n  diff: readonly InternalDiffOperation<Key, Value>[],\n  prefix: string,\n  compareKey: (diff: InternalDiffOperation<Key, Value>) => string,\n): number {\n  return binarySearch(diff.length, i =>\n    compareUTF8(prefix, compareKey(diff[i])),\n  );\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const InitialRun = 0;\nexport const Regular = 1;\n\nexport type InitialRun = typeof InitialRun;\nexport type Regular = typeof Regular;\n","import {getNonCryptoRandomValues} from '../../../shared/src/random-values.ts';\nimport type {ClientID} from './ids.ts';\n\nlet sessionID = '';\nfunction getSessionID() {\n  if (sessionID === '') {\n    const buf = new Uint8Array(4);\n    getNonCryptoRandomValues(buf);\n    sessionID = Array.from(buf, x => x.toString(16)).join('');\n  }\n  return sessionID;\n}\n\nconst REQUEST_COUNTERS: Map<string, number> = new Map();\n\n/**\n * Returns a new requestID of the form <client ID>-<session ID>-<request\n * count>. The request count enables one to find the request following or\n * preceding a given request. The sessionid scopes the request count, ensuring\n * the requestID is probabilistically unique across restarts (which is good\n * enough).\n */\nexport function newRequestID(clientID: ClientID): string {\n  const counter = REQUEST_COUNTERS.get(clientID) ?? 0;\n  REQUEST_COUNTERS.set(clientID, counter + 1);\n  return `${clientID}-${getSessionID()}-${counter}`;\n}\n","// The env value should be filled in by esbuild.\n\ndeclare const process: {\n  env: {\n    ['REPLICACHE_VERSION']?: string;\n  };\n};\n\n/**\n * The current version of Replicache.\n */\nexport const version: string = process.env.REPLICACHE_VERSION ?? '0.0.0';\n","export class Subscribable<\n  TArgs,\n  TListener extends (obj: TArgs) => unknown = (obj: TArgs) => unknown,\n> {\n  protected _listeners = new Set<TListener>();\n\n  /**\n   * Subscribe to the subscribable.\n   *\n   * @param listener - The listener to subscribe to.\n   * @returns A function to unsubscribe from the subscribable.\n   */\n  subscribe = (listener: TListener): (() => void) => {\n    this._listeners.add(listener);\n\n    return () => {\n      this._listeners.delete(listener);\n    };\n  };\n\n  /**\n   * Notify all listeners.\n   *\n   * @param update - The update to notify listeners with.\n   */\n  notify = (update: TArgs): void => {\n    this._listeners.forEach(listener => listener(update));\n  };\n\n  hasListeners = (): boolean => this._listeners.size > 0;\n\n  /**\n   * Unsubscribe all listeners.\n   */\n  cleanup = (): void => {\n    this._listeners.clear();\n  };\n}\n","import * as v from '../../shared/src/valita.ts';\n\nexport const deleteClientsBodySchema = v.union(\n  v.readonlyObject({\n    clientIDs: v.readonlyArray(v.string()).optional(),\n    clientGroupIDs: v.readonlyArray(v.string()).optional(),\n  }),\n);\n\nexport const deleteClientsMessageSchema = v.tuple([\n  v.literal('deleteClients'),\n  deleteClientsBodySchema,\n]);\n\nexport type DeleteClientsBody = v.Infer<typeof deleteClientsBodySchema>;\nexport type DeleteClientsMessage = v.Infer<typeof deleteClientsMessageSchema>;\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {astSchema} from './ast.ts';\n\nexport const putOpSchema = v.object({\n  op: v.literal('put'),\n  hash: v.string(),\n  ttl: v.number().optional(),\n});\n\nexport const upPutOpSchema = putOpSchema.extend({\n  // All fields are optional in this transitional period.\n  // - ast is filled in for client queries\n  // - name and args are filled in for custom queries\n  ast: astSchema.optional(),\n  name: v.string().optional(),\n  args: v.readonly(v.array(jsonSchema)).optional(),\n});\n\nconst delOpSchema = v.object({\n  op: v.literal('del'),\n  hash: v.string(),\n});\n\nconst clearOpSchema = v.object({\n  op: v.literal('clear'),\n});\n\nconst patchOpSchema = v.union(putOpSchema, delOpSchema, clearOpSchema);\nconst upPatchOpSchema = v.union(upPutOpSchema, delOpSchema, clearOpSchema);\n\nexport const queriesPatchSchema = v.array(patchOpSchema);\nexport const upQueriesPatchSchema = v.array(upPatchOpSchema);\n\nexport type QueriesPutOp = v.Infer<typeof putOpSchema>;\nexport type QueriesDelOp = v.Infer<typeof delOpSchema>;\nexport type QueriesClearOp = v.Infer<typeof clearOpSchema>;\nexport type QueriesPatchOp = v.Infer<typeof patchOpSchema>;\nexport type UpQueriesPatchOp = v.Infer<typeof upPatchOpSchema>;\nexport type QueriesPatch = v.Infer<typeof queriesPatchSchema>;\nexport type UpQueriesPatch = v.Infer<typeof upQueriesPatchSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {clientSchemaSchema} from './client-schema.ts';\nimport {deleteClientsBodySchema} from './delete-clients.ts';\nimport {upQueriesPatchSchema} from './queries-patch.ts';\n\n/**\n * After opening a websocket the client waits for a `connected` message\n * from the server.  It then sends an `initConnection` message to the\n * server.  The server waits for the `initConnection` message before\n * beginning to send pokes to the newly connected client, so as to avoid\n * syncing lots of queries which are no longer desired by the client.\n */\n\nexport const connectedBodySchema = v.object({\n  wsid: v.string(),\n  timestamp: v.number().optional(),\n});\n\nexport const connectedMessageSchema = v.tuple([\n  v.literal('connected'),\n  connectedBodySchema,\n]);\n\nconst userQueryMutateParamsSchema = v.object({\n  /**\n   * A client driven URL to send queries or mutations to.\n   * This URL must match one of the URLs set in the zero config.\n   *\n   * E.g., Given the following environment variable:\n   * ZERO_GET_QUERIES_URL=[https://*.example.com/query]\n   *\n   * Then this URL could be:\n   * https://myapp.example.com/query\n   */\n  url: v.string().optional(),\n  // The query string to use for query or mutation calls.\n  queryParams: v.record(v.string()).optional(),\n});\n\nconst initConnectionBodySchema = v.object({\n  desiredQueriesPatch: upQueriesPatchSchema,\n  clientSchema: clientSchemaSchema.optional(),\n  deleted: deleteClientsBodySchema.optional(),\n  // parameters to configure the mutate endpoint\n  userPushParams: userQueryMutateParamsSchema.optional(),\n  // parameters to configure the query endpoint\n  userQueryParams: userQueryMutateParamsSchema.optional(),\n\n  /**\n   * `activeClients` is an optional array of client IDs that are currently active\n   * in the client group. This is used to inform the server about the clients\n   * that are currently active (aka running, aka alive), so it can inactive\n   * queries from inactive clients.\n   */\n  activeClients: v.array(v.string()).optional(),\n});\n\nexport const initConnectionMessageSchema = v.tuple([\n  v.literal('initConnection'),\n  initConnectionBodySchema,\n]);\n\nexport type ConnectedBody = v.Infer<typeof connectedBodySchema>;\nexport type ConnectedMessage = v.Infer<typeof connectedMessageSchema>;\nexport type UserMutateParams = v.Infer<typeof userQueryMutateParamsSchema>;\nexport type UserQueryParams = v.Infer<typeof userQueryMutateParamsSchema>;\n\nexport type InitConnectionBody = v.Infer<typeof initConnectionBodySchema>;\nexport type InitConnectionMessage = v.Infer<typeof initConnectionMessageSchema>;\n\nexport function encodeSecProtocols(\n  initConnectionMessage: InitConnectionMessage | undefined,\n  authToken: string | undefined,\n): string {\n  const protocols = {\n    initConnectionMessage,\n    authToken,\n  };\n  // WS sec protocols needs to be URI encoded. To save space, we base64 encode\n  // the JSON before URI encoding it. But InitConnectionMessage can contain\n  // arbitrary unicode strings, so we need to encode the JSON as UTF-8 first.\n  // Phew!\n  const bytes = new TextEncoder().encode(JSON.stringify(protocols));\n\n  // Convert bytes to string without spreading all bytes as arguments\n  // to avoid \"Maximum call stack size exceeded\" error with large data\n  const s = Array.from(bytes, byte => String.fromCharCode(byte)).join('');\n\n  return encodeURIComponent(btoa(s));\n}\n\nexport function decodeSecProtocols(secProtocol: string): {\n  initConnectionMessage: InitConnectionMessage | undefined;\n  authToken: string | undefined;\n} {\n  const binString = atob(decodeURIComponent(secProtocol));\n  const bytes = Uint8Array.from(binString, c => c.charCodeAt(0));\n  return JSON.parse(new TextDecoder().decode(bytes));\n}\n","import * as v from '../../shared/src/valita.ts';\nimport {ErrorKind} from './error-kind.ts';\n\nconst basicErrorKindSchema = v.literalUnion(\n  ErrorKind.AuthInvalidated,\n  ErrorKind.ClientNotFound,\n  ErrorKind.InvalidConnectionRequest,\n  ErrorKind.InvalidConnectionRequestBaseCookie,\n  ErrorKind.InvalidConnectionRequestLastMutationID,\n  ErrorKind.InvalidConnectionRequestClientDeleted,\n  ErrorKind.InvalidMessage,\n  ErrorKind.InvalidPush,\n  ErrorKind.MutationRateLimited,\n  ErrorKind.MutationFailed,\n  ErrorKind.Unauthorized,\n  ErrorKind.VersionNotSupported,\n  ErrorKind.SchemaVersionNotSupported,\n  ErrorKind.Internal,\n);\n\nconst basicErrorBodySchema = v.object({\n  kind: basicErrorKindSchema,\n  message: v.string(),\n});\n\nconst backoffErrorKindSchema = v.literalUnion(\n  ErrorKind.Rebalance,\n  ErrorKind.Rehome,\n  ErrorKind.ServerOverloaded,\n);\n\nconst backoffBodySchema = v.object({\n  kind: backoffErrorKindSchema,\n  message: v.string(),\n  minBackoffMs: v.number().optional(),\n  maxBackoffMs: v.number().optional(),\n  // Query parameters to send in the next reconnect. In the event of\n  // a conflict, these will be overridden by the parameters used by\n  // the client; it is the responsibility of the server to avoid\n  // parameter name conflicts.\n  //\n  // The parameters will only be added to the immediately following\n  // reconnect, and not after that.\n  reconnectParams: v.record(v.string()).optional(),\n});\n\nexport const errorKindSchema: v.Type<ErrorKind> = v.union(\n  basicErrorKindSchema,\n  backoffErrorKindSchema,\n);\n\nexport const errorBodySchema = v.union(basicErrorBodySchema, backoffBodySchema);\n\nexport type BackoffBody = v.Infer<typeof backoffBodySchema>;\n\nexport type ErrorBody = v.Infer<typeof errorBodySchema>;\n\nexport const errorMessageSchema: v.Type<ErrorMessage> = v.tuple([\n  v.literal('error'),\n  errorBodySchema,\n]);\n\nexport type ErrorMessage = ['error', ErrorBody];\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const CRUD = 'crud';\nexport const Custom = 'custom';\nexport type MutationType = typeof CRUD | typeof Custom;\n\nexport type CRUD = typeof CRUD;\nexport type Custom = typeof Custom;\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport type {NameMapper} from '../../zero-schema/src/name-mapper.ts';\nimport {rowSchema} from './data.ts';\nimport * as MutationType from './mutation-type-enum.ts';\nimport {primaryKeySchema, primaryKeyValueRecordSchema} from './primary-key.ts';\n\n// NOTE! If you change this name you must also change the\n// string in `replicache-impl.ts` But CRUD mutators are being\n// deleted soon so this should not happen.\nexport const CRUD_MUTATION_NAME = '_zero_crud';\n\n/**\n * Inserts if entity with id does not already exist.\n */\nconst insertOpSchema = v.object({\n  op: v.literal('insert'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  value: rowSchema,\n});\n\n/**\n * Upsert semantics. Inserts if entity with id does not already exist,\n * otherwise updates existing entity with id.\n */\nconst upsertOpSchema = v.object({\n  op: v.literal('upsert'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  value: rowSchema,\n});\n\n/**\n * Updates if entity with id exists, otherwise does nothing.\n */\nconst updateOpSchema = v.object({\n  op: v.literal('update'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  // Partial value with at least the primary key fields\n  value: rowSchema,\n});\n\n/**\n * Deletes entity with id if it exists, otherwise does nothing.\n */\nconst deleteOpSchema = v.object({\n  op: v.literal('delete'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  // Partial value representing the primary key\n  value: primaryKeyValueRecordSchema,\n});\n\nconst crudOpSchema = v.union(\n  insertOpSchema,\n  upsertOpSchema,\n  updateOpSchema,\n  deleteOpSchema,\n);\n\nconst crudArgSchema = v.object({\n  ops: v.array(crudOpSchema),\n});\n\nconst crudArgsSchema = v.tuple([crudArgSchema]);\n\nexport const crudMutationSchema = v.object({\n  type: v.literal(MutationType.CRUD),\n  id: v.number(),\n  clientID: v.string(),\n  name: v.literal(CRUD_MUTATION_NAME),\n  args: crudArgsSchema,\n  timestamp: v.number(),\n});\n\nexport const customMutationSchema = v.object({\n  type: v.literal(MutationType.Custom),\n  id: v.number(),\n  clientID: v.string(),\n  name: v.string(),\n  args: v.array(jsonSchema),\n  timestamp: v.number(),\n});\n\nexport const mutationSchema = v.union(crudMutationSchema, customMutationSchema);\n\nexport const pushBodySchema = v.object({\n  clientGroupID: v.string(),\n  mutations: v.array(mutationSchema),\n  pushVersion: v.number(),\n  // For legacy (CRUD) mutations, the schema is tied to the client group /\n  // sync connection. For custom mutations, schema versioning is delegated\n  // to the custom protocol / api-server.\n  schemaVersion: v.number().optional(),\n  timestamp: v.number(),\n  requestID: v.string(),\n});\n\nexport const pushMessageSchema = v.tuple([v.literal('push'), pushBodySchema]);\nexport const mutationIDSchema = v.object({\n  id: v.number(),\n  clientID: v.string(),\n});\n\nconst appErrorSchema = v.object({\n  error: v.literal('app'),\n  // The user can return any additional data here\n  details: jsonSchema.optional(),\n});\nconst zeroErrorSchema = v.object({\n  error: v.literalUnion('oooMutation', 'alreadyProcessed'),\n  details: jsonSchema.optional(),\n});\n\nconst mutationOkSchema = v.object({\n  // The user can return any additional data here\n  data: jsonSchema.optional(),\n});\nconst mutationErrorSchema = v.union(appErrorSchema, zeroErrorSchema);\n\nexport const mutationResultSchema = v.union(\n  mutationOkSchema,\n  mutationErrorSchema,\n);\n\nexport const mutationResponseSchema = v.object({\n  id: mutationIDSchema,\n  result: mutationResultSchema,\n});\n\nconst pushOkSchema = v.object({\n  mutations: v.array(mutationResponseSchema),\n});\n\nconst unsupportedPushVersionSchema = v.object({\n  error: v.literal('unsupportedPushVersion'),\n  // optional for backwards compatibility\n  // This field is included so the client knows which mutations\n  // were not processed by the server.\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\nconst unsupportedSchemaVersionSchema = v.object({\n  error: v.literal('unsupportedSchemaVersion'),\n  // optional for backwards compatibility\n  // This field is included so the client knows which mutations\n  // were not processed by the server.\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\nconst httpErrorSchema = v.object({\n  error: v.literal('http'),\n  status: v.number(),\n  details: v.string(),\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\nconst zeroPusherErrorSchema = v.object({\n  error: v.literal('zeroPusher'),\n  details: v.string(),\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\n\nconst pushErrorSchema = v.union(\n  unsupportedPushVersionSchema,\n  unsupportedSchemaVersionSchema,\n  httpErrorSchema,\n  zeroPusherErrorSchema,\n);\n\nexport const pushResponseSchema = v.union(pushOkSchema, pushErrorSchema);\nexport const pushResponseMessageSchema = v.tuple([\n  v.literal('pushResponse'),\n  pushResponseSchema,\n]);\n\nexport const ackMutationResponsesMessageSchema = v.tuple([\n  v.literal('ackMutationResponses'),\n  mutationIDSchema,\n]);\n\n/**\n * The schema for the querystring parameters of the custom push endpoint.\n */\nexport const pushParamsSchema = v.object({\n  schema: v.string(),\n  appID: v.string(),\n});\n\nexport type InsertOp = v.Infer<typeof insertOpSchema>;\nexport type UpsertOp = v.Infer<typeof upsertOpSchema>;\nexport type UpdateOp = v.Infer<typeof updateOpSchema>;\nexport type DeleteOp = v.Infer<typeof deleteOpSchema>;\nexport type CRUDOp = v.Infer<typeof crudOpSchema>;\nexport type CRUDOpKind = CRUDOp['op'];\nexport type CRUDMutationArg = v.Infer<typeof crudArgSchema>;\nexport type CRUDMutation = v.Infer<typeof crudMutationSchema>;\nexport type CustomMutation = v.Infer<typeof customMutationSchema>;\nexport type Mutation = v.Infer<typeof mutationSchema>;\nexport type PushBody = v.Infer<typeof pushBodySchema>;\nexport type PushMessage = v.Infer<typeof pushMessageSchema>;\nexport type PushResponse = v.Infer<typeof pushResponseSchema>;\nexport type PushResponseMessage = v.Infer<typeof pushResponseMessageSchema>;\nexport type MutationResponse = v.Infer<typeof mutationResponseSchema>;\nexport type MutationOk = v.Infer<typeof mutationOkSchema>;\nexport type MutationError = v.Infer<typeof mutationErrorSchema>;\nexport type PushError = v.Infer<typeof pushErrorSchema>;\nexport type PushOk = v.Infer<typeof pushOkSchema>;\nexport type MutationID = v.Infer<typeof mutationIDSchema>;\nexport type MutationResult = v.Infer<typeof mutationResultSchema>;\nexport type AckMutationMessage = v.Infer<\n  typeof ackMutationResponsesMessageSchema\n>;\n\nexport function mapCRUD(\n  arg: CRUDMutationArg,\n  map: NameMapper,\n): CRUDMutationArg {\n  return {\n    ops: arg.ops.map(\n      ({op, tableName, primaryKey, value}) =>\n        ({\n          op,\n          tableName: map.tableName(tableName),\n          primaryKey: map.columns(tableName, primaryKey),\n          value: map.row(tableName, value),\n          // The cast is necessary because ts objects to the `value` field\n          // for \"delete\" ops being different.\n        }) as unknown as CRUDOp,\n    ),\n  };\n}\n","import * as v from '../../shared/src/valita.ts';\nimport {mutationIDSchema, mutationResponseSchema} from './push.ts';\n\n/**\n * Mutation results are stored ephemerally in the client\n * hence why we only have the `put` operation.\n *\n * On put the mutation promise is resolved/rejected\n * and reference released.\n */\nexport const putOpSchema = v.object({\n  op: v.literal('put'),\n  mutation: mutationResponseSchema,\n});\nexport const delOpSchema = v.object({\n  op: v.literal('del'),\n  id: mutationIDSchema,\n});\n\nconst patchOpSchema = v.union(putOpSchema, delOpSchema);\nexport const mutationsPatchSchema = v.array(patchOpSchema);\nexport type MutationPatch = v.Infer<typeof patchOpSchema>;\n","import {jsonObjectSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {rowSchema} from './data.ts';\nimport {primaryKeyValueRecordSchema} from './primary-key.ts';\n\nconst putOpSchema = v.object({\n  op: v.literal('put'),\n  tableName: v.string(),\n  value: rowSchema,\n});\n\nconst updateOpSchema = v.object({\n  op: v.literal('update'),\n  tableName: v.string(),\n  id: primaryKeyValueRecordSchema,\n  merge: jsonObjectSchema.optional(),\n  constrain: v.array(v.string()).optional(),\n});\n\nconst delOpSchema = v.object({\n  op: v.literal('del'),\n  tableName: v.string(),\n  id: primaryKeyValueRecordSchema,\n});\n\nconst clearOpSchema = v.object({\n  op: v.literal('clear'),\n});\n\nconst rowPatchOpSchema = v.union(\n  putOpSchema,\n  updateOpSchema,\n  delOpSchema,\n  clearOpSchema,\n);\n\nexport const rowsPatchSchema = v.array(rowPatchOpSchema);\nexport type RowPatchOp = v.Infer<typeof rowPatchOpSchema>;\n","import * as v from '../../shared/src/valita.ts';\n\nexport const versionSchema = v.string();\nexport const nullableVersionSchema = v.union(versionSchema, v.null());\n\nexport type Version = v.Infer<typeof versionSchema>;\nexport type NullableVersion = v.Infer<typeof nullableVersionSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {mutationsPatchSchema} from './mutations-patch.ts';\nimport {queriesPatchSchema} from './queries-patch.ts';\nimport {rowsPatchSchema} from './row-patch.ts';\nimport {nullableVersionSchema, versionSchema} from './version.ts';\n\n/**\n * Pokes use a multi-part format. Pokes send entity data to the client and can\n * be multiple mega-bytes in size. Using a multi-part format allows the server\n * to avoid having to have the full poke in memory at one time.\n *\n * Each poke is assigned a `pokeID`, a unique id (within the context of the\n * connection) for identifying the poke.  All messages for a poke will have the\n * same `pokeID`.\n *\n * A poke begins with a `poke-start` message which contains the `baseCookie`\n * the poke is updating from and the `cookie` the poke is updating to.\n *\n * The poke continues with zero to many `poke-part` messages, each of which\n * can contain patch parts.  These patch parts should be merged in the order\n * received.\n *\n * Finally, the poke ends with a `poke-end` message.  The merged `poke-parts`\n * can now be applied as a whole to update from `baseCookie` to `cookie`.\n *\n * Poke messages can be intermingled with other `down` messages, but cannot be\n * intermingled with poke messages for a different `pokeID`. If this is\n * observed it is an unexpected error; the client should ignore both pokes,\n * disconnect, and reconnect.\n */\n\nexport const pokeStartBodySchema = v.object({\n  pokeID: v.string(),\n  // We always specify a Version as our cookie, but Replicache starts clients\n  // with initial cookie `null`, before the first request. So we have to be\n  // able to send a base cookie with value `null` to match that state.\n  baseCookie: nullableVersionSchema,\n  /**\n   * This field is always set if the poke contains a `rowsPatch`.\n   * It may be absent for patches that only update clients and queries.\n   */\n  schemaVersions: v\n    .object({\n      minSupportedVersion: v.number(),\n      maxSupportedVersion: v.number(),\n    })\n    .optional(),\n  timestamp: v.number().optional(),\n});\n\nexport const pokePartBodySchema = v.object({\n  pokeID: v.string(),\n  // Changes to last mutation id by client id.\n  lastMutationIDChanges: v.record(v.number()).optional(),\n  // Patches to the desired query sets by client id.\n  desiredQueriesPatches: v.record(queriesPatchSchema).optional(),\n  // Patches to the set of queries for which entities are sync'd in\n  // rowsPatch.\n  gotQueriesPatch: queriesPatchSchema.optional(),\n  // Patches to the rows set.\n  rowsPatch: rowsPatchSchema.optional(),\n  // Mutation results patch\n  mutationsPatch: mutationsPatchSchema.optional(),\n});\n\nexport const pokeEndBodySchema = v.object({\n  pokeID: v.string(),\n  // Note: This should be ignored (and may be empty) if cancel === `true`.\n  cookie: versionSchema,\n  // If `true`, the poke with id `pokeID` should be discarded without\n  // applying it.\n  cancel: v.boolean().optional(),\n});\n\nexport const pokeStartMessageSchema = v.tuple([\n  v.literal('pokeStart'),\n  pokeStartBodySchema,\n]);\nexport const pokePartMessageSchema = v.tuple([\n  v.literal('pokePart'),\n  pokePartBodySchema,\n]);\nexport const pokeEndMessageSchema = v.tuple([\n  v.literal('pokeEnd'),\n  pokeEndBodySchema,\n]);\n\nexport type PokeStartBody = v.Infer<typeof pokeStartBodySchema>;\nexport type PokePartBody = v.Infer<typeof pokePartBodySchema>;\nexport type PokeEndBody = v.Infer<typeof pokeEndBodySchema>;\n\nexport type PokeStartMessage = v.Infer<typeof pokeStartMessageSchema>;\nexport type PokePartMessage = v.Infer<typeof pokePartMessageSchema>;\nexport type PokeEndMessage = v.Infer<typeof pokeEndMessageSchema>;\n","import * as v from '../../shared/src/valita.ts';\n\nexport const pongBodySchema = v.object({});\nexport const pongMessageSchema = v.tuple([v.literal('pong'), pongBodySchema]);\n\nexport type PongBody = v.Infer<typeof pongBodySchema>;\nexport type PongMessage = v.Infer<typeof pongMessageSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {nullableVersionSchema, versionSchema} from './version.ts';\n\nexport const pullRequestBodySchema = v.object({\n  clientGroupID: v.string(),\n  cookie: nullableVersionSchema,\n  requestID: v.string(),\n});\n\nexport const pullResponseBodySchema = v.object({\n  cookie: versionSchema,\n  // Matches pullRequestBodySchema requestID that initiated this response\n  requestID: v.string(),\n  lastMutationIDChanges: v.record(v.number()),\n  // Pull is currently only used for mutation recovery which does not use\n  // the patch so we save work by not computing the patch.\n});\n\nexport const pullRequestMessageSchema = v.tuple([\n  v.literal('pull'),\n  pullRequestBodySchema,\n]);\n\nexport const pullResponseMessageSchema = v.tuple([\n  v.literal('pull'),\n  pullResponseBodySchema,\n]);\n\nexport type PullRequestBody = v.Infer<typeof pullRequestBodySchema>;\nexport type PullResponseBody = v.Infer<typeof pullResponseBodySchema>;\n\nexport type PullRequestMessage = v.Infer<typeof pullRequestMessageSchema>;\nexport type PullResponseMessage = v.Infer<typeof pullResponseMessageSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {connectedMessageSchema} from './connect.ts';\nimport {transformErrorMessageSchema} from './custom-queries.ts';\nimport {deleteClientsMessageSchema} from './delete-clients.ts';\nimport {errorMessageSchema} from './error.ts';\nimport {inspectDownMessageSchema} from './inspect-down.ts';\nimport {\n  pokeEndMessageSchema,\n  pokePartMessageSchema,\n  pokeStartMessageSchema,\n} from './poke.ts';\nimport {pongMessageSchema} from './pong.ts';\nimport {pullResponseMessageSchema} from './pull.ts';\nimport {pushResponseMessageSchema} from './push.ts';\n\nexport const downstreamSchema = v.union(\n  connectedMessageSchema,\n  errorMessageSchema,\n  pongMessageSchema,\n  pokeStartMessageSchema,\n  pokePartMessageSchema,\n  pokeEndMessageSchema,\n  pullResponseMessageSchema,\n  deleteClientsMessageSchema,\n  pushResponseMessageSchema,\n  inspectDownMessageSchema,\n  transformErrorMessageSchema,\n);\n\nexport type Downstream = v.Infer<typeof downstreamSchema>;\n","import {assert} from '../../shared/src/asserts.ts';\n\n/**\n * The current `PROTOCOL_VERSION` of the code.\n *\n * The `PROTOCOL_VERSION` encompasses both the wire-protocol of the `/sync/...`\n * connection between the browser and `zero-cache`, as well as the format of\n * the `AST` objects stored in both components (i.e. IDB and CVR).\n *\n * A change in the `AST` schema (e.g. new functionality added) must be\n * accompanied by an increment of the `PROTOCOL_VERSION` and a new major\n * release. The server (`zero-cache`) must be deployed before clients start\n * running the new code.\n */\n// History:\n// -- Version 5 adds support for `pokeEnd.cookie`. (0.14)\n// -- Version 6 makes `pokeStart.cookie` optional. (0.16)\n// -- Version 7 introduces the initConnection.clientSchema field. (0.17)\n// -- Version 8 drops support for Version 5 (0.18).\n// -- Version 11 adds inspect queries. (0.18)\n// -- Version 12 adds 'timestamp' and 'date' types to the ClientSchema ValueType. (not shipped, reversed by version 14)\n// -- Version 14 removes 'timestamp' and 'date' types from the ClientSchema ValueType. (0.18)\n// -- Version 15 adds a `userPushParams` field to `initConnection` (0.19)\n// -- Version 16 adds a new error type (alreadyProcessed) to mutation responses (0.19)\n// -- Version 17 deprecates `AST` in downstream query puts. It was never used anyway. (0.21)\n// -- Version 18 adds `name` and `args` to the `queries-patch` protocol (0.21)\n// -- Version 19 adds `activeClients` to the `initConnection` protocol (0.22)\n// -- Version 20 changes inspector down message (0.22)\n// -- Version 21 removes `AST` in downstream query puts which was deprecated in Version 17, removes support for versions < 18 (0.22)\n// -- Version 22 adds an optional 'userQueryParams' field to `initConnection` (0.22)\n// -- Version 23 add `mutationResults` to poke (0.22)\n// -- Version 24 adds `ackMutationResults` to upstream (0.22).\n// -- version 25 modifies `mutationsResults` to include `del` patches (0.22)\n// -- version 26 adds inspect/metrics and adds metrics to inspect/query (0.23)\n// -- version 27 adds inspect/version (0.23)\n// -- version 28 adds more inspect/metrics (0.23)\n// -- version 29 adds error responses for custom queries (0.23)\nexport const PROTOCOL_VERSION = 29;\n\n/**\n * The minimum server-supported sync protocol version (i.e. the version\n * declared in the \"/sync/v{#}/connect\" URL). The contract for\n * backwards compatibility is that a `zero-cache` supports the current\n * `PROTOCOL_VERSION` and at least the previous one (i.e. `PROTOCOL_VERSION - 1`)\n * if not earlier ones as well. This corresponds to supporting clients running\n * the current release and the previous (major) release. Any client connections\n * from protocol versions before `MIN_SERVER_SUPPORTED_PROTOCOL_VERSION` are\n * closed with a `VersionNotSupported` error.\n */\nexport const MIN_SERVER_SUPPORTED_SYNC_PROTOCOL = 18;\n\nassert(MIN_SERVER_SUPPORTED_SYNC_PROTOCOL < PROTOCOL_VERSION);\n","import type {JSONValue} from '../../shared/src/json.ts';\nimport type {Value} from '../../zero-protocol/src/data.ts';\nimport type {TableSchema} from './table-schema.ts';\n\ntype ColumnNames = {[src: string]: string};\n\ntype DestNames = {\n  tableName: string;\n  columns: ColumnNames;\n  allColumnsSame: boolean;\n};\n\nexport function clientToServer(\n  tables: Record<string, TableSchema>,\n): NameMapper {\n  return createMapperFrom('client', tables);\n}\n\nexport function serverToClient(\n  tables: Record<string, TableSchema>,\n): NameMapper {\n  return createMapperFrom('server', tables);\n}\n\nfunction createMapperFrom(\n  src: 'client' | 'server',\n  tables: Record<string, TableSchema>,\n): NameMapper {\n  const mapping = new Map(\n    Object.entries(tables).map(\n      ([tableName, {serverName: serverTableName, columns}]) => {\n        let allColumnsSame = true;\n        const names: Record<string, string> = {};\n        for (const [name, {serverName}] of Object.entries(columns)) {\n          if (serverName && serverName !== name) {\n            allColumnsSame = false;\n          }\n          if (src === 'client') {\n            names[name] = serverName ?? name;\n          } else {\n            names[serverName ?? name] = name;\n          }\n        }\n        return [\n          src === 'client' ? tableName : (serverTableName ?? tableName),\n          {\n            tableName:\n              src === 'client' ? (serverTableName ?? tableName) : tableName,\n            columns: names,\n            allColumnsSame,\n          },\n        ];\n      },\n    ),\n  );\n  return new NameMapper(mapping);\n}\n\n/**\n * Returns an \"identity\" NameMapper that simply serves the purpose\n * of validating that all table and column names conform to the\n * specified `tablesToColumns` map.\n */\nexport function validator(tablesToColumns: Map<string, string[]>): NameMapper {\n  const identity = new Map(\n    [...tablesToColumns.entries()].map(([tableName, columns]) => [\n      tableName,\n      {\n        tableName,\n        columns: Object.fromEntries(columns.map(c => [c, c])),\n        allColumnsSame: true,\n      },\n    ]),\n  );\n  return new NameMapper(identity);\n}\n\nexport class NameMapper {\n  readonly #tables = new Map<string, DestNames>();\n\n  constructor(tables: Map<string, DestNames>) {\n    this.#tables = tables;\n  }\n\n  #getTable(src: string, ctx?: JSONValue | undefined): DestNames {\n    const table = this.#tables.get(src);\n    if (!table) {\n      throw new Error(\n        `unknown table \"${src}\" ${!ctx ? '' : `in ${JSON.stringify(ctx)}`}`,\n      );\n    }\n    return table;\n  }\n\n  tableName(src: string, context?: JSONValue): string {\n    return this.#getTable(src, context).tableName;\n  }\n\n  columnName(table: string, src: string, ctx?: JSONValue): string {\n    const dst = this.#getTable(table, ctx).columns[src];\n    if (!dst) {\n      throw new Error(\n        `unknown column \"${src}\" of \"${table}\" table ${\n          !ctx ? '' : `in ${JSON.stringify(ctx)}`\n        }`,\n      );\n    }\n    return dst;\n  }\n\n  row<V extends Value>(\n    table: string,\n    row: Readonly<Record<string, V>>,\n  ): Readonly<Record<string, V>> {\n    const dest = this.#getTable(table);\n    const {allColumnsSame, columns} = dest;\n    if (allColumnsSame) {\n      return row;\n    }\n    const clientRow: Record<string, V> = {};\n    for (const col in row) {\n      // Note: columns with unknown names simply pass through.\n      clientRow[columns[col] ?? col] = row[col];\n    }\n    return clientRow;\n  }\n\n  columns<Columns extends readonly string[] | undefined>(\n    table: string,\n    cols: Columns,\n  ): Columns {\n    const dest = this.#getTable(table);\n    const {allColumnsSame, columns} = dest;\n\n    // Note: Columns not defined in the schema simply pass through.\n    return cols === undefined || allColumnsSame\n      ? cols\n      : (cols.map(col => columns[col] ?? col) as unknown as Columns);\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport type {Expand} from '../../../shared/src/expand.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {\n  SchemaValueToTSType,\n  TableSchema,\n} from '../../../zero-schema/src/table-schema.ts';\nimport type {Query} from '../query/query.ts';\n\ntype ClientID = string;\n\nexport type Location = 'client' | 'server';\nexport type TransactionReason = 'optimistic' | 'rebase' | 'authoritative';\n\nexport interface TransactionBase<S extends Schema> {\n  readonly location: Location;\n  readonly clientID: ClientID;\n  /**\n   * The ID of the mutation that is being applied.\n   */\n  readonly mutationID: number;\n\n  /**\n   * The reason for the transaction.\n   */\n  readonly reason: TransactionReason;\n\n  readonly mutate: SchemaCRUD<S>;\n  readonly query: SchemaQuery<S>;\n}\n\nexport type Transaction<S extends Schema, TWrappedTransaction = unknown> =\n  | ServerTransaction<S, TWrappedTransaction>\n  | ClientTransaction<S>;\n\nexport interface ServerTransaction<S extends Schema, TWrappedTransaction>\n  extends TransactionBase<S> {\n  readonly location: 'server';\n  readonly reason: 'authoritative';\n  readonly dbTransaction: DBTransaction<TWrappedTransaction>;\n}\n\n/**\n * An instance of this is passed to custom mutator implementations and\n * allows reading and writing to the database and IVM at the head\n * at which the mutator is being applied.\n */\nexport interface ClientTransaction<S extends Schema>\n  extends TransactionBase<S> {\n  readonly location: 'client';\n  readonly reason: 'optimistic' | 'rebase';\n}\n\nexport interface Row {\n  [column: string]: unknown;\n}\n\nexport interface DBConnection<TWrappedTransaction> {\n  transaction: <T>(\n    cb: (tx: DBTransaction<TWrappedTransaction>) => Promise<T>,\n  ) => Promise<T>;\n}\n\nexport interface DBTransaction<T> extends Queryable {\n  readonly wrappedTransaction: T;\n}\n\ninterface Queryable {\n  query: (query: string, args: unknown[]) => Promise<Iterable<Row>>;\n}\n\nexport type SchemaCRUD<S extends Schema> = {\n  [Table in keyof S['tables']]: TableCRUD<S['tables'][Table]>;\n};\n\nexport type TableCRUD<S extends TableSchema> = {\n  /**\n   * Writes a row if a row with the same primary key doesn't already exists.\n   * Non-primary-key fields that are 'optional' can be omitted or set to\n   * `undefined`. Such fields will be assigned the value `null` optimistically\n   * and then the default value as defined by the server.\n   */\n  insert: (value: InsertValue<S>) => Promise<void>;\n\n  /**\n   * Writes a row unconditionally, overwriting any existing row with the same\n   * primary key. Non-primary-key fields that are 'optional' can be omitted or\n   * set to `undefined`. Such fields will be assigned the value `null`\n   * optimistically and then the default value as defined by the server.\n   */\n  upsert: (value: UpsertValue<S>) => Promise<void>;\n\n  /**\n   * Updates a row with the same primary key. If no such row exists, this\n   * function does nothing. All non-primary-key fields can be omitted or set to\n   * `undefined`. Such fields will be left unchanged from previous value.\n   */\n  update: (value: UpdateValue<S>) => Promise<void>;\n\n  /**\n   * Deletes the row with the specified primary key. If no such row exists, this\n   * function does nothing.\n   */\n  delete: (id: DeleteID<S>) => Promise<void>;\n};\n\nexport type SchemaQuery<S extends Schema> = {\n  readonly [K in keyof S['tables'] & string]: Query<S, K>;\n};\n\nexport type DeleteID<S extends TableSchema> = Expand<PrimaryKeyFields<S>>;\n\ntype PrimaryKeyFields<S extends TableSchema> = {\n  [K in Extract<\n    S['primaryKey'][number],\n    keyof S['columns']\n  >]: SchemaValueToTSType<S['columns'][K]>;\n};\n\nexport type InsertValue<S extends TableSchema> = Expand<\n  PrimaryKeyFields<S> & {\n    [K in keyof S['columns'] as S['columns'][K] extends {optional: true}\n      ? K\n      : never]?: SchemaValueToTSType<S['columns'][K]> | undefined;\n  } & {\n    [K in keyof S['columns'] as S['columns'][K] extends {optional: true}\n      ? never\n      : K]: SchemaValueToTSType<S['columns'][K]>;\n  }\n>;\n\nexport type UpsertValue<S extends TableSchema> = InsertValue<S>;\n\nexport type UpdateValue<S extends TableSchema> = Expand<\n  PrimaryKeyFields<S> & {\n    [K in keyof S['columns']]?:\n      | SchemaValueToTSType<S['columns'][K]>\n      | undefined;\n  }\n>;\n\nexport function customMutatorKey(namespace: string, name: string) {\n  assert(!namespace.includes('|'), 'mutator namespaces must not include a |');\n  assert(!name.includes('|'), 'mutator names must not include a |');\n  return `${namespace}|${name}`;\n}\n\nexport function splitMutatorKey(key: string) {\n  return key.split('|') as [string, string];\n}\n","import type {AST} from '../../../zero-protocol/src/ast.ts';\n\nexport type ClientMetricMap = {\n  'query-materialization-client': [queryID: string];\n  'query-materialization-end-to-end': [queryID: string, ast: AST];\n  'query-update-client': [queryID: string];\n};\n\nexport type ServerMetricMap = {\n  'query-materialization-server': [queryID: string];\n  'query-update-server': [queryID: string];\n};\n\nexport type MetricMap = ClientMetricMap & ServerMetricMap;\n\nexport interface MetricsDelegate {\n  addMetric<K extends keyof MetricMap>(\n    metric: K,\n    value: number,\n    ...args: MetricMap[K]\n  ): void;\n}\n\nexport function isClientMetric(\n  metric: keyof MetricMap,\n): metric is keyof ClientMetricMap {\n  return metric.endsWith('-client') || metric.endsWith('-end-to-end');\n}\n\nexport function isServerMetric(\n  metric: keyof MetricMap,\n): metric is keyof ServerMetricMap {\n  return metric.endsWith('-server');\n}\n","import type {Upstream} from '../../../zero-protocol/src/up.ts';\n\nexport function send(ws: WebSocket, data: Upstream) {\n  ws.send(JSON.stringify(data));\n}\n","import {resolver} from '@rocicorp/resolver';\nimport {BroadcastChannel} from '../../../shared/src/broadcast-channel.ts';\nimport {getBrowserGlobal} from '../../../shared/src/browser-env.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\n\n/**\n * The prefix for the keys used for the locks and the broadcast channels.\n */\nconst keyPrefix = 'zero-active';\n\nfunction toLockName(clientGroupID: string, clientID: string): string {\n  return `${keyPrefix}/${clientGroupID}/${clientID}`;\n}\n\nfunction toBroadcastChannelName(clientGroupID: string): string {\n  return `${keyPrefix}/${clientGroupID}`;\n}\n\nfunction fromLockName(\n  lockKey: string | undefined,\n): {clientGroupID: string; clientID: string} | undefined {\n  if (!lockKey || !lockKey.startsWith(keyPrefix)) {\n    return undefined;\n  }\n  const parts = lockKey.slice(keyPrefix.length).split('/');\n  if (parts.length !== 3) {\n    return undefined;\n  }\n  return {\n    clientGroupID: parts[1],\n    clientID: parts[2],\n  };\n}\n\nfunction ignoreAbortError(e: unknown) {\n  if (e instanceof Error && e.name === 'AbortError') {\n    // Ignore the AbortError, it is expected when the signal is aborted.\n    return;\n  }\n  throw e;\n}\n\n/**\n * A class that lists the active clients in a client group. It uses the\n * `navigator.locks` API to manage locks for each client. The class is designed\n * to be used in a browser environment where the `navigator.locks` API is\n * available.\n *\n * When navigator.locks is not available, it will return a set only containing\n * the clients in the current scripting context (window, worker, etc).\n *\n * It uses one exclusive lock per client, identified by a combination of\n * `clientGroupID` and `clientID`. Then the `query` method is used to get the\n * list of all clients that hold or are waiting for locks in the same client\n * group.\n *\n * It also tries to get a shared lock for each client in the group, so that it\n * can be notified when the exclusive lock is released. This allows the class to\n * keep track of the active clients in the group and notify when an existing\n * client is removed.\n *\n * The class also uses a `BroadcastChannel` to notify other clients in the\n * same client group when a new client is added. This allows the class to keep\n * track of the active clients in the group and notify when a new client is\n * added.\n */\nexport class ActiveClientsManager {\n  readonly clientGroupID: string;\n  readonly clientID: string;\n  readonly #resolver = resolver<void>();\n  readonly #lockManager: ClientLockManager;\n  readonly #activeClients: Set<string> = new Set();\n\n  /**\n   * A callback that is called when a client is added to the client group.\n   * It receives the client ID of the added client.\n   */\n  onAdd: ((clientID: string) => void) | undefined;\n\n  /**\n   * A callback that is called when a client is deleted from the client group.\n   * It receives the client ID of the deleted client.\n   */\n  onDelete: ((clientID: string) => void) | undefined;\n\n  /**\n   * Creates an instance of `ActiveClientsManager` for the specified client\n   * group and client ID. It will return a promise that resolves when the\n   * instance is ready to use, which means that it has successfully acquired the\n   * exclusive lock for the client and has retrieved the list of active clients.\n   */\n  static async create(\n    clientGroupID: string,\n    clientID: string,\n    signal: AbortSignal,\n  ): Promise<ActiveClientsManager> {\n    const instance = new ActiveClientsManager(clientGroupID, clientID, signal);\n    await instance.#init(signal);\n    return instance;\n  }\n\n  private constructor(\n    clientGroupID: string,\n    clientID: string,\n    signal: AbortSignal,\n  ) {\n    this.clientGroupID = clientGroupID;\n    this.clientID = clientID;\n    this.#lockManager = getClientLockManager(signal);\n    this.#activeClients.add(clientID);\n  }\n\n  async #init(signal: AbortSignal): Promise<void> {\n    const {clientGroupID, clientID} = this;\n    const name = toLockName(clientGroupID, clientID);\n\n    // The BroadcastChannel is used to notify other clients in the same client\n    // group when a new client is added. It listens for messages that contain\n    // the lock name, which is used to identify the client. When a message is\n    // received, it checks if the client belongs to the same client group and\n    // adds it to the list of active clients. It also adds a shared lock for\n    // the client, so that it can be notified when the exclusive lock is\n    // released.\n    const channel = new BroadcastChannel(toBroadcastChannelName(clientGroupID));\n    channel.addEventListener(\n      'message',\n      e => {\n        const client = fromLockName(e.data);\n        if (client?.clientGroupID === this.clientGroupID) {\n          this.#addClient(client.clientID);\n        }\n      },\n      {signal},\n    );\n\n    this.#lockManager\n      .request(name, 'exclusive', () => this.#resolver.promise)\n      .catch(ignoreAbortError);\n\n    signal.addEventListener(\n      'abort',\n      () => {\n        this.#lockManager.release(name, () => this.#resolver.resolve());\n        channel.close();\n      },\n      {once: true},\n    );\n\n    for (const clientID of await this.#getActiveClients()) {\n      if (clientID !== this.clientID) {\n        this.#addClient(clientID);\n      }\n    }\n\n    if (!signal.aborted) {\n      channel.postMessage(name);\n    }\n  }\n\n  get activeClients(): ReadonlySet<string> {\n    return this.#activeClients;\n  }\n\n  async #getActiveClients(): Promise<Set<string>> {\n    const activeClients: Set<string> = new Set();\n\n    for await (const lockName of this.#lockManager.queryExclusive()) {\n      const client = fromLockName(lockName);\n      if (client?.clientGroupID === this.clientGroupID) {\n        activeClients.add(client.clientID);\n      }\n    }\n\n    return activeClients;\n  }\n\n  /**\n   * This gets called when a new client is added to the client group.\n   *\n   * It will request a shared lock for the client, and when the exclusive lock\n   * is released, it will notify that the client has been deactivated.\n   */\n  #addSharedLockForOtherClient(clientID: string): void {\n    const name = toLockName(this.clientGroupID, clientID);\n    this.#lockManager\n      .request(name, 'shared', () => this.#removeClient(clientID))\n      .catch(ignoreAbortError);\n  }\n\n  #addClient(clientID: string): void {\n    if (!this.#activeClients.has(clientID)) {\n      this.#activeClients.add(clientID);\n      this.#addSharedLockForOtherClient(clientID);\n      this.onAdd?.(clientID);\n    }\n  }\n\n  #removeClient(clientID: string): void {\n    if (this.#activeClients.delete(clientID)) {\n      this.onDelete?.(clientID);\n    }\n  }\n}\n\nfunction getClientLockManager(signal: AbortSignal): ClientLockManager {\n  const locks = getBrowserGlobal('navigator')?.locks;\n  if (locks) {\n    return new NativeClientLockManager(locks, signal);\n  }\n  return new MockClientLockManager();\n}\n\ninterface ClientLockManager {\n  request(\n    name: string,\n    mode: 'exclusive' | 'shared',\n    fn: () => MaybePromise<void>,\n  ): Promise<void>;\n  release(name: string, fn: () => void): void;\n  queryExclusive(): AsyncIterable<string>;\n}\n\nclass NativeClientLockManager implements ClientLockManager {\n  readonly #locks: LockManager;\n  readonly #signal: AbortSignal;\n\n  constructor(locks: LockManager, signal: AbortSignal) {\n    this.#locks = locks;\n    this.#signal = signal;\n  }\n\n  request(\n    name: string,\n    mode: 'exclusive' | 'shared',\n    fn: () => Promise<void>,\n  ): Promise<void> {\n    return this.#locks.request(name, {mode, signal: this.#signal}, fn);\n  }\n\n  release(_name: string, fn: () => void): void {\n    fn();\n  }\n\n  async *queryExclusive(): AsyncIterable<string> {\n    const snapshot = await this.#locks.query();\n    for (const lock of [\n      ...(snapshot.held ?? []),\n      ...(snapshot.pending ?? []),\n    ]) {\n      if (lock.mode === 'exclusive' && lock.name) {\n        yield lock.name;\n      }\n    }\n  }\n}\n\nconst mockLockNames = new Set<string>();\n\nconst mockListeners: Set<(name: string) => void> = new Set();\n\nclass MockClientLockManager implements ClientLockManager {\n  readonly #listeners: Set<(name: string) => void> = new Set();\n\n  request(\n    name: string,\n    mode: 'exclusive' | 'shared',\n    fn: () => void | Promise<void>,\n  ): Promise<void> {\n    if (mode === 'exclusive') {\n      mockLockNames.add(name);\n    } else {\n      mode satisfies 'shared';\n\n      // For the mock locks we will add a listener that will notify us when the\n      // lock is deleted from the `allMockLocks` set.\n      const listener = (removed: string) => {\n        if (removed === name) {\n          mockListeners.delete(listener);\n          return fn();\n        }\n      };\n      mockListeners.add(listener);\n      this.#listeners.add(listener);\n    }\n    return Promise.resolve();\n  }\n\n  release(name: string, fn: () => void): void {\n    mockLockNames.delete(name);\n    for (const listener of mockListeners) {\n      listener(name);\n    }\n    for (const listener of this.#listeners) {\n      mockListeners.delete(listener);\n    }\n    fn();\n  }\n\n  async *queryExclusive(): AsyncIterable<string> {\n    yield* mockLockNames;\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const Disconnected = 0;\nexport const Connecting = 1;\nexport const Connected = 2;\n\nexport type Disconnected = typeof Disconnected;\nexport type Connecting = typeof Connecting;\nexport type Connected = typeof Connected;\n","import {compareUTF8} from 'compare-utf8';\nimport {BTreeSet} from '../../../shared/src/btree-set.ts';\nimport type {JSONValue} from '../../../shared/src/json.ts';\nimport type {Storage} from './operator.ts';\nimport type {Stream} from './stream.ts';\n\ntype Entry = [key: string, value: JSONValue];\n\nfunction comparator(a: Entry, b: Entry): number {\n  return compareUTF8(a[0], b[0]);\n}\n\n/**\n * MemoryStorage is a simple in-memory implementation of `Storage` for use\n * on the client and in tests.\n */\nexport class MemoryStorage implements Storage {\n  #data: BTreeSet<Entry> = new BTreeSet(comparator);\n\n  set(key: string, value: JSONValue) {\n    this.#data.add([key, value]);\n  }\n\n  get(key: string, def?: JSONValue): JSONValue | undefined {\n    const r = this.#data.get([key, null]);\n    if (r !== undefined) {\n      return r[1];\n    }\n    return def;\n  }\n\n  del(key: string) {\n    this.#data.delete([key, null]);\n  }\n\n  *scan(options?: {prefix: string}): Stream<[string, JSONValue]> {\n    for (const entry of this.#data.valuesFrom(\n      options && [options.prefix, null],\n    )) {\n      if (options && !entry[0].startsWith(options.prefix)) {\n        return;\n      }\n      yield entry;\n    }\n  }\n\n  cloneData(): Record<string, JSONValue> {\n    return structuredClone(Object.fromEntries(this.#data.values()));\n  }\n}\n","import {assert} from './asserts.ts';\n\nconst MAX_NODE_SIZE = 32;\n\ntype Comparator<K> = (a: K, b: K) => number;\nexport class BTreeSet<K> {\n  #root: BNode<K> = emptyLeaf as BNode<K>;\n  size: number = 0;\n\n  readonly comparator: Comparator<K>;\n\n  constructor(comparator: Comparator<K>, entries?: IterableIterator<K>) {\n    this.comparator = comparator;\n    if (entries) {\n      for (const key of entries) {\n        this.add(key);\n      }\n    }\n  }\n\n  /** Releases the tree so that its size is 0. */\n  clear() {\n    this.#root = emptyLeaf as BNode<K>;\n    this.size = 0;\n  }\n\n  clone() {\n    this.#root.isShared = true;\n    const ret = new BTreeSet<K>(this.comparator);\n    ret.#root = this.#root;\n    ret.size = this.size;\n    return ret;\n  }\n\n  get(key: K): K | undefined {\n    return this.#root.get(key, this);\n  }\n\n  add(key: K): this {\n    if (this.#root.isShared) this.#root = this.#root.clone();\n    const result = this.#root.set(key, this);\n    if (result === null) return this;\n    // Root node has split, so create a new root node.\n    this.#root = new BNodeInternal<K>([this.#root, result]);\n    return this;\n  }\n\n  /**\n   * Returns true if the key exists in the B+ tree, false if not.\n   * Use get() for best performance; use has() if you need to\n   * distinguish between \"undefined value\" and \"key not present\".\n   * @param key Key to detect\n   * @description Computational complexity: O(log size)\n   */\n  has(key: K): boolean {\n    return this.#root.has(key, this);\n  }\n\n  /**\n   * Removes a single key-value pair from the B+ tree.\n   * @param key Key to find\n   * @returns true if a pair was found and removed, false otherwise.\n   * @description Computational complexity: O(log size)\n   */\n  delete(key: K): boolean {\n    return this.#delete(key);\n  }\n\n  #delete(key: K): boolean {\n    let root = this.#root;\n    if (root.isShared) {\n      this.#root = root = root.clone();\n    }\n    try {\n      return root.delete(key, this);\n    } finally {\n      let isShared;\n      while (root.keys.length <= 1 && root.isInternal()) {\n        isShared ||= root.isShared;\n        this.#root = root =\n          root.keys.length === 0 ? emptyLeaf : root.children[0];\n      }\n      // If any ancestor of the new root was shared, the new root must also be shared\n      if (isShared) {\n        root.isShared = true;\n      }\n    }\n  }\n\n  keys(): IterableIterator<K> {\n    return valuesFrom(this.#root, this.comparator, undefined, true);\n  }\n\n  values(): IterableIterator<K> {\n    return valuesFrom(this.#root, this.comparator, undefined, true);\n  }\n\n  valuesFrom(lowestKey?: K, inclusive: boolean = true): IterableIterator<K> {\n    return valuesFrom(this.#root, this.comparator, lowestKey, inclusive);\n  }\n\n  valuesReversed(): IterableIterator<K> {\n    return valuesFromReversed(\n      this.#maxKey(),\n      this.#root,\n      this.comparator,\n      undefined,\n      true,\n    );\n  }\n\n  valuesFromReversed(\n    highestKey?: K,\n    inclusive: boolean = true,\n  ): IterableIterator<K> {\n    return valuesFromReversed(\n      this.#maxKey(),\n      this.#root,\n      this.comparator,\n      highestKey,\n      inclusive,\n    );\n  }\n\n  /** Gets the highest key in the tree. Complexity: O(1) */\n  #maxKey(): K | undefined {\n    return this.#root.maxKey();\n  }\n\n  [Symbol.iterator](): IterableIterator<K> {\n    return this.keys();\n  }\n}\n\nfunction valuesFrom<K>(\n  root: BNode<K>,\n  comparator: Comparator<K>,\n  lowestKey: K | undefined,\n  inclusive: boolean,\n): IterableIterator<K> {\n  const info = findPath(lowestKey, root, comparator);\n  if (info === undefined) {\n    return iterator<K>(() => ({done: true, value: undefined}));\n  }\n\n  // eslint-disable-next-line prefer-const\n  let [nodeQueue, nodeIndex, leaf] = info;\n  let i =\n    lowestKey === undefined\n      ? -1\n      : indexOf(lowestKey, leaf.keys, 0, comparator) - 1;\n\n  if (\n    !inclusive &&\n    i < leaf.keys.length &&\n    // +1 because we did -1 above.\n    comparator(leaf.keys[i + 1], lowestKey!) === 0\n  ) {\n    i++;\n  }\n\n  return iterator<K>(() => {\n    for (;;) {\n      if (++i < leaf.keys.length) {\n        return {done: false, value: leaf.keys[i]};\n      }\n\n      let level = -1;\n      for (;;) {\n        if (++level >= nodeQueue.length) {\n          return {done: true, value: undefined};\n        }\n        if (++nodeIndex[level] < nodeQueue[level].length) {\n          break;\n        }\n      }\n      for (; level > 0; level--) {\n        nodeQueue[level - 1] = (\n          nodeQueue[level][nodeIndex[level]] as BNodeInternal<K>\n        ).children;\n        nodeIndex[level - 1] = 0;\n      }\n      leaf = nodeQueue[0][nodeIndex[0]];\n      i = -1;\n    }\n  });\n}\n\nfunction valuesFromReversed<K>(\n  maxKey: K | undefined,\n  root: BNode<K>,\n  comparator: Comparator<K>,\n  highestKey: K | undefined,\n  inclusive: boolean,\n): IterableIterator<K> {\n  if (highestKey === undefined) {\n    highestKey = maxKey;\n    if (highestKey === undefined)\n      return iterator<K>(() => ({done: true, value: undefined})); // collection is empty\n  }\n  // eslint-disable-next-line prefer-const\n  let [nodeQueue, nodeIndex, leaf] =\n    findPath(highestKey, root, comparator) ||\n    findPath(maxKey, root, comparator)!;\n  assert(!nodeQueue[0] || leaf === nodeQueue[0][nodeIndex[0]]);\n  let i = indexOf(highestKey, leaf.keys, 0, comparator);\n  if (\n    inclusive &&\n    i < leaf.keys.length &&\n    comparator(leaf.keys[i], highestKey) <= 0\n  ) {\n    i++;\n  }\n\n  return iterator<K>(() => {\n    for (;;) {\n      if (--i >= 0) {\n        return {done: false, value: leaf.keys[i]};\n      }\n\n      let level;\n      // Advance to the next leaf node\n      for (level = -1; ; ) {\n        if (++level >= nodeQueue.length) {\n          return {done: true, value: undefined};\n        }\n        if (--nodeIndex[level] >= 0) {\n          break;\n        }\n      }\n      for (; level > 0; level--) {\n        nodeQueue[level - 1] = (\n          nodeQueue[level][nodeIndex[level]] as BNodeInternal<K>\n        ).children;\n        nodeIndex[level - 1] = nodeQueue[level - 1].length - 1;\n      }\n      leaf = nodeQueue[0][nodeIndex[0]];\n      i = leaf.keys.length;\n    }\n  });\n}\n\nfunction findPath<K>(\n  key: K | undefined,\n  root: BNode<K>,\n  comparator: Comparator<K>,\n): [nodeQueue: BNode<K>[][], nodeIndex: number[], leaf: BNode<K>] | undefined {\n  let nextNode = root;\n  const nodeQueue: BNode<K>[][] = [];\n  const nodeIndex: number[] = [];\n\n  if (nextNode.isInternal()) {\n    for (let d = 0; nextNode.isInternal(); d++) {\n      nodeQueue[d] = nextNode.children;\n      nodeIndex[d] =\n        key === undefined ? 0 : indexOf(key, nextNode.keys, 0, comparator);\n      if (nodeIndex[d] >= nodeQueue[d].length) return; // first key > maxKey()\n      nextNode = nodeQueue[d][nodeIndex[d]];\n    }\n    nodeQueue.reverse();\n    nodeIndex.reverse();\n  }\n  return [nodeQueue, nodeIndex, nextNode];\n}\n\nfunction iterator<T>(next: () => IteratorResult<T>): IterableIterator<T> {\n  return {\n    next,\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\n/** Leaf node / base class. **************************************************/\nclass BNode<K> {\n  // If this is an internal node, _keys[i] is the highest key in children[i].\n  keys: K[];\n  // True if this node might be within multiple `BTree`s (or have multiple parents).\n  // If so, it must be cloned before being mutated to avoid changing an unrelated tree.\n  // This is transitive: if it's true, children are also shared even if `isShared!=true`\n  // in those children. (Certain operations will propagate isShared=true to children.)\n  isShared: true | undefined;\n\n  constructor(keys: K[]) {\n    this.keys = keys;\n    this.isShared = undefined;\n  }\n\n  isInternal(): this is BNodeInternal<K> {\n    return false;\n  }\n\n  maxKey() {\n    return this.keys[this.keys.length - 1];\n  }\n\n  minKey(): K | undefined {\n    return this.keys[0];\n  }\n\n  clone(): BNode<K> {\n    return new BNode<K>(this.keys.slice(0));\n  }\n\n  get(key: K, tree: BTreeSet<K>): K | undefined {\n    const i = indexOf(key, this.keys, -1, tree.comparator);\n    return i < 0 ? undefined : this.keys[i];\n  }\n\n  has(key: K, tree: BTreeSet<K>): boolean {\n    const i = indexOf(key, this.keys, -1, tree.comparator);\n    return i >= 0 && i < this.keys.length;\n  }\n\n  set(key: K, tree: BTreeSet<K>): null | BNode<K> {\n    let i = indexOf(key, this.keys, -1, tree.comparator);\n    if (i < 0) {\n      // key does not exist yet\n      i = ~i;\n      tree.size++;\n\n      if (this.keys.length < MAX_NODE_SIZE) {\n        this.keys.splice(i, 0, key);\n        return null;\n      }\n      // This leaf node is full and must split\n      const newRightSibling = this.splitOffRightSide();\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let target: BNode<K> = this;\n      if (i > this.keys.length) {\n        i -= this.keys.length;\n        target = newRightSibling;\n      }\n      // target.#insertInLeaf(i, key);\n      target.keys.splice(i, 0, key);\n\n      return newRightSibling;\n    }\n\n    // usually this is a no-op, but some users may wish to edit the key\n    this.keys[i] = key;\n    return null;\n  }\n\n  takeFromRight(rhs: BNode<K>) {\n    this.keys.push(rhs.keys.shift()!);\n  }\n\n  takeFromLeft(lhs: BNode<K>) {\n    this.keys.unshift(lhs.keys.pop()!);\n  }\n\n  splitOffRightSide(): BNode<K> {\n    const half = this.keys.length >> 1;\n    const keys = this.keys.splice(half);\n    return new BNode<K>(keys);\n  }\n\n  delete(key: K, tree: BTreeSet<K>): boolean {\n    const cmp = tree.comparator;\n    const iLow = indexOf(key, this.keys, -1, cmp);\n    const iHigh = iLow + 1;\n\n    if (iLow < 0) {\n      return false;\n    }\n\n    const {keys} = this;\n    for (let i = iLow; i < iHigh; i++) {\n      const key = keys[i];\n\n      if (key !== keys[i] || this.isShared === true) {\n        throw new Error('BTree illegally changed or cloned in delete');\n      }\n\n      this.keys.splice(i, 1);\n      tree.size--;\n      return true;\n    }\n\n    return false;\n  }\n\n  mergeSibling(rhs: BNode<K>, _: number) {\n    this.keys.push(...rhs.keys);\n  }\n}\n\n/** Internal node (non-leaf node) ********************************************/\nclass BNodeInternal<K> extends BNode<K> {\n  // Note: conventionally B+ trees have one fewer key than the number of\n  // children, but I find it easier to keep the array lengths equal: each\n  // keys[i] caches the value of children[i].maxKey().\n  children: BNode<K>[];\n\n  /**\n   * This does not mark `children` as shared, so it is the responsibility of the caller\n   * to ensure children are either marked shared, or aren't included in another tree.\n   */\n  constructor(children: BNode<K>[], keys?: K[]) {\n    if (!keys) {\n      keys = [];\n      for (let i = 0; i < children.length; i++) {\n        keys[i] = children[i].maxKey();\n      }\n    }\n    super(keys);\n    this.children = children;\n  }\n\n  isInternal(): this is BNodeInternal<K> {\n    return true;\n  }\n\n  clone(): BNode<K> {\n    const children = this.children.slice(0);\n    for (let i = 0; i < children.length; i++) {\n      children[i].isShared = true;\n    }\n    return new BNodeInternal<K>(children, this.keys.slice(0));\n  }\n\n  minKey() {\n    return this.children[0].minKey();\n  }\n\n  get(key: K, tree: BTreeSet<K>): K | undefined {\n    const i = indexOf(key, this.keys, 0, tree.comparator);\n    const {children} = this;\n    return i < children.length ? children[i].get(key, tree) : undefined;\n  }\n\n  has(key: K, tree: BTreeSet<K>): boolean {\n    const i = indexOf(key, this.keys, 0, tree.comparator);\n    const {children} = this;\n    return i < children.length ? children[i].has(key, tree) : false;\n  }\n\n  set(key: K, tree: BTreeSet<K>): null | BNode<K> {\n    const c = this.children;\n    const cmp = tree.comparator;\n    let i = Math.min(indexOf(key, this.keys, 0, cmp), c.length - 1);\n    let child = c[i];\n\n    if (child.isShared) {\n      c[i] = child = child.clone();\n    }\n    if (child.keys.length >= MAX_NODE_SIZE) {\n      // child is full; inserting anything else will cause a split.\n      // Shifting an item to the left or right sibling may avoid a split.\n      // We can do a shift if the adjacent node is not full and if the\n      // current key can still be placed in the same node after the shift.\n      let other: BNode<K>;\n      if (\n        i > 0 &&\n        (other = c[i - 1]).keys.length < MAX_NODE_SIZE &&\n        cmp(child.keys[0], key) < 0\n      ) {\n        if (other.isShared) {\n          c[i - 1] = other = other.clone();\n        }\n        other.takeFromRight(child);\n        this.keys[i - 1] = other.maxKey();\n      } else if (\n        (other = c[i + 1]) !== undefined &&\n        other.keys.length < MAX_NODE_SIZE &&\n        cmp(child.maxKey(), key) < 0\n      ) {\n        if (other.isShared) c[i + 1] = other = other.clone();\n        other.takeFromLeft(child);\n        this.keys[i] = c[i].maxKey();\n      }\n    }\n\n    const result = child.set(key, tree);\n    this.keys[i] = child.maxKey();\n    if (result === null) return null;\n\n    // The child has split and `result` is a new right child... does it fit?\n    if (this.keys.length < MAX_NODE_SIZE) {\n      // yes\n      this.insert(i + 1, result);\n      return null;\n    }\n    // no, we must split also\n    const newRightSibling = this.splitOffRightSide();\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let target: BNodeInternal<K> = this;\n    if (cmp(result.maxKey(), this.maxKey()) > 0) {\n      target = newRightSibling;\n      i -= this.keys.length;\n    }\n    target.insert(i + 1, result);\n    return newRightSibling;\n  }\n\n  /**\n   * Inserts `child` at index `i`.\n   * This does not mark `child` as shared, so it is the responsibility of the caller\n   * to ensure that either child is marked shared, or it is not included in another tree.\n   */\n  insert(i: number, child: BNode<K>) {\n    this.children.splice(i, 0, child);\n    this.keys.splice(i, 0, child.maxKey());\n  }\n\n  /**\n   * Split this node.\n   * Modifies this to remove the second half of the items, returning a separate node containing them.\n   */\n  splitOffRightSide() {\n    const half = this.children.length >> 1;\n    return new BNodeInternal<K>(\n      this.children.splice(half),\n      this.keys.splice(half),\n    );\n  }\n\n  takeFromRight(rhs: BNode<K>) {\n    this.keys.push(rhs.keys.shift()!);\n    this.children.push((rhs as BNodeInternal<K>).children.shift()!);\n  }\n\n  takeFromLeft(lhs: BNode<K>) {\n    this.keys.unshift(lhs.keys.pop()!);\n    this.children.unshift((lhs as BNodeInternal<K>).children.pop()!);\n  }\n\n  delete(key: K, tree: BTreeSet<K>): boolean {\n    const cmp = tree.comparator;\n    const {keys} = this;\n    const {children} = this;\n    let iLow = indexOf(key, this.keys, 0, cmp);\n    let i = iLow;\n    const iHigh = Math.min(iLow, keys.length - 1);\n    if (i <= iHigh) {\n      try {\n        if (children[i].isShared) {\n          children[i] = children[i].clone();\n        }\n        const result = children[i].delete(key, tree);\n        // Note: if children[i] is empty then keys[i]=undefined.\n        //       This is an invalid state, but it is fixed below.\n        keys[i] = children[i].maxKey();\n        return result;\n      } finally {\n        // Deletions may have occurred, so look for opportunities to merge nodes.\n        const half = MAX_NODE_SIZE >> 1;\n        if (iLow > 0) iLow--;\n        for (i = iHigh; i >= iLow; i--) {\n          if (children[i].keys.length <= half) {\n            if (children[i].keys.length !== 0) {\n              this.tryMerge(i, MAX_NODE_SIZE);\n            } else {\n              // child is empty! delete it!\n              keys.splice(i, 1);\n              children.splice(i, 1);\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Merges child i with child i+1 if their combined size is not too large */\n  tryMerge(i: number, maxSize: number): boolean {\n    const {children} = this;\n    if (i >= 0 && i + 1 < children.length) {\n      if (children[i].keys.length + children[i + 1].keys.length <= maxSize) {\n        if (children[i].isShared)\n          // cloned already UNLESS i is outside scan range\n          children[i] = children[i].clone();\n        children[i].mergeSibling(children[i + 1], maxSize);\n        children.splice(i + 1, 1);\n        this.keys.splice(i + 1, 1);\n        this.keys[i] = children[i].maxKey();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Move children from `rhs` into this.\n   * `rhs` must be part of this tree, and be removed from it after this call\n   * (otherwise isShared for its children could be incorrect).\n   */\n  mergeSibling(rhs: BNode<K>, maxNodeSize: number) {\n    // assert !this.isShared;\n    const oldLength = this.keys.length;\n    this.keys.push(...rhs.keys);\n    const rhsChildren = (rhs as unknown as BNodeInternal<K>).children;\n    this.children.push(...rhsChildren);\n\n    if (rhs.isShared && !this.isShared) {\n      // All children of a shared node are implicitly shared, and since their new\n      // parent is not shared, they must now be explicitly marked as shared.\n      for (let i = 0; i < rhsChildren.length; i++) {\n        rhsChildren[i].isShared = true;\n      }\n    }\n\n    // If our children are themselves almost empty due to a mass-delete,\n    // they may need to be merged too (but only the oldLength-1 and its\n    // right sibling should need this).\n    this.tryMerge(oldLength - 1, maxNodeSize);\n  }\n}\n\n// If key not found, returns i^failXor where i is the insertion index.\n// Callers that don't care whether there was a match will set failXor=0.\nfunction indexOf<K>(\n  key: K,\n  keys: K[],\n  failXor: number,\n  comparator: Comparator<K>,\n): number {\n  let lo = 0;\n  let hi = keys.length;\n  let mid = hi >> 1;\n  while (lo < hi) {\n    const c = comparator(keys[mid], key);\n    if (c < 0) {\n      lo = mid + 1;\n    } else if (c > 0) {\n      // key < keys[mid]\n      hi = mid;\n    } else if (c === 0) {\n      return mid;\n    } else {\n      // c is NaN or otherwise invalid\n      if (key === key) {\n        // at least the search key is not NaN\n        return keys.length;\n      }\n      throw new Error('NaN was used as a key');\n    }\n    mid = (lo + hi) >> 1;\n  }\n  return mid ^ failXor;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst emptyLeaf = new BNode<any>([]);\nemptyLeaf.isShared = true;\n","import type {Change} from '../ivm/change.ts';\nimport type {Node} from '../ivm/data.ts';\nimport {\n  throwOutput,\n  type FetchRequest,\n  type Input,\n  type Operator,\n  type Output,\n} from '../ivm/operator.ts';\nimport type {SourceSchema} from '../ivm/schema.ts';\nimport type {Stream} from '../ivm/stream.ts';\nimport type {MetricsDelegate} from './metrics-delegate.ts';\n\ntype MetricName = 'query-update-client' | 'query-update-server';\n\nexport class MeasurePushOperator implements Operator {\n  readonly #input: Input;\n  readonly #queryID: string;\n  readonly #metricsDelegate: MetricsDelegate;\n\n  #output: Output = throwOutput;\n  readonly #metricName: MetricName;\n\n  constructor(\n    input: Input,\n    queryID: string,\n    metricsDelegate: MetricsDelegate,\n    metricName: MetricName,\n  ) {\n    this.#input = input;\n    this.#queryID = queryID;\n    this.#metricsDelegate = metricsDelegate;\n    this.#metricName = metricName;\n    input.setOutput(this);\n  }\n\n  setOutput(output: Output): void {\n    this.#output = output;\n  }\n\n  fetch(req: FetchRequest): Stream<Node> {\n    return this.#input.fetch(req);\n  }\n\n  cleanup(req: FetchRequest): Stream<Node> {\n    return this.#input.cleanup(req);\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  push(change: Change): void {\n    const startTime = performance.now();\n    this.#output.push(change);\n    this.#metricsDelegate.addMetric(\n      this.#metricName,\n      performance.now() - startTime,\n      this.#queryID,\n    );\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport {stringCompare} from '../../../shared/src/string-compare.ts';\nimport type {Writable} from '../../../shared/src/writable.ts';\nimport type {\n  Condition,\n  SimpleCondition,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport {valuesEqual} from './data.ts';\n\nexport type Constraint = {\n  readonly [key: string]: Value;\n};\n\nexport function constraintMatchesRow(\n  constraint: Constraint,\n  row: Row,\n): boolean {\n  for (const key in constraint) {\n    if (!valuesEqual(row[key], constraint[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function constraintMatchesPrimaryKey(\n  constraint: Constraint,\n  primary: PrimaryKey,\n): boolean {\n  const constraintKeys = Object.keys(constraint);\n\n  if (constraintKeys.length !== primary.length) {\n    return false;\n  }\n\n  // Primary key is always sorted\n  // Constraint does not have to be sorted\n  constraintKeys.sort(stringCompare);\n\n  for (let i = 0; i < constraintKeys.length; i++) {\n    if (constraintKeys[i][0] !== primary[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Pulls top level `and` components out of a condition tree.\n * The resulting array of simple conditions would match a superset of\n * values that the original condition would match.\n *\n * Examples:\n * a AND b OR c\n *\n * In this case we cannot pull anything because the `or` is at the top level.\n *\n * a AND b AND c\n * We can pull all three.\n *\n * a AND (b OR c)\n * We can only pull `a`.\n */\nexport function pullSimpleAndComponents(\n  condition: Condition,\n): SimpleCondition[] {\n  if (condition.type === 'and') {\n    return condition.conditions.flatMap(pullSimpleAndComponents);\n  }\n\n  if (condition.type === 'simple') {\n    return [condition];\n  }\n\n  if (condition.type === 'or' && condition.conditions.length === 1) {\n    return pullSimpleAndComponents(condition.conditions[0]);\n  }\n\n  return [];\n}\n\n/**\n * Checks if the supplied filters constitute a primary key lookup.\n * If so, returns the constraint that would be used to look up the primary key.\n * If not, returns undefined.\n */\nexport function primaryKeyConstraintFromFilters(\n  condition: Condition | undefined,\n  primary: PrimaryKey,\n): Constraint | undefined {\n  if (condition === undefined) {\n    return undefined;\n  }\n\n  const conditions = pullSimpleAndComponents(condition);\n  if (conditions.length === 0) {\n    return undefined;\n  }\n\n  const ret: Writable<Constraint> = {};\n  for (const subCondition of conditions) {\n    if (subCondition.op === '=') {\n      const column = extractColumn(subCondition);\n      if (column !== undefined) {\n        if (!primary.includes(column.name)) {\n          continue;\n        }\n        ret[column.name] = column.value;\n      }\n    }\n  }\n\n  if (Object.keys(ret).length !== primary.length) {\n    return undefined;\n  }\n\n  return ret;\n}\n\nfunction extractColumn(\n  condition: SimpleCondition,\n): {name: string; value: Value} | undefined {\n  if (condition.left.type === 'column') {\n    assert(condition.right.type === 'literal');\n    return {name: condition.left.name, value: condition.right.value};\n  }\n\n  return undefined;\n}\n\ndeclare const TESTING: boolean;\n\nexport class SetOfConstraint {\n  #data: Constraint[] = [];\n\n  constructor() {\n    // Only used in testing\n    assert(TESTING);\n  }\n\n  #indexOf(value: Constraint): number {\n    return this.#data.findIndex(v => constraintEquals(v, value));\n  }\n\n  has(value: Constraint): boolean {\n    return this.#indexOf(value) !== -1;\n  }\n\n  add(value: Constraint): this {\n    if (!this.has(value)) {\n      this.#data.push(value);\n    }\n    return this;\n  }\n}\n\nfunction constraintEquals(a: Constraint, b: Constraint): boolean {\n  const aEntries = Object.entries(a);\n  const bEntries = Object.entries(b);\n  if (aEntries.length !== bEntries.length) {\n    return false;\n  }\n  for (let i = 0; i < aEntries.length; i++) {\n    if (\n      aEntries[i][0] !== bEntries[i][0] ||\n      !valuesEqual(aEntries[i][1], bEntries[i][1])\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n","import {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport {BTreeSet} from '../../../shared/src/btree-set.ts';\nimport {hasOwn} from '../../../shared/src/has-own.ts';\nimport type {\n  Condition,\n  Ordering,\n  OrderPart,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport type {SchemaValue} from '../../../zero-schema/src/table-schema.ts';\nimport {assertOrderingIncludesPK} from '../builder/builder.ts';\nimport {\n  createPredicate,\n  transformFilters,\n  type NoSubqueryCondition,\n} from '../builder/filter.ts';\nimport type {AddChange, Change, RemoveChange} from './change.ts';\nimport {\n  constraintMatchesPrimaryKey,\n  constraintMatchesRow,\n  primaryKeyConstraintFromFilters,\n  type Constraint,\n} from './constraint.ts';\nimport {\n  compareValues,\n  valuesEqual,\n  makeComparator,\n  type Comparator,\n  type Node,\n} from './data.ts';\nimport {filterPush} from './filter-push.ts';\nimport {\n  type FetchRequest,\n  type Input,\n  type Output,\n  type Start,\n} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport type {\n  Source,\n  SourceChange,\n  SourceChangeSet,\n  SourceInput,\n} from './source.ts';\nimport type {Stream} from './stream.ts';\nimport {once} from '../../../shared/src/iterables.ts';\nimport type {DebugDelegate} from '../builder/debug-delegate.ts';\n\nexport type Overlay = {\n  outputIndex: number;\n  change: SourceChange;\n};\n\nexport type Overlays = {\n  add: Row | undefined;\n  remove: Row | undefined;\n};\n\ntype Index = {\n  comparator: Comparator;\n  data: BTreeSet<Row>;\n  usedBy: Set<Connection>;\n};\n\nexport type Connection = {\n  input: Input;\n  output: Output | undefined;\n  sort: Ordering;\n  splitEditKeys: Set<string> | undefined;\n  compareRows: Comparator;\n  filters:\n    | {\n        condition: NoSubqueryCondition;\n        predicate: (row: Row) => boolean;\n      }\n    | undefined;\n  readonly debug?: DebugDelegate | undefined;\n};\n\n/**\n * A `MemorySource` is a source that provides data to the pipeline from an\n * in-memory data source.\n *\n * This data is kept in sorted order as downstream pipelines will always expect\n * the data they receive from `pull` to be in sorted order.\n */\nexport class MemorySource implements Source {\n  readonly #tableName: string;\n  readonly #columns: Record<string, SchemaValue>;\n  readonly #primaryKey: PrimaryKey;\n  readonly #primaryIndexSort: Ordering;\n  readonly #indexes: Map<string, Index> = new Map();\n  readonly #connections: Connection[] = [];\n\n  #overlay: Overlay | undefined;\n  #splitEditOverlay: Overlay | undefined;\n\n  constructor(\n    tableName: string,\n    columns: Record<string, SchemaValue>,\n    primaryKey: PrimaryKey,\n    primaryIndexData?: BTreeSet<Row> | undefined,\n  ) {\n    this.#tableName = tableName;\n    this.#columns = columns;\n    this.#primaryKey = primaryKey;\n    this.#primaryIndexSort = primaryKey.map(k => [k, 'asc']);\n    const comparator = makeBoundComparator(this.#primaryIndexSort);\n    this.#indexes.set(JSON.stringify(this.#primaryIndexSort), {\n      comparator,\n      data: primaryIndexData ?? new BTreeSet<Row>(comparator),\n      usedBy: new Set(),\n    });\n    assertOrderingIncludesPK(this.#primaryIndexSort, this.#primaryKey);\n  }\n\n  // Mainly for tests.\n  getSchemaInfo() {\n    return {\n      tableName: this.#tableName,\n      columns: this.#columns,\n      primaryKey: this.#primaryKey,\n    };\n  }\n\n  fork() {\n    const primaryIndex = this.#getPrimaryIndex();\n    return new MemorySource(\n      this.#tableName,\n      this.#columns,\n      this.#primaryKey,\n      primaryIndex.data.clone(),\n    );\n  }\n\n  get data(): BTreeSet<Row> {\n    return this.#getPrimaryIndex().data;\n  }\n\n  #getSchema(connection: Connection): SourceSchema {\n    return {\n      tableName: this.#tableName,\n      columns: this.#columns,\n      primaryKey: this.#primaryKey,\n      sort: connection.sort,\n      system: 'client',\n      relationships: {},\n      isHidden: false,\n      compareRows: connection.compareRows,\n    };\n  }\n\n  connect(\n    sort: Ordering,\n    filters?: Condition | undefined,\n    splitEditKeys?: Set<string> | undefined,\n  ): SourceInput {\n    const transformedFilters = transformFilters(filters);\n\n    const input: SourceInput = {\n      getSchema: () => schema,\n      fetch: req => this.#fetch(req, connection),\n      cleanup: req => this.#cleanup(req, connection),\n      setOutput: output => {\n        connection.output = output;\n      },\n      destroy: () => {\n        this.#disconnect(input);\n      },\n      fullyAppliedFilters: !transformedFilters.conditionsRemoved,\n    };\n\n    const connection: Connection = {\n      input,\n      output: undefined,\n      sort,\n      splitEditKeys,\n      compareRows: makeComparator(sort),\n      filters: transformedFilters.filters\n        ? {\n            condition: transformedFilters.filters,\n            predicate: createPredicate(transformedFilters.filters),\n          }\n        : undefined,\n    };\n    const schema = this.#getSchema(connection);\n    assertOrderingIncludesPK(sort, this.#primaryKey);\n    this.#connections.push(connection);\n    return input;\n  }\n\n  #disconnect(input: Input): void {\n    const idx = this.#connections.findIndex(c => c.input === input);\n    assert(idx !== -1, 'Connection not found');\n    this.#connections.splice(idx, 1);\n\n    // TODO: We used to delete unused indexes here. But in common cases like\n    // navigating into issue detail pages it caused a ton of constantly\n    // building and destroying indexes.\n    //\n    // Perhaps some intelligent LRU or something is needed here but for now,\n    // the opposite extreme of keeping all indexes for the lifetime of the\n    // page seems better.\n  }\n\n  #getPrimaryIndex(): Index {\n    const index = this.#indexes.get(JSON.stringify(this.#primaryIndexSort));\n    assert(index, 'Primary index not found');\n    return index;\n  }\n\n  #getOrCreateIndex(sort: Ordering, usedBy: Connection): Index {\n    const key = JSON.stringify(sort);\n    const index = this.#indexes.get(key);\n    // Future optimization could use existing index if it's the same just sorted\n    // in reverse of needed.\n    if (index) {\n      index.usedBy.add(usedBy);\n      return index;\n    }\n\n    const comparator = makeBoundComparator(sort);\n\n    // When creating these synchronously becomes a problem, a few options:\n    // 1. Allow users to specify needed indexes up front\n    // 2. Create indexes in a different thread asynchronously (this would require\n    // modifying the BTree to be able to be passed over structured-clone, or using\n    // a different library.)\n    // 3. We could even theoretically do (2) on multiple threads and then merge the\n    // results!\n    const data = new BTreeSet<Row>(comparator);\n\n    // I checked, there's no special path for adding data in bulk faster.\n    // The constructor takes an array, but it just calls add/set over and over.\n    for (const row of this.#getPrimaryIndex().data) {\n      data.add(row);\n    }\n\n    const newIndex = {comparator, data, usedBy: new Set([usedBy])};\n    this.#indexes.set(key, newIndex);\n    return newIndex;\n  }\n\n  // For unit testing that we correctly clean up indexes.\n  getIndexKeys(): string[] {\n    return [...this.#indexes.keys()];\n  }\n\n  *#fetch(req: FetchRequest, from: Connection): Stream<Node> {\n    const callingConnectionIndex = this.#connections.indexOf(from);\n    assert(callingConnectionIndex !== -1, 'Output not found');\n    const conn = this.#connections[callingConnectionIndex];\n    const {sort: requestedSort} = conn;\n\n    const pkConstraint = primaryKeyConstraintFromFilters(\n      conn.filters?.condition,\n      this.#primaryKey,\n    );\n    // The primary key constraint will be more limiting than the constraint\n    // so swap out to that if it exists.\n    const fetchOrPkConstraint = pkConstraint ?? req.constraint;\n\n    // If there is a constraint, we need an index sorted by it first.\n    const indexSort: OrderPart[] = [];\n    if (fetchOrPkConstraint) {\n      for (const key of Object.keys(fetchOrPkConstraint)) {\n        indexSort.push([key, 'asc']);\n      }\n    }\n\n    // For the special case of constraining by PK, we don't need to worry about\n    // any requested sort since there can only be one result. Otherwise we also\n    // need the index sorted by the requested sort.\n    if (\n      this.#primaryKey.length > 1 ||\n      !fetchOrPkConstraint ||\n      !constraintMatchesPrimaryKey(fetchOrPkConstraint, this.#primaryKey)\n    ) {\n      indexSort.push(...requestedSort);\n    }\n\n    const index = this.#getOrCreateIndex(indexSort, from);\n    const {data, comparator: compare} = index;\n    const comparator = (r1: Row, r2: Row) =>\n      compare(r1, r2) * (req.reverse ? -1 : 1);\n\n    const startAt = req.start?.row;\n\n    // If there is a constraint, we want to start our scan at the first row that\n    // matches the constraint. But because the next OrderPart can be `desc`,\n    // it's not true that {[constraintKey]: constraintValue} is the first\n    // matching row. Because in that case, the other fields will all be\n    // `undefined`, and in Zero `undefined` is always less than any other value.\n    // So if the second OrderPart is descending then `undefined` values will\n    // actually be the *last* row. We need a way to stay \"start at the first row\n    // with this constraint value\". RowBound with the corresponding compareBound\n    // comparator accomplishes this. The right thing is probably to teach the\n    // btree library to support this concept.\n    let scanStart: RowBound | undefined;\n\n    if (fetchOrPkConstraint) {\n      scanStart = {};\n      for (const [key, dir] of indexSort) {\n        if (hasOwn(fetchOrPkConstraint, key)) {\n          scanStart[key] = fetchOrPkConstraint[key];\n        } else {\n          if (req.reverse) {\n            scanStart[key] = dir === 'asc' ? maxValue : minValue;\n          } else {\n            scanStart[key] = dir === 'asc' ? minValue : maxValue;\n          }\n        }\n      }\n    } else {\n      scanStart = startAt;\n    }\n\n    const rowsIterable = generateRows(data, scanStart, req.reverse);\n    const withOverlay = generateWithOverlay(\n      startAt,\n      pkConstraint ? once(rowsIterable) : rowsIterable,\n      // use `req.constraint` here and not `fetchOrPkConstraint` since `fetchOrPkConstraint` could be the\n      // primary key constraint. The primary key constraint comes from filters and is acting as a filter\n      // rather than as the fetch constraint.\n      req.constraint,\n      this.#overlay,\n      this.#splitEditOverlay,\n      callingConnectionIndex,\n      comparator,\n      conn.filters?.predicate,\n    );\n\n    const withConstraint = generateWithConstraint(\n      generateWithStart(withOverlay, req.start, comparator),\n      // we use `req.constraint` and not `fetchOrPkConstraint` here because we need to\n      // AND the constraint with what could have been the primary key constraint\n      req.constraint,\n    );\n\n    yield* conn.filters\n      ? generateWithFilter(withConstraint, conn.filters.predicate)\n      : withConstraint;\n  }\n\n  #cleanup(req: FetchRequest, connection: Connection): Stream<Node> {\n    return this.#fetch(req, connection);\n  }\n\n  push(change: SourceChange | SourceChangeSet): void {\n    for (const _ of this.genPush(change)) {\n      // Nothing to do.\n    }\n  }\n\n  *genPush(change: SourceChange | SourceChangeSet) {\n    const primaryIndex = this.#getPrimaryIndex();\n    const {data} = primaryIndex;\n    const exists = (row: Row) => data.has(row);\n    const setOverlay = (o: Overlay | undefined) => (this.#overlay = o);\n    const setSplitEditOverlay = (o: Overlay | undefined) =>\n      (this.#splitEditOverlay = o);\n\n    if (change.type === 'set') {\n      const existing = data.get(change.row);\n      if (existing !== undefined) {\n        change = {\n          type: 'edit',\n          row: change.row,\n          oldRow: existing,\n        };\n      } else {\n        change = {\n          type: 'add',\n          row: change.row,\n        };\n      }\n    }\n\n    for (const x of genPush(\n      change,\n      exists,\n      this.#connections.entries(),\n      setOverlay,\n      setSplitEditOverlay,\n    )) {\n      yield x;\n    }\n\n    for (const {data} of this.#indexes.values()) {\n      switch (change.type) {\n        case 'add': {\n          const added = data.add(change.row);\n          // must succeed since we checked has() above.\n          assert(added);\n          break;\n        }\n        case 'remove': {\n          const removed = data.delete(change.row);\n          // must succeed since we checked has() above.\n          assert(removed);\n          break;\n        }\n        case 'edit': {\n          // TODO: We could see if the PK (form the index tree's perspective)\n          // changed and if not we could use set.\n\n          // We cannot just do `set` with the new value since the `oldRow` might\n          // not map to the same entry as the new `row` in the index btree.\n          const removed = data.delete(change.oldRow);\n          // must succeed since we checked has() above.\n          assert(removed);\n          data.add(change.row);\n          break;\n        }\n        default:\n          unreachable(change);\n      }\n    }\n  }\n}\n\nfunction* generateWithConstraint(\n  it: Stream<Node>,\n  constraint: Constraint | undefined,\n) {\n  for (const node of it) {\n    if (constraint && !constraintMatchesRow(constraint, node.row)) {\n      break;\n    }\n    yield node;\n  }\n}\n\nfunction* generateWithFilter(it: Stream<Node>, filter: (row: Row) => boolean) {\n  for (const node of it) {\n    if (filter(node.row)) {\n      yield node;\n    }\n  }\n}\n\nexport function* genPush(\n  change: SourceChange,\n  exists: (row: Row) => boolean,\n  connections: Iterable<[number, Connection]>,\n  setOverlay: (o: Overlay | undefined) => void,\n  setSplitEditOverlay: (o: Overlay | undefined) => void,\n) {\n  switch (change.type) {\n    case 'add':\n      assert(\n        !exists(change.row),\n        () => `Row already exists ${stringify(change)}`,\n      );\n      break;\n    case 'remove':\n      assert(exists(change.row), () => `Row not found ${stringify(change)}`);\n      break;\n    case 'edit':\n      assert(exists(change.oldRow), () => `Row not found ${stringify(change)}`);\n      break;\n    default:\n      unreachable(change);\n  }\n\n  for (const [outputIndex, {output, splitEditKeys, filters}] of connections) {\n    if (output) {\n      let splitEdit = false;\n      if (change.type === 'edit' && splitEditKeys) {\n        for (const key of splitEditKeys) {\n          if (!valuesEqual(change.row[key], change.oldRow[key])) {\n            splitEdit = true;\n            break;\n          }\n        }\n      }\n      if (splitEdit) {\n        assert(change.type === 'edit');\n        setSplitEditOverlay({\n          outputIndex,\n          change: {\n            type: 'remove',\n            row: change.oldRow,\n          },\n        });\n        const outputRemove: RemoveChange = {\n          type: 'remove',\n          node: {\n            row: change.oldRow,\n            relationships: {},\n          },\n        };\n        filterPush(outputRemove, output, filters?.predicate);\n        yield;\n        setSplitEditOverlay(undefined);\n        setOverlay({outputIndex, change});\n        const outputAdd: AddChange = {\n          type: 'add',\n          node: {\n            row: change.row,\n            relationships: {},\n          },\n        };\n        filterPush(outputAdd, output, filters?.predicate);\n        yield;\n      } else {\n        setOverlay({outputIndex, change});\n        const outputChange: Change =\n          change.type === 'edit'\n            ? {\n                type: change.type,\n                oldNode: {\n                  row: change.oldRow,\n                  relationships: {},\n                },\n                node: {\n                  row: change.row,\n                  relationships: {},\n                },\n              }\n            : {\n                type: change.type,\n                node: {\n                  row: change.row,\n                  relationships: {},\n                },\n              };\n        filterPush(outputChange, output, filters?.predicate);\n        yield;\n      }\n    }\n  }\n  setOverlay(undefined);\n}\n\nexport function* generateWithStart(\n  nodes: Iterable<Node>,\n  start: Start | undefined,\n  compare: (r1: Row, r2: Row) => number,\n): Stream<Node> {\n  if (!start) {\n    yield* nodes;\n    return;\n  }\n  let started = false;\n  for (const node of nodes) {\n    if (!started) {\n      if (start.basis === 'at') {\n        if (compare(node.row, start.row) >= 0) {\n          started = true;\n        }\n      } else if (start.basis === 'after') {\n        if (compare(node.row, start.row) > 0) {\n          started = true;\n        }\n      }\n    }\n    if (started) {\n      yield node;\n    }\n  }\n}\n\n/**\n * Takes an iterator and overlay.\n * Splices the overlay into the iterator at the correct position.\n *\n * @param startAt - if there is a lower bound to the stream. If the lower bound of the stream\n * is above the overlay, the overlay will be skipped.\n * @param rows - the stream into which the overlay should be spliced\n * @param constraint - constraint that was applied to the rowIterator and should\n * also be applied to the overlay.\n * @param overlay - the overlay values to splice in\n * @param compare - the comparator to use to find the position for the overlay\n */\nexport function* generateWithOverlay(\n  startAt: Row | undefined,\n  rows: Iterable<Row>,\n  constraint: Constraint | undefined,\n  overlay: Overlay | undefined,\n  splitEditOverlay: Overlay | undefined,\n  connectionIndex: number,\n  compare: Comparator,\n  filterPredicate?: (row: Row) => boolean | undefined,\n) {\n  let overlayToApply: Overlay | undefined = undefined;\n  if (splitEditOverlay && splitEditOverlay.outputIndex === connectionIndex) {\n    overlayToApply = splitEditOverlay;\n  } else if (overlay && connectionIndex <= overlay.outputIndex) {\n    overlayToApply = overlay;\n  }\n  const overlays = computeOverlays(\n    startAt,\n    constraint,\n    overlayToApply,\n    compare,\n    filterPredicate,\n  );\n  yield* generateWithOverlayInner(rows, overlays, compare);\n}\n\nfunction computeOverlays(\n  startAt: Row | undefined,\n  constraint: Constraint | undefined,\n  overlay: Overlay | undefined,\n  compare: Comparator,\n  filterPredicate?: (row: Row) => boolean | undefined,\n): Overlays {\n  let overlays: Overlays = {\n    add: undefined,\n    remove: undefined,\n  };\n  switch (overlay?.change.type) {\n    case 'add':\n      overlays = {\n        add: overlay.change.row,\n        remove: undefined,\n      };\n      break;\n    case 'remove':\n      overlays = {\n        add: undefined,\n        remove: overlay.change.row,\n      };\n      break;\n    case 'edit':\n      overlays = {\n        add: overlay.change.row,\n        remove: overlay.change.oldRow,\n      };\n      break;\n  }\n\n  if (startAt) {\n    overlays = overlaysForStartAt(overlays, startAt, compare);\n  }\n\n  if (constraint) {\n    overlays = overlaysForConstraint(overlays, constraint);\n  }\n\n  if (filterPredicate) {\n    overlays = overlaysForFilterPredicate(overlays, filterPredicate);\n  }\n\n  return overlays;\n}\n\nexport {overlaysForStartAt as overlaysForStartAtForTest};\n\nfunction overlaysForStartAt(\n  {add, remove}: Overlays,\n  startAt: Row,\n  compare: Comparator,\n): Overlays {\n  const undefinedIfBeforeStartAt = (row: Row | undefined) =>\n    row === undefined || compare(row, startAt) < 0 ? undefined : row;\n  return {\n    add: undefinedIfBeforeStartAt(add),\n    remove: undefinedIfBeforeStartAt(remove),\n  };\n}\n\nexport {overlaysForConstraint as overlaysForConstraintForTest};\n\nfunction overlaysForConstraint(\n  {add, remove}: Overlays,\n  constraint: Constraint,\n): Overlays {\n  const undefinedIfDoesntMatchConstraint = (row: Row | undefined) =>\n    row === undefined || !constraintMatchesRow(constraint, row)\n      ? undefined\n      : row;\n\n  return {\n    add: undefinedIfDoesntMatchConstraint(add),\n    remove: undefinedIfDoesntMatchConstraint(remove),\n  };\n}\n\nfunction overlaysForFilterPredicate(\n  {add, remove}: Overlays,\n  filterPredicate: (row: Row) => boolean | undefined,\n): Overlays {\n  const undefinedIfDoesntMatchFilter = (row: Row | undefined) =>\n    row === undefined || !filterPredicate(row) ? undefined : row;\n\n  return {\n    add: undefinedIfDoesntMatchFilter(add),\n    remove: undefinedIfDoesntMatchFilter(remove),\n  };\n}\n\nexport function* generateWithOverlayInner(\n  rowIterator: Iterable<Row>,\n  overlays: Overlays,\n  compare: (r1: Row, r2: Row) => number,\n) {\n  let addOverlayYielded = false;\n  let removeOverlaySkipped = false;\n  for (const row of rowIterator) {\n    if (!addOverlayYielded && overlays.add) {\n      const cmp = compare(overlays.add, row);\n      if (cmp < 0) {\n        addOverlayYielded = true;\n        yield {row: overlays.add, relationships: {}};\n      }\n    }\n\n    if (!removeOverlaySkipped && overlays.remove) {\n      const cmp = compare(overlays.remove, row);\n      if (cmp === 0) {\n        removeOverlaySkipped = true;\n        continue;\n      }\n    }\n    yield {row, relationships: {}};\n  }\n\n  if (!addOverlayYielded && overlays.add) {\n    yield {row: overlays.add, relationships: {}};\n  }\n}\n\n/**\n * A location to begin scanning an index from. Can either be a specific value\n * or the min or max possible value for the type. This is used to start a scan\n * at the beginning of the rows matching a constraint.\n */\ntype Bound = Value | MinValue | MaxValue;\ntype RowBound = Record<string, Bound>;\nconst minValue = Symbol('min-value');\ntype MinValue = typeof minValue;\nconst maxValue = Symbol('max-value');\ntype MaxValue = typeof maxValue;\n\nfunction makeBoundComparator(sort: Ordering) {\n  return (a: RowBound, b: RowBound) => {\n    // Hot! Do not use destructuring\n    for (const entry of sort) {\n      const key = entry[0];\n      const cmp = compareBounds(a[key], b[key]);\n      if (cmp !== 0) {\n        return entry[1] === 'asc' ? cmp : -cmp;\n      }\n    }\n    return 0;\n  };\n}\n\nfunction compareBounds(a: Bound, b: Bound): number {\n  if (a === b) {\n    return 0;\n  }\n  if (a === minValue) {\n    return -1;\n  }\n  if (b === minValue) {\n    return 1;\n  }\n  if (a === maxValue) {\n    return 1;\n  }\n  if (b === maxValue) {\n    return -1;\n  }\n  return compareValues(a, b);\n}\n\nfunction* generateRows(\n  data: BTreeSet<Row>,\n  scanStart: RowBound | undefined,\n  reverse: boolean | undefined,\n) {\n  yield* data[reverse ? 'valuesFromReversed' : 'valuesFrom'](\n    scanStart as Row | undefined,\n  );\n}\n\nexport function stringify(change: SourceChange) {\n  return JSON.stringify(change, (_, v) =>\n    typeof v === 'bigint' ? v.toString() : v,\n  );\n}\n","import {MemorySource} from '../../../zql/src/ivm/memory-source.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport {wrapIterable} from '../../../shared/src/iterables.ts';\nimport {type Read, type Store} from '../../../replicache/src/dag/store.ts';\nimport {using, withRead} from '../../../replicache/src/with-transactions.ts';\nimport type {Hash} from '../../../replicache/src/hash.ts';\nimport * as FormatVersion from '../../../replicache/src/format-version-enum.ts';\nimport {ENTITIES_KEY_PREFIX, sourceNameFromKey} from './keys.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport {diff, DiffsMap} from '../../../replicache/src/sync/diff.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {\n  InternalDiff,\n  InternalDiffOperation,\n  NoIndexDiff,\n} from '../../../replicache/src/btree/node.ts';\nimport {diffBinarySearch} from '../../../replicache/src/subscriptions.ts';\nimport {readFromHash} from '../../../replicache/src/db/read.ts';\nimport type {ZeroReadOptions} from '../../../replicache/src/replicache-options.ts';\nimport type {LazyStore} from '../../../replicache/src/dag/lazy-store.ts';\n\n/**\n * Replicache needs to rebase mutations onto different\n * commits of it's b-tree. These mutations can have reads\n * in them and those reads must be run against the IVM sources.\n *\n * To ensure the reads get the correct state, the IVM\n * sources need to reflect the state of the commit\n * being rebased onto. `IVMSourceBranch` allows us to:\n * 1. fork the IVM sources\n * 2. patch them up to match the desired head\n * 3. run the reads against the forked sources\n *\n * (2) is expected to be a cheap operation as there should only\n * ever be a few outstanding diffs to apply given Zero is meant\n * to be run in a connected state.\n */\nexport class IVMSourceBranch {\n  readonly #sources: Map<string, MemorySource | undefined>;\n  readonly #tables: Record<string, TableSchema>;\n  hash: Hash | undefined;\n\n  constructor(\n    tables: Record<string, TableSchema>,\n    hash?: Hash | undefined,\n    sources: Map<string, MemorySource | undefined> = new Map(),\n  ) {\n    this.#tables = tables;\n    this.#sources = sources;\n    this.hash = hash;\n  }\n\n  getSource(name: string): MemorySource | undefined {\n    if (this.#sources.has(name)) {\n      return this.#sources.get(name);\n    }\n\n    const schema = this.#tables[name];\n    const source = schema\n      ? new MemorySource(name, schema.columns, schema.primaryKey)\n      : undefined;\n    this.#sources.set(name, source);\n    return source;\n  }\n\n  clear() {\n    this.#sources.clear();\n  }\n\n  /**\n   * Mutates the current branch, advancing it to the new head\n   * by applying the given diffs.\n   */\n  advance(expectedHead: Hash | undefined, newHead: Hash, diffs: NoIndexDiff) {\n    assert(\n      this.hash === expectedHead,\n      () =>\n        `Expected head must match the main head. Got: ${this.hash}, expected: ${expectedHead}`,\n    );\n\n    applyDiffs(diffs, this);\n    this.hash = newHead;\n  }\n\n  /**\n   * Fork the branch and patch it up to match the desired head.\n   */\n  async forkToHead(\n    store: LazyStore,\n    desiredHead: Hash,\n    readOptions?: ZeroReadOptions | undefined,\n  ): Promise<IVMSourceBranch> {\n    const fork = this.fork();\n\n    if (fork.hash === desiredHead) {\n      return fork;\n    }\n\n    await patchBranch(desiredHead, store, fork, readOptions);\n    fork.hash = desiredHead;\n    return fork;\n  }\n\n  /**\n   * Creates a new IVMSourceBranch that is a copy of the current one.\n   * This is a cheap operation since the b-trees are shared until a write is performed\n   * and then only the modified nodes are copied.\n   *\n   * IVM branches are forked when we need to rebase mutations.\n   * The mutations modify the fork rather than original branch.\n   */\n  fork() {\n    return new IVMSourceBranch(\n      this.#tables,\n      this.hash,\n      new Map(\n        wrapIterable(this.#sources.entries()).map(([name, source]) => [\n          name,\n          source?.fork(),\n        ]),\n      ),\n    );\n  }\n}\n\nexport async function initFromStore(\n  branch: IVMSourceBranch,\n  hash: Hash,\n  store: Store,\n) {\n  const diffs: InternalDiffOperation[] = [];\n  await withRead(store, async dagRead => {\n    const read = await readFromHash(hash, dagRead, FormatVersion.Latest);\n    for await (const entry of read.map.scan(ENTITIES_KEY_PREFIX)) {\n      if (!entry[0].startsWith(ENTITIES_KEY_PREFIX)) {\n        break;\n      }\n      diffs.push({\n        op: 'add',\n        key: entry[0],\n        newValue: entry[1],\n      });\n    }\n  });\n\n  branch.advance(undefined, hash, diffs);\n}\n\nasync function patchBranch(\n  desiredHead: Hash,\n  store: LazyStore,\n  fork: IVMSourceBranch,\n  readOptions: ZeroReadOptions | undefined,\n) {\n  const diffs = await computeDiffs(\n    must(fork.hash),\n    desiredHead,\n    store,\n    readOptions,\n  );\n  if (!diffs) {\n    return;\n  }\n  applyDiffs(diffs, fork);\n}\n\nasync function computeDiffs(\n  startHash: Hash,\n  endHash: Hash,\n  store: LazyStore,\n  readOptions: ZeroReadOptions | undefined,\n): Promise<InternalDiff | undefined> {\n  const readFn = (dagRead: Read) =>\n    diff(\n      startHash,\n      endHash,\n      dagRead,\n      {\n        shouldComputeDiffs: () => true,\n        shouldComputeDiffsForIndex(_name) {\n          return false;\n        },\n      },\n      FormatVersion.Latest,\n    );\n\n  let diffs: DiffsMap;\n  if (readOptions?.openLazySourceRead) {\n    diffs = await using(store.read(readOptions.openLazySourceRead), readFn);\n  } else if (readOptions?.openLazyRead) {\n    diffs = await readFn(readOptions.openLazyRead);\n  } else {\n    diffs = await withRead(store, readFn);\n  }\n\n  return diffs.get('');\n}\n\nfunction applyDiffs(diffs: NoIndexDiff, branch: IVMSourceBranch) {\n  for (\n    let i = diffBinarySearch(diffs, ENTITIES_KEY_PREFIX, diff => diff.key);\n    i < diffs.length;\n    i++\n  ) {\n    const diff = diffs[i];\n    const {key} = diff;\n    if (!key.startsWith(ENTITIES_KEY_PREFIX)) {\n      break;\n    }\n    const name = sourceNameFromKey(key);\n    const source = must(branch.getSource(name));\n    switch (diff.op) {\n      case 'del':\n        source.push({\n          type: 'remove',\n          row: diff.oldValue as Row,\n        });\n        break;\n      case 'add':\n        source.push({\n          type: 'add',\n          row: diff.newValue as Row,\n        });\n        break;\n      case 'change':\n        source.push({\n          type: 'edit',\n          row: diff.newValue as Row,\n          oldRow: diff.oldValue as Row,\n        });\n        break;\n    }\n  }\n}\n","import type {NoIndexDiff} from '../../../replicache/src/btree/node.ts';\nimport type {Hash} from '../../../replicache/src/hash.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {AST} from '../../../zero-protocol/src/ast.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport type {FilterInput} from '../../../zql/src/ivm/filter-operators.ts';\nimport {MemoryStorage} from '../../../zql/src/ivm/memory-storage.ts';\nimport type {Input, Storage} from '../../../zql/src/ivm/operator.ts';\nimport type {Source, SourceInput} from '../../../zql/src/ivm/source.ts';\nimport {MeasurePushOperator} from '../../../zql/src/query/measure-push-operator.ts';\nimport type {MetricsDelegate} from '../../../zql/src/query/metrics-delegate.ts';\nimport type {\n  CommitListener,\n  QueryDelegate,\n} from '../../../zql/src/query/query-delegate.ts';\nimport type {RunOptions} from '../../../zql/src/query/query.ts';\nimport {type IVMSourceBranch} from './ivm-branch.ts';\nimport type {QueryManager} from './query-manager.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\nexport type AddQuery = QueryManager['addLegacy'];\nexport type AddCustomQuery = QueryManager['addCustom'];\n\nexport type UpdateQuery = QueryManager['updateLegacy'];\nexport type UpdateCustomQuery = QueryManager['updateCustom'];\nexport type FlushQueryChanges = QueryManager['flushBatch'];\n\n/**\n * ZeroContext glues together zql and Replicache. It listens to changes in\n * Replicache data and pushes them into IVM and on tells the server about new\n * queries.\n */\nexport class ZeroContext implements QueryDelegate {\n  // It is a bummer to have to maintain separate MemorySources here and copy the\n  // data in from the Replicache db. But we want the data to be accessible via\n  // pipelines *synchronously* and the core Replicache infra is all async. So\n  // that needs to be fixed.\n  readonly #mainSources: IVMSourceBranch;\n  readonly addServerQuery: AddQuery;\n  readonly addCustomQuery: AddCustomQuery;\n  readonly updateServerQuery: UpdateQuery;\n  readonly updateCustomQuery: UpdateCustomQuery;\n  readonly flushQueryChanges: () => void;\n  readonly #batchViewUpdates: (applyViewUpdates: () => void) => void;\n  readonly #commitListeners: Set<CommitListener> = new Set();\n\n  readonly #lc: ZeroLogContext;\n  readonly assertValidRunOptions: (options?: RunOptions) => void;\n\n  /**\n   * Client-side queries start out as \"unknown\" and are then updated to\n   * \"complete\" once the server has sent back the query result.\n   */\n  readonly defaultQueryComplete = false;\n\n  readonly addMetric: MetricsDelegate['addMetric'];\n\n  constructor(\n    lc: ZeroLogContext,\n    mainSources: IVMSourceBranch,\n    addQuery: AddQuery,\n    addCustomQuery: AddCustomQuery,\n    updateQuery: UpdateQuery,\n    updateCustomQuery: UpdateCustomQuery,\n    flushQueryChanges: () => void,\n    batchViewUpdates: (applyViewUpdates: () => void) => void,\n    addMetric: MetricsDelegate['addMetric'],\n    assertValidRunOptions: (options?: RunOptions) => void,\n  ) {\n    this.#mainSources = mainSources;\n    this.addServerQuery = addQuery;\n    this.updateServerQuery = updateQuery;\n    this.updateCustomQuery = updateCustomQuery;\n    this.#batchViewUpdates = batchViewUpdates;\n    this.#lc = lc;\n    this.assertValidRunOptions = assertValidRunOptions;\n    this.addCustomQuery = addCustomQuery;\n    this.flushQueryChanges = flushQueryChanges;\n    this.addMetric = addMetric;\n  }\n\n  getSource(name: string): Source | undefined {\n    return this.#mainSources.getSource(name);\n  }\n\n  mapAst(ast: AST): AST {\n    return ast;\n  }\n\n  createStorage(): Storage {\n    return new MemoryStorage();\n  }\n\n  decorateInput(input: Input): Input {\n    return input;\n  }\n\n  decorateFilterInput(input: FilterInput): FilterInput {\n    return input;\n  }\n\n  decorateSourceInput(input: SourceInput, queryID: string): Input {\n    return new MeasurePushOperator(input, queryID, this, 'query-update-client');\n  }\n\n  addEdge() {}\n\n  onTransactionCommit(cb: CommitListener): () => void {\n    this.#commitListeners.add(cb);\n    return () => {\n      this.#commitListeners.delete(cb);\n    };\n  }\n\n  batchViewUpdates<T>(applyViewUpdates: () => T) {\n    let result: T | undefined;\n    let viewChangesPerformed = false;\n    this.#batchViewUpdates(() => {\n      result = applyViewUpdates();\n      viewChangesPerformed = true;\n    });\n    assert(\n      viewChangesPerformed,\n      'batchViewUpdates must call applyViewUpdates synchronously.',\n    );\n    return result as T;\n  }\n\n  processChanges(\n    expectedHead: Hash | undefined,\n    newHead: Hash,\n    changes: NoIndexDiff,\n  ) {\n    this.batchViewUpdates(() => {\n      try {\n        this.#mainSources.advance(expectedHead, newHead, changes);\n      } finally {\n        this.#endTransaction();\n      }\n    });\n  }\n\n  #endTransaction() {\n    for (const listener of this.#commitListeners) {\n      try {\n        listener();\n      } catch (e) {\n        // We should not fatal the inner-workings of Zero due to the user's application\n        // code throwing an error.\n        // Hence we wrap notifications in a try-catch block.\n        this.#lc.error?.(\n          ErrorKind.Internal,\n          'Failed notifying a commit listener of IVM updates',\n          e,\n        );\n      }\n    }\n  }\n}\n","import type {ReadonlyJSONObject} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport {\n  CRUD_MUTATION_NAME,\n  type CRUDMutationArg,\n  type CRUDOp,\n  type DeleteOp,\n  type InsertOp,\n  type UpdateOp,\n  type UpsertOp,\n} from '../../../zero-protocol/src/push.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport type {IVMSourceBranch} from './ivm-branch.ts';\nimport {toPrimaryKeyString} from './keys.ts';\nimport type {MutatorDefs, WriteTransaction} from './replicache-types.ts';\nimport type {\n  InsertValue,\n  UpdateValue,\n  UpsertValue,\n  DeleteID,\n} from '../../../zql/src/mutate/custom.ts';\n\n/**\n * This is the type of the generated mutate.<name>.<verb> function.\n */\nexport type TableMutator<S extends TableSchema> = {\n  /**\n   * Writes a row if a row with the same primary key doesn't already exists.\n   * Non-primary-key fields that are 'optional' can be omitted or set to\n   * `undefined`. Such fields will be assigned the value `null` optimistically\n   * and then the default value as defined by the server.\n   */\n  insert: (value: InsertValue<S>) => Promise<void>;\n\n  /**\n   * Writes a row unconditionally, overwriting any existing row with the same\n   * primary key. Non-primary-key fields that are 'optional' can be omitted or\n   * set to `undefined`. Such fields will be assigned the value `null`\n   * optimistically and then the default value as defined by the server.\n   */\n  upsert: (value: UpsertValue<S>) => Promise<void>;\n\n  /**\n   * Updates a row with the same primary key. If no such row exists, this\n   * function does nothing. All non-primary-key fields can be omitted or set to\n   * `undefined`. Such fields will be left unchanged from previous value.\n   */\n  update: (value: UpdateValue<S>) => Promise<void>;\n\n  /**\n   * Deletes the row with the specified primary key. If no such row exists, this\n   * function does nothing.\n   */\n  delete: (id: DeleteID<S>) => Promise<void>;\n};\n\nexport type DBMutator<S extends Schema> =\n  S['enableLegacyMutators'] extends false\n    ? {} // eslint-disable-line @typescript-eslint/ban-types -- {} is needed here for intersection type identity\n    : {\n        [K in keyof S['tables']]: TableMutator<S['tables'][K]>;\n      };\n\nexport type BatchMutator<S extends Schema> = <R>(\n  body: (m: DBMutator<S>) => MaybePromise<R>,\n) => Promise<R>;\n\ntype ZeroCRUDMutate = {\n  [CRUD_MUTATION_NAME]: CRUDMutate;\n};\n\n/**\n * This is the zero.mutate object part representing the CRUD operations. If the\n * queries are `issue` and `label`, then this object will have `issue` and\n * `label` properties.\n */\nexport function makeCRUDMutate<const S extends Schema>(\n  schema: S,\n  repMutate: ZeroCRUDMutate,\n): {mutate: DBMutator<S>; mutateBatch: BatchMutator<S>} {\n  const {[CRUD_MUTATION_NAME]: zeroCRUD} = repMutate;\n\n  const mutateBatch = async <R>(body: (m: DBMutator<S>) => R): Promise<R> => {\n    const ops: CRUDOp[] = [];\n    const m = {} as Record<string, unknown>;\n    for (const name of Object.keys(schema.tables)) {\n      m[name] = makeBatchCRUDMutate(name, schema, ops);\n    }\n\n    const rv = await body(m as DBMutator<S>);\n    await zeroCRUD({ops});\n    return rv;\n  };\n\n  const mutate: Record<string, TableMutator<TableSchema>> = {};\n  for (const [name, tableSchema] of Object.entries(schema.tables)) {\n    mutate[name] = makeEntityCRUDMutate(name, tableSchema.primaryKey, zeroCRUD);\n  }\n  return {\n    mutate: mutate as DBMutator<S>,\n    mutateBatch: mutateBatch as BatchMutator<S>,\n  };\n}\n\n/**\n * Creates the `{insert, upsert, update, delete}` object for use outside a\n * batch.\n */\nfunction makeEntityCRUDMutate<S extends TableSchema>(\n  tableName: string,\n  primaryKey: S['primaryKey'],\n  zeroCRUD: CRUDMutate,\n): TableMutator<S> {\n  return {\n    insert: (value: InsertValue<S>) => {\n      const op: InsertOp = {\n        op: 'insert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n    upsert: (value: UpsertValue<S>) => {\n      const op: UpsertOp = {\n        op: 'upsert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n    update: (value: UpdateValue<S>) => {\n      const op: UpdateOp = {\n        op: 'update',\n        tableName,\n        primaryKey,\n        value,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n    delete: (id: DeleteID<S>) => {\n      const op: DeleteOp = {\n        op: 'delete',\n        tableName,\n        primaryKey,\n        value: id,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n  };\n}\n\n/**\n * Creates the `{inesrt, upsert, update, delete}` object for use inside a\n * batch.\n */\nexport function makeBatchCRUDMutate<S extends TableSchema>(\n  tableName: string,\n  schema: Schema,\n  ops: CRUDOp[],\n): TableMutator<S> {\n  const {primaryKey} = schema.tables[tableName];\n  return {\n    insert: (value: InsertValue<S>) => {\n      const op: InsertOp = {\n        op: 'insert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n    upsert: (value: UpsertValue<S>) => {\n      const op: UpsertOp = {\n        op: 'upsert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n    update: (value: UpdateValue<S>) => {\n      const op: UpdateOp = {\n        op: 'update',\n        tableName,\n        primaryKey,\n        value,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n    delete: (id: DeleteID<S>) => {\n      const op: DeleteOp = {\n        op: 'delete',\n        tableName,\n        primaryKey,\n        value: id,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n  };\n}\n\nexport type WithCRUD<MD extends MutatorDefs> = MD & {\n  [CRUD_MUTATION_NAME]: CRUDMutator;\n};\n\nexport type CRUDMutate = (crudArg: CRUDMutationArg) => Promise<void>;\n\nexport type CRUDMutator = (\n  tx: WriteTransaction,\n  crudArg: CRUDMutationArg,\n) => Promise<void>;\n\n// Zero crud mutators cannot function at the same\n// time as custom mutators as the rebase of crud mutators will not\n// update the IVM branch. That's ok, we're removing crud mutators\n// in favor of custom mutators.\nexport function makeCRUDMutator(schema: Schema): CRUDMutator {\n  return async function zeroCRUDMutator(\n    tx: WriteTransaction,\n    crudArg: CRUDMutationArg,\n  ): Promise<void> {\n    for (const op of crudArg.ops) {\n      switch (op.op) {\n        case 'insert':\n          await insertImpl(tx, op, schema, undefined);\n          break;\n        case 'upsert':\n          await upsertImpl(tx, op, schema, undefined);\n          break;\n        case 'update':\n          await updateImpl(tx, op, schema, undefined);\n          break;\n        case 'delete':\n          await deleteImpl(tx, op, schema, undefined);\n          break;\n      }\n    }\n  };\n}\n\nfunction defaultOptionalFieldsToNull(\n  schema: TableSchema,\n  value: ReadonlyJSONObject,\n): ReadonlyJSONObject {\n  let rv = value;\n  for (const name in schema.columns) {\n    if (rv[name] === undefined) {\n      rv = {...rv, [name]: null};\n    }\n  }\n  return rv;\n}\n\nexport async function insertImpl(\n  tx: WriteTransaction,\n  arg: InsertOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  if (!(await tx.has(key))) {\n    const val = defaultOptionalFieldsToNull(\n      schema.tables[arg.tableName],\n      arg.value,\n    );\n    await tx.set(key, val);\n    if (ivmBranch) {\n      must(ivmBranch.getSource(arg.tableName)).push({\n        type: 'add',\n        row: arg.value,\n      });\n    }\n  }\n}\n\nexport async function upsertImpl(\n  tx: WriteTransaction,\n  arg: InsertOp | UpsertOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  const val = defaultOptionalFieldsToNull(\n    schema.tables[arg.tableName],\n    arg.value,\n  );\n  await tx.set(key, val);\n  if (ivmBranch) {\n    must(ivmBranch.getSource(arg.tableName)).push({\n      type: 'set',\n      row: arg.value,\n    });\n  }\n}\n\nexport async function updateImpl(\n  tx: WriteTransaction,\n  arg: UpdateOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  const prev = await tx.get(key);\n  if (prev === undefined) {\n    return;\n  }\n  const update = arg.value;\n  const next = {...(prev as ReadonlyJSONObject)};\n  for (const k in update) {\n    if (update[k] !== undefined) {\n      next[k] = update[k];\n    }\n  }\n  await tx.set(key, next);\n  if (ivmBranch) {\n    must(ivmBranch.getSource(arg.tableName)).push({\n      type: 'edit',\n      oldRow: prev as Row,\n      row: next,\n    });\n  }\n}\n\nexport async function deleteImpl(\n  tx: WriteTransaction,\n  arg: DeleteOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  const prev = await tx.get(key);\n  if (prev === undefined) {\n    return;\n  }\n  await tx.del(key);\n  if (ivmBranch) {\n    must(ivmBranch.getSource(arg.tableName)).push({\n      type: 'remove',\n      row: prev as Row,\n    });\n  }\n}\n","export function emptyFunction() {}\nexport const emptyObject = Object.freeze({});\n","import {\n  WriteTransactionImpl,\n  zeroData,\n} from '../../../replicache/src/transactions.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {emptyFunction} from '../../../shared/src/sentinels.ts';\nimport type {MutationOk} from '../../../zero-protocol/src/push.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport type {\n  ClientTransaction,\n  DeleteID,\n  InsertValue,\n  SchemaCRUD,\n  SchemaQuery,\n  TableCRUD,\n  Transaction,\n  UpdateValue,\n  UpsertValue,\n} from '../../../zql/src/mutate/custom.ts';\nimport {newQuery} from '../../../zql/src/query/query-impl.ts';\nimport {type Query, type RunOptions} from '../../../zql/src/query/query.ts';\nimport type {ClientID} from '../types/client-state.ts';\nimport {ZeroContext} from './context.ts';\nimport {deleteImpl, insertImpl, updateImpl, upsertImpl} from './crud.ts';\nimport type {IVMSourceBranch} from './ivm-branch.ts';\nimport type {WriteTransaction} from './replicache-types.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\n/**\n * The shape which a user's custom mutator definitions must conform to.\n */\nexport type CustomMutatorDefs = {\n  [namespaceOrKey: string]:\n    | {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [key: string]: CustomMutatorImpl<any>;\n      }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | CustomMutatorImpl<any>;\n};\n\nexport type MutatorResult = {\n  client: Promise<void>;\n  server: Promise<MutationOk>;\n};\n\nexport type CustomMutatorImpl<\n  S extends Schema,\n  TWrappedTransaction = unknown,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TArgs = any,\n> = (\n  tx: Transaction<S, TWrappedTransaction>,\n  // TODO: many args. See commit: 52657c2f934b4a458d628ea77e56ce92b61eb3c6 which did have many args.\n  // The issue being that it will be a protocol change to support varargs.\n  args: TArgs,\n) => Promise<void>;\n\n/**\n * The shape exposed on the `Zero.mutate` instance.\n * The signature of a custom mutator takes a `transaction` as its first arg\n * but the user does not provide this arg when calling the mutator.\n *\n * This utility strips the `tx` arg from the user's custom mutator signatures.\n */\nexport type MakeCustomMutatorInterfaces<\n  S extends Schema,\n  MD extends CustomMutatorDefs,\n> = {\n  readonly [NamespaceOrName in keyof MD]: MD[NamespaceOrName] extends (\n    tx: Transaction<S>,\n    ...args: infer Args\n  ) => Promise<void>\n    ? (...args: Args) => MutatorResult\n    : {\n        readonly [P in keyof MD[NamespaceOrName]]: MakeCustomMutatorInterface<\n          S,\n          MD[NamespaceOrName][P]\n        >;\n      };\n};\n\nexport type MakeCustomMutatorInterface<\n  S extends Schema,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  F,\n> = F extends (tx: ClientTransaction<S>, ...args: infer Args) => Promise<void>\n  ? (...args: Args) => MutatorResult\n  : never;\n\nexport class TransactionImpl<S extends Schema> implements ClientTransaction<S> {\n  constructor(lc: ZeroLogContext, repTx: WriteTransaction, schema: S) {\n    const castedRepTx = repTx as WriteTransactionImpl;\n    must(repTx.reason === 'initial' || repTx.reason === 'rebase');\n    this.clientID = repTx.clientID;\n    this.mutationID = repTx.mutationID;\n    this.reason = repTx.reason === 'initial' ? 'optimistic' : 'rebase';\n    const txData = must(\n      castedRepTx[zeroData],\n      'zero was not set on replicache internal options!',\n    );\n    this.mutate = makeSchemaCRUD(\n      schema,\n      repTx,\n      txData.ivmSources as IVMSourceBranch,\n    );\n    this.query = makeSchemaQuery(\n      lc,\n      schema,\n      txData.ivmSources as IVMSourceBranch,\n    );\n    this.token = txData.token;\n  }\n\n  readonly clientID: ClientID;\n  readonly mutationID: number;\n  readonly reason: 'optimistic' | 'rebase';\n  readonly location = 'client';\n  readonly mutate: SchemaCRUD<S>;\n  readonly query: SchemaQuery<S>;\n  readonly token: string | undefined;\n}\n\nexport function makeReplicacheMutator<S extends Schema, TWrappedTransaction>(\n  lc: ZeroLogContext,\n  mutator: CustomMutatorImpl<S, TWrappedTransaction>,\n  schema: S,\n) {\n  return async (\n    repTx: WriteTransaction,\n    args: ReadonlyJSONValue,\n  ): Promise<void> => {\n    const tx = new TransactionImpl(lc, repTx, schema);\n    await mutator(tx, args);\n  };\n}\n\nfunction makeSchemaCRUD<S extends Schema>(\n  schema: S,\n  tx: WriteTransaction,\n  ivmBranch: IVMSourceBranch,\n) {\n  // Only creates the CRUD mutators on demand\n  // rather than creating them all up-front for each mutation.\n  return new Proxy(\n    {},\n    {\n      get(target: Record<string, TableCRUD<TableSchema>>, prop: string) {\n        if (prop in target) {\n          return target[prop];\n        }\n\n        target[prop] = makeTableCRUD(schema, prop, tx, ivmBranch);\n        return target[prop];\n      },\n    },\n  ) as SchemaCRUD<S>;\n}\n\nfunction assertValidRunOptions(options: RunOptions | undefined): void {\n  // TODO(arv): We should enforce this with the type system too.\n  assert(\n    options?.type !== 'complete',\n    'Cannot wait for complete results in custom mutations',\n  );\n}\n\nfunction makeSchemaQuery<S extends Schema>(\n  lc: ZeroLogContext,\n  schema: S,\n  ivmBranch: IVMSourceBranch,\n) {\n  const context = new ZeroContext(\n    lc,\n    ivmBranch,\n    () => emptyFunction,\n    () => emptyFunction,\n    emptyFunction,\n    emptyFunction,\n    emptyFunction,\n    applyViewUpdates => applyViewUpdates(),\n    emptyFunction,\n    assertValidRunOptions,\n  );\n\n  return new Proxy(\n    {},\n    {\n      get(target: Record<string, Query<S, string>>, prop: string) {\n        if (prop in target) {\n          return target[prop];\n        }\n\n        target[prop] = newQuery(context, schema, prop);\n        return target[prop];\n      },\n    },\n  ) as SchemaQuery<S>;\n}\n\nfunction makeTableCRUD(\n  schema: Schema,\n  tableName: string,\n  tx: WriteTransaction,\n  ivmBranch: IVMSourceBranch,\n) {\n  const table = must(schema.tables[tableName]);\n  const {primaryKey} = table;\n  return {\n    insert: (value: InsertValue<TableSchema>) =>\n      insertImpl(\n        tx,\n        {op: 'insert', tableName, primaryKey, value},\n        schema,\n        ivmBranch,\n      ),\n    upsert: (value: UpsertValue<TableSchema>) =>\n      upsertImpl(\n        tx,\n        {op: 'upsert', tableName, primaryKey, value},\n        schema,\n        ivmBranch,\n      ),\n    update: (value: UpdateValue<TableSchema>) =>\n      updateImpl(\n        tx,\n        {op: 'update', tableName, primaryKey, value},\n        schema,\n        ivmBranch,\n      ),\n    delete: (id: DeleteID<TableSchema>) =>\n      deleteImpl(\n        tx,\n        {op: 'delete', tableName, primaryKey, value: id},\n        schema,\n        ivmBranch,\n      ),\n  };\n}\n","import type {Store} from '../../../replicache/src/dag/store.ts';\nimport {\n  getDeletedClients,\n  removeDeletedClients,\n  type DeletedClients,\n} from '../../../replicache/src/deleted-clients.ts';\nimport type {\n  ClientGroupID,\n  ClientID,\n} from '../../../replicache/src/sync/ids.ts';\nimport {\n  withRead,\n  withWrite,\n} from '../../../replicache/src/with-transactions.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {\n  DeleteClientsBody,\n  DeleteClientsMessage,\n} from '../../../zero-protocol/src/delete-clients.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\n/**\n * Replicache will tell us when it deletes clients from the persistent storage\n * due to GC. When this happens we tell the server about the deleted clients.\n * Replicache also store the deleted clients in IDB in case the server is\n * currently offline.\n *\n * The server will reply with the client it actually deleted. When we get that\n * we remove those IDs from our local storage.\n */\nexport class DeleteClientsManager {\n  readonly #send: (msg: DeleteClientsMessage) => void;\n  readonly #lc: ZeroLogContext;\n  readonly #dagStore: Store;\n\n  constructor(\n    send: (msg: DeleteClientsMessage) => void,\n    dagStore: Store,\n    lc: ZeroLogContext,\n  ) {\n    this.#send = send;\n    this.#dagStore = dagStore;\n    this.#lc = lc;\n  }\n\n  /**\n   * This gets called by Replicache when it deletes clients from the persistent\n   * storage.\n   */\n  onClientsDeleted(\n    clientIDs: readonly ClientID[],\n    clientGroupIDs: readonly ClientGroupID[],\n  ): void {\n    this.#lc.debug?.('DeletedClientsManager, send:', clientIDs);\n    this.#send(['deleteClients', {clientIDs, clientGroupIDs}]);\n  }\n\n  /**\n   * Zero calls this after it connects to ensure that the server knows about all\n   * the clients that might have been deleted locally since the last connection.\n   */\n  async sendDeletedClientsToServer(): Promise<void> {\n    const deleted = await withRead(this.#dagStore, dagRead =>\n      getDeletedClients(dagRead),\n    );\n    if (deleted.clientIDs.length > 0 || deleted.clientGroupIDs.length > 0) {\n      this.#send(['deleteClients', deleted]);\n      this.#lc.debug?.('DeletedClientsManager, send:', deleted);\n    }\n  }\n\n  /**\n   * This is called as a response to the server telling us which clients it\n   * actually deleted.\n   */\n  clientsDeletedOnServer(deletedClients: DeleteClientsBody): Promise<void> {\n    const {clientIDs = [], clientGroupIDs = []} = deletedClients;\n    if (clientIDs.length > 0 || clientGroupIDs.length > 0) {\n      // Get the deleted clients from the dag and remove the ones from the server.\n      // then write them back to the dag.\n      return withWrite(this.#dagStore, async dagWrite => {\n        this.#lc.debug?.('clientsDeletedOnServer:', clientIDs, clientGroupIDs);\n        await removeDeletedClients(dagWrite, clientIDs, clientGroupIDs);\n      });\n    }\n    return promiseVoid;\n  }\n\n  getDeletedClients(): Promise<DeletedClients> {\n    return withRead(this.#dagStore, getDeletedClients);\n  }\n}\n","// https://www.oreilly.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\nconst IPV4_ADDRESS_REGEX =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n// This doesn't ensure a valid ipv6, but any ipv6 hostname will\n// match this regex, and no domain based hostnames will.\nconst IPV6_ADDRESS_HOSTNAME_REGEX = /^\\[[a-fA-F0-9:]*:[a-fA-F0-9:]*\\]$/;\n\nexport const IP_ADDRESS_HOSTNAME_REGEX = new RegExp(\n  `(${IPV4_ADDRESS_REGEX.source}|${IPV6_ADDRESS_HOSTNAME_REGEX.source})`,\n);\n\nexport function shouldEnableAnalytics(\n  server: string | null,\n  enableAnalytics = true,\n): boolean {\n  if (!enableAnalytics) {\n    return false;\n  }\n  const serverURL = server === null ? null : new URL(server);\n  const socketHostname = serverURL?.hostname;\n  // If the hostname is undefined, localhost, or an ip address, then\n  // this is most likely a test or local development, in which case we\n  // do not want to enable analytics.\n  return (\n    server !== null &&\n    socketHostname !== undefined &&\n    socketHostname !== 'localhost' &&\n    !IP_ADDRESS_HOSTNAME_REGEX.test(socketHostname)\n  );\n}\n","import {assert} from '../../../shared/src/asserts.ts';\n\nexport type HTTPString = `http${'' | 's'}://${string}`;\n\nexport type WSString = `ws${'' | 's'}://${string}`;\n\nexport function toWSString(url: HTTPString): WSString {\n  return ('ws' + url.slice(4)) as WSString;\n}\n\nexport function toHTTPString(url: WSString): HTTPString {\n  return ('http' + url.slice(2)) as HTTPString;\n}\n\nexport function assertHTTPString(url: string): asserts url is HTTPString {\n  assert(/^https?:\\/\\//.test(url));\n}\n\nexport function assertWSString(url: string): asserts url is WSString {\n  assert(/^wss?:\\/\\//.test(url));\n}\n\nexport function appendPath<T extends HTTPString | WSString>(\n  url: T,\n  toAppend: `/${string}`,\n): T {\n  return (url + (url.endsWith('/') ? toAppend.substring(1) : toAppend)) as T;\n}\n","import {\n  TeeLogSink,\n  consoleLogSink,\n  type Context,\n  type LogLevel,\n  type LogSink,\n} from '@rocicorp/logger';\nimport {\n  DatadogLogSink,\n  type DatadogLogSinkOptions,\n} from '../../../datadog/src/datadog-log-sink.ts';\nimport {appendPath, type HTTPString} from './http-string.ts';\nimport {version} from './version.ts';\n\nclass LevelFilterLogSink implements LogSink {\n  readonly #wrappedLogSink: LogSink;\n  readonly #level: LogLevel;\n\n  constructor(wrappedLogSink: LogSink, level: LogLevel) {\n    this.#wrappedLogSink = wrappedLogSink;\n    this.#level = level;\n  }\n\n  log(level: LogLevel, context: Context | undefined, ...args: unknown[]): void {\n    if (this.#level === 'error' && level !== 'error') {\n      return;\n    }\n    if (this.#level === 'info' && level === 'debug') {\n      return;\n    }\n    this.#wrappedLogSink.log(level, context, ...args);\n  }\n\n  async flush() {\n    await consoleLogSink.flush?.();\n  }\n}\n\nconst DATADOG_LOG_LEVEL = 'info';\nconst ZERO_SASS_DOMAIN = '.reflect-server.net';\n\nexport type LogOptions = {\n  readonly logLevel: LogLevel;\n  readonly logSink: LogSink;\n};\n\nexport function createLogOptions(\n  options: {\n    consoleLogLevel: LogLevel;\n    server: HTTPString | null;\n    enableAnalytics: boolean;\n  },\n  createDatadogLogSink: (options: DatadogLogSinkOptions) => LogSink = (\n    options: DatadogLogSinkOptions,\n  ) => new DatadogLogSink(options),\n): LogOptions {\n  const {consoleLogLevel, server, enableAnalytics} = options;\n\n  if (!enableAnalytics || server === null) {\n    return {\n      logLevel: consoleLogLevel,\n      logSink: consoleLogSink,\n    };\n  }\n\n  const serverURL = new URL(server);\n  const {hostname} = serverURL;\n  const datadogServiceLabel = hostname.endsWith(ZERO_SASS_DOMAIN)\n    ? hostname\n        .substring(0, hostname.length - ZERO_SASS_DOMAIN.length)\n        .toLowerCase()\n    : hostname;\n  const baseURL = new URL(appendPath(server, '/logs/v0/log'));\n  const logLevel = consoleLogLevel === 'debug' ? 'debug' : 'info';\n  const logSink = new TeeLogSink([\n    new LevelFilterLogSink(consoleLogSink, consoleLogLevel),\n    new LevelFilterLogSink(\n      createDatadogLogSink({\n        service: datadogServiceLabel,\n        host: location.host,\n        version,\n        baseURL,\n      }),\n      DATADOG_LOG_LEVEL,\n    ),\n  ]);\n  return {\n    logLevel,\n    logSink,\n  };\n}\n","import {Lock} from '@rocicorp/lock';\nimport type {Context, LogLevel, LogSink} from '@rocicorp/logger';\n\nexport interface DatadogLogSinkOptions {\n  apiKey?: string | undefined;\n  source?: string | undefined;\n  service?: string | undefined;\n  host?: string | undefined;\n  version?: string | undefined;\n  interval?: number | undefined;\n  baseURL?: URL | undefined;\n}\n\nconst DD_BASE_URL = new URL(\n  'https://http-intake.logs.datadoghq.com/api/v2/logs',\n);\n\n// https://docs.datadoghq.com/api/latest/logs/\nexport const MAX_LOG_ENTRIES_PER_FLUSH = 1000;\nexport const FORCE_FLUSH_THRESHOLD = 250;\nconst MAX_ENTRY_BYTES = 5 * 1024 * 1024;\nconst MAX_MESSAGE_RETRIES = 2;\n\n// Conservative limit that assumes all chars are encoded as 4 UTF-8 bytes.\n// This makes the actual limit somewhere closer to 1.25 MB, which is still\n// a reasonable amount of log data to send per request.\nexport const MAX_ENTRY_CHARS = MAX_ENTRY_BYTES / 4;\n\nexport class DatadogLogSink implements LogSink {\n  #messages: Message[] = [];\n  readonly #apiKey: string | undefined;\n  readonly #source: string | undefined;\n  readonly #service: string | undefined;\n  readonly #host: string | undefined;\n  readonly #version: string | undefined;\n  readonly #interval: number;\n  readonly #baseURL: string;\n  #timerID: ReturnType<typeof setTimeout> | 0 = 0;\n  #flushLock = new Lock();\n\n  constructor(options: DatadogLogSinkOptions) {\n    const {\n      apiKey,\n      source,\n      service,\n      host,\n      version,\n      interval = 5_000,\n      baseURL: baseUrl = DD_BASE_URL,\n    } = options;\n\n    this.#apiKey = apiKey;\n    this.#source = source;\n    this.#service = service;\n    this.#host = host;\n    this.#version = version;\n    this.#interval = interval;\n    this.#baseURL = baseUrl.toString();\n  }\n\n  log(level: LogLevel, context: Context | undefined, ...args: unknown[]): void {\n    this.#messages.push(makeMessage(args, context, level));\n    if (level === 'error' || this.#messages.length === FORCE_FLUSH_THRESHOLD) {\n      // Do not await. Later calls to flush will await as needed.\n      void this.flush();\n    } else {\n      this.#startTimer();\n    }\n  }\n  #startTimer() {\n    if (this.#timerID) {\n      return;\n    }\n\n    this.#timerID = setTimeout(() => {\n      this.#timerID = 0;\n\n      void this.flush();\n    }, this.#interval);\n  }\n\n  flush(): Promise<void> {\n    return this.#flushLock.withLock(async () => {\n      const {length} = this.#messages;\n      if (length === 0) {\n        return;\n      }\n      do {\n        const flushTime = Date.now();\n        const stringified = [];\n        let totalBytes = 0;\n\n        for (const m of this.#messages) {\n          // As a small perf optimization, we directly mutate\n          // the message rather than making a shallow copy.\n          // The LOG_SINK_FLUSH_DELAY_ATTRIBUTE will be clobbered by\n          // the next flush if this flush fails (which is the desired behavior).\n          m.flushDelayMs = flushTime - m.date;\n\n          let str = JSON.stringify(m);\n          if (str.length > MAX_ENTRY_CHARS) {\n            // A single message above the total payload limit will otherwise halt\n            // log flushing progress. Drop and replace with a message indicating so.\n            m.message = `[Dropped message of length ${str.length}]`;\n            str = JSON.stringify(m);\n          }\n          // Calculate the totalBytes with the newline characters between messages.\n          if (str.length + totalBytes + stringified.length > MAX_ENTRY_CHARS) {\n            break;\n          }\n          totalBytes += str.length;\n          stringified.push(str);\n\n          if (stringified.length === MAX_LOG_ENTRIES_PER_FLUSH) {\n            break;\n          }\n        }\n\n        const body = stringified.join('\\n');\n        const url = new URL(this.#baseURL);\n        if (this.#apiKey !== undefined) {\n          url.searchParams.set('dd-api-key', this.#apiKey);\n        }\n\n        if (this.#source) {\n          // Both need to be set for server to treat us as the browser SDK for\n          // value 'browser'.\n          url.searchParams.set('ddsource', this.#source);\n          url.searchParams.set('dd-evp-origin', this.#source);\n        }\n\n        if (this.#service) {\n          url.searchParams.set('service', this.#service);\n        }\n\n        if (this.#host) {\n          url.searchParams.set('host', this.#host);\n        }\n\n        if (this.#version) {\n          url.searchParams.set('ddtags', `version:${this.#version}`);\n        }\n\n        let ok = false;\n        try {\n          const response = await fetch(url.toString(), {\n            method: 'POST',\n            body,\n            keepalive: true,\n          } as RequestInit);\n\n          ok = response.ok;\n          if (!ok) {\n            // Log to console so that we might catch this in `wrangler tail`.\n            // eslint-disable-next-line no-console\n            console.error(\n              'response',\n              response.status,\n              response.statusText,\n              await response.text,\n            );\n          }\n        } catch (e) {\n          // Log to console so that we might catch this in `wrangler tail`.\n          // eslint-disable-next-line no-console\n          console.error('Log flush to datadog failed', e);\n        }\n\n        if (ok) {\n          // Remove messages that were successfully flushed.\n          this.#messages.splice(0, stringified.length);\n        } else {\n          let numWithTooManyRetries = 0;\n          for (let i = 0; i < stringified.length; i++) {\n            const m = this.#messages[i];\n            m.flushRetryCount = (m.flushRetryCount ?? 0) + 1;\n            if (m.flushRetryCount > MAX_MESSAGE_RETRIES) {\n              numWithTooManyRetries++;\n            }\n          }\n          if (numWithTooManyRetries > 0) {\n            // eslint-disable-next-line no-console\n            console.error(\n              `Dropping ${numWithTooManyRetries} datadog log messages which failed to send ${\n                MAX_MESSAGE_RETRIES + 1\n              } times.`,\n            );\n            // Remove messages that have failed too many times.\n            this.#messages.splice(0, numWithTooManyRetries);\n          }\n        }\n      } while (this.#messages.length >= FORCE_FLUSH_THRESHOLD);\n      // If any messages left at this point schedule another flush.\n      if (this.#messages.length) {\n        this.#startTimer();\n      }\n    });\n  }\n}\n\ntype Message = Context & {\n  status: LogLevel;\n  date: number;\n  message: unknown;\n  error?: {origin: 'logger'};\n  flushDelayMs?: number;\n  flushRetryCount?: number;\n};\n\nfunction flattenMessage(message: unknown): unknown {\n  if (Array.isArray(message) && message.length === 1) {\n    return flattenMessage(message[0]);\n  }\n  return message;\n}\n\nfunction convertError(e: Error): {\n  name: string;\n  message: string;\n  stack: string | undefined;\n} {\n  return {\n    name: e.name,\n    message: e.message,\n    stack: e.stack,\n  };\n}\n\nfunction convertErrors(message: unknown): unknown {\n  if (message instanceof Error) {\n    return convertError(message);\n  }\n  if (message instanceof Array) {\n    const convertedMessage: unknown[] = [];\n    for (const item of message) {\n      if (item instanceof Error) {\n        convertedMessage.push(convertError(item));\n      } else {\n        convertedMessage.push(item);\n      }\n    }\n    return convertedMessage;\n  }\n  return message;\n}\n\nconst LOG_SINK_FLUSH_RETRY_COUNT = 'flushRetryCount';\nconst LOG_SINK_FLUSH_DELAY_ATTRIBUTE = 'flushDelayMs';\n// This code assumes that no context keys will start with\n// @DATADOG_RESERVED_ (a fairly safe assumption).\nconst RESERVED_KEY_PREFIX = '@DATADOG_RESERVED_';\n// See https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#reserved-attributes\n// Note 'msg' and 'date' are not documented.\n// We should avoid using these as context keys.  We escape them here\n// because otherwise the impact on the data dog log UI is very confusing\n// (e.g. using 'msg' as a context key results, in the context value\n// replacing the log message.)\nconst RESERVED_KEYS: ReadonlyArray<string> = [\n  'host',\n  'source',\n  'status',\n  'service',\n  'version',\n  'trace_id',\n  'message',\n  'msg', // alias for message\n  'date',\n  // The following are attributes reserved by the DataDogLogSink\n  // itself (as opposed to DataDog), to report on its own behavior.\n  LOG_SINK_FLUSH_DELAY_ATTRIBUTE,\n  LOG_SINK_FLUSH_RETRY_COUNT,\n];\n\nfunction makeMessage(\n  message: unknown,\n  context: Context | undefined,\n  logLevel: LogLevel,\n): Message {\n  let safeContext = undefined;\n  if (context !== undefined) {\n    for (const reservedKey of RESERVED_KEYS) {\n      if (Object.hasOwn(context, reservedKey)) {\n        if (safeContext === undefined) {\n          safeContext = {...context};\n        }\n        safeContext[RESERVED_KEY_PREFIX + reservedKey] =\n          safeContext[reservedKey];\n        delete safeContext[reservedKey];\n      }\n    }\n  }\n  const msg: Message = {\n    ...(safeContext ?? context),\n    date: Date.now(),\n    message: convertErrors(flattenMessage(message)),\n    status: logLevel,\n  };\n  if (logLevel === 'error') {\n    msg.error = {origin: 'logger'};\n  }\n  return msg;\n}\n","// The env value should be filled in by esbuild.\n\ndeclare const process: {\n  env: {\n    ['ZERO_VERSION']?: string;\n  };\n};\n\n/**\n * The current version of Zero.\n */\nexport const version = process.env.ZERO_VERSION ?? '0.0.0';\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const TimeToConnectMs = 'time_to_connect_ms';\nexport const LastConnectError = 'last_connect_error';\nexport const TimeToConnectMsV2 = 'time_to_connect_ms_v2';\nexport const LastConnectErrorV2 = 'last_connect_error_v2';\nexport const TotalTimeToConnectMs = 'total_time_to_connect_ms';\nexport const NotConnected = 'not_connected';\n\nexport type TimeToConnectMs = typeof TimeToConnectMs;\nexport type LastConnectError = typeof LastConnectError;\nexport type TimeToConnectMsV2 = typeof TimeToConnectMsV2;\nexport type LastConnectErrorV2 = typeof LastConnectErrorV2;\nexport type TotalTimeToConnectMs = typeof TotalTimeToConnectMs;\nexport type NotConnected = typeof NotConnected;\n","import type {MaybePromise} from '../../../shared/src/types.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport * as MetricName from './metric-name-enum.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\n// This value is used to indicate that the client's last connection attempt\n// failed. We don't make this -1 because we want to stack this never connected\n// state in a graph on top of actual connection times, so it should be greater\n// than any other value.\nexport const DID_NOT_CONNECT_VALUE = 100 * 1000;\n\nexport const REPORT_INTERVAL_MS = 5_000;\n\ntype ClientDisconnectReason =\n  | 'AbruptClose'\n  | 'CleanClose'\n  | 'ClientClosed'\n  | 'ConnectTimeout'\n  | 'UnexpectedBaseCookie'\n  | 'PingTimeout'\n  | 'Hidden';\n\ntype NotConnectedReason =\n  | 'init'\n  | 'error'\n  | 'hidden'\n  | 'hidden_was_init'\n  | 'hidden_was_error';\n\nexport type DisconnectReason =\n  | {\n      server: ErrorKind;\n    }\n  | {\n      client: ClientDisconnectReason;\n    };\n\nexport function getLastConnectErrorValue(reason: DisconnectReason): string {\n  if ('server' in reason) {\n    return `server_${camelToSnake(reason.server)}`;\n  }\n  return `client_${camelToSnake(reason.client)}`;\n}\n\n// camelToSnake is used to convert a protocol ErrorKind into a suitable\n// metric name, eg AuthInvalidated => auth_invalidated. It converts\n// both PascalCase and camelCase to snake_case.\nfunction camelToSnake(s: string): string {\n  return s\n    .split(/\\.?(?=[A-Z])/)\n    .join('_')\n    .toLowerCase();\n}\n\ntype MetricsReporter = (metrics: Series[]) => MaybePromise<void>;\n\nexport type MetricManagerOptions = {\n  reportIntervalMs: number;\n  host: string;\n  source: string;\n  reporter: MetricsReporter;\n  lc: ZeroLogContext;\n};\n\n/**\n * MetricManager keeps track of the set of metrics in use and flushes them\n * to a format suitable for reporting.\n */\nexport class MetricManager {\n  #reportIntervalMs: number;\n  #host: string;\n  #reporter: MetricsReporter;\n  #lc: ZeroLogContext;\n  #timerID: ReturnType<typeof setInterval> | null;\n\n  constructor(opts: MetricManagerOptions) {\n    this.#reportIntervalMs = opts.reportIntervalMs;\n    this.#host = opts.host;\n    this.#reporter = opts.reporter;\n    this.#lc = opts.lc;\n\n    this.tags.push(`source:${opts.source}`);\n\n    this.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n    this.#setNotConnectedReason('init');\n\n    this.#timerID = setInterval(() => {\n      void this.flush();\n    }, this.#reportIntervalMs);\n  }\n\n  #metrics: Flushable[] = [];\n\n  // timeToConnectMs measures the time from the call to connect() to receiving\n  // the 'connected' ws message. We record the DID_NOT_CONNECT_VALUE if the previous\n  // connection attempt failed for any reason.\n  //\n  // We set the gauge using #connectStart as follows:\n  // - #connectStart is undefined if we are disconnected or connected; it is\n  //   defined only in the Connecting state, as a number representing the timestamp\n  //   at which we started connecting.\n  // - #connectStart is set to the current time when connect() is called.\n  // - When we receive the 'connected' message we record the time to connect and\n  //   set #connectStart to undefined.\n  // - If disconnect() is called with a defined #connectStart then we record\n  //   DID_NOT_CONNECT_VALUE and set #connectStart to undefined.\n  //\n  // TODO It's clear after playing with the connection code we should encapsulate\n  // the ConnectionState along with its state transitions and possibly behavior.\n  // In that world the metric gauge(s) and bookkeeping like #connectStart would\n  // be encapsulated with the ConnectionState. This will probably happen as part\n  // of https://github.com/rocicorp/reflect-server/issues/255.\n  readonly timeToConnectMs = this.#register(\n    new Gauge(MetricName.TimeToConnectMs),\n  );\n\n  // lastConnectError records the last error that occurred when connecting,\n  // if any. It is cleared when connecting successfully or when reported, so this\n  // state only gets reported if there was a failure during the reporting period and\n  // we are still not connected.\n  readonly lastConnectError = this.#register(\n    new State(\n      MetricName.LastConnectError,\n      true, // clearOnFlush\n    ),\n  );\n\n  // notConnected records the reason why the client is not currently connected.\n  // It is cleared when the client successfully connects.\n  readonly #notConnected = this.#register(new State(MetricName.NotConnected));\n\n  // The time from the call to connect() to receiving the 'connected' ws message\n  // for the current connection.  Cleared when the client is not connected.\n  // TODO: Not actually currently cleared on disconnect untill there is a\n  // connect error, or client reports disconnected and waiting for visible.\n  // Should have a value iff _notConnected has no value.\n  readonly #timeToConnectMsV2 = this.#register(\n    new Gauge(MetricName.TimeToConnectMsV2),\n  );\n\n  // lastConnectErrorV2 records the last error that occurred when connecting,\n  // if any. It is cleared when the client successfully connects or\n  // stops trying to connect due to being hidden.\n  // Should have a value iff notConnected state is NotConnectedReason.Error.\n  readonly #lastConnectErrorV2 = this.#register(\n    new State(MetricName.LastConnectErrorV2),\n  );\n\n  // The total time it took to connect across retries for the current\n  // connection.  Cleared when the client is not connected.\n  // TODO: Not actually currently cleared on disconnect until there is a\n  // connect error, or client reports disconnected and waiting for visible.\n  // See Zero.#totalToConnectStart for details of how this total is computed.\n  // Should have a value iff _notConnected has no value.\n  readonly #totalTimeToConnectMs = this.#register(\n    new Gauge(MetricName.TotalTimeToConnectMs),\n  );\n\n  #setNotConnectedReason(reason: NotConnectedReason) {\n    this.#notConnected.set(reason);\n  }\n\n  setConnected(timeToConnectMs: number, totalTimeToConnectMs: number) {\n    this.#notConnected.clear();\n    this.#lastConnectErrorV2.clear();\n    this.#timeToConnectMsV2.set(timeToConnectMs);\n    this.#totalTimeToConnectMs.set(totalTimeToConnectMs);\n  }\n\n  setDisconnectedWaitingForVisible() {\n    this.#timeToConnectMsV2.clear();\n    this.#totalTimeToConnectMs.clear();\n    this.#lastConnectErrorV2.clear();\n    let notConnectedReason: NotConnectedReason;\n    switch (this.#notConnected.get()) {\n      case 'init':\n        notConnectedReason = 'hidden_was_init';\n        break;\n      case 'error':\n        notConnectedReason = 'hidden_was_error';\n        break;\n      default:\n        notConnectedReason = 'hidden';\n        break;\n    }\n    this.#setNotConnectedReason(notConnectedReason);\n  }\n\n  setConnectError(reason: DisconnectReason) {\n    this.#timeToConnectMsV2.clear();\n    this.#totalTimeToConnectMs.clear();\n    this.#setNotConnectedReason('error');\n    this.#lastConnectErrorV2.set(getLastConnectErrorValue(reason));\n  }\n\n  /**\n   * Tags to include in all metrics.\n   */\n  readonly tags: string[] = [];\n\n  // Flushes all metrics to an array of time series (plural), one Series\n  // per metric.\n  async flush() {\n    const lc = this.#lc;\n    if (this.#timerID === null) {\n      lc.error?.('MetricManager.flush() called but already stopped');\n      return;\n    }\n    const allSeries: Series[] = [];\n    for (const metric of this.#metrics) {\n      const series = metric.flush();\n      if (series !== undefined) {\n        allSeries.push({\n          ...series,\n          host: this.#host,\n          tags: this.tags,\n        });\n      }\n    }\n    if (allSeries.length === 0) {\n      lc?.debug?.('No metrics to report');\n      return;\n    }\n    try {\n      await this.#reporter(allSeries);\n    } catch (e) {\n      lc?.error?.('Error reporting metrics', e);\n    }\n  }\n\n  stop() {\n    if (this.#timerID === null) {\n      this.#lc.error?.('MetricManager.stop() called but already stopped');\n      return;\n    }\n    clearInterval(this.#timerID);\n    this.#timerID = null;\n  }\n\n  #register<M extends Flushable>(metric: M) {\n    this.#metrics.push(metric);\n    return metric;\n  }\n}\n\n// These two types are influenced by Datadog's API's needs. We could change what\n// we use internally if necessary, but we'd just have to convert to/from before\n// sending to DD. So for convenience we go with their format.\n\n/** Series is a time series of points for a single metric. */\nexport type Series = {\n  host: string;\n  metric: string; // We call this 'name' bc 'metric' is overloaded in code.\n  points: Point[];\n  tags?: string[];\n};\n/**\n * A point is a second-resolution timestamp and a set of values for that\n * timestamp. A point represents exactly one second in time and the values\n * are those recorded for that second. The first element of this array\n * is the timestamp and the second element is an array of values.\n */\nexport type Point = [number, number[]];\n\nfunction makePoint(ts: number, value: number): Point {\n  return [ts, [value]];\n}\n\ntype Flushable = {\n  flush(): Pick<Series, 'metric' | 'points'> | undefined;\n};\n\n/**\n * Gauge is a metric type that represents a single value that can go up and\n * down. It's typically used to track discrete values or counts eg the number\n * of active users, number of connections, cpu load, etc. A gauge retains\n * its value when flushed.\n *\n * We use a Gauge to sample at the client. If we are interested in tracking\n * a metric value *per client*, the client can note the latest value in\n * a Gauge metric. The metric is periodically reported via Reporter. On the\n * server, we graph the value of the metric rolled up over the periodic\n * reporting period, that is, counted over a span of time equal to the\n * reporting period. The result is ~one point per client per reporting\n * period.\n */\nexport class Gauge implements Flushable {\n  readonly #name: string;\n  #value: number | undefined = undefined;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  set(value: number) {\n    this.#value = value;\n  }\n\n  get() {\n    return this.#value;\n  }\n\n  clear() {\n    this.#value = undefined;\n  }\n\n  flush() {\n    if (this.#value === undefined) {\n      return undefined;\n    }\n    // Gauge reports the timestamp at flush time, not at the point the value was\n    // recorded.\n    const points = [makePoint(t(), this.#value)];\n    return {metric: this.#name, points};\n  }\n}\n\nfunction t() {\n  return Math.round(Date.now() / 1000);\n}\n\n/**\n * State is a metric type that represents a specific state that the system is\n * in, for example the state of a connection which may be 'open' or 'closed'.\n * The state is given a name/prefix at construction time (eg 'connection') and\n * then can be set to a specific state (eg 'open'). The prefix is prepended to\n * the set state (eg, 'connection_open') and a value of 1 is reported.\n * Unset/cleared states are not reported.\n *\n * Example:\n *   const s = new State('connection');\n *   s.set('open');\n *   s.flush(); // returns {metric: 'connection_open', points: [[now(), [1]]]}\n */\nexport class State implements Flushable {\n  readonly #prefix: string;\n  readonly #clearOnFlush: boolean;\n  #current: string | undefined = undefined;\n\n  constructor(prefix: string, clearOnFlush = false) {\n    this.#prefix = prefix;\n    this.#clearOnFlush = clearOnFlush;\n  }\n\n  set(state: string) {\n    this.#current = state;\n  }\n\n  get() {\n    return this.#current;\n  }\n\n  clear() {\n    this.#current = undefined;\n  }\n\n  flush() {\n    if (this.#current === undefined) {\n      return undefined;\n    }\n    const gauge = new Gauge([this.#prefix, this.#current].join('_'));\n    gauge.set(1);\n    const series = gauge.flush();\n    if (this.#clearOnFlush) {\n      this.clear();\n    }\n    return series;\n  }\n}\n","import {resolver, type Resolver} from '@rocicorp/resolver';\nimport type {\n  EphemeralID,\n  MutationTrackingData,\n} from '../../../replicache/src/replicache-options.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport {emptyObject} from '../../../shared/src/sentinels.ts';\nimport {\n  mutationResultSchema,\n  type MutationError,\n  type MutationID,\n  type MutationOk,\n  type PushError,\n  type PushOk,\n  type PushResponse,\n} from '../../../zero-protocol/src/push.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\nimport type {ReplicacheImpl} from '../../../replicache/src/impl.ts';\nimport {MUTATIONS_KEY_PREFIX} from './keys.ts';\nimport type {NoIndexDiff} from '../../../replicache/src/btree/node.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport * as v from '../../../shared/src/valita.ts';\n\ntype ErrorType =\n  | MutationError\n  | Omit<PushError, 'mutationIDs'>\n  | Error\n  | unknown;\n\nlet currentEphemeralID = 0;\nfunction nextEphemeralID(): EphemeralID {\n  return ++currentEphemeralID as EphemeralID;\n}\n\n/**\n * Tracks what pushes are in-flight and resolves promises when they're acked.\n */\nexport class MutationTracker {\n  readonly #outstandingMutations: Map<\n    EphemeralID,\n    {\n      mutationID?: number | undefined;\n      resolver: Resolver<MutationOk, ErrorType>;\n    }\n  >;\n  readonly #ephemeralIDsByMutationID: Map<number, EphemeralID>;\n  readonly #allMutationsAppliedListeners: Set<() => void>;\n  readonly #lc: ZeroLogContext;\n\n  readonly #ackMutations: (upTo: MutationID) => void;\n  #clientID: string | undefined;\n  #largestOutstandingMutationID: number;\n  #currentMutationID: number;\n\n  constructor(lc: ZeroLogContext, ackMutations: (upTo: MutationID) => void) {\n    this.#lc = lc.withContext('MutationTracker');\n    this.#outstandingMutations = new Map();\n    this.#ephemeralIDsByMutationID = new Map();\n    this.#allMutationsAppliedListeners = new Set();\n    this.#largestOutstandingMutationID = 0;\n    this.#currentMutationID = 0;\n    this.#ackMutations = ackMutations;\n  }\n\n  setClientIDAndWatch(\n    clientID: string,\n    experimentalWatch: ReplicacheImpl['experimentalWatch'],\n  ) {\n    assert(this.#clientID === undefined, 'clientID already set');\n    this.#clientID = clientID;\n    experimentalWatch(\n      diffs => {\n        this.#processMutationResponses(diffs);\n      },\n      {\n        prefix: MUTATIONS_KEY_PREFIX + clientID + '/',\n        initialValuesInFirstDiff: true,\n      },\n    );\n  }\n\n  trackMutation(): MutationTrackingData {\n    const id = nextEphemeralID();\n    const mutationResolver = resolver<MutationOk, ErrorType>();\n\n    this.#outstandingMutations.set(id, {\n      resolver: mutationResolver,\n    });\n    return {ephemeralID: id, serverPromise: mutationResolver.promise};\n  }\n\n  mutationIDAssigned(id: EphemeralID, mutationID: number): void {\n    const entry = this.#outstandingMutations.get(id);\n    if (entry) {\n      entry.mutationID = mutationID;\n      this.#ephemeralIDsByMutationID.set(mutationID, id);\n      this.#largestOutstandingMutationID = Math.max(\n        this.#largestOutstandingMutationID,\n        mutationID,\n      );\n    }\n  }\n\n  /**\n   * Reject the mutation due to an unhandled exception on the client.\n   * The mutation must not have been persisted to the client store.\n   */\n  rejectMutation(id: EphemeralID, e: unknown): void {\n    const entry = this.#outstandingMutations.get(id);\n    if (entry) {\n      this.#settleMutation(id, entry, 'reject', e);\n    }\n  }\n\n  /**\n   * Used when zero-cache pokes down mutation results.\n   */\n  #processMutationResponses(diffs: NoIndexDiff): void {\n    const clientID = must(this.#clientID);\n    let largestLmid = 0;\n    for (const diff of diffs) {\n      const mutationID = Number(\n        diff.key.slice(MUTATIONS_KEY_PREFIX.length + clientID.length + 1),\n      );\n      assert(\n        !isNaN(mutationID),\n        `MutationTracker received a diff with an invalid mutation ID: ${diff.key}`,\n      );\n      largestLmid = Math.max(largestLmid, mutationID);\n      switch (diff.op) {\n        case 'add': {\n          const result = v.parse(diff.newValue, mutationResultSchema);\n          if ('error' in result) {\n            this.#processMutationError(clientID, mutationID, result);\n          } else {\n            this.#processMutationOk(clientID, mutationID, result);\n          }\n          break;\n        }\n        case 'del':\n          break;\n        case 'change':\n          throw new Error('MutationTracker does not expect change operations');\n      }\n    }\n\n    if (largestLmid > 0) {\n      this.#ackMutations({\n        clientID: must(this.#clientID),\n        id: largestLmid,\n      });\n    }\n  }\n\n  processPushResponse(response: PushResponse): void {\n    if ('error' in response) {\n      this.#lc.error?.(\n        'Received an error response when pushing mutations',\n        response,\n      );\n    } else {\n      this.#processPushOk(response);\n    }\n  }\n\n  /**\n   * DEPRECATED: to be removed when we switch to fully driving\n   * mutation resolution via poke.\n   *\n   * When we reconnect to zero-cache, we resolve all outstanding mutations\n   * whose ID is less than or equal to the lastMutationID.\n   *\n   * The reason is that any responses the API server sent\n   * to those mutations have been lost.\n   *\n   * An example case: the API server responds while the connection\n   * is down. Those responses are lost.\n   *\n   * Mutations whose LMID is > the lastMutationID are not resolved\n   * since they will be retried by the client, giving us another chance\n   * at getting a response.\n   *\n   * The only way to ensure that all API server responses are\n   * received would be to have the API server write them\n   * to the DB while writing the LMID.\n   */\n  onConnected(lastMutationID: number) {\n    this.lmidAdvanced(lastMutationID);\n  }\n\n  /**\n   * lmid advance will:\n   * 1. notify \"allMutationsApplied\" listeners if the lastMutationID\n   *    is greater than or equal to the largest outstanding mutation ID.\n   * 2. resolve all mutations whose mutation ID is less than or equal to\n   *    the lastMutationID.\n   */\n  lmidAdvanced(lastMutationID: number): void {\n    assert(\n      lastMutationID >= this.#currentMutationID,\n      'lmid must be greater than or equal to current lmid',\n    );\n    if (lastMutationID === this.#currentMutationID) {\n      return;\n    }\n\n    try {\n      this.#currentMutationID = lastMutationID;\n      this.#resolveMutations(lastMutationID);\n    } finally {\n      if (lastMutationID >= this.#largestOutstandingMutationID) {\n        // this is very important otherwise we hang query de-registration\n        this.#notifyAllMutationsAppliedListeners();\n      }\n    }\n  }\n\n  get size() {\n    return this.#outstandingMutations.size;\n  }\n\n  #resolveMutations(upTo: number): void {\n    // We resolve all mutations whose mutation ID is less than or equal to\n    // the upTo mutation ID.\n    for (const [id, entry] of this.#outstandingMutations) {\n      if (entry.mutationID && entry.mutationID <= upTo) {\n        this.#settleMutation(id, entry, 'resolve', emptyObject);\n      } else {\n        break; // the map is in insertion order which is in mutation ID order\n      }\n    }\n  }\n\n  #processPushOk(ok: PushOk): void {\n    for (const mutation of ok.mutations) {\n      if ('error' in mutation.result) {\n        this.#processMutationError(\n          mutation.id.clientID,\n          mutation.id.id,\n          mutation.result,\n        );\n      } else {\n        this.#processMutationOk(\n          mutation.id.clientID,\n          mutation.id.id,\n          mutation.result,\n        );\n      }\n    }\n  }\n\n  #processMutationError(\n    clientID: string,\n    mid: number,\n    error: MutationError | Omit<PushError, 'mutationIDs'>,\n  ): void {\n    assert(\n      clientID === this.#clientID,\n      'received mutation for the wrong client',\n    );\n\n    const ephemeralID = this.#ephemeralIDsByMutationID.get(mid);\n    if (!ephemeralID && error.error === 'alreadyProcessed') {\n      return;\n    }\n\n    // Each tab sends all mutations for the client group\n    // and the server responds back to the individual client that actually\n    // ran the mutation. This means that N clients can send the same\n    // mutation concurrently. If that happens, the promise for the mutation tracked\n    // by this class will try to be resolved N times.\n    // Every time after the first, the ephemeral ID will not be\n    // found in the map. These later times, however, should always have been\n    // \"mutation already processed\" events which we ignore (above).\n    assert(\n      ephemeralID,\n      `ephemeral ID is missing for mutation error: ${error.error}.`,\n    );\n\n    const entry = this.#outstandingMutations.get(ephemeralID);\n    assert(entry && entry.mutationID === mid);\n    // Resolving the promise with an error was an intentional API decision\n    // so the user receives typed errors.\n    this.#settleMutation(ephemeralID, entry, 'reject', error);\n  }\n\n  #processMutationOk(clientID: string, mid: number, result: MutationOk): void {\n    assert(\n      clientID === this.#clientID,\n      'received mutation for the wrong client',\n    );\n\n    const ephemeralID = this.#ephemeralIDsByMutationID.get(mid);\n    assert(\n      ephemeralID,\n      'ephemeral ID is missing. This can happen if a mutation response is received twice ' +\n        'but it should be impossible to receive a success response twice for the same mutation.',\n    );\n    const entry = this.#outstandingMutations.get(ephemeralID);\n    assert(entry && entry.mutationID === mid);\n    this.#settleMutation(ephemeralID, entry, 'resolve', result);\n  }\n\n  #settleMutation<Type extends 'resolve' | 'reject'>(\n    ephemeralID: EphemeralID,\n    entry: {\n      mutationID?: number | undefined;\n      resolver: Resolver<MutationOk, ErrorType>;\n    },\n    type: Type,\n    result: 'resolve' extends Type ? MutationOk : unknown,\n  ): void {\n    switch (type) {\n      case 'resolve':\n        entry.resolver.resolve(result as MutationOk);\n        break;\n      case 'reject':\n        entry.resolver.reject(result);\n        break;\n    }\n\n    this.#outstandingMutations.delete(ephemeralID);\n    if (entry.mutationID) {\n      this.#ephemeralIDsByMutationID.delete(entry.mutationID);\n    }\n  }\n\n  /**\n   * Be notified when all mutations have been included in the server snapshot.\n   *\n   * The query manager will not de-register queries from the server until there\n   * are no pending mutations.\n   *\n   * The reason is that a mutation may need to be rebased. We do not want\n   * data that was available the first time it was run to not be available\n   * on a rebase.\n   */\n  onAllMutationsApplied(listener: () => void): void {\n    this.#allMutationsAppliedListeners.add(listener);\n  }\n\n  #notifyAllMutationsAppliedListeners() {\n    for (const listener of this.#allMutationsAppliedListeners) {\n      listener();\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const TimedOut = 0;\nexport const Success = 1;\n\nexport type TimedOut = typeof TimedOut;\nexport type Success = typeof Success;\n","import type {ReplicacheImpl} from '../../../replicache/src/replicache-impl.ts';\nimport type {ClientID} from '../../../replicache/src/sync/ids.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {TDigest} from '../../../shared/src/tdigest.ts';\nimport {\n  mapAST,\n  normalizeAST,\n  type AST,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {ChangeDesiredQueriesMessage} from '../../../zero-protocol/src/change-desired-queries.ts';\nimport type {UpQueriesPatchOp} from '../../../zero-protocol/src/queries-patch.ts';\nimport {\n  hashOfAST,\n  hashOfNameAndArgs,\n} from '../../../zero-protocol/src/query-hash.ts';\nimport {\n  clientToServer,\n  serverToClient,\n  type NameMapper,\n} from '../../../zero-schema/src/name-mapper.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport type {ClientMetricMap} from '../../../zql/src/query/metrics-delegate.ts';\nimport type {CustomQueryID} from '../../../zql/src/query/named.ts';\nimport type {GotCallback} from '../../../zql/src/query/query-delegate.ts';\nimport {clampTTL, compareTTL, type TTL} from '../../../zql/src/query/ttl.ts';\nimport type {InspectorDelegate} from './inspector/inspector.ts';\nimport {desiredQueriesPrefixForClient, GOT_QUERIES_KEY_PREFIX} from './keys.ts';\nimport type {MutationTracker} from './mutation-tracker.ts';\nimport type {ReadTransaction} from './replicache-types.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\ntype QueryHash = string;\n\ntype Entry = {\n  // We keep track of the AST so we can use it in the inspector.\n  normalized: AST;\n  name: string | undefined;\n  args: readonly ReadonlyJSONValue[] | undefined;\n  count: number;\n  gotCallbacks: GotCallback[];\n  ttl: TTL;\n};\n\ntype ClientMetric = {\n  [K in keyof ClientMetricMap]: TDigest;\n};\n\n/**\n * Tracks what queries the client is currently subscribed to on the server.\n * Sends `changeDesiredQueries` message to server when this changes.\n * Deduplicates requests so that we only listen to a given unique query once.\n */\nexport class QueryManager implements InspectorDelegate {\n  readonly #clientID: ClientID;\n  readonly #clientToServer: NameMapper;\n  readonly #serverToClient: NameMapper;\n  readonly #send: (change: ChangeDesiredQueriesMessage) => void;\n  readonly #queries: Map<QueryHash, Entry> = new Map();\n  readonly #recentQueriesMaxSize: number;\n  readonly #recentQueries: Set<string> = new Set();\n  readonly #gotQueries: Set<string> = new Set();\n  readonly #mutationTracker: MutationTracker;\n  readonly #pendingQueryChanges: UpQueriesPatchOp[] = [];\n  readonly #queryChangeThrottleMs: number;\n  #pendingRemovals: Array<() => void> = [];\n  #batchTimer: ReturnType<typeof setTimeout> | undefined;\n  readonly #lc: ZeroLogContext;\n  readonly #metrics: ClientMetric = newMetrics();\n  readonly #queryMetrics: Map<string, ClientMetric> = new Map();\n  readonly #slowMaterializeThreshold: number;\n\n  constructor(\n    lc: ZeroLogContext,\n    mutationTracker: MutationTracker,\n    clientID: ClientID,\n    tables: Record<string, TableSchema>,\n    send: (change: ChangeDesiredQueriesMessage) => void,\n    experimentalWatch: ReplicacheImpl['experimentalWatch'],\n    recentQueriesMaxSize: number,\n    queryChangeThrottleMs: number,\n    slowMaterializeThreshold: number,\n  ) {\n    this.#lc = lc.withContext('QueryManager');\n    this.#clientID = clientID;\n    this.#clientToServer = clientToServer(tables);\n    this.#serverToClient = serverToClient(tables);\n    this.#recentQueriesMaxSize = recentQueriesMaxSize;\n    this.#send = send;\n    this.#mutationTracker = mutationTracker;\n    this.#queryChangeThrottleMs = queryChangeThrottleMs;\n    this.#slowMaterializeThreshold = slowMaterializeThreshold;\n\n    this.#mutationTracker.onAllMutationsApplied(() => {\n      if (this.#pendingRemovals.length === 0) {\n        return;\n      }\n      const pendingRemovals = this.#pendingRemovals;\n      this.#pendingRemovals = [];\n      for (const removal of pendingRemovals) {\n        removal();\n      }\n    });\n\n    experimentalWatch(\n      diff => {\n        for (const diffOp of diff) {\n          const queryHash = diffOp.key.substring(GOT_QUERIES_KEY_PREFIX.length);\n          switch (diffOp.op) {\n            case 'add':\n              this.#gotQueries.add(queryHash);\n              this.#fireGotCallbacks(queryHash, true);\n              break;\n            case 'del':\n              this.#gotQueries.delete(queryHash);\n              this.#fireGotCallbacks(queryHash, false);\n              break;\n          }\n        }\n      },\n      {\n        prefix: GOT_QUERIES_KEY_PREFIX,\n        initialValuesInFirstDiff: true,\n      },\n    );\n  }\n\n  getAST(queryID: string): AST | undefined {\n    const ast = this.#queries.get(queryID)?.normalized;\n    return ast && mapAST(ast, this.#serverToClient);\n  }\n\n  #fireGotCallbacks(queryHash: string, got: boolean) {\n    const gotCallbacks = this.#queries.get(queryHash)?.gotCallbacks ?? [];\n    for (const gotCallback of gotCallbacks) {\n      gotCallback(got);\n    }\n  }\n\n  /**\n   * Get the queries that need to be registered with the server.\n   *\n   * An optional `lastPatch` can be provided. This is the last patch that was\n   * sent to the server and may not yet have been acked. If `lastPatch` is provided,\n   * this method will return a patch that does not include any events sent in `lastPatch`.\n   *\n   * This diffing of last patch and current patch is needed since we send\n   * a set of queries to the server when we first connect inside of the `sec-protocol` as\n   * the `initConnectionMessage`.\n   *\n   * While we're waiting for the `connected` response to come back from the server,\n   * the client may have registered more queries. We need to diff the `initConnectionMessage`\n   * queries with the current set of queries to understand what those were.\n   */\n  async getQueriesPatch(\n    tx: ReadTransaction,\n    lastPatch?: Map<string, UpQueriesPatchOp> | undefined,\n  ): Promise<Map<string, UpQueriesPatchOp>> {\n    const existingQueryHashes = new Set<string>();\n    const prefix = desiredQueriesPrefixForClient(this.#clientID);\n    for await (const key of tx.scan({prefix}).keys()) {\n      existingQueryHashes.add(key.substring(prefix.length, key.length));\n    }\n    const patch: Map<string, UpQueriesPatchOp> = new Map();\n    for (const hash of existingQueryHashes) {\n      if (!this.#queries.has(hash)) {\n        patch.set(hash, {op: 'del', hash});\n      }\n    }\n\n    for (const [hash, {normalized, ttl, name, args}] of this.#queries) {\n      if (!existingQueryHashes.has(hash)) {\n        patch.set(hash, {\n          op: 'put',\n          hash,\n          ast: name === undefined ? normalized : undefined,\n          name,\n          args,\n          // We get TTL out of the DagStore so it is possible that the TTL was written\n          // with a too high TTL.\n          ttl: clampTTL(ttl), // no lc here since no need to log here\n        });\n      }\n    }\n\n    if (lastPatch) {\n      // if there are any `puts` in `lastPatch` that are not in `patch` then we need to\n      // send a `del` event in `patch`.\n      for (const [hash, {op}] of lastPatch) {\n        if (op === 'put' && !patch.has(hash)) {\n          patch.set(hash, {op: 'del', hash});\n        }\n      }\n      // Remove everything from `patch` that was already sent in `lastPatch`.\n      for (const [hash, {op}] of patch) {\n        const lastPatchOp = lastPatch.get(hash);\n        if (lastPatchOp && lastPatchOp.op === op) {\n          patch.delete(hash);\n        }\n      }\n    }\n\n    return patch;\n  }\n\n  addCustom(\n    ast: AST,\n    {name, args}: CustomQueryID,\n    ttl: TTL,\n    gotCallback?: GotCallback | undefined,\n  ): () => void {\n    const normalized = normalizeAST(ast);\n    const queryId = hashOfNameAndArgs(name, args);\n    return this.#add(queryId, normalized, name, args, ttl, gotCallback);\n  }\n\n  addLegacy(\n    ast: AST,\n    ttl: TTL,\n    gotCallback?: GotCallback | undefined,\n  ): () => void {\n    const normalized = normalizeAST(ast);\n    const astHash = hashOfAST(normalized);\n    return this.#add(\n      astHash,\n      normalized,\n      undefined, // name is undefined for legacy queries\n      undefined, // args are undefined for legacy queries\n      ttl,\n      gotCallback,\n    );\n  }\n\n  #add(\n    queryId: string,\n    normalized: AST,\n    name: string | undefined,\n    args: readonly ReadonlyJSONValue[] | undefined,\n    ttl: TTL,\n    gotCallback?: GotCallback | undefined,\n  ) {\n    assert(\n      (name === undefined) === (args === undefined),\n      'If name is defined, args must be defined',\n    );\n    ttl = clampTTL(ttl, this.#lc);\n    let entry = this.#queries.get(queryId);\n    this.#recentQueries.delete(queryId);\n    if (!entry) {\n      normalized = mapAST(normalized, this.#clientToServer);\n\n      entry = {\n        normalized,\n        name,\n        args,\n        count: 1,\n        gotCallbacks: gotCallback ? [gotCallback] : [],\n        ttl,\n      };\n      this.#queries.set(queryId, entry);\n      this.#queueQueryChange({\n        op: 'put',\n        hash: queryId,\n        ast: name === undefined ? normalized : undefined,\n        name,\n        args,\n        ttl,\n      });\n    } else {\n      ++entry.count;\n      this.#updateEntry(entry, queryId, ttl);\n\n      if (gotCallback) {\n        entry.gotCallbacks.push(gotCallback);\n      }\n    }\n\n    if (gotCallback) {\n      gotCallback(this.#gotQueries.has(queryId));\n    }\n\n    let removed = false;\n    return () => {\n      if (removed) {\n        return;\n      }\n      removed = true;\n\n      // We cannot remove queries while mutations are pending\n      // as that could take data out of scope that is needed in a rebase\n      if (this.#mutationTracker.size > 0) {\n        this.#pendingRemovals.push(() =>\n          this.#remove(entry, queryId, gotCallback),\n        );\n        return;\n      }\n\n      this.#remove(entry, queryId, gotCallback);\n    };\n  }\n\n  updateCustom({name, args}: CustomQueryID, ttl: TTL) {\n    const queryID = hashOfNameAndArgs(name, args);\n    const entry = must(this.#queries.get(queryID));\n    this.#updateEntry(entry, queryID, ttl);\n  }\n\n  updateLegacy(ast: AST, ttl: TTL) {\n    const normalized = normalizeAST(ast);\n    const queryID = hashOfAST(normalized);\n    const entry = must(this.#queries.get(queryID));\n    this.#updateEntry(entry, queryID, ttl);\n  }\n\n  #updateEntry(entry: Entry, queryID: string, ttl: TTL): void {\n    // If the query already exists and the new ttl is larger than the old one\n    // we send a changeDesiredQueries message to the server to update the ttl.\n    ttl = clampTTL(ttl, this.#lc);\n    if (compareTTL(ttl, entry.ttl) > 0) {\n      entry.ttl = ttl;\n      this.#queueQueryChange({\n        op: 'put',\n        hash: queryID,\n        ast: entry.name === undefined ? entry.normalized : undefined,\n        name: entry.name,\n        args: entry.args,\n        ttl,\n      });\n    }\n  }\n\n  #queueQueryChange(op: UpQueriesPatchOp) {\n    this.#pendingQueryChanges.push(op);\n    this.#scheduleBatch();\n  }\n\n  #scheduleBatch() {\n    if (this.#batchTimer === undefined) {\n      this.#batchTimer = setTimeout(\n        () => this.flushBatch(),\n        this.#queryChangeThrottleMs,\n      );\n    }\n  }\n\n  flushBatch() {\n    if (this.#batchTimer !== undefined) {\n      clearTimeout(this.#batchTimer);\n      this.#batchTimer = undefined;\n    }\n    if (this.#pendingQueryChanges.length > 0) {\n      this.#send([\n        'changeDesiredQueries',\n        {\n          desiredQueriesPatch: [...this.#pendingQueryChanges],\n        },\n      ]);\n      this.#pendingQueryChanges.length = 0;\n    }\n  }\n\n  #remove(entry: Entry, astHash: string, gotCallback: GotCallback | undefined) {\n    if (gotCallback) {\n      const index = entry.gotCallbacks.indexOf(gotCallback);\n      entry.gotCallbacks.splice(index, 1);\n    }\n    --entry.count;\n    if (entry.count === 0) {\n      this.#recentQueries.add(astHash);\n      if (this.#recentQueries.size > this.#recentQueriesMaxSize) {\n        const lruQueryID = this.#recentQueries.values().next().value;\n        assert(lruQueryID);\n        this.#queries.delete(lruQueryID);\n        this.#recentQueries.delete(lruQueryID);\n        this.#queryMetrics.delete(lruQueryID);\n        this.#queueQueryChange({op: 'del', hash: lruQueryID});\n      }\n    }\n  }\n\n  /**\n   * Gets the aggregated metrics for all queries managed by this QueryManager.\n   */\n  get metrics(): ClientMetric {\n    return this.#metrics;\n  }\n\n  addMetric<K extends keyof ClientMetricMap>(\n    metric: K,\n    value: number,\n    ...args: ClientMetricMap[K]\n  ): void {\n    // Only query metrics are tracked at this point.\n    // If this check fails then we need to add a runtime check.\n    metric satisfies `query-${string}`;\n\n    // We track all materializations of queries as well as per\n    // query materializations.\n    this.#metrics[metric].add(value);\n\n    const queryID = args[0];\n\n    // Handle slow query logging for end-to-end materialization\n    if (metric === 'query-materialization-end-to-end') {\n      const ast = args[1];\n\n      if (\n        this.#slowMaterializeThreshold !== undefined &&\n        value > this.#slowMaterializeThreshold\n      ) {\n        this.#lc.warn?.(\n          'Slow query materialization (including server/network)',\n          queryID,\n          ast,\n          value,\n        );\n      } else {\n        this.#lc.debug?.(\n          'Materialized query (including server/network)',\n          queryID,\n          ast,\n          value,\n        );\n      }\n    }\n\n    // The query manager manages metrics that are per query.\n    let existing = this.#queryMetrics.get(queryID);\n    if (!existing) {\n      existing = newMetrics();\n      this.#queryMetrics.set(queryID, existing);\n    }\n    existing[metric].add(value);\n  }\n\n  getQueryMetrics(queryID: string): ClientMetric | undefined {\n    return this.#queryMetrics.get(queryID);\n  }\n}\n\nfunction newMetrics(): ClientMetric {\n  return {\n    'query-materialization-client': new TDigest(),\n    'query-materialization-end-to-end': new TDigest(),\n    'query-update-client': new TDigest(),\n  };\n}\n","import type {LogLevel} from '@rocicorp/logger';\nimport type {StoreProvider} from '../../../replicache/src/kv/store.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport * as v from '../../../shared/src/valita.ts';\nimport type {\n  UserMutateParams,\n  UserQueryParams,\n} from '../../../zero-protocol/src/connect.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {CustomMutatorDefs} from './custom.ts';\nimport type {OnError} from './on-error.ts';\nimport {UpdateNeededReasonType} from './update-needed-reason-type.ts';\n\n/**\n * Configuration for {@linkcode Zero}.\n */\nexport interface ZeroOptions<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> {\n  /**\n   * URL to the zero-cache. This can be a simple hostname, e.g.\n   * - \"https://myapp-myteam.zero.ms\"\n   * or a prefix with a single path component, e.g.\n   * - \"https://myapp-myteam.zero.ms/zero\"\n   * - \"https://myapp-myteam.zero.ms/db\"\n   *\n   * The latter is useful for configuring routing rules (e.g. \"/zero/\\*\") when\n   * the zero-cache is hosted on the same domain as the application. **Note that\n   * only a single path segment is allowed (e.g. it cannot be \"/proxy/zero/\\*\")**.\n   */\n  server?: string | null | undefined;\n\n  /**\n   * A JWT to identify and authenticate the user. Can be provided as either:\n   * - A string containing the JWT token\n   * - A function that returns a JWT token\n   * - `undefined` if there is no logged in user\n   *\n   * Token validation behavior:\n   * 1. **For function providers:**\n   *    When zero-cache reports that a token is invalid (expired, malformed,\n   *    or has an invalid signature), Zero will call the function again with\n   *    `error='invalid-token'` to obtain a new token.\n   *\n   * 2. **For string tokens:**\n   *    Zero will continue to use the provided token even if zero-cache initially\n   *    reports it as invalid. This is because zero-cache may be able to validate\n   *    the token after fetching new public keys from its configured JWKS URL\n   *    (if `ZERO_AUTH_JWKS_URL` is set).\n   */\n  auth?:\n    | string\n    | ((error?: 'invalid-token') => MaybePromise<string | undefined>)\n    | undefined;\n\n  /**\n   * A unique identifier for the user. Must be non-empty.\n   *\n   * Each userID gets its own client-side storage so that the app can switch\n   * between users without losing state.\n   *\n   * This must match the `sub` claim of the `auth` token if\n   * `auth` is provided.\n   */\n  userID: string;\n\n  /**\n   * Distinguishes the storage used by this Zero instance from that of other\n   * instances with the same userID. Useful in the case where the app wants to\n   * have multiple Zero instances for the same user for different parts of the\n   * app.\n   */\n  storageKey?: string | undefined;\n\n  /**\n   * Determines the level of detail at which Zero logs messages about\n   * its operation. Messages are logged to the `console`.\n   *\n   * When this is set to `'debug'`, `'info'` and `'error'` messages are also\n   * logged. When set to `'info'`, `'info'` and `'error'` but not\n   * `'debug'` messages are logged. When set to `'error'` only `'error'`\n   * messages are logged.\n   *\n   * Default is `'error'`.\n   */\n  logLevel?: LogLevel | undefined;\n\n  /**\n   * This defines the schema of the tables used in Zero and their relationships\n   * to one another.\n   */\n  schema: S;\n\n  /**\n   * `mutators` is a map of custom mutator definitions. The keys are\n   * namespaces or names of the mutators. The values are the mutator\n   * implementations. Client side mutators must be idempotent as a\n   * mutation can be rebased multiple times when folding in authoritative\n   * changes from the server to the client.\n   */\n  mutators?: MD | undefined;\n\n  /**\n   * Custom mutations are pushed to zero-cache and then to\n   * your API server.\n   *\n   * push.queryParams can be used to augment the URL\n   * used to connect to your API server so it includes\n   * variables in the query string.\n   *\n   * DEPRECATED: Use `userMutateParams` instead.\n   */\n  push?: UserMutateParams;\n  mutate?: UserMutateParams;\n  query?: UserQueryParams;\n\n  /**\n   * `onOnlineChange` is called when the Zero instance's online status changes.\n   *\n   * @deprecated Use `onOnline` on the Zero instance instead. e.g.\n   * ```ts\n   * const zero = new Zero({...});\n   * zero.onOnline((online) => { ... });\n   * ```\n   */\n  onOnlineChange?: ((online: boolean) => void) | undefined;\n\n  /**\n   * `onUpdateNeeded` is called when a client code update is needed.\n   *\n   * See {@link UpdateNeededReason} for why updates can be needed.\n   *\n   * The default behavior is to reload the page (using `location.reload()`).\n   * Provide your own function to prevent the page from\n   * reloading automatically. You may want to display a toast to inform the end\n   * user there is a new version of your app available and prompt them to\n   * refresh.\n   */\n  onUpdateNeeded?: ((reason: UpdateNeededReason) => void) | undefined;\n\n  /**\n   * `onClientStateNotFound` is called when this client is no longer able\n   * to sync with the zero-cache due to missing synchronization state.  This\n   * can be because:\n   * - the local persistent synchronization state has been garbage collected.\n   *   This can happen if the client has no pending mutations and has not been\n   *   used for a while (e.g. the client's tab has been hidden for a long time).\n   * - the zero-cache fails to find the server side synchronization state for\n   *   this client.\n   *\n   * The default behavior is to reload the page (using `location.reload()`).\n   * Provide your own function to prevent the page from reloading automatically.\n   */\n  onClientStateNotFound?: (() => void) | undefined;\n\n  /**\n   * The number of milliseconds to wait before disconnecting a Zero\n   * instance whose tab has become hidden.\n   *\n   * Instances in hidden tabs are disconnected to save resources.\n   *\n   * Default is 5_000.\n   */\n  hiddenTabDisconnectDelay?: number | undefined;\n\n  /**\n   * This gets called when the Zero instance encounters an error. The default\n   * behavior is to log the error to the console. Provide your own function to\n   * prevent the default behavior.\n   */\n  onError?: OnError | undefined;\n\n  /**\n   * Determines what kind of storage implementation to use on the client.\n   *\n   * Defaults to `'idb'` which means that Zero uses an IndexedDB storage\n   * implementation. This allows the data to be persisted on the client and\n   * enables faster syncs between application restarts.\n   *\n   * By setting this to `'mem'`, Zero uses an in memory storage and\n   * the data is not persisted on the client.\n   *\n   * You can also set this to a function that is used to create new KV stores,\n   * allowing a custom implementation of the underlying storage layer.\n   */\n  kvStore?: 'mem' | 'idb' | StoreProvider | undefined;\n\n  /**\n   * The maximum number of bytes to allow in a single header.\n   *\n   * Zero adds some extra information to headers on initialization if possible.\n   * This speeds up data synchronization. This number should be kept less than\n   * or equal to the maximum header size allowed by the zero-cache and any load\n   * balancers.\n   *\n   * Default value: 8kb.\n   */\n  maxHeaderLength?: number | undefined;\n\n  /**\n   * The maximum amount of milliseconds to wait for a materialization to\n   * complete (including network/server time) before printing a warning to the\n   * console.\n   *\n   * Default value: 5_000.\n   */\n  slowMaterializeThreshold?: number | undefined;\n\n  /**\n   * UI rendering libraries will often provide a utility for batching multiple\n   * state updates into a single render. Some examples are React's\n   * `unstable_batchedUpdates`, and solid-js's `batch`.\n   *\n   * This option enables integrating these batch utilities with Zero.\n   *\n   * When `batchViewUpdates` is provided, Zero will call it whenever\n   * it updates query view state with an `applyViewUpdates` function\n   * that performs the actual state updates.\n   *\n   * Zero updates query view state when:\n   * 1. creating a new view\n   * 2. updating all existing queries' views to a new consistent state\n   *\n   * When creating a new view, that single view's creation will be wrapped\n   * in a `batchViewUpdates` call.\n   *\n   * When updating existing queries, all queries will be updated in a single\n   * `batchViewUpdates` call, so that the transition to the new consistent\n   * state can be done in a single render.\n   *\n   * Implementations must always call `applyViewUpdates` synchronously.\n   */\n  batchViewUpdates?: ((applyViewUpdates: () => void) => void) | undefined;\n\n  /**\n   * The maximum number of recent queries, no longer subscribed to by a preload\n   * or view, to continue syncing.\n   *\n   * Defaults is 0.\n   *\n   * @deprecated Use ttl instead\n   */\n  maxRecentQueries?: number | undefined;\n\n  /**\n   * Changes to queries are sent to server in batches. This option controls\n   * the number of milliseconds to wait before sending the next batch.\n   *\n   * Defaults is 10.\n   */\n  queryChangeThrottleMs?: number | undefined;\n}\n\n/**\n * @deprecated Use {@link ZeroOptions} instead.\n */\nexport interface ZeroAdvancedOptions<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> extends ZeroOptions<S, MD> {}\n\nexport type UpdateNeededReason =\n  | {type: UpdateNeededReasonType.NewClientGroup}\n  | {type: UpdateNeededReasonType.VersionNotSupported}\n  | {type: UpdateNeededReasonType.SchemaVersionNotSupported};\n\nexport const updateNeededReasonTypeSchema: v.Type<UpdateNeededReason['type']> =\n  v.literalUnion(\n    UpdateNeededReasonType.NewClientGroup,\n    UpdateNeededReasonType.VersionNotSupported,\n    UpdateNeededReasonType.SchemaVersionNotSupported,\n  );\n","import * as v from '../../../shared/src/valita.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport {errorKindSchema} from '../../../zero-protocol/src/error.ts';\nimport {updateNeededReasonTypeSchema} from './options.ts';\nimport type {UpdateNeededReasonType} from './update-needed-reason-type.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\nexport const RELOAD_REASON_STORAGE_KEY = '_zeroReloadReason';\nexport const RELOAD_BACKOFF_STATE_KEY = '_zeroReloadBackoffState';\n\nconst reloadReasonSchema = v.tuple([\n  v.union(updateNeededReasonTypeSchema, errorKindSchema),\n  v.string(),\n]);\n\nconst backoffStateSchema = v.object({\n  lastReloadTime: v.number().default(0),\n  nextIntervalMs: v.number().default(0),\n});\n\nexport type BackoffState = v.Infer<typeof backoffStateSchema>;\n\nexport const MIN_RELOAD_INTERVAL_MS = 500;\nexport const MAX_RELOAD_INTERVAL_MS = 60_000;\n\n// For the fraction of browsers that do not support sessionStorage.\nexport const FALLBACK_RELOAD_INTERVAL_MS = 10_000;\n\nlet reloadTimer: ReturnType<typeof setTimeout> | null = null;\n\n// TODO: This should get pushed down into Replicache and used for reloads we\n// do there.\nexport function reloadWithReason(\n  lc: ZeroLogContext,\n  reload: () => void,\n  reason: UpdateNeededReasonType | ErrorKind,\n  message: string,\n) {\n  if (reloadTimer) {\n    lc.info?.('reload timer already scheduled');\n    return;\n  }\n  const now = Date.now();\n  const backoff = nextBackoff(lc, now);\n\n  // Record state immediately so that it persists if the user manually reloads first.\n  if (typeof sessionStorage !== 'undefined') {\n    sessionStorage.setItem(RELOAD_BACKOFF_STATE_KEY, JSON.stringify(backoff));\n    sessionStorage.setItem(\n      RELOAD_REASON_STORAGE_KEY,\n      JSON.stringify([reason, message]),\n    );\n  }\n\n  const delay = backoff.lastReloadTime - now;\n  lc.error?.(\n    reason,\n    '\\n',\n    'reloading',\n    delay > 0 ? `in ${delay / 1000} seconds` : '',\n  );\n  reloadTimer = setTimeout(() => {\n    reloadTimer = null;\n    reload();\n  }, delay);\n}\n\nexport function reportReloadReason(lc: ZeroLogContext) {\n  if (typeof sessionStorage !== 'undefined') {\n    const value = sessionStorage.getItem(RELOAD_REASON_STORAGE_KEY);\n    if (value) {\n      sessionStorage.removeItem(RELOAD_REASON_STORAGE_KEY);\n      try {\n        const parsed = JSON.parse(value);\n        const [reasonType, message] = v.parse(parsed, reloadReasonSchema);\n        lc.error?.(reasonType, 'Zero reloaded the page.', message);\n      } catch (e) {\n        lc.error?.('Zero reloaded the page.', e);\n        // ignore if not able to parse\n        return;\n      }\n    }\n  }\n}\n\n/** If a reload is scheduled, do not attempt to reconnect. */\nexport function reloadScheduled() {\n  return reloadTimer !== null;\n}\n\n/** Call upon a successful connection, indicating that backoff should be reset. */\nexport function resetBackoff() {\n  if (typeof sessionStorage !== 'undefined') {\n    sessionStorage.removeItem(RELOAD_BACKOFF_STATE_KEY);\n  }\n}\n\nfunction nextBackoff(lc: ZeroLogContext, now: number): BackoffState {\n  if (typeof sessionStorage === 'undefined') {\n    lc.warn?.(\n      `sessionStorage not supported. backing off in ${\n        FALLBACK_RELOAD_INTERVAL_MS / 1000\n      } seconds`,\n    );\n    return {\n      lastReloadTime: now + FALLBACK_RELOAD_INTERVAL_MS,\n      nextIntervalMs: MIN_RELOAD_INTERVAL_MS,\n    };\n  }\n  const val = sessionStorage.getItem(RELOAD_BACKOFF_STATE_KEY);\n  if (!val) {\n    return {lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS};\n  }\n  let parsed: BackoffState;\n  try {\n    parsed = v.parse(JSON.parse(val), backoffStateSchema, 'passthrough');\n  } catch (e) {\n    lc.warn?.('ignoring unparsable backoff state', val, e);\n    return {lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS};\n  }\n  const {lastReloadTime, nextIntervalMs} = parsed;\n\n  // Backoff state might not have been cleared. Reset for sufficiently old state.\n  if (now - lastReloadTime > MAX_RELOAD_INTERVAL_MS * 2) {\n    return {lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS};\n  }\n  if (now < lastReloadTime) {\n    // If the user manually reloaded, stick to the existing schedule.\n    return parsed;\n  }\n  const nextReloadTime = Math.max(now, lastReloadTime + nextIntervalMs);\n  return {\n    lastReloadTime: nextReloadTime,\n    nextIntervalMs: Math.min(nextIntervalMs * 2, MAX_RELOAD_INTERVAL_MS),\n  };\n}\n","import {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport {\n  type BackoffBody,\n  type ErrorBody,\n} from '../../../zero-protocol/src/error.ts';\n\n/**\n * Represents an error sent by server as part of Zero protocol.\n */\nexport class ServerError<K extends ErrorKind = ErrorKind> extends Error {\n  readonly name = 'ServerError';\n  readonly errorBody: ErrorBody;\n  get kind(): K {\n    return this.errorBody.kind as K;\n  }\n\n  constructor(errorBody: ErrorBody) {\n    super(errorBody.kind + ': ' + errorBody.message);\n    this.errorBody = errorBody;\n  }\n}\n\nexport function isServerError(ex: unknown): ex is ServerError {\n  return ex instanceof ServerError;\n}\n\nexport function isAuthError(\n  ex: unknown,\n): ex is\n  | ServerError<ErrorKind.AuthInvalidated>\n  | ServerError<ErrorKind.Unauthorized> {\n  return isServerError(ex) && isAuthErrorKind(ex.kind);\n}\n\nfunction isAuthErrorKind(\n  kind: ErrorKind,\n): kind is ErrorKind.AuthInvalidated | ErrorKind.Unauthorized {\n  return kind === ErrorKind.AuthInvalidated || kind === ErrorKind.Unauthorized;\n}\n\nexport function isBackoffError(ex: unknown): BackoffBody | undefined {\n  if (isServerError(ex)) {\n    switch (ex.errorBody.kind) {\n      case ErrorKind.Rebalance:\n      case ErrorKind.Rehome:\n      case ErrorKind.ServerOverloaded:\n        return ex.errorBody;\n    }\n  }\n  return undefined;\n}\n","import {getBrowserGlobal} from '../../../shared/src/browser-env.ts';\nimport type {HTTPString} from './http-string.ts';\n\nfunction validateServerParam(paramName: string, server: string): HTTPString {\n  const expectedProtocol = 'http';\n  const forExample = (path: string = '') =>\n    ` For example: \"${expectedProtocol}s://myapp-myteam.zero.ms/${path}\".`;\n\n  if (\n    !server.startsWith(`${expectedProtocol}://`) &&\n    !server.startsWith(`${expectedProtocol}s://`)\n  ) {\n    throw new Error(\n      `ZeroOptions.${paramName} must use the \"${expectedProtocol}\" or \"${expectedProtocol}s\" scheme.`,\n    );\n  }\n  let url;\n  try {\n    url = new URL(server);\n  } catch {\n    throw new Error(\n      `ZeroOptions.${paramName} must be a valid URL.${forExample()}`,\n    );\n  }\n\n  const urlString = url.toString();\n\n  const pathComponents = url.pathname.split('/');\n  if (pathComponents[0] === '') {\n    pathComponents.shift();\n  }\n  if (pathComponents[pathComponents.length - 1] === '') {\n    pathComponents.pop();\n  }\n  if (pathComponents.length > 1) {\n    throw new Error(\n      `ZeroOptions.${paramName} may have at most one path component.${forExample(\n        'zero',\n      )}`,\n    );\n  }\n\n  for (const [property, invalidEndsWith] of [\n    ['search', '?'],\n    ['hash', '#'],\n  ] as const) {\n    if (url[property] || urlString.endsWith(invalidEndsWith)) {\n      throw new Error(\n        `ZeroOptions.${paramName} must not contain a ${property} component.${forExample()}`,\n      );\n    }\n  }\n\n  return urlString as HTTPString;\n}\n\nexport function getServer(\n  server: string | undefined | null,\n): HTTPString | null {\n  const WS = getBrowserGlobal('WebSocket');\n  if (!WS) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Zero started in an unsupported environment, no data will be synced.',\n    );\n    return null;\n  }\n  if (server === undefined || server === null) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Zero starting up with no server URL. No data will be synced.',\n    );\n    return null;\n  }\n  return validateServerParam('server', server);\n}\n","import {LogContext} from '@rocicorp/logger';\nimport type {OnErrorParameters} from './on-error.ts';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const ZeroLogContext = LogContext<OnErrorParameters>;\nexport type ZeroLogContext = LogContext<OnErrorParameters>;\n","import {Lock} from '@rocicorp/lock';\nimport type {\n  PatchOperationInternal,\n  PokeInternal,\n} from '../../../replicache/src/impl.ts';\nimport type {PatchOperation} from '../../../replicache/src/patch-operation.ts';\nimport type {ClientID} from '../../../replicache/src/sync/ids.ts';\nimport {getBrowserGlobalMethod} from '../../../shared/src/browser-env.ts';\nimport type {JSONValue} from '../../../shared/src/json.ts';\nimport type {\n  PokeEndBody,\n  PokePartBody,\n  PokeStartBody,\n} from '../../../zero-protocol/src/poke.ts';\nimport type {QueriesPatchOp} from '../../../zero-protocol/src/queries-patch.ts';\nimport type {RowPatchOp} from '../../../zero-protocol/src/row-patch.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {\n  serverToClient,\n  type NameMapper,\n} from '../../../zero-schema/src/name-mapper.ts';\nimport {\n  toDesiredQueriesKey,\n  toGotQueriesKey,\n  toMutationResponseKey,\n  toPrimaryKeyString,\n} from './keys.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\nimport {unreachable} from '../../../shared/src/asserts.ts';\nimport type {MutationPatch} from '../../../zero-protocol/src/mutations-patch.ts';\nimport type {MutationTracker} from './mutation-tracker.ts';\n\ntype PokeAccumulator = {\n  readonly pokeStart: PokeStartBody;\n  readonly parts: PokePartBody[];\n  readonly pokeEnd: PokeEndBody;\n};\n\n/**\n * Handles the multi-part format of zero pokes.\n * As an optimization it also debounces pokes, only poking Replicache with a\n * merged poke at most once per frame (as determined by requestAnimationFrame).\n * The client cannot control how fast the server sends pokes, and it can only\n * update the UI once per frame. This debouncing avoids wastefully\n * computing separate diffs and IVM updates for intermediate states that will\n * never been displayed to the UI.\n */\nexport class PokeHandler {\n  readonly #replicachePoke: (poke: PokeInternal) => Promise<void>;\n  readonly #onPokeError: () => void;\n  readonly #clientID: ClientID;\n  readonly #lc: ZeroLogContext;\n  #receivingPoke: Omit<PokeAccumulator, 'pokeEnd'> | undefined = undefined;\n  readonly #pokeBuffer: PokeAccumulator[] = [];\n  #pokePlaybackLoopRunning = false;\n  #lastRafPerfTimestamp = 0;\n  // Serializes calls to this.#replicachePoke otherwise we can cause out of\n  // order poke errors.\n  readonly #pokeLock = new Lock();\n  readonly #schema: Schema;\n  readonly #serverToClient: NameMapper;\n  readonly #mutationTracker: MutationTracker;\n\n  readonly #raf =\n    getBrowserGlobalMethod('requestAnimationFrame') ?? rafFallback;\n\n  constructor(\n    replicachePoke: (poke: PokeInternal) => Promise<void>,\n    onPokeError: () => void,\n    clientID: ClientID,\n    schema: Schema,\n    lc: ZeroLogContext,\n    mutationTracker: MutationTracker,\n  ) {\n    this.#replicachePoke = replicachePoke;\n    this.#onPokeError = onPokeError;\n    this.#clientID = clientID;\n    this.#schema = schema;\n    this.#serverToClient = serverToClient(schema.tables);\n    this.#lc = lc.withContext('PokeHandler');\n    this.#mutationTracker = mutationTracker;\n  }\n\n  handlePokeStart(pokeStart: PokeStartBody) {\n    if (this.#receivingPoke) {\n      this.#handlePokeError(\n        `pokeStart ${JSON.stringify(\n          pokeStart,\n        )} while still receiving  ${JSON.stringify(\n          this.#receivingPoke.pokeStart,\n        )} `,\n      );\n      return;\n    }\n    this.#receivingPoke = {\n      pokeStart,\n      parts: [],\n    };\n  }\n\n  handlePokePart(pokePart: PokePartBody): number | undefined {\n    if (pokePart.pokeID !== this.#receivingPoke?.pokeStart.pokeID) {\n      this.#handlePokeError(\n        `pokePart for ${pokePart.pokeID}, when receiving ${\n          this.#receivingPoke?.pokeStart.pokeID\n        }`,\n      );\n      return;\n    }\n    this.#receivingPoke.parts.push(pokePart);\n    return pokePart.lastMutationIDChanges?.[this.#clientID];\n  }\n\n  handlePokeEnd(pokeEnd: PokeEndBody): void {\n    if (pokeEnd.pokeID !== this.#receivingPoke?.pokeStart.pokeID) {\n      this.#handlePokeError(\n        `pokeEnd for ${pokeEnd.pokeID}, when receiving ${\n          this.#receivingPoke?.pokeStart.pokeID\n        }`,\n      );\n      return;\n    }\n    if (pokeEnd.cancel) {\n      this.#receivingPoke = undefined;\n      return;\n    }\n    this.#pokeBuffer.push({...this.#receivingPoke, pokeEnd});\n    this.#receivingPoke = undefined;\n    if (!this.#pokePlaybackLoopRunning) {\n      this.#startPlaybackLoop();\n    }\n  }\n\n  handleDisconnect(): void {\n    this.#lc.debug?.('clearing due to disconnect');\n    this.#clear();\n  }\n\n  #startPlaybackLoop() {\n    this.#lc.debug?.('starting playback loop');\n    this.#pokePlaybackLoopRunning = true;\n    this.#raf(this.#rafCallback);\n  }\n\n  #rafCallback = async () => {\n    const rafLC = this.#lc.withContext('rafAt', Math.floor(performance.now()));\n    if (this.#pokeBuffer.length === 0) {\n      rafLC.debug?.('stopping playback loop');\n      this.#pokePlaybackLoopRunning = false;\n      return;\n    }\n    this.#raf(this.#rafCallback);\n    const start = performance.now();\n    rafLC.debug?.(\n      'raf fired, processing pokes.  Since last raf',\n      start - this.#lastRafPerfTimestamp,\n    );\n    this.#lastRafPerfTimestamp = start;\n    await this.#processPokesForFrame(rafLC);\n    rafLC.debug?.('processing pokes took', performance.now() - start);\n  };\n\n  #processPokesForFrame(lc: ZeroLogContext): Promise<void> {\n    return this.#pokeLock.withLock(async () => {\n      const now = Date.now();\n      lc.debug?.('got poke lock at', now);\n      lc.debug?.('merging', this.#pokeBuffer.length);\n      try {\n        const merged = mergePokes(\n          this.#pokeBuffer,\n          this.#schema,\n          this.#serverToClient,\n        );\n        this.#pokeBuffer.length = 0;\n        if (merged === undefined) {\n          lc.debug?.('frame is empty');\n          return;\n        }\n        const start = performance.now();\n        lc.debug?.('poking replicache');\n        await this.#replicachePoke(merged);\n        lc.debug?.('poking replicache took', performance.now() - start);\n\n        if (!('error' in merged.pullResponse)) {\n          const lmid =\n            merged.pullResponse.lastMutationIDChanges[this.#clientID];\n          if (lmid !== undefined) {\n            this.#mutationTracker.lmidAdvanced(lmid);\n          }\n        }\n      } catch (e) {\n        this.#handlePokeError(e);\n      }\n    });\n  }\n\n  #handlePokeError(e: unknown) {\n    if (String(e).includes('unexpected base cookie for poke')) {\n      // This can happen if cookie changes due to refresh from idb due\n      // to an update arriving to different tabs in the same\n      // client group at very different times.  Unusual but possible.\n      this.#lc.debug?.('clearing due to', e);\n    } else {\n      this.#lc.error?.('clearing due to unexpected poke error', e);\n    }\n    this.#clear();\n    this.#onPokeError();\n  }\n\n  #clear() {\n    this.#receivingPoke = undefined;\n    this.#pokeBuffer.length = 0;\n  }\n}\n\nexport function mergePokes(\n  pokeBuffer: PokeAccumulator[],\n  schema: Schema,\n  serverToClient: NameMapper,\n):\n  | (PokeInternal & {mutationResults?: MutationPatch[] | undefined})\n  | undefined {\n  if (pokeBuffer.length === 0) {\n    return undefined;\n  }\n  const {baseCookie} = pokeBuffer[0].pokeStart;\n  const lastPoke = pokeBuffer[pokeBuffer.length - 1];\n  const {cookie} = lastPoke.pokeEnd;\n  const mergedPatch: PatchOperationInternal[] = [];\n  const mergedLastMutationIDChanges: Record<string, number> = {};\n  const mutationResults: MutationPatch[] = [];\n\n  let prevPokeEnd = undefined;\n  for (const pokeAccumulator of pokeBuffer) {\n    if (\n      prevPokeEnd &&\n      pokeAccumulator.pokeStart.baseCookie &&\n      pokeAccumulator.pokeStart.baseCookie > prevPokeEnd.cookie\n    ) {\n      throw Error(\n        `unexpected cookie gap ${JSON.stringify(prevPokeEnd)} ${JSON.stringify(\n          pokeAccumulator.pokeStart,\n        )}`,\n      );\n    }\n    prevPokeEnd = pokeAccumulator.pokeEnd;\n    for (const pokePart of pokeAccumulator.parts) {\n      if (pokePart.lastMutationIDChanges) {\n        for (const [clientID, lastMutationID] of Object.entries(\n          pokePart.lastMutationIDChanges,\n        )) {\n          mergedLastMutationIDChanges[clientID] = lastMutationID;\n        }\n      }\n      if (pokePart.desiredQueriesPatches) {\n        for (const [clientID, queriesPatch] of Object.entries(\n          pokePart.desiredQueriesPatches,\n        )) {\n          for (const op of queriesPatch) {\n            mergedPatch.push(\n              queryPatchOpToReplicachePatchOp(op, hash =>\n                toDesiredQueriesKey(clientID, hash),\n              ),\n            );\n          }\n        }\n      }\n      if (pokePart.gotQueriesPatch) {\n        for (const op of pokePart.gotQueriesPatch) {\n          mergedPatch.push(\n            queryPatchOpToReplicachePatchOp(op, toGotQueriesKey),\n          );\n        }\n      }\n      if (pokePart.rowsPatch) {\n        for (const p of pokePart.rowsPatch) {\n          mergedPatch.push(\n            rowsPatchOpToReplicachePatchOp(p, schema, serverToClient),\n          );\n        }\n      }\n      if (pokePart.mutationsPatch) {\n        for (const op of pokePart.mutationsPatch) {\n          mergedPatch.push(mutationPatchOpToReplicachePatchOp(op));\n        }\n      }\n    }\n  }\n  const ret: PokeInternal & {mutationResults?: MutationPatch[] | undefined} = {\n    baseCookie,\n    pullResponse: {\n      lastMutationIDChanges: mergedLastMutationIDChanges,\n      patch: mergedPatch,\n      cookie,\n    },\n  };\n\n  // For backwards compatibility. Because we're strict on our validation,\n  // zero-client must be able to parse pokes with this field before we introduce it.\n  // So users can update their clients and then start using custom mutators that write responses to the db.\n  if (mutationResults.length > 0) {\n    ret.mutationResults = mutationResults;\n  }\n  return ret;\n}\n\nfunction queryPatchOpToReplicachePatchOp(\n  op: QueriesPatchOp,\n  toKey: (hash: string) => string,\n): PatchOperation {\n  switch (op.op) {\n    case 'clear':\n      return op;\n    case 'del':\n      return {\n        op: 'del',\n        key: toKey(op.hash),\n      };\n    case 'put':\n      return {\n        op: 'put',\n        key: toKey(op.hash),\n        value: null,\n      };\n    default:\n      unreachable(op);\n  }\n}\n\nexport function mutationPatchOpToReplicachePatchOp(\n  op: MutationPatch,\n): PatchOperationInternal {\n  switch (op.op) {\n    case 'put':\n      return {\n        op: 'put',\n        key: toMutationResponseKey(op.mutation.id),\n        value: op.mutation.result,\n      };\n    case 'del':\n      return {\n        op: 'del',\n        key: toMutationResponseKey(op.id),\n      };\n  }\n}\n\nfunction rowsPatchOpToReplicachePatchOp(\n  op: RowPatchOp,\n  schema: Schema,\n  serverToClient: NameMapper,\n): PatchOperationInternal {\n  if (op.op === 'clear') {\n    return op;\n  }\n  const tableName = serverToClient.tableName(op.tableName, op as JSONValue);\n  switch (op.op) {\n    case 'del':\n      return {\n        op: 'del',\n        key: toPrimaryKeyString(\n          tableName,\n          schema.tables[tableName].primaryKey,\n          serverToClient.row(op.tableName, op.id),\n        ),\n      };\n    case 'put':\n      return {\n        op: 'put',\n        key: toPrimaryKeyString(\n          tableName,\n          schema.tables[tableName].primaryKey,\n          serverToClient.row(op.tableName, op.value),\n        ),\n        value: serverToClient.row(op.tableName, op.value),\n      };\n    case 'update':\n      return {\n        op: 'update',\n        key: toPrimaryKeyString(\n          tableName,\n          schema.tables[tableName].primaryKey,\n          serverToClient.row(op.tableName, op.id),\n        ),\n        merge: op.merge\n          ? serverToClient.row(op.tableName, op.merge)\n          : undefined,\n        constrain: serverToClient.columns(op.tableName, op.constrain),\n      };\n    default:\n      unreachable(op);\n  }\n}\n\n/**\n * Some environments we run in don't have `requestAnimationFrame` (such as\n * Node, Cloudflare Workers).\n */\nfunction rafFallback(callback: () => void): void {\n  setTimeout(callback, 0);\n}\n","import type {\n  InternalDiff,\n  InternalDiffOperation,\n} from '../../../replicache/src/btree/node.ts';\nimport {readFromHash} from '../../../replicache/src/db/read.ts';\nimport type {Hash} from '../../../replicache/src/hash.ts';\nimport {withRead} from '../../../replicache/src/with-transactions.ts';\nimport type {ZeroContext} from './context.ts';\nimport * as FormatVersion from '../../../replicache/src/format-version-enum.ts';\nimport type {IVMSourceBranch} from './ivm-branch.ts';\nimport {ENTITIES_KEY_PREFIX} from './keys.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {LazyStore} from '../../../replicache/src/dag/lazy-store.ts';\nimport type {\n  EphemeralID,\n  MutationTrackingData,\n  ZeroOption,\n  ZeroReadOptions,\n} from '../../../replicache/src/replicache-options.ts';\nimport type {MutationTracker} from './mutation-tracker.ts';\n\ntype TxData = {\n  ivmSources: IVMSourceBranch;\n  token: string | undefined;\n};\n\nexport class ZeroRep implements ZeroOption {\n  readonly #context: ZeroContext;\n  readonly #ivmMain: IVMSourceBranch;\n  readonly #customMutatorsEnabled: boolean;\n  readonly #mutationTracker: MutationTracker;\n  #store: LazyStore | undefined;\n  #auth: string | undefined;\n\n  constructor(\n    context: ZeroContext,\n    ivmMain: IVMSourceBranch,\n    customMutatorsEnabled: boolean,\n    mutationTracker: MutationTracker,\n  ) {\n    this.#context = context;\n    this.#ivmMain = ivmMain;\n    this.#customMutatorsEnabled = customMutatorsEnabled;\n    this.#mutationTracker = mutationTracker;\n  }\n\n  set auth(auth: string) {\n    if (auth === '') {\n      this.#auth = undefined;\n    } else {\n      this.#auth = auth;\n    }\n  }\n\n  async init(hash: Hash, store: LazyStore) {\n    const diffs: InternalDiffOperation[] = [];\n    await withRead(store, async dagRead => {\n      const read = await readFromHash(hash, dagRead, FormatVersion.Latest);\n      for await (const entry of read.map.scan(ENTITIES_KEY_PREFIX)) {\n        if (!entry[0].startsWith(ENTITIES_KEY_PREFIX)) {\n          break;\n        }\n        diffs.push({\n          op: 'add',\n          key: entry[0],\n          newValue: entry[1],\n        });\n      }\n    });\n    this.#store = store;\n\n    this.#context.processChanges(undefined, hash, diffs);\n  }\n\n  getTxData = (\n    desiredHead: Hash,\n    readOptions?: ZeroReadOptions | undefined,\n  ): Promise<TxData> | undefined => {\n    // getTxData requires some extensive testing for complete confidence\n    // that it will not break. Do not enable `getTxData` unless the user\n    // has opted into custom mutators.\n    if (!this.#customMutatorsEnabled) {\n      return;\n    }\n\n    return this.#ivmMain\n      .forkToHead(must(this.#store), desiredHead, readOptions)\n      .then(branch => ({\n        ivmSources: branch,\n        token: this.#auth,\n      }));\n  };\n\n  advance = (expectedHash: Hash, newHash: Hash, diffs: InternalDiff): void => {\n    this.#context.processChanges(expectedHash, newHash, diffs);\n  };\n\n  trackMutation(): MutationTrackingData {\n    return this.#mutationTracker.trackMutation();\n  }\n  mutationIDAssigned(ephemeralID: EphemeralID, mutationID: number): void {\n    this.#mutationTracker.mutationIDAssigned(ephemeralID, mutationID);\n  }\n  rejectMutation(ephemeralID: EphemeralID, ex: unknown): void {\n    this.#mutationTracker.rejectMutation(ephemeralID, ex);\n  }\n}\n"],"names":["v","db","resolver","promiseVoid","resolver","process","ReadImpl","WriteImpl","ReadImpl","WriteImpl","ReadImpl","ReadImpl","WriteImpl","string","number","table","table","name","serverName","SchemaVersionNotSupported","VersionNotSupported","resolver","consoleLogSink","resolver","resolver","resolver","resolver","t","ok","RWLock","RWLock","greaterThan","greaterThan","zeroData","clientID","localMutations","latestGCUpdate","latestGCUpdate","mainClientGroupID","perdagLMID","perdagBaseSnapshot","memdagBaseSnapshot","gatheredChunks","zeroData","perdagClientGroupHeadHash","perdagLmid","perdagClientGroupBaseSnapshot","gatheredChunks","memdagBaseSnapshot","zeroData","resolver","process","requestIdle","resolver","greaterThan","scan","diff","diff","newDiff","greaterThan","noop","consoleLogSink","resolver","hasClientState","zeroData","pusherResult","requestID","beginPullResponse","zeroErrorSchema","putOpSchema","delOpSchema","patchOpSchema","putOpSchema","updateOpSchema","delOpSchema","clearOpSchema","table","resolver","resolver","clientID","compareUTF8","comparator","key","compareUTF8","comparator","data","diff","assertValidRunOptions","table","send","TeeLogSink","consoleLogSink","Lock","version","version","consoleLogSink","options","TeeLogSink","version","resolver","resolver","diff","send","diff","reload","LogContext","Lock","Lock","serverToClient","version","resolver","assertValidRunOptions","e"],"mappings":"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","debugId":null}}]
}