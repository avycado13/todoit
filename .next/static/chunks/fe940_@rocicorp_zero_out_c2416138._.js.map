{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/resolved-promises.ts"],"sourcesContent":["export const promiseTrue = Promise.resolve(true as const);\nexport const promiseFalse = Promise.resolve(false as const);\nexport const promiseUndefined = Promise.resolve(undefined);\nexport const promiseVoid = Promise.resolve();\n\n/**\n * A promise that never resolves.\n */\nexport const promiseNever = new Promise<never>(() => {});\n"],"names":[],"mappings":";;;;;;;;;;;AAAO,IAAM,cAAc,QAAQ,OAAA,CAAQ,IAAa;AACjD,IAAM,eAAe,QAAQ,OAAA,CAAQ,KAAc;AACnD,IAAM,mBAAmB,QAAQ,OAAA,CAAQ,KAAA,CAAS;AAClD,IAAM,cAAc,QAAQ,OAAA,CAAQ;AAKpC,IAAM,eAAe,IAAI,QAAe,KAAO,CAAD,AAAE","debugId":null}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/asserts.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/has-own.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/config.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/frozen-json.ts"],"sourcesContent":["export function assert(\n  b: unknown,\n  msg: string | (() => string) = 'Assertion failed',\n): asserts b {\n  if (!b) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport function assertString(v: unknown): asserts v is string {\n  assertType(v, 'string');\n}\n\nexport function assertNumber(v: unknown): asserts v is number {\n  assertType(v, 'number');\n}\n\nexport function assertBoolean(v: unknown): asserts v is boolean {\n  assertType(v, 'boolean');\n}\n\nfunction assertType(v: unknown, t: string) {\n  if (typeof v !== t) {\n    throwInvalidType(v, t);\n  }\n}\n\nexport function assertObject(v: unknown): asserts v is Record<string, unknown> {\n  if (v === null) {\n    throwInvalidType(v, 'object');\n  }\n  assertType(v, 'object');\n}\n\nexport function assertArray(v: unknown): asserts v is unknown[] {\n  if (!Array.isArray(v)) {\n    throwInvalidType(v, 'array');\n  }\n}\n\nexport function invalidType(v: unknown, t: string): string {\n  let s = 'Invalid type: ';\n  if (v === null || v === undefined) {\n    s += v;\n  } else {\n    s += `${typeof v} \\`${v}\\``;\n  }\n  return s + `, expected ${t}`;\n}\n\nexport function throwInvalidType(v: unknown, t: string): never {\n  throw new Error(invalidType(v, t));\n}\n\nexport function assertNotNull<T>(v: T | null): asserts v is T {\n  if (v === null) {\n    throw new Error('Expected non-null value');\n  }\n}\n\nexport function assertUndefined<T>(\n  v: T | undefined,\n  msg = 'Expected undefined value',\n): asserts v is T {\n  if (v !== undefined) {\n    throw new Error(msg);\n  }\n}\n\nexport function assertNotUndefined<T>(\n  v: T | undefined,\n  msg = 'Expected non undefined value',\n): asserts v is T {\n  if (v === undefined) {\n    throw new Error(msg);\n  }\n}\n\nexport function assertInstanceof<T>(\n  v: unknown,\n  t: new (...args: unknown[]) => T,\n): asserts v is T {\n  if (!(v instanceof t)) {\n    throw new Error(`Expected instanceof ${t.name}`);\n  }\n}\n\nexport function assertUint8Array(v: unknown): asserts v is Uint8Array {\n  assertInstanceof(v, Uint8Array);\n}\n\nexport function unreachable(): never;\nexport function unreachable(v: never): never;\nexport function unreachable(_?: never): never {\n  throw new Error('Unreachable');\n}\n\nexport function notImplemented(): never {\n  throw new Error('Not implemented');\n}\n","// hasOwn was added in ES2022\nexport const {hasOwn} = Object;\n","declare const process: {\n  env: {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    NODE_ENV?: string;\n  };\n};\n\nexport const isProd = process.env.NODE_ENV === 'production';\n\nexport {isProd as skipAssertJSONValue};\n","import {throwInvalidType} from '../../shared/src/asserts.ts';\nimport {skipAssertJSONValue} from '../../shared/src/config.ts';\nimport {hasOwn} from '../../shared/src/has-own.ts';\nimport type {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from '../../shared/src/json.ts';\nimport {skipFreeze, skipFrozenAsserts} from './config.ts';\nimport type {Cookie, FrozenCookie} from './cookies.ts';\n\ndeclare const frozenJSONTag: unique symbol;\n\n/**\n * Used to mark a type as having been frozen.\n */\nexport type FrozenTag<T> = T & {readonly [frozenJSONTag]: true};\n\nexport type FrozenJSONValue =\n  | null\n  | string\n  | boolean\n  | number\n  | FrozenJSONArray\n  | FrozenJSONObject;\n\ntype FrozenJSONArray = FrozenTag<ReadonlyArray<FrozenJSONValue>>;\n\nexport type FrozenJSONObject = FrozenTag<{\n  readonly [key: string]: FrozenJSONValue;\n}>;\n\n/**\n * We tag deep frozen objects in debug mode so that we do not have to deep\n * freeze an object more than once.\n */\nconst deepFrozenObjects = new WeakSet<object>();\n\n/**\n * Recursively freezes the passed in value (mutates it) and returns it.\n *\n * This is controlled by `skipFreeze` which is true in release mode.\n */\nexport function deepFreeze(v: Cookie): FrozenCookie;\nexport function deepFreeze(v: ReadonlyJSONValue): FrozenJSONValue;\nexport function deepFreeze(v: ReadonlyJSONValue): FrozenJSONValue {\n  if (skipFreeze) {\n    return v as FrozenJSONValue;\n  }\n\n  deepFreezeInternal(v, []);\n  return v as FrozenJSONValue;\n}\n\nfunction deepFreezeInternal(\n  v: ReadonlyJSONValue | undefined,\n  seen: object[],\n): void {\n  switch (typeof v) {\n    case 'undefined':\n      throw new TypeError('Unexpected value undefined');\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return;\n    case 'object': {\n      if (v === null) {\n        return;\n      }\n\n      if (deepFrozenObjects.has(v)) {\n        return;\n      }\n      deepFrozenObjects.add(v);\n\n      if (seen.includes(v)) {\n        throwInvalidType(v, 'Cyclic JSON object');\n      }\n\n      seen.push(v);\n\n      Object.freeze(v);\n      if (Array.isArray(v)) {\n        deepFreezeArray(v, seen);\n      } else {\n        deepFreezeObject(v as ReadonlyJSONObject, seen);\n      }\n      seen.pop();\n      return;\n    }\n\n    default:\n      throwInvalidType(v, 'JSON value');\n  }\n}\n\nfunction deepFreezeArray(\n  v: ReadonlyArray<ReadonlyJSONValue>,\n  seen: object[],\n): void {\n  for (const item of v) {\n    deepFreezeInternal(item, seen);\n  }\n}\n\nfunction deepFreezeObject(v: ReadonlyJSONObject, seen: object[]): void {\n  for (const k in v) {\n    if (hasOwn(v, k)) {\n      const value = v[k];\n      if (value !== undefined) {\n        deepFreezeInternal(value, seen);\n      }\n    }\n  }\n}\n\nexport function assertFrozenJSONValue(\n  v: unknown,\n): asserts v is FrozenJSONValue {\n  if (skipFrozenAsserts || skipAssertJSONValue) {\n    return;\n  }\n\n  switch (typeof v) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return;\n    case 'object':\n      if (v === null) {\n        return;\n      }\n\n      if (isDeepFrozen(v, [])) {\n        return;\n      }\n  }\n  throwInvalidType(v, 'JSON value');\n}\n\nexport function assertDeepFrozen<V>(v: V): asserts v is Readonly<V> {\n  if (skipFrozenAsserts) {\n    return;\n  }\n\n  if (!isDeepFrozen(v, [])) {\n    throw new Error('Expected frozen object');\n  }\n}\n\n/**\n * Recursive deep frozen check.\n *\n * It adds frozen objects to the {@link deepFrozenObjects} WeakSet so that we do\n * not have to check the same object more than once.\n */\nexport function isDeepFrozen(v: unknown, seen: object[]): boolean {\n  switch (typeof v) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return true;\n    case 'object':\n      if (v === null) {\n        return true;\n      }\n\n      if (deepFrozenObjects.has(v)) {\n        return true;\n      }\n\n      if (!Object.isFrozen(v)) {\n        return false;\n      }\n\n      if (seen.includes(v)) {\n        throwInvalidType(v, 'Cyclic JSON object');\n      }\n\n      seen.push(v);\n\n      if (Array.isArray(v)) {\n        for (const item of v) {\n          if (!isDeepFrozen(item, seen)) {\n            seen.pop();\n            return false;\n          }\n        }\n      } else {\n        for (const k in v) {\n          if (hasOwn(v, k)) {\n            const value = (v as Record<string, unknown>)[k];\n            if (value !== undefined && !isDeepFrozen(value, seen)) {\n              seen.pop();\n              return false;\n            }\n          }\n        }\n      }\n\n      deepFrozenObjects.add(v);\n      seen.pop();\n      return true;\n\n    default:\n      throwInvalidType(v, 'JSON value');\n  }\n}\n\nexport type P = Parameters<typeof deepFreeze>[0];\nexport type R = ReturnType<typeof deepFreeze>;\nexport function deepFreezeAllowUndefined(v: P | undefined): R | undefined {\n  if (v === undefined) {\n    return undefined;\n  }\n  return deepFreeze(v) as R;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/components/mark-icon.tsx"],"sourcesContent":["import type {FC, SVGProps} from 'react';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const MarkIcon: FC<SVGProps<SVGSVGElement>> = props => (\n  <svg\n    width=\"18\"\n    height=\"18\"\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <title>Show Zero Inspector</title>\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M0.407235 15.1075C-0.661857 11.1041 0.374032 6.65546 3.51478 3.51471C8.20106 -1.17157 15.799 -1.17157 20.4854 3.51471C20.8969 3.92627 21.2723 4.36029 21.6115 4.81284L17.6063 8.81802H12.7576L16.7275 4.84814C13.3994 2.64322 8.87135 3.00687 5.9391 5.93909C4.24366 7.63455 3.40687 9.86362 3.42896 12.0857L0.407235 15.1075ZM18.0609 18.0609C15.1287 20.9931 10.6006 21.3568 7.27247 19.1519L11.2423 15.182H6.39356L2.38844 19.1872C2.72767 19.6397 3.10316 20.0737 3.51466 20.4853C8.20094 25.1716 15.799 25.1716 20.4852 20.4853C23.626 17.3445 24.6619 12.8959 23.5927 8.89255L20.5709 11.9143C20.593 14.1364 19.7564 16.3654 18.0609 18.0609Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n);\n"],"names":[],"mappings":";;;;;AAIE,SAQE,KARF;;AADK,IAAM,WAAwC,CAAA,QACnD,aAAA,GAAA,IAAA,qVAAA,EAAC,OAAA;QACC,OAAM;QACN,QAAO;QACP,SAAQ;QACR,MAAK;QACL,OAAM;QACL,GAAG,KAAA;QAEJ,UAAA;YAAA,aAAA,GAAA,IAAA,oVAAA,EAAC,SAAA;gBAAM,UAAA;YAAA,CAAmB;YAC1B,aAAA,GAAA,IAAA,oVAAA,EAAC,QAAA;gBACC,UAAS;gBACT,UAAS;gBACT,GAAE;gBACF,MAAK;YAAA;SACP;IAAA","debugId":null}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/components/zero-inspector.tsx","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/use-query.tsx","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/deep-clone.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/zero-provider.tsx","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/use-zero-online.tsx"],"sourcesContent":["import {lazy, Suspense, useState} from 'react';\nimport type {CustomMutatorDefs} from '../../../zero-client/src/client/custom.ts';\nimport type {Zero} from '../../../zero-client/src/client/zero.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {MarkIcon} from './mark-icon.tsx';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Inspector = lazy(() => import('./inspector.tsx'));\n\nexport function ZeroInspector<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>({zero}: {zero: Zero<S, MD>}): JSX.Element {\n  const [show, setShow] = useState(false);\n  return show ? (\n    <Suspense fallback={<div>Loading Inspector...</div>}>\n      <Inspector\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        zero={zero as any}\n        onClose={() => setShow(false)}\n      />\n    </Suspense>\n  ) : (\n    <button\n      onClick={() => setShow(!show)}\n      style={{\n        position: 'fixed',\n        bottom: 0,\n        right: 0,\n        zIndex: 1000,\n        padding: '5px',\n        color: 'white',\n        backgroundColor: '#333',\n        borderTopLeftRadius: '8px',\n        opacity: 0.95,\n      }}\n    >\n      <MarkIcon\n        style={{\n          width: '20px',\n          height: '20px',\n          fill: 'currentColor',\n        }}\n      />\n    </button>\n  );\n}\n","import React, {useSyncExternalStore} from 'react';\nimport {resolver} from '@rocicorp/resolver';\nimport {deepClone} from '../../shared/src/deep-clone.ts';\nimport type {Immutable} from '../../shared/src/immutable.ts';\nimport type {ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {Zero} from '../../zero-client/src/client/zero.ts';\nimport type {Schema} from '../../zero-schema/src/builder/schema-builder.ts';\nimport type {Format} from '../../zql/src/ivm/view.ts';\nimport {AbstractQuery} from '../../zql/src/query/query-impl.ts';\nimport {type HumanReadable, type Query} from '../../zql/src/query/query.ts';\nimport {DEFAULT_TTL_MS, type TTL} from '../../zql/src/query/ttl.ts';\nimport type {ResultType, TypedView} from '../../zql/src/query/typed-view.ts';\nimport {useZero} from './zero-provider.tsx';\n\nexport type QueryResultDetails = Readonly<{\n  type: ResultType;\n}>;\n\nexport type QueryResult<TReturn> = readonly [\n  HumanReadable<TReturn>,\n  QueryResultDetails,\n];\n\nexport type UseQueryOptions = {\n  enabled?: boolean | undefined;\n  /**\n   * Time to live (TTL) in seconds. Controls how long query results are cached\n   * after the query is removed. During this time, Zero continues to sync the query.\n   * Default is 'never'.\n   */\n  ttl?: TTL | undefined;\n};\n\nexport type UseSuspenseQueryOptions = UseQueryOptions & {\n  /**\n   * Whether to suspend until:\n   * - 'partial': the query has partial results (partial array or defined\n   *   value for singular results) which may be of result type 'unknown',\n   *   or the query result type is 'complete' (in which case results may be\n   *   empty).  This is useful for suspending until there are partial\n   *   optimistic local results, or the query has completed loading from the\n   *   server.\n   * - 'complete': the query result type is 'complete'.\n   *\n   * Default is 'partial'.\n   */\n  suspendUntil?: 'complete' | 'partial';\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\nconst reactUse = (React as unknown as {use?: (p: Promise<unknown>) => void})\n  .use;\nconst suspend: (p: Promise<unknown>) => void = reactUse\n  ? reactUse\n  : p => {\n      throw p;\n    };\n\nexport function useQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn,\n>(\n  query: Query<TSchema, TTable, TReturn>,\n  options?: UseQueryOptions | boolean,\n): QueryResult<TReturn> {\n  let enabled = true;\n  let ttl: TTL = DEFAULT_TTL_MS;\n  if (typeof options === 'boolean') {\n    enabled = options;\n  } else if (options) {\n    ({enabled = true, ttl = DEFAULT_TTL_MS} = options);\n  }\n\n  const view = viewStore.getView(\n    useZero(),\n    query as AbstractQuery<TSchema, TTable, TReturn>,\n    enabled,\n    ttl,\n  );\n  // https://react.dev/reference/react/useSyncExternalStore\n  return useSyncExternalStore(\n    view.subscribeReactInternals,\n    view.getSnapshot,\n    view.getSnapshot,\n  );\n}\n\nexport function useSuspenseQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn,\n>(\n  query: Query<TSchema, TTable, TReturn>,\n  options?: UseSuspenseQueryOptions | boolean,\n): QueryResult<TReturn> {\n  let enabled = true;\n  let ttl: TTL = DEFAULT_TTL_MS;\n  let suspendUntil: 'complete' | 'partial' = 'partial';\n  if (typeof options === 'boolean') {\n    enabled = options;\n  } else if (options) {\n    ({\n      enabled = true,\n      ttl = DEFAULT_TTL_MS,\n      suspendUntil = 'complete',\n    } = options);\n  }\n\n  const view = viewStore.getView(\n    useZero(),\n    query as AbstractQuery<TSchema, TTable, TReturn>,\n    enabled,\n    ttl,\n  );\n  // https://react.dev/reference/react/useSyncExternalStore\n  const snapshot = useSyncExternalStore(\n    view.subscribeReactInternals,\n    view.getSnapshot,\n    view.getSnapshot,\n  );\n\n  if (enabled) {\n    if (suspendUntil === 'complete' && !view.complete) {\n      suspend(view.waitForComplete());\n    }\n\n    if (suspendUntil === 'partial' && !view.nonEmpty) {\n      suspend(view.waitForNonEmpty());\n    }\n  }\n\n  return snapshot;\n}\n\nconst emptyArray: unknown[] = [];\nconst disabledSubscriber = () => () => {};\n\nconst resultTypeUnknown = {type: 'unknown'} as const;\nconst resultTypeComplete = {type: 'complete'} as const;\n\nconst emptySnapshotSingularUnknown = [undefined, resultTypeUnknown] as const;\nconst emptySnapshotSingularComplete = [undefined, resultTypeComplete] as const;\nconst emptySnapshotPluralUnknown = [emptyArray, resultTypeUnknown] as const;\nconst emptySnapshotPluralComplete = [emptyArray, resultTypeComplete] as const;\n\nfunction getDefaultSnapshot<TReturn>(singular: boolean): QueryResult<TReturn> {\n  return (\n    singular ? emptySnapshotSingularUnknown : emptySnapshotPluralUnknown\n  ) as QueryResult<TReturn>;\n}\n\n/**\n * Returns a new snapshot or one of the empty predefined ones. Returning the\n * predefined ones is important to prevent unnecessary re-renders in React.\n */\nfunction getSnapshot<TReturn>(\n  singular: boolean,\n  data: HumanReadable<TReturn>,\n  resultType: string,\n): QueryResult<TReturn> {\n  if (singular && data === undefined) {\n    return (resultType === 'complete'\n      ? emptySnapshotSingularComplete\n      : emptySnapshotSingularUnknown) as unknown as QueryResult<TReturn>;\n  }\n\n  if (!singular && (data as unknown[]).length === 0) {\n    return (\n      resultType === 'complete'\n        ? emptySnapshotPluralComplete\n        : emptySnapshotPluralUnknown\n    ) as QueryResult<TReturn>;\n  }\n\n  return [\n    data,\n    resultType === 'complete' ? resultTypeComplete : resultTypeUnknown,\n  ];\n}\n\ndeclare const TESTING: boolean;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ViewWrapperAny = ViewWrapper<any, any, any>;\n\nconst allViews = new WeakMap<ViewStore, Map<string, ViewWrapperAny>>();\n\nexport function getAllViewsSizeForTesting(store: ViewStore): number {\n  if (TESTING) {\n    return allViews.get(store)?.size ?? 0;\n  }\n  return 0;\n}\n\n/**\n * A global store of all active views.\n *\n * React subscribes and unsubscribes to these views\n * via `useSyncExternalStore`.\n *\n * Managing views through `useEffect` or `useLayoutEffect` causes\n * inconsistencies because effects run after render.\n *\n * For example, if useQuery used use*Effect in the component below:\n * ```ts\n * function Foo({issueID}) {\n *   const issue = useQuery(z.query.issue.where('id', issueID).one());\n *   if (issue?.id !== undefined && issue.id !== issueID) {\n *     console.log('MISMATCH!', issue.id, issueID);\n *   }\n * }\n * ```\n *\n * `MISMATCH` will be printed whenever the `issueID` prop changes.\n *\n * This is because the component will render once with\n * the old state returned from `useQuery`. Then the effect inside\n * `useQuery` will run. The component will render again with the new\n * state. This inconsistent transition can cause unexpected results.\n *\n * Emulating `useEffect` via `useState` and `if` causes resource leaks.\n * That is:\n *\n * ```ts\n * function useQuery(q) {\n *   const [oldHash, setOldHash] = useState();\n *   if (hash(q) !== oldHash) {\n *      // make new view\n *   }\n *\n *   useEffect(() => {\n *     return () => view.destroy();\n *   }, []);\n * }\n * ```\n *\n * I'm not sure why but in strict mode the cleanup function\n * fails to be called for the first instance of the view and only\n * cleans up later instances.\n *\n * Swapping `useState` to `useRef` has similar problems.\n */\nexport class ViewStore {\n  #views = new Map<string, ViewWrapperAny>();\n\n  constructor() {\n    if (TESTING) {\n      allViews.set(this, this.#views);\n    }\n  }\n\n  getView<\n    TSchema extends Schema,\n    TTable extends keyof TSchema['tables'] & string,\n    TReturn,\n  >(\n    zero: Zero<TSchema>,\n    query: Query<TSchema, TTable, TReturn>,\n    enabled: boolean,\n    ttl: TTL,\n  ): {\n    getSnapshot: () => QueryResult<TReturn>;\n    subscribeReactInternals: (internals: () => void) => () => void;\n    updateTTL: (ttl: TTL) => void;\n    waitForComplete: () => Promise<void>;\n    waitForNonEmpty: () => Promise<void>;\n    complete: boolean;\n    nonEmpty: boolean;\n  } {\n    const {format} = query;\n    if (!enabled) {\n      return {\n        getSnapshot: () => getDefaultSnapshot(format.singular),\n        subscribeReactInternals: disabledSubscriber,\n        updateTTL: () => {},\n        waitForComplete: () => Promise.resolve(),\n        waitForNonEmpty: () => Promise.resolve(),\n        complete: false,\n        nonEmpty: false,\n      };\n    }\n\n    const hash = query.hash() + zero.clientID;\n    let existing = this.#views.get(hash);\n    if (!existing) {\n      existing = new ViewWrapper(\n        zero,\n        query,\n        format,\n        ttl,\n        view => {\n          const lastView = this.#views.get(hash);\n          // I don't think this can happen\n          // but lets guard against it so we don't\n          // leak resources.\n          if (lastView && lastView !== view) {\n            throw new Error('View already exists');\n          }\n          this.#views.set(hash, view);\n        },\n        () => {\n          this.#views.delete(hash);\n        },\n      );\n      this.#views.set(hash, existing);\n    } else {\n      existing.updateTTL(ttl);\n    }\n    return existing as ViewWrapper<TSchema, TTable, TReturn>;\n  }\n}\n\nconst viewStore = new ViewStore();\n\n/**\n * This wraps and ref counts a view.\n *\n * The only signal we have from React as to whether or not it is\n * done with a view is when it calls `unsubscribe`.\n *\n * In non-strict-mode we can clean up the view as soon\n * as the listener count goes to 0.\n *\n * In strict-mode, the listener count will go to 0 then a\n * new listener for the same view is immediately added back.\n *\n * This is why the `onMaterialized` and `onDematerialized` callbacks exist --\n * they allow a view which React is still referencing to be added\n * back into the store when React re-subscribes to it.\n *\n * This wrapper also exists to deal with the various\n * `useSyncExternalStore` caveats that cause excessive\n * re-renders and materializations.\n *\n * See: https://react.dev/reference/react/useSyncExternalStore#caveats\n * Especially:\n * 1. The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.\n * 2. If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component.\n */\nclass ViewWrapper<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn,\n> {\n  #zero: Zero<TSchema>;\n  #view: TypedView<HumanReadable<TReturn>> | undefined;\n  readonly #onDematerialized;\n  readonly #onMaterialized;\n  readonly #query: Query<TSchema, TTable, TReturn>;\n  readonly #format: Format;\n  #snapshot: QueryResult<TReturn>;\n  #reactInternals: Set<() => void>;\n  #ttl: TTL;\n  #complete = false;\n  #completeResolver = resolver<void>();\n  #nonEmpty = false;\n  #nonEmptyResolver = resolver<void>();\n\n  constructor(\n    zero: Zero<TSchema>,\n    query: Query<TSchema, TTable, TReturn>,\n    format: Format,\n    ttl: TTL,\n    onMaterialized: (view: ViewWrapper<TSchema, TTable, TReturn>) => void,\n    onDematerialized: () => void,\n  ) {\n    this.#zero = zero;\n    this.#query = query;\n    this.#format = format;\n    this.#ttl = ttl;\n    this.#onMaterialized = onMaterialized;\n    this.#onDematerialized = onDematerialized;\n    this.#snapshot = getDefaultSnapshot(format.singular);\n    this.#reactInternals = new Set();\n    this.#materializeIfNeeded();\n  }\n\n  #onData = (\n    snap: Immutable<HumanReadable<TReturn>>,\n    resultType: ResultType,\n  ) => {\n    const data =\n      snap === undefined\n        ? snap\n        : (deepClone(snap as ReadonlyJSONValue) as HumanReadable<TReturn>);\n    this.#snapshot = getSnapshot(this.#format.singular, data, resultType);\n    if (resultType === 'complete') {\n      this.#complete = true;\n      this.#completeResolver.resolve();\n      this.#nonEmpty = true;\n      this.#nonEmptyResolver.resolve();\n    }\n\n    if (\n      this.#format.singular\n        ? this.#snapshot[0] !== undefined\n        : (this.#snapshot[0] as unknown[]).length !== 0\n    ) {\n      this.#nonEmpty = true;\n      this.#nonEmptyResolver.resolve();\n    }\n\n    for (const internals of this.#reactInternals) {\n      internals();\n    }\n  };\n\n  #materializeIfNeeded = () => {\n    if (this.#view) {\n      return;\n    }\n\n    this.#view = this.#zero.materialize(this.#query, {ttl: this.#ttl});\n    this.#view.addListener(this.#onData);\n\n    this.#onMaterialized(this);\n  };\n\n  getSnapshot = () => this.#snapshot;\n\n  subscribeReactInternals = (internals: () => void): (() => void) => {\n    this.#reactInternals.add(internals);\n    this.#materializeIfNeeded();\n    return () => {\n      this.#reactInternals.delete(internals);\n\n      // only schedule a cleanup task if we have no listeners left\n      if (this.#reactInternals.size === 0) {\n        setTimeout(() => {\n          // Someone re-registered a listener on this view before the timeout elapsed.\n          // This happens often in strict-mode which forces a component\n          // to mount, unmount, remount.\n          if (this.#reactInternals.size > 0) {\n            return;\n          }\n          // We already destroyed the view\n          if (this.#view === undefined) {\n            return;\n          }\n          this.#view.destroy();\n          this.#view = undefined;\n          this.#complete = false;\n          this.#completeResolver = resolver();\n          this.#nonEmpty = false;\n          this.#nonEmptyResolver = resolver();\n          this.#onDematerialized();\n        }, 10);\n      }\n    };\n  };\n\n  updateTTL(ttl: TTL): void {\n    this.#ttl = ttl;\n    this.#view?.updateTTL(ttl);\n  }\n\n  get complete() {\n    return this.#complete;\n  }\n\n  waitForComplete(): Promise<void> {\n    return this.#completeResolver.promise;\n  }\n\n  get nonEmpty() {\n    return this.#nonEmpty;\n  }\n\n  waitForNonEmpty(): Promise<void> {\n    return this.#nonEmptyResolver.promise;\n  }\n}\n","import {hasOwn} from './has-own.ts';\nimport type {JSONValue, ReadonlyJSONValue} from './json.ts';\n\nexport function deepClone(value: ReadonlyJSONValue): JSONValue {\n  const seen: Array<ReadonlyJSONValue> = [];\n  return internalDeepClone(value, seen);\n}\n\nexport function internalDeepClone(\n  value: ReadonlyJSONValue,\n  seen: Array<ReadonlyJSONValue>,\n): JSONValue {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n    case 'undefined':\n      return value;\n    case 'object': {\n      if (value === null) {\n        return null;\n      }\n      if (seen.includes(value)) {\n        throw new Error('Cyclic object');\n      }\n      seen.push(value);\n      if (Array.isArray(value)) {\n        const rv = value.map(v => internalDeepClone(v, seen));\n        seen.pop();\n        return rv;\n      }\n\n      const obj: JSONValue = {};\n\n      for (const k in value) {\n        if (hasOwn(value, k)) {\n          const v = (value as Record<string, ReadonlyJSONValue>)[k];\n          if (v !== undefined) {\n            obj[k] = internalDeepClone(v, seen);\n          }\n        }\n      }\n      seen.pop();\n      return obj;\n    }\n\n    default:\n      throw new Error(`Invalid type: ${typeof value}`);\n  }\n}\n","import {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  type ReactNode,\n} from 'react';\nimport {Zero} from '../../zero-client/src/client/zero.ts';\nimport type {Schema} from '../../zero-schema/src/builder/schema-builder.ts';\nimport type {CustomMutatorDefs} from '../../zero-client/src/client/custom.ts';\nimport type {ZeroOptions} from '../../zero-client/src/client/options.ts';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst ZeroContext = createContext<unknown | undefined>(undefined);\n\nexport function useZero<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>(): Zero<S, MD> {\n  const zero = useContext(ZeroContext);\n  if (zero === undefined) {\n    throw new Error('useZero must be used within a ZeroProvider');\n  }\n  return zero as Zero<S, MD>;\n}\n\nexport function createUseZero<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>() {\n  return () => useZero<S, MD>();\n}\n\nexport type ZeroProviderProps<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> = (ZeroOptions<S, MD> | {zero: Zero<S, MD>}) & {\n  init?: (zero: Zero<S, MD>) => void;\n  children: ReactNode;\n};\n\nexport function ZeroProvider<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>({children, init, ...props}: ZeroProviderProps<S, MD>) {\n  const [zero, setZero] = useState<Zero<S, MD> | undefined>(\n    'zero' in props ? props.zero : undefined,\n  );\n\n  // If Zero is not passed in, we construct it, but only client-side.\n  // Zero doesn't really work SSR today so this is usually the right thing.\n  // When we support Zero SSR this will either become a breaking change or\n  // more likely server support will be opt-in with a new prop on this\n  // component.\n  useEffect(() => {\n    if ('zero' in props) {\n      setZero(props.zero);\n      return;\n    }\n\n    const z = new Zero(props);\n    init?.(z);\n    setZero(z);\n\n    return () => {\n      void z.close();\n      setZero(undefined);\n    };\n  }, [init, ...Object.values(props)]);\n\n  return (\n    zero && <ZeroContext.Provider value={zero}>{children}</ZeroContext.Provider>\n  );\n}\n","import {useSyncExternalStore} from 'react';\nimport {useZero} from './zero-provider.tsx';\n\n/**\n * Hook to subscribe to the online status of the Zero instance.\n *\n * This is useful when you want to update state based on the online status.\n *\n * @returns The online status of the Zero instance.\n */\nexport function useZeroOnline(): boolean {\n  const zero = useZero();\n  return useSyncExternalStore(\n    zero.onOnline,\n    () => zero.online,\n    () => zero.online,\n  );\n}\n"],"names":["useState","jsx","useState","useSyncExternalStore","useSyncExternalStore"],"mappings":"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","debugId":null}},
    {"offset": {"line": 733, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/builder/relationship-builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/static-query.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/permissions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/escape-like.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/named.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {Relationship, TableSchema} from '../table-schema.ts';\nimport type {TableBuilderWithColumns} from './table-builder.ts';\n\ntype ConnectArg<TSourceField, TDestField, TDest extends TableSchema> = {\n  readonly sourceField: TSourceField;\n  readonly destField: TDestField;\n  readonly destSchema: TableBuilderWithColumns<TDest>;\n};\n\ntype ManyConnection<TSourceField, TDestField, TDest extends TableSchema> = {\n  readonly sourceField: TSourceField;\n  readonly destField: TDestField;\n  readonly destSchema: TDest['name'];\n  readonly cardinality: 'many';\n};\n\ntype OneConnection<TSourceField, TDestField, TDest extends TableSchema> = {\n  readonly sourceField: TSourceField;\n  readonly destField: TDestField;\n  readonly destSchema: TDest['name'];\n  readonly cardinality: 'one';\n};\n\ntype Prev = [-1, 0, 1, 2, 3, 4, 5, 6];\n\nexport type PreviousSchema<\n  TSource extends TableSchema,\n  K extends number,\n  TDests extends TableSchema[],\n> = K extends 0 ? TSource : TDests[Prev[K]];\n\nexport type Relationships = {\n  name: string; // table name\n  relationships: Record<string, Relationship>; // relationships for that table\n};\n\nexport function relationships<\n  TSource extends TableSchema,\n  TRelationships extends Record<string, Relationship>,\n>(\n  table: TableBuilderWithColumns<TSource>,\n  cb: (connects: {\n    many: <\n      TDests extends TableSchema[],\n      TSourceFields extends {\n        [K in keyof TDests]: (keyof PreviousSchema<\n          TSource,\n          K & number,\n          TDests\n        >['columns'] &\n          string)[];\n      },\n      TDestFields extends {\n        [K in keyof TDests]: (keyof TDests[K]['columns'] & string)[];\n      },\n    >(\n      ...args: {\n        [K in keyof TDests]: ConnectArg<\n          TSourceFields[K],\n          TDestFields[K],\n          TDests[K]\n        >;\n      }\n    ) => {\n      [K in keyof TDests]: ManyConnection<\n        TSourceFields[K],\n        TDestFields[K],\n        TDests[K]\n      >;\n    };\n    one: <\n      TDests extends TableSchema[],\n      TSourceFields extends {\n        [K in keyof TDests]: (keyof PreviousSchema<\n          TSource,\n          K & number,\n          TDests\n        >['columns'] &\n          string)[];\n      },\n      TDestFields extends {\n        [K in keyof TDests]: (keyof TDests[K]['columns'] & string)[];\n      },\n    >(\n      ...args: {\n        [K in keyof TDests]: ConnectArg<\n          TSourceFields[K],\n          TDestFields[K],\n          TDests[K]\n        >;\n      }\n    ) => {\n      [K in keyof TDests]: OneConnection<\n        TSourceFields[K],\n        TDestFields[K],\n        TDests[K]\n      >;\n    };\n  }) => TRelationships,\n): {name: TSource['name']; relationships: TRelationships} {\n  const relationships = cb({many, one} as any);\n\n  return {\n    name: table.schema.name,\n    relationships,\n  };\n}\n\nfunction many(\n  ...args: readonly ConnectArg<any, any, TableSchema>[]\n): ManyConnection<any, any, any>[] {\n  return args.map(arg => ({\n    sourceField: arg.sourceField,\n    destField: arg.destField,\n    destSchema: arg.destSchema.schema.name,\n    cardinality: 'many',\n  }));\n}\n\nfunction one(\n  ...args: readonly ConnectArg<any, any, TableSchema>[]\n): OneConnection<any, any, any>[] {\n  return args.map(arg => ({\n    sourceField: arg.sourceField,\n    destField: arg.destField,\n    destSchema: arg.destSchema.schema.name,\n    cardinality: 'one',\n  }));\n}\n","import type {AST, System} from '../../../zero-protocol/src/ast.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {Format} from '../ivm/view.ts';\nimport {ExpressionBuilder} from './expression.ts';\nimport type {CustomQueryID} from './named.ts';\nimport type {QueryDelegate} from './query-delegate.ts';\nimport {AbstractQuery, defaultFormat, newQuerySymbol} from './query-impl.ts';\nimport type {HumanReadable, PullRow, Query} from './query.ts';\nimport type {TypedView} from './typed-view.ts';\n\nexport function staticQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(schema: TSchema, tableName: TTable): Query<TSchema, TTable> {\n  return new StaticQuery<TSchema, TTable>(\n    schema,\n    tableName,\n    {table: tableName},\n    defaultFormat,\n  );\n}\n\n/**\n * A query that cannot be run.\n * Only serves to generate ASTs.\n */\nexport class StaticQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn = PullRow<TTable, TSchema>,\n> extends AbstractQuery<TSchema, TTable, TReturn> {\n  constructor(\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST,\n    format: Format,\n    system: System = 'permissions',\n    customQueryID?: CustomQueryID | undefined,\n    currentJunction?: string | undefined,\n  ) {\n    super(\n      undefined,\n      schema,\n      tableName,\n      ast,\n      format,\n      system,\n      customQueryID,\n      currentJunction,\n    );\n  }\n\n  expressionBuilder() {\n    return new ExpressionBuilder(this._exists);\n  }\n\n  protected [newQuerySymbol]<\n    TSchema extends Schema,\n    TTable extends keyof TSchema['tables'] & string,\n    TReturn,\n  >(\n    _delegate: QueryDelegate | undefined,\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST,\n    format: Format,\n    customQueryID: CustomQueryID | undefined,\n    currentJunction: string | undefined,\n  ): StaticQuery<TSchema, TTable, TReturn> {\n    return new StaticQuery(\n      schema,\n      tableName,\n      ast,\n      format,\n      'permissions',\n      customQueryID,\n      currentJunction,\n    );\n  }\n\n  get ast() {\n    return this._completeAst();\n  }\n\n  materialize(): TypedView<HumanReadable<TReturn>> {\n    throw new Error('StaticQuery cannot be materialized');\n  }\n\n  run(): Promise<HumanReadable<TReturn>> {\n    return Promise.reject(new Error('StaticQuery cannot be run'));\n  }\n\n  preload(): {\n    cleanup: () => void;\n    complete: Promise<void>;\n  } {\n    throw new Error('StaticQuery cannot be preloaded');\n  }\n}\n","import {assert} from '../../shared/src/asserts.ts';\nimport {\n  mapCondition,\n  toStaticParam,\n  type Condition,\n  type Parameter,\n} from '../../zero-protocol/src/ast.ts';\nimport type {ExpressionBuilder} from '../../zql/src/query/expression.ts';\nimport {defaultFormat, staticParam} from '../../zql/src/query/query-impl.ts';\nimport type {Query} from '../../zql/src/query/query.ts';\nimport {StaticQuery} from '../../zql/src/query/static-query.ts';\nimport type {Schema} from './builder/schema-builder.ts';\nimport type {\n  AssetPermissions as CompiledAssetPermissions,\n  PermissionsConfig as CompiledPermissionsConfig,\n} from './compiled-permissions.ts';\nimport {clientToServer, NameMapper} from './name-mapper.ts';\n\nexport const ANYONE_CAN = [\n  (_: unknown, eb: ExpressionBuilder<Schema, never>) => eb.and(),\n];\n\n/**\n * @deprecated Use {@link ANYONE_CAN} instead.\n */\nexport const ANYONE_CAN_DO_ANYTHING = {\n  row: {\n    select: ANYONE_CAN,\n    insert: ANYONE_CAN,\n    update: {\n      preMutation: ANYONE_CAN,\n      postMutation: ANYONE_CAN,\n    },\n    delete: ANYONE_CAN,\n  },\n};\n\nexport const NOBODY_CAN = [];\n\nexport type Anchor = 'authData' | 'preMutationRow';\n\nexport type Queries<TSchema extends Schema> = {\n  [K in keyof TSchema['tables']]: Query<Schema, K & string>;\n};\n\nexport type PermissionRule<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n> = (\n  authData: TAuthDataShape,\n  eb: ExpressionBuilder<TSchema, TTable>,\n) => Condition;\n\nexport type AssetPermissions<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n> = {\n  // Why an array of rules?: https://github.com/rocicorp/mono/pull/3184/files#r1869680716\n  select?: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined;\n  /**\n   * @deprecated Use Mutators instead.\n   * @see {@link https://zero.rocicorp.dev/docs/writing-data}\n   */\n  insert?: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined;\n  /**\n   * @deprecated Use Mutators instead.\n   * @see {@link https://zero.rocicorp.dev/docs/writing-data}\n   */\n  update?:\n    | {\n        preMutation?: PermissionRule<TAuthDataShape, TSchema, TTable>[];\n        postMutation?: PermissionRule<TAuthDataShape, TSchema, TTable>[];\n      }\n    | undefined;\n  /**\n   * @deprecated Use Mutators instead.\n   * @see {@link https://zero.rocicorp.dev/docs/writing-data}\n   */\n  delete?: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined;\n};\n\nexport type PermissionsConfig<TAuthDataShape, TSchema extends Schema> = {\n  [K in keyof TSchema['tables']]?: {\n    row?: AssetPermissions<TAuthDataShape, TSchema, K & string> | undefined;\n    cell?:\n      | {\n          [C in keyof TSchema['tables'][K]['columns']]?: Omit<\n            AssetPermissions<TAuthDataShape, TSchema, K & string>,\n            'cell'\n          >;\n        }\n      | undefined;\n  };\n};\n\nexport async function definePermissions<TAuthDataShape, TSchema extends Schema>(\n  schema: TSchema,\n  definer: () =>\n    | Promise<PermissionsConfig<TAuthDataShape, TSchema>>\n    | PermissionsConfig<TAuthDataShape, TSchema>,\n): Promise<CompiledPermissionsConfig | undefined> {\n  const expressionBuilders = {} as Record<\n    string,\n    ExpressionBuilder<Schema, string>\n  >;\n  for (const name of Object.keys(schema.tables)) {\n    expressionBuilders[name] = new StaticQuery(\n      schema,\n      name,\n      {table: name},\n      defaultFormat,\n    ).expressionBuilder();\n  }\n\n  const config = await definer();\n  return compilePermissions(schema, config, expressionBuilders);\n}\n\nfunction compilePermissions<TAuthDataShape, TSchema extends Schema>(\n  schema: TSchema,\n  authz: PermissionsConfig<TAuthDataShape, TSchema> | undefined,\n  expressionBuilders: Record<string, ExpressionBuilder<Schema, string>>,\n): CompiledPermissionsConfig | undefined {\n  if (!authz) {\n    return undefined;\n  }\n  const nameMapper = clientToServer(schema.tables);\n  const ret: CompiledPermissionsConfig = {tables: {}};\n  for (const [tableName, tableConfig] of Object.entries(authz)) {\n    const serverName = schema.tables[tableName].serverName ?? tableName;\n    ret.tables[serverName] = {\n      row: compileRowConfig(\n        nameMapper,\n        tableName,\n        tableConfig.row,\n        expressionBuilders[tableName],\n      ),\n      cell: compileCellConfig(\n        nameMapper,\n        tableName,\n        tableConfig.cell,\n        expressionBuilders[tableName],\n      ),\n    };\n  }\n\n  return ret;\n}\n\nfunction compileRowConfig<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  clientToServer: NameMapper,\n  tableName: TTable,\n  rowRules: AssetPermissions<TAuthDataShape, TSchema, TTable> | undefined,\n  expressionBuilder: ExpressionBuilder<TSchema, TTable>,\n): CompiledAssetPermissions | undefined {\n  if (!rowRules) {\n    return undefined;\n  }\n  return {\n    select: compileRules(\n      clientToServer,\n      tableName,\n      rowRules.select,\n      expressionBuilder,\n    ),\n    insert: compileRules(\n      clientToServer,\n      tableName,\n      rowRules.insert,\n      expressionBuilder,\n    ),\n    update: {\n      preMutation: compileRules(\n        clientToServer,\n        tableName,\n        rowRules.update?.preMutation,\n        expressionBuilder,\n      ),\n      postMutation: compileRules(\n        clientToServer,\n        tableName,\n        rowRules.update?.postMutation,\n        expressionBuilder,\n      ),\n    },\n    delete: compileRules(\n      clientToServer,\n      tableName,\n      rowRules.delete,\n      expressionBuilder,\n    ),\n  };\n}\n\n/**\n * What is this \"allow\" and why are permissions policies an array of rules?\n *\n * Please read: https://github.com/rocicorp/mono/pull/3184/files#r1869680716\n */\nfunction compileRules<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  clientToServer: NameMapper,\n  tableName: TTable,\n  rules: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined,\n  expressionBuilder: ExpressionBuilder<TSchema, TTable>,\n): ['allow', Condition][] | undefined {\n  if (!rules) {\n    return undefined;\n  }\n\n  return rules.map(rule => {\n    const cond = rule(authDataRef as TAuthDataShape, expressionBuilder);\n    return ['allow', mapCondition(cond, tableName, clientToServer)] as const;\n  });\n}\n\nfunction compileCellConfig<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  clientToServer: NameMapper,\n  tableName: TTable,\n  cellRules:\n    | Record<string, AssetPermissions<TAuthDataShape, TSchema, TTable>>\n    | undefined,\n  expressionBuilder: ExpressionBuilder<TSchema, TTable>,\n): Record<string, CompiledAssetPermissions> | undefined {\n  if (!cellRules) {\n    return undefined;\n  }\n  const ret: Record<string, CompiledAssetPermissions> = {};\n  for (const [columnName, rules] of Object.entries(cellRules)) {\n    ret[columnName] = {\n      select: compileRules(\n        clientToServer,\n        tableName,\n        rules.select,\n        expressionBuilder,\n      ),\n      insert: compileRules(\n        clientToServer,\n        tableName,\n        rules.insert,\n        expressionBuilder,\n      ),\n      update: {\n        preMutation: compileRules(\n          clientToServer,\n          tableName,\n          rules.update?.preMutation,\n          expressionBuilder,\n        ),\n        postMutation: compileRules(\n          clientToServer,\n          tableName,\n          rules.update?.postMutation,\n          expressionBuilder,\n        ),\n      },\n      delete: compileRules(\n        clientToServer,\n        tableName,\n        rules.delete,\n        expressionBuilder,\n      ),\n    };\n  }\n  return ret;\n}\n\nclass CallTracker {\n  readonly #anchor: Anchor;\n  readonly #path: string[];\n  constructor(anchor: Anchor, path: string[]) {\n    this.#anchor = anchor;\n    this.#path = path;\n  }\n\n  get(target: {[toStaticParam]: () => Parameter}, prop: string | symbol) {\n    if (prop === toStaticParam) {\n      return target[toStaticParam];\n    }\n    assert(typeof prop === 'string');\n    const path = [...this.#path, prop];\n    return new Proxy(\n      {\n        [toStaticParam]: () => staticParam(this.#anchor, path),\n      },\n      new CallTracker(this.#anchor, path),\n    );\n  }\n}\n\nfunction baseTracker(anchor: Anchor) {\n  return new Proxy(\n    {\n      [toStaticParam]: () => {\n        throw new Error('no JWT field specified');\n      },\n    },\n    new CallTracker(anchor, []),\n  );\n}\n\nexport const authDataRef = baseTracker('authData');\nexport const preMutationRowRef = baseTracker('preMutationRow');\n","export function escapeLike(val: string) {\n  return val.replace(/[%_]/g, '\\\\$&');\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {SchemaQuery} from '../mutate/custom.ts';\nimport {newQuery} from './query-impl.ts';\nimport type {Query} from './query.ts';\n\nexport type QueryFn<\n  TContext,\n  TTakesContext extends boolean,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n> = TTakesContext extends false\n  ? {(...args: TArg): TReturnQuery}\n  : {(context: TContext, ...args: TArg): TReturnQuery};\n\nexport type SyncedQuery<\n  TName extends string,\n  TContext,\n  TTakesContext extends boolean,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n> = QueryFn<TContext, TTakesContext, TArg, TReturnQuery> & {\n  queryName: TName;\n  parse: ParseFn<TArg> | undefined;\n  takesContext: TTakesContext;\n};\n\nfunction normalizeParser<T extends ReadonlyJSONValue[]>(\n  parser: ParseFn<T> | HasParseFn<T> | undefined,\n): ParseFn<T> | undefined {\n  if (parser) {\n    if ('parse' in parser) {\n      return parser.parse.bind(parser);\n    }\n    return parser;\n  }\n  return undefined;\n}\n\nexport function syncedQuery<\n  TName extends string,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n>(\n  name: TName,\n  parser: ParseFn<TArg> | HasParseFn<TArg> | undefined,\n  fn: QueryFn<unknown, false, TArg, TReturnQuery>,\n): SyncedQuery<TName, unknown, false, TArg, TReturnQuery> {\n  const impl = syncedQueryImpl(name, fn, false);\n  const ret: any = (...args: TArg) => impl(undefined, args);\n  ret.queryName = name;\n  ret.parse = normalizeParser(parser);\n  ret.takesContext = false;\n  return ret;\n}\n\nexport function syncedQueryWithContext<\n  TName extends string,\n  TContext,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n>(\n  name: TName,\n  parser: ParseFn<TArg> | HasParseFn<TArg> | undefined,\n  fn: QueryFn<TContext, true, TArg, TReturnQuery>,\n): SyncedQuery<TName, TContext, true, TArg, TReturnQuery> {\n  const impl = syncedQueryImpl(name, fn, true);\n  const ret: any = (context: TContext, ...args: TArg) => impl(context, args);\n  ret.queryName = name;\n  ret.parse = normalizeParser(parser);\n  ret.takesContext = true;\n  return ret;\n}\n\nfunction syncedQueryImpl<\n  TName extends string,\n  TContext,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n>(name: TName, fn: any, takesContext: boolean) {\n  return (context: TContext, args: TArg) => {\n    const q = takesContext ? fn(context, ...args) : fn(...args);\n    return q.nameAndArgs(name, args) as TReturnQuery;\n  };\n}\n\nexport function withValidation<T extends SyncedQuery<any, any, any, any, any>>(\n  fn: T,\n): T extends SyncedQuery<infer N, infer C, any, any, infer R>\n  ? SyncedQuery<N, C, true, ReadonlyJSONValue[], R>\n  : never {\n  if (!fn.parse) {\n    throw new Error('ret does not have a parse function defined');\n  }\n  const ret: any = (context: unknown, ...args: unknown[]) => {\n    const f = fn as any;\n    const parsed = f.parse(args);\n    return f.takesContext ? f(context, ...parsed) : f(...parsed);\n  };\n  ret.queryName = fn.queryName;\n  ret.parse = fn.parse;\n  ret.takesContext = true;\n\n  return ret;\n}\n\nexport type ParseFn<T extends ReadonlyJSONValue[]> = (args: unknown[]) => T;\n\nexport type HasParseFn<T extends ReadonlyJSONValue[]> = {\n  parse: ParseFn<T>;\n};\n\nexport type Parser<T extends ReadonlyJSONValue[]> = ParseFn<T> | HasParseFn<T>;\n\nexport type CustomQueryID = {\n  name: string;\n  args: ReadonlyArray<ReadonlyJSONValue>;\n};\n\n/**\n * Returns a set of query builders for the given schema.\n */\nexport function createBuilder<S extends Schema>(s: S): SchemaQuery<S> {\n  return makeQueryBuilders(s) as SchemaQuery<S>;\n}\n\n/**\n * This produces the query builders for a given schema.\n * For use in Zero on the server to process custom queries.\n */\nfunction makeQueryBuilders<S extends Schema>(schema: S): SchemaQuery<S> {\n  return new Proxy(\n    {},\n    {\n      get: (\n        target: Record<\n          string,\n          Omit<Query<S, string, any>, 'materialize' | 'preload'>\n        >,\n        prop: string,\n      ) => {\n        if (prop in target) {\n          return target[prop];\n        }\n\n        if (!(prop in schema.tables)) {\n          throw new Error(`Table ${prop} does not exist in schema`);\n        }\n\n        const q = newQuery(undefined, schema, prop);\n        target[prop] = q;\n        return q;\n      },\n    },\n  ) as SchemaQuery<S>;\n}\n"],"names":["table","relationships","clientToServer"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}}]
}