{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/ast-to-zql/src/ast-to-zql.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/inspector/inspector.ts"],"sourcesContent":["import {unreachable} from '../../shared/src/asserts.ts';\nimport {must} from '../../shared/src/must.ts';\nimport type {\n  AST,\n  Condition,\n  Conjunction,\n  CorrelatedSubquery,\n  CorrelatedSubqueryCondition,\n  Disjunction,\n  LiteralReference,\n  Ordering,\n  Parameter,\n  SimpleCondition,\n  ValuePosition,\n} from '../../zero-protocol/src/ast.ts';\nimport {SUBQ_PREFIX} from '../../zql/src/query/query-impl.ts';\n\n/**\n * Converts an AST to the equivalent query builder code.\n * This is useful for debugging and understanding queries.\n *\n * @example\n * ```\n * const ast = query.issue.where('id', '=', 123)[astSymbol];\n * console.log(astToZQL(ast)); // outputs: .where('id', '=', 123)\n * ```\n */\nexport function astToZQL(ast: AST): string {\n  let code = '';\n\n  // Handle where conditions\n  if (ast.where) {\n    code += transformCondition(ast.where, '.where', new Set());\n  }\n\n  // Handle related subqueries\n  if (ast.related && ast.related.length > 0) {\n    for (const related of ast.related) {\n      if (related.hidden) {\n        const nestedRelated = related.subquery.related?.[0];\n        if (nestedRelated) {\n          code += transformRelated(nestedRelated);\n        }\n      } else {\n        code += transformRelated(related);\n      }\n    }\n  }\n\n  // Handle orderBy\n  if (ast.orderBy && ast.orderBy.length > 0) {\n    code += transformOrder(ast.orderBy);\n  }\n\n  // Handle limit\n  if (ast.limit !== undefined) {\n    code += `.limit(${ast.limit})`;\n  }\n\n  // Handle start\n  if (ast.start) {\n    const {row, exclusive} = ast.start;\n    code += `.start(${JSON.stringify(row)}${\n      exclusive ? '' : ', { inclusive: true }'\n    })`;\n  }\n\n  return code;\n}\n\ntype Args = Set<string>;\n\ntype Prefix = '.where' | 'cmp';\n\nfunction transformCondition(\n  condition: Condition,\n  prefix: Prefix,\n  args: Args,\n): string {\n  switch (condition.type) {\n    case 'simple':\n      return transformSimpleCondition(condition, prefix);\n    case 'and':\n    case 'or':\n      return transformLogicalCondition(condition, prefix, args);\n    case 'correlatedSubquery':\n      return transformExistsCondition(condition, prefix, args);\n    default:\n      unreachable(condition);\n  }\n}\n\nfunction transformSimpleCondition(\n  condition: SimpleCondition,\n  prefix: Prefix,\n): string {\n  const {left, op, right} = condition;\n\n  const leftCode = transformValuePosition(left);\n  const rightCode = transformValuePosition(right);\n\n  // Handle the shorthand form for equals\n  if (op === '=') {\n    return `${prefix}(${leftCode}, ${rightCode})`;\n  }\n\n  return `${prefix}(${leftCode}, '${op}', ${rightCode})`;\n}\n\nfunction transformLogicalCondition(\n  condition: Conjunction | Disjunction,\n  prefix: Prefix,\n  args: Args,\n): string {\n  const {type, conditions} = condition;\n\n  // For single condition, no need for logical operator\n  if (conditions.length === 1) {\n    return transformCondition(conditions[0], prefix, args);\n  }\n\n  // Generate multiple where calls for top-level AND conditions\n  if (type === 'and') {\n    const parts = conditions.map(c => transformCondition(c, prefix, args));\n    // Simply concatenate the where conditions\n    if (prefix === '.where') {\n      return parts.join('');\n    }\n    args.add('and');\n    return 'and(' + parts.join(', ') + ')';\n  }\n\n  args = new Set<string>();\n\n  // Handle nested conditions with a callback for OR conditions and nested ANDs/ORs\n  const conditionsCode = conditions\n    .map(c => transformCondition(c, 'cmp', args))\n    .join(', ');\n\n  args.add('cmp');\n  args.add(type);\n  const argsCode = [...args].sort().join(', ');\n\n  return `.where(({${argsCode}}) => ${type}(${conditionsCode}))`;\n}\n\nfunction transformExistsCondition(\n  condition: CorrelatedSubqueryCondition,\n  prefix: '.where' | 'cmp',\n  args: Set<string>,\n): string {\n  const {related, op} = condition;\n  const relationship = extractRelationshipName(related);\n\n  const nextSubquery = getNextExistsSubquery(related);\n\n  // Check if subquery has additional properties\n  const hasSubQueryProps =\n    nextSubquery.where ||\n    (nextSubquery.related && nextSubquery.related.length > 0) ||\n    nextSubquery.orderBy ||\n    nextSubquery.limit;\n\n  if (op === 'EXISTS') {\n    if (!hasSubQueryProps) {\n      if (prefix === '.where') {\n        return `.whereExists('${relationship}')`;\n      }\n      args.add('exists');\n      return `exists('${relationship}')`;\n    }\n\n    if (prefix === '.where') {\n      return `.whereExists('${relationship}', q => q${astToZQL(nextSubquery)})`;\n    }\n    prefix satisfies 'cmp';\n    args.add('exists');\n    return `exists('${relationship}', q => q${astToZQL(nextSubquery)})`;\n  }\n\n  op satisfies 'NOT EXISTS';\n\n  if (hasSubQueryProps) {\n    if (prefix === '.where') {\n      return `.where(({exists, not}) => not(exists('${relationship}', q => q${astToZQL(\n        nextSubquery,\n      )})))`;\n    }\n    prefix satisfies 'cmp';\n    args.add('not');\n    args.add('exists');\n    return `not(exists('${relationship}', q => q${astToZQL(nextSubquery)}))`;\n  }\n\n  if (prefix === '.where') {\n    return `.where(({exists, not}) => not(exists('${relationship}')))`;\n  }\n  args.add('not');\n  args.add('exists');\n\n  return `not(exists('${relationship}')))`;\n}\n\n// If the `exists` is applied against a junction edge, both hops will have the same alias and both hops will be exists conditions.\nfunction getNextExistsSubquery(related: CorrelatedSubquery): AST {\n  if (\n    related.subquery.where?.type === 'correlatedSubquery' &&\n    related.subquery.where.related.subquery.alias?.includes(\n      SUBQ_PREFIX + 'zhidden_',\n    )\n  ) {\n    return getNextExistsSubquery(related.subquery.where.related);\n  }\n\n  return related.subquery;\n}\n\nfunction extractRelationshipName(related: CorrelatedSubquery): string {\n  const alias = must(related.subquery.alias);\n  return alias.startsWith(SUBQ_PREFIX)\n    ? alias.substring(SUBQ_PREFIX.length)\n    : alias;\n}\n\nfunction transformRelated(related: CorrelatedSubquery): string {\n  const {alias} = related.subquery;\n  if (!alias) return '';\n\n  const relationship = alias;\n  let code = `.related('${relationship}'`;\n\n  // If the subquery has additional filters or configurations\n  if (\n    related.subquery.where ||\n    (related.subquery.related && related.subquery.related.length > 0) ||\n    related.subquery.orderBy ||\n    related.subquery.limit\n  ) {\n    code += ', q => q' + astToZQL(related.subquery);\n  }\n\n  code += ')';\n  return code;\n}\n\nfunction transformOrder(orderBy: Ordering): string {\n  let code = '';\n  for (const [field, direction] of orderBy) {\n    code += `.orderBy('${field}', '${direction}')`;\n  }\n  return code;\n}\n\nfunction transformValuePosition(value: ValuePosition): string {\n  switch (value.type) {\n    case 'literal':\n      return transformLiteral(value);\n    case 'column':\n      return `'${value.name}'`;\n    case 'static':\n      return transformParameter(value);\n    default:\n      unreachable(value);\n  }\n}\n\nfunction transformLiteral(literal: LiteralReference): string {\n  if (literal.value === null) {\n    return 'null';\n  }\n  if (Array.isArray(literal.value)) {\n    return JSON.stringify(literal.value);\n  }\n  if (typeof literal.value === 'string') {\n    return `'${literal.value.replace(/'/g, \"\\\\'\")}'`;\n  }\n  return String(literal.value);\n}\n\nfunction transformParameter(param: Parameter): string {\n  const fieldStr = Array.isArray(param.field)\n    ? `[${param.field.map(f => `'${f}'`).join(', ')}]`\n    : `'${param.field}'`;\n\n  return `authParam(${fieldStr})`;\n}\n","import {astToZQL} from '../../../../ast-to-zql/src/ast-to-zql.ts';\nimport type {BTreeRead} from '../../../../replicache/src/btree/read.ts';\nimport {type Read} from '../../../../replicache/src/dag/store.ts';\nimport {readFromHash} from '../../../../replicache/src/db/read.ts';\nimport * as FormatVersion from '../../../../replicache/src/format-version-enum.ts';\nimport {getClientGroup} from '../../../../replicache/src/persist/client-groups.ts';\nimport {\n  getClient,\n  getClients,\n  type ClientMap,\n} from '../../../../replicache/src/persist/clients.ts';\nimport type {ReplicacheImpl} from '../../../../replicache/src/replicache-impl.ts';\nimport {withRead} from '../../../../replicache/src/with-transactions.ts';\nimport {assert} from '../../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../../shared/src/json.ts';\nimport {mapValues} from '../../../../shared/src/objects.ts';\nimport {TDigest, type ReadonlyTDigest} from '../../../../shared/src/tdigest.ts';\nimport * as valita from '../../../../shared/src/valita.ts';\nimport type {AST} from '../../../../zero-protocol/src/ast.ts';\nimport type {Row} from '../../../../zero-protocol/src/data.ts';\nimport {\n  inspectMetricsDownSchema,\n  inspectQueriesDownSchema,\n  inspectVersionDownSchema,\n  type InspectDownBody,\n  type InspectQueryRow,\n  type ServerMetrics as ServerMetricsJSON,\n} from '../../../../zero-protocol/src/inspect-down.ts';\nimport type {\n  InspectQueriesUpBody,\n  InspectUpBody,\n  InspectUpMessage,\n} from '../../../../zero-protocol/src/inspect-up.ts';\nimport type {Schema} from '../../../../zero-schema/src/builder/schema-builder.ts';\nimport type {\n  ClientMetricMap,\n  ServerMetricMap,\n} from '../../../../zql/src/query/metrics-delegate.ts';\nimport {normalizeTTL, type TTL} from '../../../../zql/src/query/ttl.ts';\nimport {nanoid} from '../../util/nanoid.ts';\nimport {ENTITIES_KEY_PREFIX} from '../keys.ts';\nimport type {MutatorDefs} from '../replicache-types.ts';\nimport type {\n  ClientGroup as ClientGroupInterface,\n  Client as ClientInterface,\n  Inspector as InspectorInterface,\n  Query as QueryInterface,\n} from './types.ts';\n\ntype Rep = ReplicacheImpl<MutatorDefs>;\n\ntype GetWebSocket = () => Promise<WebSocket>;\n\ntype Metrics = {\n  readonly [K in keyof (ClientMetricMap & ServerMetricMap)]: ReadonlyTDigest;\n};\n\ntype ClientMetrics = {\n  readonly [K in keyof ClientMetricMap]: ReadonlyTDigest;\n};\n\ntype ServerMetrics = {\n  readonly [K in keyof ServerMetricMap]: ReadonlyTDigest;\n};\n\nexport interface InspectorDelegate {\n  getQueryMetrics(hash: string): ClientMetrics | undefined;\n  getAST(queryID: string): AST | undefined;\n  readonly metrics: ClientMetrics;\n}\n\nexport async function newInspector(\n  rep: Rep,\n  delegate: InspectorDelegate,\n  schema: Schema,\n  socket: GetWebSocket,\n): Promise<InspectorInterface> {\n  const clientGroupID = await rep.clientGroupID;\n  return new Inspector(\n    rep,\n    delegate,\n    schema,\n    rep.clientID,\n    clientGroupID,\n    socket,\n  );\n}\n\nclass Inspector implements InspectorInterface {\n  readonly #rep: Rep;\n  readonly client: Client;\n  readonly clientGroup: ClientGroup;\n  readonly #schema: Schema;\n  readonly socket: GetWebSocket;\n  readonly #delegate: InspectorDelegate;\n\n  constructor(\n    rep: ReplicacheImpl,\n    delegate: InspectorDelegate,\n    schema: Schema,\n    clientID: string,\n    clientGroupID: string,\n    socket: GetWebSocket,\n  ) {\n    this.#rep = rep;\n    this.#schema = schema;\n    this.client = new Client(\n      rep,\n      delegate,\n      schema,\n      socket,\n      clientID,\n      clientGroupID,\n    );\n    this.clientGroup = this.client.clientGroup;\n    this.socket = socket;\n    this.#delegate = delegate;\n  }\n\n  async metrics(): Promise<Metrics> {\n    const clientMetrics = this.#delegate.metrics;\n    const serverMetricsJSON = await rpc(\n      await this.socket(),\n      {op: 'metrics'},\n      inspectMetricsDownSchema,\n    );\n    return mergeMetrics(clientMetrics, serverMetricsJSON);\n  }\n\n  clients(): Promise<ClientInterface[]> {\n    return withDagRead(this.#rep, dagRead =>\n      clients(this.#rep, this.#delegate, this.socket, this.#schema, dagRead),\n    );\n  }\n\n  clientsWithQueries(): Promise<ClientInterface[]> {\n    return withDagRead(this.#rep, dagRead =>\n      clientsWithQueries(\n        this.#rep,\n        this.#delegate,\n        this.socket,\n        this.#schema,\n        dagRead,\n      ),\n    );\n  }\n\n  async serverVersion(): Promise<string> {\n    return rpc(await this.socket(), {op: 'version'}, inspectVersionDownSchema);\n  }\n}\n\nfunction rpc<T extends InspectDownBody>(\n  socket: WebSocket,\n  arg: Omit<InspectUpBody, 'id'>,\n  downSchema: valita.Type<T>,\n): Promise<T['value']> {\n  return new Promise((resolve, reject) => {\n    const id = nanoid();\n    const f = (ev: MessageEvent) => {\n      const msg = JSON.parse(ev.data);\n      if (msg[0] === 'inspect') {\n        const body = msg[1];\n        if (body.id !== id) {\n          return;\n        }\n        const res = valita.test(body, downSchema);\n        if (res.ok) {\n          resolve(res.value.value);\n        } else {\n          reject(res.error);\n        }\n        socket.removeEventListener('message', f);\n      }\n    };\n    socket.addEventListener('message', f);\n    socket.send(\n      JSON.stringify(['inspect', {...arg, id}] satisfies InspectUpMessage),\n    );\n  });\n}\n\nclass Client implements ClientInterface {\n  readonly #rep: Rep;\n  readonly id: string;\n  readonly clientGroup: ClientGroup;\n  readonly #socket: GetWebSocket;\n  readonly #delegate: InspectorDelegate;\n\n  constructor(\n    rep: Rep,\n    delegate: InspectorDelegate,\n    schema: Schema,\n    socket: GetWebSocket,\n    id: string,\n    clientGroupID: string,\n  ) {\n    this.#rep = rep;\n    this.#socket = socket;\n    this.id = id;\n    this.clientGroup = new ClientGroup(\n      rep,\n      delegate,\n      socket,\n      schema,\n      clientGroupID,\n    );\n    this.#delegate = delegate;\n  }\n\n  async queries(): Promise<QueryInterface[]> {\n    const rows: InspectQueryRow[] = await rpc(\n      await this.#socket(),\n      {op: 'queries', clientID: this.id} as InspectQueriesUpBody,\n      inspectQueriesDownSchema,\n    );\n    return rows.map(row => new Query(row, this.#delegate));\n  }\n\n  map(): Promise<Map<string, ReadonlyJSONValue>> {\n    return withDagRead(this.#rep, async dagRead => {\n      const tree = await getBTree(dagRead, this.id);\n      const map = new Map<string, ReadonlyJSONValue>();\n      for await (const [key, value] of tree.scan('')) {\n        map.set(key, value);\n      }\n      return map;\n    });\n  }\n\n  rows(tableName: string): Promise<Row[]> {\n    return withDagRead(this.#rep, async dagRead => {\n      const prefix = ENTITIES_KEY_PREFIX + tableName;\n      const tree = await getBTree(dagRead, this.id);\n      const rows: Row[] = [];\n      for await (const [key, value] of tree.scan(prefix)) {\n        if (!key.startsWith(prefix)) {\n          break;\n        }\n        rows.push(value as Row);\n      }\n      return rows;\n    });\n  }\n}\n\nclass ClientGroup implements ClientGroupInterface {\n  readonly #rep: Rep;\n  readonly id: string;\n  readonly #schema: Schema;\n  readonly #socket: GetWebSocket;\n  readonly #delegate: InspectorDelegate;\n\n  constructor(\n    rep: Rep,\n    delegate: InspectorDelegate,\n    socket: GetWebSocket,\n    schema: Schema,\n    id: string,\n  ) {\n    this.#rep = rep;\n    this.#delegate = delegate;\n    this.#socket = socket;\n    this.#schema = schema;\n    this.id = id;\n  }\n\n  clients(): Promise<ClientInterface[]> {\n    return withDagRead(this.#rep, dagRead =>\n      clients(\n        this.#rep,\n        this.#delegate,\n        this.#socket,\n        this.#schema,\n        dagRead,\n        ([_, v]) => v.clientGroupID === this.id,\n      ),\n    );\n  }\n\n  clientsWithQueries(): Promise<ClientInterface[]> {\n    return withDagRead(this.#rep, dagRead =>\n      clientsWithQueries(\n        this.#rep,\n        this.#delegate,\n        this.#socket,\n        this.#schema,\n        dagRead,\n        ([_, v]) => v.clientGroupID === this.id,\n      ),\n    );\n  }\n\n  async queries(): Promise<QueryInterface[]> {\n    const rows: InspectQueryRow[] = await rpc(\n      await this.#socket(),\n      {op: 'queries'},\n      inspectQueriesDownSchema,\n    );\n    return rows.map(row => new Query(row, this.#delegate));\n  }\n}\n\nasync function withDagRead<T>(\n  rep: Rep,\n  f: (dagRead: Read) => Promise<T>,\n): Promise<T> {\n  await rep.refresh();\n  await rep.persist();\n  return withRead(rep.perdag, f);\n}\n\nasync function getBTree(dagRead: Read, clientID: string): Promise<BTreeRead> {\n  const client = await getClient(clientID, dagRead);\n  assert(client, `Client not found: ${clientID}`);\n  const {clientGroupID} = client;\n  const clientGroup = await getClientGroup(clientGroupID, dagRead);\n  assert(clientGroup, `Client group not found: ${clientGroupID}`);\n  const dbRead = await readFromHash(\n    clientGroup.headHash,\n    dagRead,\n    FormatVersion.Latest,\n  );\n  return dbRead.map;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype MapEntry<T extends ReadonlyMap<any, any>> =\n  T extends ReadonlyMap<infer K, infer V> ? readonly [K, V] : never;\n\nasync function clients(\n  rep: Rep,\n  delegate: InspectorDelegate,\n  socket: GetWebSocket,\n  schema: Schema,\n  dagRead: Read,\n  predicate: (entry: MapEntry<ClientMap>) => boolean = () => true,\n): Promise<ClientInterface[]> {\n  const clients = await getClients(dagRead);\n  return [...clients.entries()]\n    .filter(predicate)\n    .map(\n      ([clientID, {clientGroupID}]) =>\n        new Client(rep, delegate, schema, socket, clientID, clientGroupID),\n    );\n}\n\nasync function clientsWithQueries(\n  rep: Rep,\n  delegate: InspectorDelegate,\n  socket: GetWebSocket,\n  schema: Schema,\n  dagRead: Read,\n  predicate: (entry: MapEntry<ClientMap>) => boolean = () => true,\n): Promise<ClientInterface[]> {\n  const allClients = await clients(\n    rep,\n    delegate,\n    socket,\n    schema,\n    dagRead,\n    predicate,\n  );\n  const clientsWithQueries: ClientInterface[] = [];\n  await Promise.all(\n    allClients.map(async client => {\n      const queries = await client.queries();\n      if (queries.length > 0) {\n        clientsWithQueries.push(client);\n      }\n    }),\n  );\n  return clientsWithQueries;\n}\n\nclass Query implements QueryInterface {\n  readonly name: string | null;\n  readonly args: ReadonlyArray<ReadonlyJSONValue> | null;\n  readonly got: boolean;\n  readonly ttl: TTL;\n  readonly inactivatedAt: Date | null;\n  readonly rowCount: number;\n  readonly deleted: boolean;\n  readonly id: string;\n  readonly clientID: string;\n  readonly metrics: Metrics | null;\n  readonly clientZQL: string | null;\n  readonly serverZQL: string | null;\n\n  constructor(row: InspectQueryRow, delegate: InspectorDelegate) {\n    const {ast, queryID, inactivatedAt} = row;\n    // Use own properties to make this more useful in dev tools. For example, in\n    // Chrome dev tools, if you do console.table(queries) you'll see the\n    // properties in the table, if these were getters you would not see them in the table.\n    this.clientID = row.clientID;\n    this.id = queryID;\n    this.inactivatedAt =\n      inactivatedAt === null ? null : new Date(inactivatedAt);\n    this.ttl = normalizeTTL(row.ttl);\n    this.name = row.name;\n    this.args = row.args;\n    this.got = row.got;\n    this.rowCount = row.rowCount;\n    this.deleted = row.deleted;\n    this.serverZQL = ast ? ast.table + astToZQL(ast) : null;\n    const clientAST = delegate.getAST(queryID);\n    this.clientZQL = clientAST ? clientAST.table + astToZQL(clientAST) : null;\n\n    // Merge client and server metrics\n    const clientMetrics = delegate.getQueryMetrics(queryID);\n    const serverMetrics = row.metrics;\n\n    this.metrics = mergeMetrics(clientMetrics, serverMetrics);\n  }\n}\n\nfunction mergeMetrics(\n  clientMetrics: ClientMetrics | undefined,\n  serverMetrics: ServerMetricsJSON | null | undefined,\n): ClientMetrics & ServerMetrics {\n  return {\n    ...(clientMetrics ?? newClientMetrics()),\n    ...(serverMetrics\n      ? convertServerMetrics(serverMetrics)\n      : newServerMetrics()),\n  };\n}\n\nfunction newClientMetrics(): ClientMetrics {\n  return {\n    'query-materialization-client': new TDigest(),\n    'query-materialization-end-to-end': new TDigest(),\n    'query-update-client': new TDigest(),\n  };\n}\n\nfunction newServerMetrics(): ServerMetrics {\n  return {\n    'query-materialization-server': new TDigest(),\n    'query-update-server': new TDigest(),\n  };\n}\n\nfunction convertServerMetrics(metrics: ServerMetricsJSON): ServerMetrics {\n  return mapValues(metrics, v => TDigest.fromJSON(v));\n}\n"],"names":["clients","clientsWithQueries"],"mappings":"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","debugId":null}}]
}