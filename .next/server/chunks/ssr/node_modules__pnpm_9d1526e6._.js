module.exports = [
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}),
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}),
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}),
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactDOM; //# sourceMappingURL=react-dom.js.map
}),
"[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxRuntime; //# sourceMappingURL=react-jsx-runtime.js.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// packages/react/compose-refs/src/compose-refs.tsx
__turbopack_context__.s([
    "composeRefs",
    ()=>composeRefs,
    "useComposedRefs",
    ()=>useComposedRefs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs(...refs) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"](composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/slot.tsx
__turbopack_context__.s([
    "Root",
    ()=>Slot,
    "Slot",
    ()=>Slot,
    "Slottable",
    ()=>Slottable,
    "createSlot",
    ()=>createSlot,
    "createSlottable",
    ()=>createSlottable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$compose$2d$refs$40$1$2e$1$2e$2_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
;
;
;
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child)=>{
                if (child === slottable) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].only(null);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](newElement) ? newElement.props.children : null;
                } else {
                    return child;
                }
            });
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
                ...slotProps,
                ref: forwardedRef,
                children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](newElement) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneElement"](newElement, void 0, newChildren) : null
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children
        });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
    const SlotClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](children)) {
            const childrenRef = getElementRef(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"]) {
                props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$compose$2d$refs$40$1$2e$1$2e$2_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneElement"](children, props2);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
    const Slottable2 = ({ children })=>{
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], {
            children
        });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = (...args)=>{
                    const result = childPropValue(...args);
                    slotPropValue(...args);
                    return result;
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.2.0_@types+react@19.2.1__@types+rea_e5f28545a81d3a9cbba4676d380d9706/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/primitive.tsx
__turbopack_context__.s([
    "Primitive",
    ()=>Primitive,
    "Root",
    ()=>Root,
    "dispatchDiscreteCustomEvent",
    ()=>dispatchDiscreteCustomEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$slot$40$1$2e$2$2e$3_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.2.1_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
;
;
;
;
var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
];
var Primitive = NODES.reduce((primitive, node)=>{
    const Slot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$slot$40$1$2e$2$2e$3_$40$types$2b$react$40$19$2e$2$2e$1_react$40$19$2e$1$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSlot"])(`Primitive.${node}`);
    const Node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { asChild, ...primitiveProps } = props;
        const Comp = asChild ? Slot : node;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(Comp, {
            ...primitiveProps,
            ref: forwardedRef
        });
    });
    Node.displayName = `Primitive.${node}`;
    return {
        ...primitive,
        [node]: Node
    };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
    if (target) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flushSync"](()=>target.dispatchEvent(event));
}
var Root = Primitive;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-separator@1.1.7_@types+react-dom@19.2.0_@types+react@19.2.1__@types+rea_4614ec30d7df5dc18a0bd1b3d5dffd86/node_modules/@radix-ui/react-separator/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/separator.tsx
__turbopack_context__.s([
    "Root",
    ()=>Root,
    "Separator",
    ()=>Separator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$primitive$40$2$2e$1$2e$3_$40$types$2b$react$2d$dom$40$19$2e$2$2e$0_$40$types$2b$react$40$19$2e$2$2e$1_$5f40$types$2b$rea_e5f28545a81d3a9cbba4676d380d9706$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.2.0_@types+react@19.2.1__@types+rea_e5f28545a81d3a9cbba4676d380d9706/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
;
;
;
var NAME = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = [
    "horizontal",
    "vertical"
];
var Separator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
    const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
    const ariaOrientation = orientation === "vertical" ? orientation : void 0;
    const semanticProps = decorative ? {
        role: "none"
    } : {
        "aria-orientation": ariaOrientation,
        role: "separator"
    };
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$1$2e$0_react$40$19$2e$1$2e$0_$5f$react$40$19$2e$1$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$primitive$40$2$2e$1$2e$3_$40$types$2b$react$2d$dom$40$19$2e$2$2e$0_$40$types$2b$react$40$19$2e$2$2e$1_$5f40$types$2b$rea_e5f28545a81d3a9cbba4676d380d9706$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Primitive"].div, {
        "data-orientation": orientation,
        ...semanticProps,
        ...domProps,
        ref: forwardedRef
    });
});
Separator.displayName = NAME;
function isValidOrientation(orientation) {
    return ORIENTATIONS.includes(orientation);
}
var Root = Separator;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/.pnpm/@badrap+valita@0.3.11/node_modules/@badrap/valita/dist/node-mjs/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @module
 * A typesafe validation & parsing library for TypeScript.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * const vehicle = v.union(
 *   v.object({ type: v.literal("plane"), airline: v.string() }),
 *   v.object({ type: v.literal("train") }),
 *   v.object({ type: v.literal("automobile"), make: v.string() })
 * );
 * vehicle.parse({ type: "bike" });
 * // ValitaError: invalid_literal at .type (expected "plane", "train" or "automobile")
 * ```
 */ __turbopack_context__.s([
    "ValitaError",
    ()=>ValitaError,
    "array",
    ()=>array,
    "bigint",
    ()=>bigint,
    "boolean",
    ()=>boolean,
    "err",
    ()=>err,
    "lazy",
    ()=>lazy,
    "literal",
    ()=>literal,
    "never",
    ()=>never,
    "null",
    ()=>null_,
    "number",
    ()=>number,
    "object",
    ()=>object,
    "ok",
    ()=>ok,
    "record",
    ()=>record,
    "string",
    ()=>string,
    "tuple",
    ()=>tuple,
    "undefined",
    ()=>undefined_,
    "union",
    ()=>union,
    "unknown",
    ()=>unknown
]);
function joinIssues(left, right) {
    return left ? {
        ok: false,
        code: "join",
        left,
        right
    } : right;
}
function prependPath(key, tree) {
    return {
        ok: false,
        code: "prepend",
        key,
        tree
    };
}
function cloneIssueWithPath(tree, path) {
    const code = tree.code;
    switch(code){
        case "invalid_type":
            return {
                code,
                path,
                expected: tree.expected
            };
        case "invalid_literal":
            return {
                code,
                path,
                expected: tree.expected
            };
        case "missing_value":
            return {
                code,
                path
            };
        case "invalid_length":
            return {
                code,
                path,
                minLength: tree.minLength,
                maxLength: tree.maxLength
            };
        case "unrecognized_keys":
            return {
                code,
                path,
                keys: tree.keys
            };
        case "invalid_union":
            return {
                code,
                path,
                tree: tree.tree
            };
        default:
            return {
                code,
                path,
                error: tree.error
            };
    }
}
function collectIssues(tree, path = [], issues = []) {
    for(;;){
        if (tree.code === "join") {
            collectIssues(tree.left, path.slice(), issues);
            tree = tree.right;
        } else if (tree.code === "prepend") {
            path.push(tree.key);
            tree = tree.tree;
        } else {
            if (tree.code === "custom_error" && typeof tree.error === "object" && tree.error.path !== undefined) {
                path.push(...tree.error.path);
            }
            issues.push(cloneIssueWithPath(tree, path));
            return issues;
        }
    }
}
function separatedList(list, sep) {
    if (list.length === 0) {
        return "nothing";
    } else if (list.length === 1) {
        return list[0];
    } else {
        return `${list.slice(0, -1).join(", ")} ${sep} ${list[list.length - 1]}`;
    }
}
function formatLiteral(value) {
    return typeof value === "bigint" ? `${value}n` : JSON.stringify(value);
}
function countIssues(tree) {
    let count = 0;
    for(;;){
        if (tree.code === "join") {
            count += countIssues(tree.left);
            tree = tree.right;
        } else if (tree.code === "prepend") {
            tree = tree.tree;
        } else {
            return count + 1;
        }
    }
}
function formatIssueTree(tree) {
    let path = "";
    let count = 0;
    for(;;){
        if (tree.code === "join") {
            count += countIssues(tree.right);
            tree = tree.left;
        } else if (tree.code === "prepend") {
            path += "." + tree.key;
            tree = tree.tree;
        } else {
            break;
        }
    }
    let message = "validation failed";
    if (tree.code === "invalid_type") {
        message = `expected ${separatedList(tree.expected, "or")}`;
    } else if (tree.code === "invalid_literal") {
        message = `expected ${separatedList(tree.expected.map(formatLiteral), "or")}`;
    } else if (tree.code === "missing_value") {
        message = `missing value`;
    } else if (tree.code === "unrecognized_keys") {
        const keys = tree.keys;
        message = `unrecognized ${keys.length === 1 ? "key" : "keys"} ${separatedList(keys.map(formatLiteral), "and")}`;
    } else if (tree.code === "invalid_length") {
        const min = tree.minLength;
        const max = tree.maxLength;
        message = `expected an array with `;
        if (min > 0) {
            if (max === min) {
                message += `${min}`;
            } else if (max !== undefined) {
                message += `between ${min} and ${max}`;
            } else {
                message += `at least ${min}`;
            }
        } else {
            message += `at most ${max}`;
        }
        message += ` item(s)`;
    } else if (tree.code === "custom_error") {
        const error = tree.error;
        if (typeof error === "string") {
            message = error;
        } else if (error !== undefined) {
            if (error.message !== undefined) {
                message = error.message;
            }
            if (error.path !== undefined) {
                path += "." + error.path.join(".");
            }
        }
    }
    let msg = `${tree.code} at .${path.slice(1)} (${message})`;
    if (count === 1) {
        msg += ` (+ 1 other issue)`;
    } else if (count > 1) {
        msg += ` (+ ${count} other issues)`;
    }
    return msg;
}
class ValitaError extends Error {
    constructor(issueTree){
        super(formatIssueTree(issueTree));
        this.issueTree = issueTree;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = new.target.name;
        this._issues = undefined;
    }
    get issues() {
        if (this._issues === undefined) {
            this._issues = collectIssues(this.issueTree);
        }
        return this._issues;
    }
}
class ErrImpl {
    constructor(issueTree){
        this.issueTree = issueTree;
        this.ok = false;
        this._issues = undefined;
        this._message = undefined;
    }
    get issues() {
        if (this._issues === undefined) {
            this._issues = collectIssues(this.issueTree);
        }
        return this._issues;
    }
    get message() {
        if (this._message === undefined) {
            this._message = formatIssueTree(this.issueTree);
        }
        return this._message;
    }
    throw() {
        throw new ValitaError(this.issueTree);
    }
}
function ok(value) {
    return {
        ok: true,
        value
    };
}
/**
 * Create a value for returning a parsing error from chain().
 *
 * An optional error message can be provided.
 *
 * @example
 * ```ts
 * const t = v.string().chain(() => v.err("bad value"));
 *
 * t.parse("hello");
 * // ValitaError: custom_error at . (bad value)
 * ```
 */ function err(error) {
    return new ErrImpl({
        ok: false,
        code: "custom_error",
        error
    });
}
function isObject(v) {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}
const FLAG_FORBID_EXTRA_KEYS = 0x1;
const FLAG_STRIP_EXTRA_KEYS = 0x2;
const FLAG_MISSING_VALUE = 0x4;
class AbstractType {
    optional(defaultFn) {
        const optional = new Optional(this);
        if (!defaultFn) {
            return optional;
        }
        return new TransformType(optional, (v)=>{
            return v === undefined ? {
                ok: true,
                value: defaultFn()
            } : undefined;
        });
    }
    default(defaultValue) {
        const defaultResult = ok(defaultValue);
        return new TransformType(this.optional(), (v)=>{
            return v === undefined ? defaultResult : undefined;
        });
    }
    assert(func, error) {
        const err = {
            ok: false,
            code: "custom_error",
            error
        };
        return new TransformType(this, (v, options)=>func(v, options) ? undefined : err);
    }
    map(func) {
        return new TransformType(this, (v, options)=>({
                ok: true,
                value: func(v, options)
            }));
    }
    chain(func) {
        return new TransformType(this, (v, options)=>{
            const r = func(v, options);
            return r.ok ? r : r.issueTree;
        });
    }
}
/**
 * A base class for all concreate validators/parsers.
 */ class Type extends AbstractType {
    /**
     * Return new validator that accepts both the original type and `null`.
     */ nullable() {
        return new Nullable(this);
    }
    toTerminals(func) {
        func(this);
    }
    /**
     * Parse a value without throwing.
     */ try(v, options) {
        let flags = FLAG_FORBID_EXTRA_KEYS;
        if (options?.mode === "passthrough") {
            flags = 0;
        } else if (options?.mode === "strip") {
            flags = FLAG_STRIP_EXTRA_KEYS;
        }
        const r = this.func(v, flags);
        if (r === undefined) {
            return {
                ok: true,
                value: v
            };
        } else if (r.ok) {
            return {
                ok: true,
                value: r.value
            };
        } else {
            return new ErrImpl(r);
        }
    }
    /**
     * Parse a value. Throw a ValitaError on failure.
     */ parse(v, options) {
        let flags = FLAG_FORBID_EXTRA_KEYS;
        if (options?.mode === "passthrough") {
            flags = 0;
        } else if (options?.mode === "strip") {
            flags = FLAG_STRIP_EXTRA_KEYS;
        }
        const r = this.func(v, flags);
        if (r === undefined) {
            return v;
        } else if (r.ok) {
            return r.value;
        } else {
            throw new ValitaError(r);
        }
    }
}
class Nullable extends Type {
    constructor(type){
        super();
        this.type = type;
        this.name = "nullable";
    }
    func(v, flags) {
        return v === null ? undefined : this.type.func(v, flags);
    }
    toTerminals(func) {
        func(nullSingleton);
        this.type.toTerminals(func);
    }
    nullable() {
        return this;
    }
}
/**
 * A validator/parser marked as "optional", signifying that their value can
 * be missing from the parsed object.
 *
 * As such optionals can only be used as property validators within
 * object validators.
 */ class Optional extends AbstractType {
    constructor(type){
        super();
        this.type = type;
        this.name = "optional";
    }
    func(v, flags) {
        return v === undefined || flags & FLAG_MISSING_VALUE ? undefined : this.type.func(v, flags);
    }
    toTerminals(func) {
        func(this);
        func(undefinedSingleton);
        this.type.toTerminals(func);
    }
    optional(defaultFn) {
        if (!defaultFn) {
            return this;
        }
        return new TransformType(this, (v)=>{
            return v === undefined ? {
                ok: true,
                value: defaultFn()
            } : undefined;
        });
    }
}
// Set a bit in position `index` to one and return the updated bitset.
// This function may or may not mutate `bits` in-place.
function setBit(bits, index) {
    if (typeof bits !== "number") {
        const idx = index >> 5;
        for(let i = bits.length; i <= idx; i++){
            bits.push(0);
        }
        bits[idx] |= 1 << index % 32;
        return bits;
    } else if (index < 32) {
        return bits | 1 << index;
    } else {
        return setBit([
            bits,
            0
        ], index);
    }
}
// Get the bit at position `index`.
function getBit(bits, index) {
    if (typeof bits === "number") {
        return index < 32 ? bits >>> index & 1 : 0;
    } else {
        return bits[index >> 5] >>> index % 32 & 1;
    }
}
class ObjectType extends Type {
    constructor(shape, restType, checks){
        super();
        this.shape = shape;
        this.restType = restType;
        this.checks = checks;
        this.name = "object";
        this._invalidType = {
            ok: false,
            code: "invalid_type",
            expected: [
                "object"
            ]
        };
    }
    check(func, error) {
        const issue = {
            ok: false,
            code: "custom_error",
            error
        };
        return new ObjectType(this.shape, this.restType, [
            ...this.checks ?? [],
            {
                func: func,
                issue
            }
        ]);
    }
    func(v, flags) {
        if (!isObject(v)) {
            return this._invalidType;
        }
        let func = this._func;
        if (func === undefined) {
            func = createObjectMatcher(this.shape, this.restType, this.checks);
            this._func = func;
        }
        return func(v, flags);
    }
    rest(restType) {
        return new ObjectType(this.shape, restType);
    }
    extend(shape) {
        return new ObjectType({
            ...this.shape,
            ...shape
        }, this.restType);
    }
    pick(...keys) {
        const shape = {};
        keys.forEach((key)=>{
            shape[key] = this.shape[key];
        });
        return new ObjectType(shape, undefined);
    }
    omit(...keys) {
        const shape = {
            ...this.shape
        };
        keys.forEach((key)=>{
            delete shape[key];
        });
        return new ObjectType(shape, this.restType);
    }
    partial() {
        const shape = {};
        Object.keys(this.shape).forEach((key)=>{
            shape[key] = this.shape[key].optional();
        });
        const rest = this.restType?.optional();
        return new ObjectType(shape, rest);
    }
}
function createObjectMatcher(shape, rest, checks) {
    const requiredKeys = [];
    const optionalKeys = [];
    for(const key in shape){
        let hasOptional = false;
        shape[key].toTerminals((t)=>{
            hasOptional ||= t.name === "optional";
        });
        if (hasOptional) {
            optionalKeys.push(key);
        } else {
            requiredKeys.push(key);
        }
    }
    const keys = [
        ...requiredKeys,
        ...optionalKeys
    ];
    const totalCount = keys.length;
    if (totalCount === 0 && rest?.name === "unknown") {
        // A fast path for record(unknown())
        return function(obj, _) {
            if (checks !== undefined) {
                for(let i = 0; i < checks.length; i++){
                    if (!checks[i].func(obj)) {
                        return checks[i].issue;
                    }
                }
            }
            return undefined;
        };
    }
    const types = keys.map((key)=>shape[key]);
    const requiredCount = requiredKeys.length;
    const invertedIndexes = Object.create(null);
    keys.forEach((key, index)=>{
        invertedIndexes[key] = ~index;
    });
    const missingValues = requiredKeys.map((key)=>prependPath(key, {
            ok: false,
            code: "missing_value"
        }));
    function set(obj, key, value) {
        if (key === "__proto__") {
            Object.defineProperty(obj, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        } else {
            obj[key] = value;
        }
    }
    return function(obj, flags) {
        let copied = false;
        let output = obj;
        let issues;
        let unrecognized = undefined;
        let seenBits = 0;
        let seenCount = 0;
        if (flags & FLAG_FORBID_EXTRA_KEYS || flags & FLAG_STRIP_EXTRA_KEYS || rest !== undefined) {
            for(const key in obj){
                const value = obj[key];
                const index = ~invertedIndexes[key];
                let r;
                if (index >= 0) {
                    seenCount++;
                    seenBits = setBit(seenBits, index);
                    r = types[index].func(value, flags);
                } else if (rest !== undefined) {
                    r = rest.func(value, flags);
                } else {
                    if (flags & FLAG_FORBID_EXTRA_KEYS) {
                        if (unrecognized === undefined) {
                            unrecognized = [
                                key
                            ];
                        } else {
                            unrecognized.push(key);
                        }
                    } else if (flags & FLAG_STRIP_EXTRA_KEYS && issues === undefined && !copied) {
                        output = {};
                        copied = true;
                        for(let m = 0; m < totalCount; m++){
                            if (getBit(seenBits, m)) {
                                const k = keys[m];
                                set(output, k, obj[k]);
                            }
                        }
                    }
                    continue;
                }
                if (r === undefined) {
                    if (copied && issues === undefined) {
                        set(output, key, value);
                    }
                } else if (!r.ok) {
                    issues = joinIssues(issues, prependPath(key, r));
                } else if (issues === undefined) {
                    if (!copied) {
                        output = {};
                        copied = true;
                        if (rest === undefined) {
                            for(let m = 0; m < totalCount; m++){
                                if (m !== index && getBit(seenBits, m)) {
                                    const k = keys[m];
                                    set(output, k, obj[k]);
                                }
                            }
                        } else {
                            for(const k in obj){
                                set(output, k, obj[k]);
                            }
                        }
                    }
                    set(output, key, r.value);
                }
            }
        }
        if (seenCount < totalCount) {
            for(let i = 0; i < totalCount; i++){
                if (getBit(seenBits, i)) {
                    continue;
                }
                const key = keys[i];
                const value = obj[key];
                let keyFlags = flags & ~FLAG_MISSING_VALUE;
                if (value === undefined && !(key in obj)) {
                    if (i < requiredCount) {
                        issues = joinIssues(issues, missingValues[i]);
                        continue;
                    }
                    keyFlags |= FLAG_MISSING_VALUE;
                }
                const r = types[i].func(value, keyFlags);
                if (r === undefined) {
                    if (copied && issues === undefined && !(keyFlags & FLAG_MISSING_VALUE)) {
                        set(output, key, value);
                    }
                } else if (!r.ok) {
                    issues = joinIssues(issues, prependPath(key, r));
                } else if (issues === undefined) {
                    if (!copied) {
                        output = {};
                        copied = true;
                        if (rest === undefined) {
                            for(let m = 0; m < totalCount; m++){
                                if (m < i || getBit(seenBits, m)) {
                                    const k = keys[m];
                                    set(output, k, obj[k]);
                                }
                            }
                        } else {
                            for(const k in obj){
                                set(output, k, obj[k]);
                            }
                            for(let m = 0; m < i; m++){
                                if (!getBit(seenBits, m)) {
                                    const k = keys[m];
                                    set(output, k, obj[k]);
                                }
                            }
                        }
                    }
                    set(output, key, r.value);
                }
            }
        }
        if (unrecognized !== undefined) {
            issues = joinIssues(issues, {
                ok: false,
                code: "unrecognized_keys",
                keys: unrecognized
            });
        }
        if (issues === undefined && checks !== undefined) {
            for(let i = 0; i < checks.length; i++){
                if (!checks[i].func(output)) {
                    return checks[i].issue;
                }
            }
        }
        if (issues === undefined && copied) {
            return {
                ok: true,
                value: output
            };
        } else {
            return issues;
        }
    };
}
class ArrayOrTupleType extends Type {
    constructor(prefix, rest, suffix){
        super();
        this.prefix = prefix;
        this.rest = rest;
        this.suffix = suffix;
        this.name = "array";
        this.restType = rest ?? never();
        this.minLength = this.prefix.length + this.suffix.length;
        this.maxLength = rest ? undefined : this.minLength;
        this.invalidType = {
            ok: false,
            code: "invalid_type",
            expected: [
                "array"
            ]
        };
        this.invalidLength = {
            ok: false,
            code: "invalid_length",
            minLength: this.minLength,
            maxLength: this.maxLength
        };
    }
    func(arr, flags) {
        if (!Array.isArray(arr)) {
            return this.invalidType;
        }
        const length = arr.length;
        const minLength = this.minLength;
        const maxLength = this.maxLength ?? Infinity;
        if (length < minLength || length > maxLength) {
            return this.invalidLength;
        }
        const headEnd = this.prefix.length;
        const tailStart = arr.length - this.suffix.length;
        let issueTree = undefined;
        let output = arr;
        for(let i = 0; i < arr.length; i++){
            const type = i < headEnd ? this.prefix[i] : i >= tailStart ? this.suffix[i - tailStart] : this.restType;
            const r = type.func(arr[i], flags);
            if (r !== undefined) {
                if (r.ok) {
                    if (output === arr) {
                        output = arr.slice();
                    }
                    output[i] = r.value;
                } else {
                    issueTree = joinIssues(issueTree, prependPath(i, r));
                }
            }
        }
        if (issueTree) {
            return issueTree;
        } else if (arr === output) {
            return undefined;
        } else {
            return {
                ok: true,
                value: output
            };
        }
    }
    concat(type) {
        if (this.rest) {
            if (type.rest) {
                throw new TypeError("can not concatenate two variadic types");
            }
            return new ArrayOrTupleType(this.prefix, this.rest, [
                ...this.suffix,
                ...type.prefix,
                ...type.suffix
            ]);
        } else if (type.rest) {
            return new ArrayOrTupleType([
                ...this.prefix,
                ...this.suffix,
                ...type.prefix
            ], type.rest, type.suffix);
        } else {
            return new ArrayOrTupleType([
                ...this.prefix,
                ...this.suffix,
                ...type.prefix,
                ...type.suffix
            ], type.rest, type.suffix);
        }
    }
}
function toInputType(v) {
    const type = typeof v;
    if (type !== "object") {
        return type;
    } else if (v === null) {
        return "null";
    } else if (Array.isArray(v)) {
        return "array";
    } else {
        return type;
    }
}
function dedup(arr) {
    return Array.from(new Set(arr));
}
function findCommonKeys(rs) {
    const map = new Map();
    rs.forEach((r)=>{
        for(const key in r){
            map.set(key, (map.get(key) || 0) + 1);
        }
    });
    const result = [];
    map.forEach((count, key)=>{
        if (count === rs.length) {
            result.push(key);
        }
    });
    return result;
}
function groupTerminals(terminals) {
    const order = new Map();
    const literals = new Map();
    const types = new Map();
    const unknowns = [];
    const optionals = [];
    const expectedTypes = [];
    terminals.forEach(({ root, terminal })=>{
        order.set(root, order.get(root) ?? order.size);
        if (terminal.name === "never") {
        // skip
        } else if (terminal.name === "optional") {
            optionals.push(root);
        } else if (terminal.name === "unknown") {
            unknowns.push(root);
        } else if (terminal.name === "literal") {
            const roots = literals.get(terminal.value) || [];
            roots.push(root);
            literals.set(terminal.value, roots);
            expectedTypes.push(toInputType(terminal.value));
        } else {
            const roots = types.get(terminal.name) || [];
            roots.push(root);
            types.set(terminal.name, roots);
            expectedTypes.push(terminal.name);
        }
    });
    literals.forEach((roots, value)=>{
        const options = types.get(toInputType(value));
        if (options) {
            options.push(...roots);
            literals.delete(value);
        }
    });
    const byOrder = (a, b)=>{
        return (order.get(a) ?? 0) - (order.get(b) ?? 0);
    };
    types.forEach((roots, type)=>types.set(type, dedup(roots.concat(unknowns).sort(byOrder))));
    literals.forEach((roots, value)=>literals.set(value, dedup(roots.concat(unknowns)).sort(byOrder)));
    return {
        types,
        literals,
        unknowns: dedup(unknowns).sort(byOrder),
        optionals: dedup(optionals).sort(byOrder),
        expectedTypes: dedup(expectedTypes)
    };
}
function createObjectKeyMatcher(objects, key) {
    const list = [];
    for (const { root, terminal } of objects){
        terminal.shape[key].toTerminals((t)=>list.push({
                root,
                terminal: t
            }));
    }
    const { types, literals, optionals, unknowns, expectedTypes } = groupTerminals(list);
    if (unknowns.length > 0 || optionals.length > 1) {
        return undefined;
    }
    for (const roots of literals.values()){
        if (roots.length > 1) {
            return undefined;
        }
    }
    for (const roots of types.values()){
        if (roots.length > 1) {
            return undefined;
        }
    }
    const missingValue = prependPath(key, {
        ok: false,
        code: "missing_value"
    });
    const issue = prependPath(key, types.size === 0 ? {
        ok: false,
        code: "invalid_literal",
        expected: Array.from(literals.keys())
    } : {
        ok: false,
        code: "invalid_type",
        expected: expectedTypes
    });
    const litMap = literals.size > 0 ? new Map() : undefined;
    for (const [literal, options] of literals){
        litMap.set(literal, options[0]);
    }
    const byType = types.size > 0 ? {} : undefined;
    for (const [type, options] of types){
        byType[type] = options[0];
    }
    return function(_obj, flags) {
        const obj = _obj;
        const value = obj[key];
        if (value === undefined && !(key in obj)) {
            return optionals.length > 0 ? optionals[0].func(obj, flags) : missingValue;
        }
        const option = byType?.[toInputType(value)] ?? litMap?.get(value);
        return option ? option.func(obj, flags) : issue;
    };
}
function createUnionObjectMatcher(terminals) {
    if (terminals.some(({ terminal: t })=>t.name === "unknown")) {
        return undefined;
    }
    const objects = terminals.filter((item)=>{
        return item.terminal.name === "object";
    });
    if (objects.length < 2) {
        return undefined;
    }
    const shapes = objects.map(({ terminal })=>terminal.shape);
    for (const key of findCommonKeys(shapes)){
        const matcher = createObjectKeyMatcher(objects, key);
        if (matcher) {
            return matcher;
        }
    }
    return undefined;
}
function createUnionBaseMatcher(terminals) {
    const { expectedTypes, literals, types, unknowns, optionals } = groupTerminals(terminals);
    const issue = types.size === 0 && unknowns.length === 0 ? {
        ok: false,
        code: "invalid_literal",
        expected: Array.from(literals.keys())
    } : {
        ok: false,
        code: "invalid_type",
        expected: expectedTypes
    };
    const litMap = literals.size > 0 ? literals : undefined;
    const byType = types.size > 0 ? {} : undefined;
    for (const [type, options] of types){
        byType[type] = options;
    }
    return function(value, flags) {
        let options;
        if (flags & FLAG_MISSING_VALUE) {
            options = optionals;
        } else {
            options = byType?.[toInputType(value)] ?? litMap?.get(value) ?? unknowns;
        }
        if (!options) {
            return issue;
        }
        let count = 0;
        let issueTree = issue;
        for(let i = 0; i < options.length; i++){
            const r = options[i].func(value, flags);
            if (r === undefined || r.ok) {
                return r;
            }
            issueTree = count > 0 ? joinIssues(issueTree, r) : r;
            count++;
        }
        if (count > 1) {
            return {
                ok: false,
                code: "invalid_union",
                tree: issueTree
            };
        }
        return issueTree;
    };
}
class UnionType extends Type {
    constructor(options){
        super();
        this.options = options;
        this.name = "union";
    }
    toTerminals(func) {
        this.options.forEach((o)=>o.toTerminals(func));
    }
    func(v, flags) {
        let func = this._func;
        if (func === undefined) {
            const flattened = [];
            this.options.forEach((option)=>option.toTerminals((terminal)=>{
                    flattened.push({
                        root: option,
                        terminal
                    });
                }));
            const base = createUnionBaseMatcher(flattened);
            const object = createUnionObjectMatcher(flattened);
            if (!object) {
                func = base;
            } else {
                func = function(v, f) {
                    if (isObject(v)) {
                        return object(v, f);
                    }
                    return base(v, f);
                };
            }
            this._func = func;
        }
        return func(v, flags);
    }
}
const STRICT = Object.freeze({
    mode: "strict"
});
const STRIP = Object.freeze({
    mode: "strip"
});
const PASSTHROUGH = Object.freeze({
    mode: "passthrough"
});
class TransformType extends Type {
    constructor(transformed, transform){
        super();
        this.transformed = transformed;
        this.transform = transform;
        this.name = "transform";
        this.undef = ok(undefined);
        this.transformChain = undefined;
        this.transformRoot = undefined;
    }
    func(v, flags) {
        let chain = this.transformChain;
        if (!chain) {
            chain = [];
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            let next = this;
            while(next instanceof TransformType){
                chain.push(next.transform);
                next = next.transformed;
            }
            chain.reverse();
            this.transformChain = chain;
            this.transformRoot = next;
        }
        // eslint-disable-next-line
        let result = this.transformRoot.func(v, flags);
        if (result !== undefined && !result.ok) {
            return result;
        }
        let current;
        if (result !== undefined) {
            current = result.value;
        } else if (flags & FLAG_MISSING_VALUE) {
            current = undefined;
            result = this.undef;
        } else {
            current = v;
        }
        const options = flags & FLAG_FORBID_EXTRA_KEYS ? STRICT : flags & FLAG_STRIP_EXTRA_KEYS ? STRIP : PASSTHROUGH;
        for(let i = 0; i < chain.length; i++){
            const r = chain[i](current, options);
            if (r !== undefined) {
                if (!r.ok) {
                    return r;
                }
                current = r.value;
                result = r;
            }
        }
        return result;
    }
    toTerminals(func) {
        this.transformed.toTerminals(func);
    }
}
class LazyType extends Type {
    constructor(definer){
        super();
        this.definer = definer;
        this.name = "lazy";
        this.recursing = false;
    }
    func(v, flags) {
        if (!this.type) {
            this.type = this.definer();
        }
        return this.type.func(v, flags);
    }
    toTerminals(func) {
        if (this.recursing) {
            return;
        }
        try {
            this.recursing = true;
            if (!this.type) {
                this.type = this.definer();
            }
            this.type.toTerminals(func);
        } finally{
            this.recursing = false;
        }
    }
}
class NeverType extends Type {
    constructor(){
        super(...arguments);
        this.name = "never";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: []
        };
    }
    func(_, __) {
        return this.issue;
    }
}
const neverSingleton = new NeverType();
/**
 * Create a validator that never matches any value,
 * analogous to the TypeScript type `never`.
 */ function never() {
    return neverSingleton;
}
class UnknownType extends Type {
    constructor(){
        super(...arguments);
        this.name = "unknown";
    }
    func(_, __) {
        return undefined;
    }
}
const unknownSingleton = new UnknownType();
/**
 * Create a validator that matches any value,
 * analogous to the TypeScript type `unknown`.
 */ function unknown() {
    return unknownSingleton;
}
class UndefinedType extends Type {
    constructor(){
        super(...arguments);
        this.name = "undefined";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "undefined"
            ]
        };
    }
    func(v, _) {
        return v === undefined ? undefined : this.issue;
    }
}
const undefinedSingleton = new UndefinedType();
/**
 * Create a validator that matches `undefined`.
 */ function undefined_() {
    return undefinedSingleton;
}
class NullType extends Type {
    constructor(){
        super(...arguments);
        this.name = "null";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "null"
            ]
        };
    }
    func(v, _) {
        return v === null ? undefined : this.issue;
    }
}
const nullSingleton = new NullType();
/**
 * Create a validator that matches `null`.
 */ function null_() {
    return nullSingleton;
}
class NumberType extends Type {
    constructor(){
        super(...arguments);
        this.name = "number";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "number"
            ]
        };
    }
    func(v, _) {
        return typeof v === "number" ? undefined : this.issue;
    }
}
const numberSingleton = new NumberType();
/**
 * Create a validator that matches any number value.
 */ function number() {
    return numberSingleton;
}
class BigIntType extends Type {
    constructor(){
        super(...arguments);
        this.name = "bigint";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "bigint"
            ]
        };
    }
    func(v, _) {
        return typeof v === "bigint" ? undefined : this.issue;
    }
}
const bigintSingleton = new BigIntType();
/**
 * Create a validator that matches any bigint value.
 */ function bigint() {
    return bigintSingleton;
}
class StringType extends Type {
    constructor(){
        super(...arguments);
        this.name = "string";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "string"
            ]
        };
    }
    func(v, _) {
        return typeof v === "string" ? undefined : this.issue;
    }
}
const stringSingleton = new StringType();
/**
 * Create a validator that matches any string value.
 */ function string() {
    return stringSingleton;
}
class BooleanType extends Type {
    constructor(){
        super(...arguments);
        this.name = "boolean";
        this.issue = {
            ok: false,
            code: "invalid_type",
            expected: [
                "boolean"
            ]
        };
    }
    func(v, _) {
        return typeof v === "boolean" ? undefined : this.issue;
    }
}
const booleanSingleton = new BooleanType();
/**
 * Create a validator that matches any boolean value.
 */ function boolean() {
    return booleanSingleton;
}
class LiteralType extends Type {
    constructor(value){
        super();
        this.value = value;
        this.name = "literal";
        this.issue = {
            ok: false,
            code: "invalid_literal",
            expected: [
                value
            ]
        };
    }
    func(v, _) {
        return v === this.value ? undefined : this.issue;
    }
}
/**
 * Create a validator for a specific string, number, bigint or boolean value.
 */ function literal(value) {
    return new LiteralType(value);
}
/**
 * Create a validator for an object type.
 */ function object(obj) {
    return new ObjectType(obj, undefined);
}
/**
 * Create a validator for a record type `Record<string, T>`,
 * where `T` is the output type of the given subvalidator.
 */ function record(valueType) {
    return new ObjectType({}, valueType ?? unknown());
}
/**
 * Create a validator for an array type `T[]`,
 * where `T` is the output type of the given subvalidator.
 */ function array(item) {
    return new ArrayOrTupleType([], item ?? unknown(), []);
}
/**
 * Create a validator for an array type `[T1, T2, ..., Tn]`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 */ function tuple(items) {
    return new ArrayOrTupleType(items, undefined, []);
}
/**
 * Create a validator that matches any type `T1 | T2 | ... | Tn`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 *
 * This is analogous to how TypeScript's union types are constructed.
 */ function union(...options) {
    return new UnionType(options);
}
/**
 * Create a validator that can reference itself, directly or indirectly.
 *
 * In most cases an explicit type annotation is also needed, as TypeScript
 * cannot infer return types of recursive functions.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * type T = string | T[];
 * const type: v.Type<T> = v.lazy(() => v.union(v.string(), v.array(type)));
 * ```
 */ function lazy(definer) {
    return new LazyType(definer);
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/compare-utf8@0.1.1/node_modules/compare-utf8/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
/**
 * Compares two JavaScript strings as if they were UTF-8 encoded byte arrays.
 * @param {string} a
 * @param {string} b
 * @returns {number}
 */ __turbopack_context__.s([
    "compareUTF8",
    ()=>compareUTF8,
    "greaterThan",
    ()=>greaterThan,
    "greaterThanEq",
    ()=>greaterThanEq,
    "lessThan",
    ()=>lessThan,
    "lessThanEq",
    ()=>lessThanEq,
    "utf16LengthForCodePoint",
    ()=>utf16LengthForCodePoint
]);
function compareUTF8(a, b) {
    const aLength = a.length;
    const bLength = b.length;
    const length = Math.min(aLength, bLength);
    for(let i = 0; i < length;){
        const aCodePoint = a.codePointAt(i);
        const bCodePoint = b.codePointAt(i);
        if (aCodePoint !== bCodePoint) {
            // Code points below 0x80 are represented the same way in UTF-8 as in
            // UTF-16.
            if (aCodePoint < 0x80 && bCodePoint < 0x80) {
                return aCodePoint - bCodePoint;
            }
            // get the UTF-8 bytes for the code points
            const aLength = utf8Bytes(aCodePoint, aBytes);
            const bLength = utf8Bytes(bCodePoint, bBytes);
            return compareArrays(aBytes, aLength, bBytes, bLength);
        }
        i += utf16LengthForCodePoint(aCodePoint);
    }
    return aLength - bLength;
}
/**
 * @param {number[]} a
 * @param {number} aLength
 * @param {number[]} b
 * @param {number} bLength
 * @returns {number}
 */ function compareArrays(a, aLength, b, bLength) {
    const length = Math.min(aLength, bLength);
    for(let i = 0; i < length; i++){
        const aValue = a[i];
        const bValue = b[i];
        if (aValue !== bValue) {
            return aValue - bValue;
        }
    }
    return aLength - bLength;
}
function utf16LengthForCodePoint(aCodePoint) {
    return aCodePoint > 0xffff ? 2 : 1;
}
// 2 preallocated arrays for utf8Bytes.
const arr = ()=>Array.from({
        length: 4
    }, ()=>0);
const aBytes = arr();
const bBytes = arr();
/**
 * @param {number} codePoint
 * @param {number[]} bytes
 * @returns {number}
 */ function utf8Bytes(codePoint, bytes) {
    if (codePoint < 0x80) {
        bytes[0] = codePoint;
        return 1;
    }
    let count;
    let offset;
    if (codePoint <= 0x07ff) {
        count = 1;
        offset = 0xc0;
    } else if (codePoint <= 0xffff) {
        count = 2;
        offset = 0xe0;
    } else if (codePoint <= 0x10ffff) {
        count = 3;
        offset = 0xf0;
    } else {
        throw new Error("Invalid code point");
    }
    bytes[0] = (codePoint >> 6 * count) + offset;
    let i = 1;
    for(; count > 0; count--){
        const temp = codePoint >> 6 * (count - 1);
        bytes[i++] = 0x80 | temp & 0x3f;
    }
    return i;
}
function greaterThan(a, b) {
    return compareUTF8(a, b) > 0;
}
function greaterThanEq(a, b) {
    return compareUTF8(a, b) >= 0;
}
function lessThan(a, b) {
    return compareUTF8(a, b) < 0;
}
function lessThanEq(a, b) {
    return compareUTF8(a, b) <= 0;
}
}),
"[project]/node_modules/.pnpm/@rocicorp+resolver@1.0.2/node_modules/@rocicorp/resolver/out/resolver.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolver",
    ()=>resolver
]);
function resolver() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
}),
"[project]/node_modules/.pnpm/@rocicorp+lock@1.0.4/node_modules/@rocicorp/lock/out/lock.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Lock",
    ()=>Lock,
    "RWLock",
    ()=>RWLock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@rocicorp+resolver@1.0.2/node_modules/@rocicorp/resolver/out/resolver.js [app-ssr] (ecmascript)");
;
class Lock {
    _lockP = null;
    async lock() {
        const previous = this._lockP;
        const { promise, resolve } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolver"])();
        this._lockP = promise;
        await previous;
        return resolve;
    }
    withLock(f) {
        return run(this.lock(), f);
    }
}
class RWLock {
    _lock = new Lock();
    _writeP = null;
    _readP = [];
    read() {
        return this._lock.withLock(async ()=>{
            await this._writeP;
            const { promise, resolve } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolver"])();
            this._readP.push(promise);
            return resolve;
        });
    }
    withRead(f) {
        return run(this.read(), f);
    }
    async write() {
        return await this._lock.withLock(async ()=>{
            await this._writeP;
            await Promise.all(this._readP);
            const { promise, resolve } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$rocicorp$2b$resolver$40$1$2e$0$2e$2$2f$node_modules$2f40$rocicorp$2f$resolver$2f$out$2f$resolver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolver"])();
            this._writeP = promise;
            this._readP = [];
            return resolve;
        });
    }
    withWrite(f) {
        return run(this.write(), f);
    }
}
async function run(p, f) {
    const release = await p;
    try {
        return await f();
    } finally{
        release();
    }
}
}),
"[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xxHash32",
    ()=>xxHash32
]);
const PRIME32_1 = 2654435761;
const PRIME32_2 = 2246822519;
const PRIME32_3 = 3266489917;
const PRIME32_4 = 668265263;
const PRIME32_5 = 374761393;
let encoder;
function xxHash32(input, seed = 0) {
    const buffer = typeof input === 'string' ? (encoder ??= new TextEncoder()).encode(input) : input;
    const b = buffer;
    /*
        Step 1. Initialize internal accumulators
        Each accumulator gets an initial value based on optional seed input. Since the seed is optional, it can be 0.

        ```
            u32 acc1 = seed + PRIME32_1 + PRIME32_2;
            u32 acc2 = seed + PRIME32_2;
            u32 acc3 = seed + 0;
            u32 acc4 = seed - PRIME32_1;
        ```
        Special case : input is less than 16 bytes
        When input is too small (< 16 bytes), the algorithm will not process any stripe. Consequently, it will not
        make use of parallel accumulators.

        In which case, a simplified initialization is performed, using a single accumulator :

        u32 acc  = seed + PRIME32_5;
        The algorithm then proceeds directly to step 4.
    */ let acc = seed + PRIME32_5 & 0xffffffff;
    let offset = 0;
    if (b.length >= 16) {
        const accN = [
            seed + PRIME32_1 + PRIME32_2 & 0xffffffff,
            seed + PRIME32_2 & 0xffffffff,
            seed + 0 & 0xffffffff,
            seed - PRIME32_1 & 0xffffffff
        ];
        /*
            Step 2. Process stripes
            A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 lanes, of 4 bytes each.
            The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.

            Each lane read its associated 32-bit value using little-endian convention.

            For each {lane, accumulator}, the update process is called a round, and applies the following formula :

            ```
            accN = accN + (laneN * PRIME32_2);
            accN = accN <<< 13;
            accN = accN * PRIME32_1;
            ```

            This shuffles the bits so that any bit from input lane impacts several bits in output accumulator.
            All operations are performed modulo 2^32.

            Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume
            the whole input, except the last remaining bytes which cannot form a stripe (< 16 bytes). When that
            happens, move to step 3.
        */ const b = buffer;
        const limit = b.length - 16;
        let lane = 0;
        for(offset = 0; (offset & 0xfffffff0) <= limit; offset += 4){
            const i = offset;
            const laneN0 = b[i + 0] + (b[i + 1] << 8);
            const laneN1 = b[i + 2] + (b[i + 3] << 8);
            const laneNP = laneN0 * PRIME32_2 + (laneN1 * PRIME32_2 << 16);
            let acc = accN[lane] + laneNP & 0xffffffff;
            acc = acc << 13 | acc >>> 19;
            const acc0 = acc & 0xffff;
            const acc1 = acc >>> 16;
            accN[lane] = acc0 * PRIME32_1 + (acc1 * PRIME32_1 << 16) & 0xffffffff;
            lane = lane + 1 & 0x3;
        }
        /*
            Step 3. Accumulator convergence
            All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator
            of same width (32-bit). The associated formula is as follows :

            ```
            acc = (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18);
            ```
        */ acc = (accN[0] << 1 | accN[0] >>> 31) + (accN[1] << 7 | accN[1] >>> 25) + (accN[2] << 12 | accN[2] >>> 20) + (accN[3] << 18 | accN[3] >>> 14) & 0xffffffff;
    }
    /*
        Step 4. Add input length
        The input total length is presumed known at this stage. This step is just about adding the length to
        accumulator, so that it participates to final mixing.

        ```
        acc = acc + (u32)inputLength;
        ```
    */ acc = acc + buffer.length & 0xffffffff;
    /*
        Step 5. Consume remaining input
        There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according
        to following pseudo-code :
        ```
        while (remainingLength >= 4) {
            lane = read_32bit_little_endian(input_ptr);
            acc = acc + lane * PRIME32_3;
            acc = (acc <<< 17) * PRIME32_4;
            input_ptr += 4; remainingLength -= 4;
        }
        ```
        This process ensures that all input bytes are present in the final mix.
    */ const limit = buffer.length - 4;
    for(; offset <= limit; offset += 4){
        const i = offset;
        const laneN0 = b[i + 0] + (b[i + 1] << 8);
        const laneN1 = b[i + 2] + (b[i + 3] << 8);
        const laneP = laneN0 * PRIME32_3 + (laneN1 * PRIME32_3 << 16);
        acc = acc + laneP & 0xffffffff;
        acc = acc << 17 | acc >>> 15;
        acc = (acc & 0xffff) * PRIME32_4 + ((acc >>> 16) * PRIME32_4 << 16) & 0xffffffff;
    }
    /*
        ```
        while (remainingLength >= 1) {
            lane = read_byte(input_ptr);
            acc = acc + lane * PRIME32_5;
            acc = (acc <<< 11) * PRIME32_1;
            input_ptr += 1; remainingLength -= 1;
        }
        ```
    */ for(; offset < b.length; ++offset){
        const lane = b[offset];
        acc = acc + lane * PRIME32_5;
        acc = acc << 11 | acc >>> 21;
        acc = (acc & 0xffff) * PRIME32_1 + ((acc >>> 16) * PRIME32_1 << 16) & 0xffffffff;
    }
    /*
        Step 6. Final mix (avalanche)
        The final mix ensures that all input bits have a chance to impact any bit in the output digest,
        resulting in an unbiased distribution. This is also called avalanche effect.
        ```
        acc = acc xor (acc >> 15);
        acc = acc * PRIME32_2;
        acc = acc xor (acc >> 13);
        acc = acc * PRIME32_3;
        acc = acc xor (acc >> 16);
        ```
    */ acc = acc ^ acc >>> 15;
    acc = ((acc & 0xffff) * PRIME32_2 & 0xffffffff) + ((acc >>> 16) * PRIME32_2 << 16);
    acc = acc ^ acc >>> 13;
    acc = ((acc & 0xffff) * PRIME32_3 & 0xffffffff) + ((acc >>> 16) * PRIME32_3 << 16);
    acc = acc ^ acc >>> 16;
    // turn any negatives back into a positive number;
    return acc < 0 ? acc + 4294967296 : acc;
} //# sourceMappingURL=xxHash32.js.map
}),
"[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$xxhash$40$4$2e$0$2e$0$2f$node_modules$2f$js$2d$xxhash$2f$dist$2f$esm$2f$xxHash32$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
;
}),
"[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/index.mjs [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$xxhash$40$4$2e$0$2e$0$2f$node_modules$2f$js$2d$xxhash$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
;
}),
"[project]/node_modules/.pnpm/@rocicorp+logger@5.4.0/node_modules/@rocicorp/logger/out/logger.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * A [[LogSink]] implementation that logs to multiple sinks.
 */ __turbopack_context__.s([
    "ConsoleLogger",
    ()=>ConsoleLogger,
    "FormatLogger",
    ()=>FormatLogger,
    "LogContext",
    ()=>LogContext,
    "OptionalLoggerImpl",
    ()=>OptionalLoggerImpl,
    "SilentLogger",
    ()=>SilentLogger,
    "TeeLogSink",
    ()=>TeeLogSink,
    "consoleLogSink",
    ()=>consoleLogSink,
    "logLevelPrefix",
    ()=>logLevelPrefix,
    "nodeConsoleLogSink",
    ()=>nodeConsoleLogSink
]);
class TeeLogSink {
    #sinks;
    constructor(sinks){
        this.#sinks = sinks;
    }
    log(level, context, ...args) {
        for (const logger of this.#sinks){
            logger.log(level, context, ...args);
        }
    }
    async flush() {
        await Promise.all(this.#sinks.map((logger)=>logger.flush?.()));
    }
}
class OptionalLoggerImpl {
    debug = undefined;
    info = undefined;
    warn = undefined;
    error = undefined;
    flush;
    constructor(logSink, level = 'info', context){
        const impl = (level)=>(...args)=>logSink.log(level, context, ...args);
        /* eslint-disable no-fallthrough , @typescript-eslint/ban-ts-comment */ switch(level){
            // @ts-ignore
            case 'debug':
                this.debug = impl('debug');
            // @ts-ignore
            case 'info':
                this.info = impl('info');
            // @ts-ignore
            case 'warn':
                this.warn = impl('warn');
            // @ts-ignore
            case 'error':
                this.error = impl('error');
        }
        /* eslint-enable @typescript-eslint/ban-ts-comment, no-fallthrough */ this.flush = ()=>logSink.flush?.() ?? Promise.resolve();
    }
}
class ConsoleLogger extends OptionalLoggerImpl {
    constructor(level, context){
        super(consoleLogSink, level, context);
    }
}
const consoleLogSink = {
    log (level, context, ...args) {
        console[level](...stringified(context), ...args.map(normalizeArgument));
    }
};
class FormatLogger {
    #format;
    constructor(format){
        this.#format = format;
    }
    log(level, context, ...args) {
        console[level](...this.#format(level, ...stringified(context), ...args));
    }
}
const nodeConsoleLogSink = {
    log (level, context, ...args) {
        console[level](logLevelPrefix[level], ...stringified(context), ...args.map(normalizeArgument));
    }
};
const logLevelPrefix = {
    error: 'ERR',
    warn: 'WRN',
    info: 'INF',
    debug: 'DBG'
};
class SilentLogger {
}
class LogContext extends OptionalLoggerImpl {
    #logSink;
    #level;
    #context;
    constructor(level = 'info', context, logSink = consoleLogSink){
        super(logSink, level, context);
        this.#level = level;
        this.#logSink = logSink;
        this.#context = context;
    }
    /**
     * Creates a new Logger that with the given key and value
     * added to the logged Context.
     */ withContext(key, value) {
        const ctx = {
            ...this.#context,
            [key]: value
        };
        return new LogContext(this.#level, ctx, this.#logSink);
    }
}
function stringified(context) {
    const args = [];
    for (const [k, v] of Object.entries(context ?? {})){
        const arg = v === undefined ? k : `${k}=${v}`;
        args.push(arg);
    }
    return args;
}
function normalizeArgument(v) {
    switch(typeof v){
        case 'string':
        case 'number':
        case 'boolean':
        case 'undefined':
        case 'symbol':
        case 'bigint':
            return v;
        case 'object':
            if (v === null) {
                return null;
            }
            break;
    }
    return JSON.stringify(v, errorReplacer);
}
function errorReplacer(_key, v) {
    if (v instanceof Error) {
        return {
            name: v.name,
            message: v.message,
            stack: v.stack,
            ...'cause' in v ? {
                cause: v.cause
            } : null
        };
    }
    return v;
}
}),
];

//# sourceMappingURL=node_modules__pnpm_9d1526e6._.js.map