{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/next%4015.5.4_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/next%4015.5.4_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,gOACRC,QAAQ,CAAC,YAAY,CAAEC,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/resolved-promises.ts"],"sourcesContent":["export const promiseTrue = Promise.resolve(true as const);\nexport const promiseFalse = Promise.resolve(false as const);\nexport const promiseUndefined = Promise.resolve(undefined);\nexport const promiseVoid = Promise.resolve();\n\n/**\n * A promise that never resolves.\n */\nexport const promiseNever = new Promise<never>(() => {});\n"],"names":[],"mappings":";;;;;;;;;;;AAAO,IAAM,cAAc,QAAQ,OAAA,CAAQ,IAAa;AACjD,IAAM,eAAe,QAAQ,OAAA,CAAQ,KAAc;AACnD,IAAM,mBAAmB,QAAQ,OAAA,CAAQ,KAAA,CAAS;AAClD,IAAM,cAAc,QAAQ,OAAA,CAAQ;AAKpC,IAAM,eAAe,IAAI,QAAe,KAAO,CAAD,AAAE","debugId":null}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/asserts.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/has-own.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/config.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/frozen-json.ts"],"sourcesContent":["export function assert(\n  b: unknown,\n  msg: string | (() => string) = 'Assertion failed',\n): asserts b {\n  if (!b) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport function assertString(v: unknown): asserts v is string {\n  assertType(v, 'string');\n}\n\nexport function assertNumber(v: unknown): asserts v is number {\n  assertType(v, 'number');\n}\n\nexport function assertBoolean(v: unknown): asserts v is boolean {\n  assertType(v, 'boolean');\n}\n\nfunction assertType(v: unknown, t: string) {\n  if (typeof v !== t) {\n    throwInvalidType(v, t);\n  }\n}\n\nexport function assertObject(v: unknown): asserts v is Record<string, unknown> {\n  if (v === null) {\n    throwInvalidType(v, 'object');\n  }\n  assertType(v, 'object');\n}\n\nexport function assertArray(v: unknown): asserts v is unknown[] {\n  if (!Array.isArray(v)) {\n    throwInvalidType(v, 'array');\n  }\n}\n\nexport function invalidType(v: unknown, t: string): string {\n  let s = 'Invalid type: ';\n  if (v === null || v === undefined) {\n    s += v;\n  } else {\n    s += `${typeof v} \\`${v}\\``;\n  }\n  return s + `, expected ${t}`;\n}\n\nexport function throwInvalidType(v: unknown, t: string): never {\n  throw new Error(invalidType(v, t));\n}\n\nexport function assertNotNull<T>(v: T | null): asserts v is T {\n  if (v === null) {\n    throw new Error('Expected non-null value');\n  }\n}\n\nexport function assertUndefined<T>(\n  v: T | undefined,\n  msg = 'Expected undefined value',\n): asserts v is T {\n  if (v !== undefined) {\n    throw new Error(msg);\n  }\n}\n\nexport function assertNotUndefined<T>(\n  v: T | undefined,\n  msg = 'Expected non undefined value',\n): asserts v is T {\n  if (v === undefined) {\n    throw new Error(msg);\n  }\n}\n\nexport function assertInstanceof<T>(\n  v: unknown,\n  t: new (...args: unknown[]) => T,\n): asserts v is T {\n  if (!(v instanceof t)) {\n    throw new Error(`Expected instanceof ${t.name}`);\n  }\n}\n\nexport function assertUint8Array(v: unknown): asserts v is Uint8Array {\n  assertInstanceof(v, Uint8Array);\n}\n\nexport function unreachable(): never;\nexport function unreachable(v: never): never;\nexport function unreachable(_?: never): never {\n  throw new Error('Unreachable');\n}\n\nexport function notImplemented(): never {\n  throw new Error('Not implemented');\n}\n","// hasOwn was added in ES2022\nexport const {hasOwn} = Object;\n","declare const process: {\n  env: {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    NODE_ENV?: string;\n  };\n};\n\nexport const isProd = process.env.NODE_ENV === 'production';\n\nexport {isProd as skipAssertJSONValue};\n","import {throwInvalidType} from '../../shared/src/asserts.ts';\nimport {skipAssertJSONValue} from '../../shared/src/config.ts';\nimport {hasOwn} from '../../shared/src/has-own.ts';\nimport type {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from '../../shared/src/json.ts';\nimport {skipFreeze, skipFrozenAsserts} from './config.ts';\nimport type {Cookie, FrozenCookie} from './cookies.ts';\n\ndeclare const frozenJSONTag: unique symbol;\n\n/**\n * Used to mark a type as having been frozen.\n */\nexport type FrozenTag<T> = T & {readonly [frozenJSONTag]: true};\n\nexport type FrozenJSONValue =\n  | null\n  | string\n  | boolean\n  | number\n  | FrozenJSONArray\n  | FrozenJSONObject;\n\ntype FrozenJSONArray = FrozenTag<ReadonlyArray<FrozenJSONValue>>;\n\nexport type FrozenJSONObject = FrozenTag<{\n  readonly [key: string]: FrozenJSONValue;\n}>;\n\n/**\n * We tag deep frozen objects in debug mode so that we do not have to deep\n * freeze an object more than once.\n */\nconst deepFrozenObjects = new WeakSet<object>();\n\n/**\n * Recursively freezes the passed in value (mutates it) and returns it.\n *\n * This is controlled by `skipFreeze` which is true in release mode.\n */\nexport function deepFreeze(v: Cookie): FrozenCookie;\nexport function deepFreeze(v: ReadonlyJSONValue): FrozenJSONValue;\nexport function deepFreeze(v: ReadonlyJSONValue): FrozenJSONValue {\n  if (skipFreeze) {\n    return v as FrozenJSONValue;\n  }\n\n  deepFreezeInternal(v, []);\n  return v as FrozenJSONValue;\n}\n\nfunction deepFreezeInternal(\n  v: ReadonlyJSONValue | undefined,\n  seen: object[],\n): void {\n  switch (typeof v) {\n    case 'undefined':\n      throw new TypeError('Unexpected value undefined');\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return;\n    case 'object': {\n      if (v === null) {\n        return;\n      }\n\n      if (deepFrozenObjects.has(v)) {\n        return;\n      }\n      deepFrozenObjects.add(v);\n\n      if (seen.includes(v)) {\n        throwInvalidType(v, 'Cyclic JSON object');\n      }\n\n      seen.push(v);\n\n      Object.freeze(v);\n      if (Array.isArray(v)) {\n        deepFreezeArray(v, seen);\n      } else {\n        deepFreezeObject(v as ReadonlyJSONObject, seen);\n      }\n      seen.pop();\n      return;\n    }\n\n    default:\n      throwInvalidType(v, 'JSON value');\n  }\n}\n\nfunction deepFreezeArray(\n  v: ReadonlyArray<ReadonlyJSONValue>,\n  seen: object[],\n): void {\n  for (const item of v) {\n    deepFreezeInternal(item, seen);\n  }\n}\n\nfunction deepFreezeObject(v: ReadonlyJSONObject, seen: object[]): void {\n  for (const k in v) {\n    if (hasOwn(v, k)) {\n      const value = v[k];\n      if (value !== undefined) {\n        deepFreezeInternal(value, seen);\n      }\n    }\n  }\n}\n\nexport function assertFrozenJSONValue(\n  v: unknown,\n): asserts v is FrozenJSONValue {\n  if (skipFrozenAsserts || skipAssertJSONValue) {\n    return;\n  }\n\n  switch (typeof v) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return;\n    case 'object':\n      if (v === null) {\n        return;\n      }\n\n      if (isDeepFrozen(v, [])) {\n        return;\n      }\n  }\n  throwInvalidType(v, 'JSON value');\n}\n\nexport function assertDeepFrozen<V>(v: V): asserts v is Readonly<V> {\n  if (skipFrozenAsserts) {\n    return;\n  }\n\n  if (!isDeepFrozen(v, [])) {\n    throw new Error('Expected frozen object');\n  }\n}\n\n/**\n * Recursive deep frozen check.\n *\n * It adds frozen objects to the {@link deepFrozenObjects} WeakSet so that we do\n * not have to check the same object more than once.\n */\nexport function isDeepFrozen(v: unknown, seen: object[]): boolean {\n  switch (typeof v) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return true;\n    case 'object':\n      if (v === null) {\n        return true;\n      }\n\n      if (deepFrozenObjects.has(v)) {\n        return true;\n      }\n\n      if (!Object.isFrozen(v)) {\n        return false;\n      }\n\n      if (seen.includes(v)) {\n        throwInvalidType(v, 'Cyclic JSON object');\n      }\n\n      seen.push(v);\n\n      if (Array.isArray(v)) {\n        for (const item of v) {\n          if (!isDeepFrozen(item, seen)) {\n            seen.pop();\n            return false;\n          }\n        }\n      } else {\n        for (const k in v) {\n          if (hasOwn(v, k)) {\n            const value = (v as Record<string, unknown>)[k];\n            if (value !== undefined && !isDeepFrozen(value, seen)) {\n              seen.pop();\n              return false;\n            }\n          }\n        }\n      }\n\n      deepFrozenObjects.add(v);\n      seen.pop();\n      return true;\n\n    default:\n      throwInvalidType(v, 'JSON value');\n  }\n}\n\nexport type P = Parameters<typeof deepFreeze>[0];\nexport type R = ReturnType<typeof deepFreeze>;\nexport function deepFreezeAllowUndefined(v: P | undefined): R | undefined {\n  if (v === undefined) {\n    return undefined;\n  }\n  return deepFreeze(v) as R;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,SAAS,OACd,CAAA,EACA,MAA+B,kBAAA,EACpB;IACX,IAAI,CAAC,GAAG;QACN,MAAM,IAAI,MAAM,OAAO,QAAQ,WAAW,MAAM,IAAI,CAAC;IACvD;AACF;AAEO,SAAS,aAAa,CAAA,EAAiC;IAC5D,WAAW,GAAG,QAAQ;AACxB;AAEO,SAAS,aAAa,CAAA,EAAiC;IAC5D,WAAW,GAAG,QAAQ;AACxB;AAEO,SAAS,cAAc,CAAA,EAAkC;IAC9D,WAAW,GAAG,SAAS;AACzB;AAEA,SAAS,WAAW,CAAA,EAAY,CAAA,EAAW;IACzC,IAAI,OAAO,MAAM,GAAG;QAClB,iBAAiB,GAAG,CAAC;IACvB;AACF;AAEO,SAAS,aAAa,CAAA,EAAkD;IAC7E,IAAI,MAAM,MAAM;QACd,iBAAiB,GAAG,QAAQ;IAC9B;IACA,WAAW,GAAG,QAAQ;AACxB;AAEO,SAAS,YAAY,CAAA,EAAoC;IAC9D,IAAI,CAAC,MAAM,OAAA,CAAQ,CAAC,GAAG;QACrB,iBAAiB,GAAG,OAAO;IAC7B;AACF;AAEO,SAAS,YAAY,CAAA,EAAY,CAAA,EAAmB;IACzD,IAAI,IAAI;IACR,IAAI,MAAM,QAAQ,MAAM,KAAA,GAAW;QACjC,KAAK;IACP,OAAO;QACL,KAAK,GAAG,OAAO,CAAC,CAAA,GAAA,EAAM,CAAC,CAAA,EAAA,CAAA;IACzB;IACA,OAAO,IAAI,CAAA,WAAA,EAAc,CAAC,EAAA;AAC5B;AAEO,SAAS,iBAAiB,CAAA,EAAY,CAAA,EAAkB;IAC7D,MAAM,IAAI,MAAM,YAAY,GAAG,CAAC,CAAC;AACnC;AAEO,SAAS,cAAiB,CAAA,EAA6B;IAC5D,IAAI,MAAM,MAAM;QACd,MAAM,IAAI,MAAM,yBAAyB;IAC3C;AACF;AAmCO,SAAS,YAAY,CAAA,EAAkB;IAC5C,MAAM,IAAI,MAAM,aAAa;AAC/B;;AC9FO,IAAM,EAAC,MAAA,CAAM,CAAA,GAAI;;ACMjB,IAAM,SAAS,QAAQ,IAAI,wCAAa;;AC4B/C,IAAM,oBAAoB,aAAA,GAAA,IAAI,QAAgB;AASvC,SAAS,WAAW,CAAA,EAAuC;IAChE,IAAI,QAAY;;IAIhB,mBAAmB,GAAG,CAAC,CAAC;IACxB,OAAO;AACT;AAEA,SAAS,mBACP,CAAA,EACA,IAAA,EACM;IACN,OAAQ,OAAO,GAAG;QAChB,KAAK;YACH,MAAM,IAAI,UAAU,4BAA4B;QAClD,KAAK;QACL,KAAK;QACL,KAAK;YACH;QACF,KAAK;YAAU;gBACb,IAAI,MAAM,MAAM;oBACd;gBACF;gBAEA,IAAI,kBAAkB,GAAA,CAAI,CAAC,GAAG;oBAC5B;gBACF;gBACA,kBAAkB,GAAA,CAAI,CAAC;gBAEvB,IAAI,KAAK,QAAA,CAAS,CAAC,GAAG;oBACpB,iBAAiB,GAAG,oBAAoB;gBAC1C;gBAEA,KAAK,IAAA,CAAK,CAAC;gBAEX,OAAO,MAAA,CAAO,CAAC;gBACf,IAAI,MAAM,OAAA,CAAQ,CAAC,GAAG;oBACpB,gBAAgB,GAAG,IAAI;gBACzB,OAAO;oBACL,iBAAiB,GAAyB,IAAI;gBAChD;gBACA,KAAK,GAAA,CAAI;gBACT;YACF;QAEA;YACE,iBAAiB,GAAG,YAAY;IACpC;AACF;AAEA,SAAS,gBACP,CAAA,EACA,IAAA,EACM;IACN,KAAA,MAAW,QAAQ,EAAG;QACpB,mBAAmB,MAAM,IAAI;IAC/B;AACF;AAEA,SAAS,iBAAiB,CAAA,EAAuB,IAAA,EAAsB;IACrE,IAAA,MAAW,KAAK,EAAG;QACjB,IAAI,OAAO,GAAG,CAAC,GAAG;YAChB,MAAM,QAAQ,CAAA,CAAE,CAAC,CAAA;YACjB,IAAI,UAAU,KAAA,GAAW;gBACvB,mBAAmB,OAAO,IAAI;YAChC;QACF;IACF;AACF;AA0BO,SAAS,iBAAoB,CAAA,EAAgC;IAClE,IAAI,QAAmB;;IAIvB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,GAAG;QACxB,MAAM,IAAI,MAAM,wBAAwB;IAC1C;AACF;AAQO,SAAS,aAAa,CAAA,EAAY,IAAA,EAAyB;IAChE,OAAQ,OAAO,GAAG;QAChB,KAAK;QACL,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;YACH,IAAI,MAAM,MAAM;gBACd,OAAO;YACT;YAEA,IAAI,kBAAkB,GAAA,CAAI,CAAC,GAAG;gBAC5B,OAAO;YACT;YAEA,IAAI,CAAC,OAAO,QAAA,CAAS,CAAC,GAAG;gBACvB,OAAO;YACT;YAEA,IAAI,KAAK,QAAA,CAAS,CAAC,GAAG;gBACpB,iBAAiB,GAAG,oBAAoB;YAC1C;YAEA,KAAK,IAAA,CAAK,CAAC;YAEX,IAAI,MAAM,OAAA,CAAQ,CAAC,GAAG;gBACpB,KAAA,MAAW,QAAQ,EAAG;oBACpB,IAAI,CAAC,aAAa,MAAM,IAAI,GAAG;wBAC7B,KAAK,GAAA,CAAI;wBACT,OAAO;oBACT;gBACF;YACF,OAAO;gBACL,IAAA,MAAW,KAAK,EAAG;oBACjB,IAAI,OAAO,GAAG,CAAC,GAAG;wBAChB,MAAM,QAAS,CAAA,CAA8B,CAAC,CAAA;wBAC9C,IAAI,UAAU,KAAA,KAAa,CAAC,aAAa,OAAO,IAAI,GAAG;4BACrD,KAAK,GAAA,CAAI;4BACT,OAAO;wBACT;oBACF;gBACF;YACF;YAEA,kBAAkB,GAAA,CAAI,CAAC;YACvB,KAAK,GAAA,CAAI;YACT,OAAO;QAET;YACE,iBAAiB,GAAG,YAAY;IACpC;AACF;AAIO,SAAS,yBAAyB,CAAA,EAAiC;IACxE,IAAI,MAAM,KAAA,GAAW;QACnB,OAAO,KAAA;IACT;IACA,OAAO,WAAW,CAAC;AACrB","debugId":null}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 288, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@badrap+valita@0.3.11/node_modules/@badrap/valita/dist/node-mjs/index.js","sourceRoot":"","sources":["../../src/index.ts"],"sourcesContent":[],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1670, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/compare-utf8%400.1.1/node_modules/compare-utf8/src/index.js"],"sourcesContent":["// @ts-check\n\n/**\n * Compares two JavaScript strings as if they were UTF-8 encoded byte arrays.\n * @param {string} a\n * @param {string} b\n * @returns {number}\n */\nexport function compareUTF8(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const length = Math.min(aLength, bLength);\n  for (let i = 0; i < length; ) {\n    const aCodePoint = /** @type {number} */ (a.codePointAt(i));\n    const bCodePoint = /** @type {number} */ (b.codePointAt(i));\n    if (aCodePoint !== bCodePoint) {\n      // Code points below 0x80 are represented the same way in UTF-8 as in\n      // UTF-16.\n      if (aCodePoint < 0x80 && bCodePoint < 0x80) {\n        return aCodePoint - bCodePoint;\n      }\n\n      // get the UTF-8 bytes for the code points\n      const aLength = utf8Bytes(aCodePoint, aBytes);\n      const bLength = utf8Bytes(bCodePoint, bBytes);\n      return compareArrays(aBytes, aLength, bBytes, bLength);\n    }\n\n    i += utf16LengthForCodePoint(aCodePoint);\n  }\n\n  return aLength - bLength;\n}\n\n/**\n * @param {number[]} a\n * @param {number} aLength\n * @param {number[]} b\n * @param {number} bLength\n * @returns {number}\n */\nfunction compareArrays(a, aLength, b, bLength) {\n  const length = Math.min(aLength, bLength);\n  for (let i = 0; i < length; i++) {\n    const aValue = a[i];\n    const bValue = b[i];\n    if (aValue !== bValue) {\n      return aValue - bValue;\n    }\n  }\n  return aLength - bLength;\n}\n\n/**\n * @param {number} aCodePoint\n * @returns {number}\n */\nexport function utf16LengthForCodePoint(aCodePoint) {\n  return aCodePoint > 0xffff ? 2 : 1;\n}\n\n// 2 preallocated arrays for utf8Bytes.\nconst arr = () => Array.from({ length: 4 }, () => 0);\nconst aBytes = arr();\nconst bBytes = arr();\n\n/**\n * @param {number} codePoint\n * @param {number[]} bytes\n * @returns {number}\n */\nfunction utf8Bytes(codePoint, bytes) {\n  if (codePoint < 0x80) {\n    bytes[0] = codePoint;\n    return 1;\n  }\n\n  let count;\n  let offset;\n\n  if (codePoint <= 0x07ff) {\n    count = 1;\n    offset = 0xc0;\n  } else if (codePoint <= 0xffff) {\n    count = 2;\n    offset = 0xe0;\n  } else if (codePoint <= 0x10ffff) {\n    count = 3;\n    offset = 0xf0;\n  } else {\n    throw new Error(\"Invalid code point\");\n  }\n\n  bytes[0] = (codePoint >> (6 * count)) + offset;\n  let i = 1;\n  for (; count > 0; count--) {\n    const temp = codePoint >> (6 * (count - 1));\n    bytes[i++] = 0x80 | (temp & 0x3f);\n  }\n  return i;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {boolean}\n */\nexport function greaterThan(a, b) {\n  return compareUTF8(a, b) > 0;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {boolean}\n */\nexport function greaterThanEq(a, b) {\n  return compareUTF8(a, b) >= 0;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {boolean}\n */\nexport function lessThan(a, b) {\n  return compareUTF8(a, b) < 0;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {boolean}\n */\nexport function lessThanEq(a, b) {\n  return compareUTF8(a, b) <= 0;\n}\n"],"names":[],"mappings":"AAAA,YAAY;AAEZ;;;;;CAKC;;;;;;;;;;;;;;AACM,SAAS,YAAY,CAAC,EAAE,CAAC;IAC9B,MAAM,UAAU,EAAE,MAAM;IACxB,MAAM,UAAU,EAAE,MAAM;IACxB,MAAM,SAAS,KAAK,GAAG,CAAC,SAAS;IACjC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAU;QAC5B,MAAM,aAAoC,EAAE,WAAW,CAAC;QACxD,MAAM,aAAoC,EAAE,WAAW,CAAC;QACxD,IAAI,eAAe,YAAY;YAC7B,qEAAqE;YACrE,UAAU;YACV,IAAI,aAAa,QAAQ,aAAa,MAAM;gBAC1C,OAAO,aAAa;YACtB;YAEA,0CAA0C;YAC1C,MAAM,UAAU,UAAU,YAAY;YACtC,MAAM,UAAU,UAAU,YAAY;YACtC,OAAO,cAAc,QAAQ,SAAS,QAAQ;QAChD;QAEA,KAAK,wBAAwB;IAC/B;IAEA,OAAO,UAAU;AACnB;AAEA;;;;;;CAMC,GACD,SAAS,cAAc,CAAC,EAAE,OAAO,EAAE,CAAC,EAAE,OAAO;IAC3C,MAAM,SAAS,KAAK,GAAG,CAAC,SAAS;IACjC,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC/B,MAAM,SAAS,CAAC,CAAC,EAAE;QACnB,MAAM,SAAS,CAAC,CAAC,EAAE;QACnB,IAAI,WAAW,QAAQ;YACrB,OAAO,SAAS;QAClB;IACF;IACA,OAAO,UAAU;AACnB;AAMO,SAAS,wBAAwB,UAAU;IAChD,OAAO,aAAa,SAAS,IAAI;AACnC;AAEA,uCAAuC;AACvC,MAAM,MAAM,IAAM,MAAM,IAAI,CAAC;QAAE,QAAQ;IAAE,GAAG,IAAM;AAClD,MAAM,SAAS;AACf,MAAM,SAAS;AAEf;;;;CAIC,GACD,SAAS,UAAU,SAAS,EAAE,KAAK;IACjC,IAAI,YAAY,MAAM;QACpB,KAAK,CAAC,EAAE,GAAG;QACX,OAAO;IACT;IAEA,IAAI;IACJ,IAAI;IAEJ,IAAI,aAAa,QAAQ;QACvB,QAAQ;QACR,SAAS;IACX,OAAO,IAAI,aAAa,QAAQ;QAC9B,QAAQ;QACR,SAAS;IACX,OAAO,IAAI,aAAa,UAAU;QAChC,QAAQ;QACR,SAAS;IACX,OAAO;QACL,MAAM,IAAI,MAAM;IAClB;IAEA,KAAK,CAAC,EAAE,GAAG,CAAC,aAAc,IAAI,KAAM,IAAI;IACxC,IAAI,IAAI;IACR,MAAO,QAAQ,GAAG,QAAS;QACzB,MAAM,OAAO,aAAc,IAAI,CAAC,QAAQ,CAAC;QACzC,KAAK,CAAC,IAAI,GAAG,OAAQ,OAAO;IAC9B;IACA,OAAO;AACT;AAOO,SAAS,YAAY,CAAC,EAAE,CAAC;IAC9B,OAAO,YAAY,GAAG,KAAK;AAC7B;AAOO,SAAS,cAAc,CAAC,EAAE,CAAC;IAChC,OAAO,YAAY,GAAG,MAAM;AAC9B;AAOO,SAAS,SAAS,CAAC,EAAE,CAAC;IAC3B,OAAO,YAAY,GAAG,KAAK;AAC7B;AAOO,SAAS,WAAW,CAAC,EAAE,CAAC;IAC7B,OAAO,YAAY,GAAG,MAAM;AAC9B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1785, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bresolver%401.0.2/node_modules/%40rocicorp/resolver/out/resolver.js"],"sourcesContent":["export function resolver() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS;IACZ,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;QAC9B,UAAU;QACV,SAAS;IACb;IACA,OAAO;QAAE;QAAS;QAAS;IAAO;AACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Block%401.0.4/node_modules/%40rocicorp/lock/out/lock.js"],"sourcesContent":["import { resolver } from '@rocicorp/resolver';\nexport class Lock {\n    _lockP = null;\n    async lock() {\n        const previous = this._lockP;\n        const { promise, resolve } = resolver();\n        this._lockP = promise;\n        await previous;\n        return resolve;\n    }\n    withLock(f) {\n        return run(this.lock(), f);\n    }\n}\nexport class RWLock {\n    _lock = new Lock();\n    _writeP = null;\n    _readP = [];\n    read() {\n        return this._lock.withLock(async () => {\n            await this._writeP;\n            const { promise, resolve } = resolver();\n            this._readP.push(promise);\n            return resolve;\n        });\n    }\n    withRead(f) {\n        return run(this.read(), f);\n    }\n    async write() {\n        return await this._lock.withLock(async () => {\n            await this._writeP;\n            await Promise.all(this._readP);\n            const { promise, resolve } = resolver();\n            this._writeP = promise;\n            this._readP = [];\n            return resolve;\n        });\n    }\n    withWrite(f) {\n        return run(this.write(), f);\n    }\n}\nasync function run(p, f) {\n    const release = await p;\n    try {\n        return await f();\n    }\n    finally {\n        release();\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AACO,MAAM;IACT,SAAS,KAAK;IACd,MAAM,OAAO;QACT,MAAM,WAAW,IAAI,CAAC,MAAM;QAC5B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,IAAA,wOAAQ;QACrC,IAAI,CAAC,MAAM,GAAG;QACd,MAAM;QACN,OAAO;IACX;IACA,SAAS,CAAC,EAAE;QACR,OAAO,IAAI,IAAI,CAAC,IAAI,IAAI;IAC5B;AACJ;AACO,MAAM;IACT,QAAQ,IAAI,OAAO;IACnB,UAAU,KAAK;IACf,SAAS,EAAE,CAAC;IACZ,OAAO;QACH,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YACvB,MAAM,IAAI,CAAC,OAAO;YAClB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,IAAA,wOAAQ;YACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YACjB,OAAO;QACX;IACJ;IACA,SAAS,CAAC,EAAE;QACR,OAAO,IAAI,IAAI,CAAC,IAAI,IAAI;IAC5B;IACA,MAAM,QAAQ;QACV,OAAO,MAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YAC7B,MAAM,IAAI,CAAC,OAAO;YAClB,MAAM,QAAQ,GAAG,CAAC,IAAI,CAAC,MAAM;YAC7B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,IAAA,wOAAQ;YACrC,IAAI,CAAC,OAAO,GAAG;YACf,IAAI,CAAC,MAAM,GAAG,EAAE;YAChB,OAAO;QACX;IACJ;IACA,UAAU,CAAC,EAAE;QACT,OAAO,IAAI,IAAI,CAAC,KAAK,IAAI;IAC7B;AACJ;AACA,eAAe,IAAI,CAAC,EAAE,CAAC;IACnB,MAAM,UAAU,MAAM;IACtB,IAAI;QACA,OAAO,MAAM;IACjB,SACQ;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1868, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/js-xxhash%404.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js"],"sourcesContent":["const PRIME32_1 = 2654435761;\nconst PRIME32_2 = 2246822519;\nconst PRIME32_3 = 3266489917;\nconst PRIME32_4 = 668265263;\nconst PRIME32_5 = 374761393;\nlet encoder;\n/**\n *\n * @param input - byte array or string\n * @param seed - optional seed (32-bit unsigned);\n */\nexport function xxHash32(input, seed = 0) {\n    const buffer = typeof input === 'string' ? (encoder ??= new TextEncoder()).encode(input) : input;\n    const b = buffer;\n    /*\n        Step 1. Initialize internal accumulators\n        Each accumulator gets an initial value based on optional seed input. Since the seed is optional, it can be 0.\n\n        ```\n            u32 acc1 = seed + PRIME32_1 + PRIME32_2;\n            u32 acc2 = seed + PRIME32_2;\n            u32 acc3 = seed + 0;\n            u32 acc4 = seed - PRIME32_1;\n        ```\n        Special case : input is less than 16 bytes\n        When input is too small (< 16 bytes), the algorithm will not process any stripe. Consequently, it will not\n        make use of parallel accumulators.\n\n        In which case, a simplified initialization is performed, using a single accumulator :\n\n        u32 acc  = seed + PRIME32_5;\n        The algorithm then proceeds directly to step 4.\n    */\n    let acc = (seed + PRIME32_5) & 0xffffffff;\n    let offset = 0;\n    if (b.length >= 16) {\n        const accN = [\n            (seed + PRIME32_1 + PRIME32_2) & 0xffffffff,\n            (seed + PRIME32_2) & 0xffffffff,\n            (seed + 0) & 0xffffffff,\n            (seed - PRIME32_1) & 0xffffffff,\n        ];\n        /*\n            Step 2. Process stripes\n            A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 lanes, of 4 bytes each.\n            The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.\n\n            Each lane read its associated 32-bit value using little-endian convention.\n\n            For each {lane, accumulator}, the update process is called a round, and applies the following formula :\n\n            ```\n            accN = accN + (laneN * PRIME32_2);\n            accN = accN <<< 13;\n            accN = accN * PRIME32_1;\n            ```\n\n            This shuffles the bits so that any bit from input lane impacts several bits in output accumulator.\n            All operations are performed modulo 2^32.\n\n            Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume\n            the whole input, except the last remaining bytes which cannot form a stripe (< 16 bytes). When that\n            happens, move to step 3.\n        */\n        const b = buffer;\n        const limit = b.length - 16;\n        let lane = 0;\n        for (offset = 0; (offset & 0xfffffff0) <= limit; offset += 4) {\n            const i = offset;\n            const laneN0 = b[i + 0] + (b[i + 1] << 8);\n            const laneN1 = b[i + 2] + (b[i + 3] << 8);\n            const laneNP = laneN0 * PRIME32_2 + ((laneN1 * PRIME32_2) << 16);\n            let acc = (accN[lane] + laneNP) & 0xffffffff;\n            acc = (acc << 13) | (acc >>> 19);\n            const acc0 = acc & 0xffff;\n            const acc1 = acc >>> 16;\n            accN[lane] = (acc0 * PRIME32_1 + ((acc1 * PRIME32_1) << 16)) & 0xffffffff;\n            lane = (lane + 1) & 0x3;\n        }\n        /*\n            Step 3. Accumulator convergence\n            All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator\n            of same width (32-bit). The associated formula is as follows :\n\n            ```\n            acc = (acc1 <<< 1) + (acc2 <<< 7) + (acc3 <<< 12) + (acc4 <<< 18);\n            ```\n        */\n        acc =\n            (((accN[0] << 1) | (accN[0] >>> 31)) +\n                ((accN[1] << 7) | (accN[1] >>> 25)) +\n                ((accN[2] << 12) | (accN[2] >>> 20)) +\n                ((accN[3] << 18) | (accN[3] >>> 14))) &\n                0xffffffff;\n    }\n    /*\n        Step 4. Add input length\n        The input total length is presumed known at this stage. This step is just about adding the length to\n        accumulator, so that it participates to final mixing.\n\n        ```\n        acc = acc + (u32)inputLength;\n        ```\n    */\n    acc = (acc + buffer.length) & 0xffffffff;\n    /*\n        Step 5. Consume remaining input\n        There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according\n        to following pseudo-code :\n        ```\n        while (remainingLength >= 4) {\n            lane = read_32bit_little_endian(input_ptr);\n            acc = acc + lane * PRIME32_3;\n            acc = (acc <<< 17) * PRIME32_4;\n            input_ptr += 4; remainingLength -= 4;\n        }\n        ```\n        This process ensures that all input bytes are present in the final mix.\n    */\n    const limit = buffer.length - 4;\n    for (; offset <= limit; offset += 4) {\n        const i = offset;\n        const laneN0 = b[i + 0] + (b[i + 1] << 8);\n        const laneN1 = b[i + 2] + (b[i + 3] << 8);\n        const laneP = laneN0 * PRIME32_3 + ((laneN1 * PRIME32_3) << 16);\n        acc = (acc + laneP) & 0xffffffff;\n        acc = (acc << 17) | (acc >>> 15);\n        acc = ((acc & 0xffff) * PRIME32_4 + (((acc >>> 16) * PRIME32_4) << 16)) & 0xffffffff;\n    }\n    /*\n        ```\n        while (remainingLength >= 1) {\n            lane = read_byte(input_ptr);\n            acc = acc + lane * PRIME32_5;\n            acc = (acc <<< 11) * PRIME32_1;\n            input_ptr += 1; remainingLength -= 1;\n        }\n        ```\n    */\n    for (; offset < b.length; ++offset) {\n        const lane = b[offset];\n        acc = acc + lane * PRIME32_5;\n        acc = (acc << 11) | (acc >>> 21);\n        acc = ((acc & 0xffff) * PRIME32_1 + (((acc >>> 16) * PRIME32_1) << 16)) & 0xffffffff;\n    }\n    /*\n        Step 6. Final mix (avalanche)\n        The final mix ensures that all input bits have a chance to impact any bit in the output digest,\n        resulting in an unbiased distribution. This is also called avalanche effect.\n        ```\n        acc = acc xor (acc >> 15);\n        acc = acc * PRIME32_2;\n        acc = acc xor (acc >> 13);\n        acc = acc * PRIME32_3;\n        acc = acc xor (acc >> 16);\n        ```\n    */\n    acc = acc ^ (acc >>> 15);\n    acc = (((acc & 0xffff) * PRIME32_2) & 0xffffffff) + (((acc >>> 16) * PRIME32_2) << 16);\n    acc = acc ^ (acc >>> 13);\n    acc = (((acc & 0xffff) * PRIME32_3) & 0xffffffff) + (((acc >>> 16) * PRIME32_3) << 16);\n    acc = acc ^ (acc >>> 16);\n    // turn any negatives back into a positive number;\n    return acc < 0 ? acc + 4294967296 : acc;\n}\n//# sourceMappingURL=xxHash32.js.map"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2024, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/js-xxhash%404.0.0/node_modules/js-xxhash/dist/esm/index.js"],"sourcesContent":["export { xxHash32 } from './xxHash32.js';\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":";AAAA,mWACA,iCAAiC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2031, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/js-xxhash%404.0.0/node_modules/js-xxhash/index.mjs"],"sourcesContent":["export { xxHash32 } from './dist/esm/index.js';\n"],"names":[],"mappings":";AAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/format-version-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/valita.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/with-transactions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/chunk.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/random-uint64.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/hash.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/index-defs.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/client-groups.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/json.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/size-of-value.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/btree/node.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/binary-search.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/iterables.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/btree/splice.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/btree/read.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/string-compare.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/cookies.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/meta-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/commit.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/index-operation-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/index.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/read.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/async-iterable-to-array.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/btree/diff.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/btree/write.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/lazy.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/diff.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/write.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/ids.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/make-client-id.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/clients.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/objects.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/must.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/data.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/view-apply-change.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/ttl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/json-schema.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/tdigest-schema.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/ast.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/arrays.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/data.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/inspect-down.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/random-values.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/util/nanoid.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/hash.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/primary-key.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/keys.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/centroid.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/tdigest.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/table-schema.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/query.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/query-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/query-hash.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/filter-operators.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/operator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/stream.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/exists.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/fan-in.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/fan-out.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/maybe-split-and-push-edit-change.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/filter-push.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/filter.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/join.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/skip.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/take.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/expression.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/builder/like.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/builder/filter.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/builder/builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/array-view.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/assert-no-not-exists.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const SDD = 4;\nexport const DD31 = 5;\n// V6 added refreshHashes and persistHash to Client to fix ChunkNotFound errors\nexport const V6 = 6;\n// V7 added sizeOfEntry to the BTree chunk data.\nexport const V7 = 7;\nexport const Latest = V7;\n\nexport type SDD = typeof SDD;\nexport type DD31 = typeof DD31;\nexport type V6 = typeof V6;\nexport type V7 = typeof V7;\nexport type Latest = typeof Latest;\n","import * as v from '@badrap/valita';\n\nexport * from '@badrap/valita';\n\nfunction toDisplay(value: unknown): string {\n  switch (typeof value) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return JSON.stringify(value);\n    case 'undefined':\n      return 'undefined';\n    case 'bigint':\n      return value.toString() + 'n';\n    default:\n      if (value === null) {\n        return 'null';\n      }\n      if (Array.isArray(value)) {\n        return 'array';\n      }\n      return typeof value;\n  }\n}\n\ntype Key = string | number;\n\nfunction toDisplayAtPath(v: unknown, path: Key[] | undefined): string {\n  if (!path?.length) {\n    return toDisplay(v);\n  }\n\n  let cur = v;\n  for (const p of path) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    cur = (cur as any)[p];\n  }\n  return toDisplay(cur);\n}\n\nfunction displayList<T>(\n  word: string,\n  expected: T[],\n  toDisplay: (x: T) => string | number = x => String(x),\n): string | number {\n  if (expected.length === 1) {\n    return toDisplay(expected[0]);\n  }\n\n  const suffix = `${toDisplay(\n    expected[expected.length - 2],\n  )} ${word} ${toDisplay(expected[expected.length - 1])}`;\n  if (expected.length === 2) {\n    return suffix;\n  }\n  return `${expected.slice(0, -2).map(toDisplay).join(', ')}, ${suffix}`;\n}\n\nfunction getMessage(\n  err: v.Err | v.ValitaError,\n  v: unknown,\n  schema: v.Type | v.Optional,\n  mode: ParseOptionsMode | undefined,\n): string {\n  const firstIssue = err.issues[0];\n  const {path} = firstIssue;\n  const atPath = path?.length ? ` at ${path.join('.')}` : '';\n\n  switch (firstIssue.code) {\n    case 'invalid_type':\n      return `Expected ${displayList(\n        'or',\n        firstIssue.expected,\n      )}${atPath}. Got ${toDisplayAtPath(v, path)}`;\n    case 'missing_value': {\n      const atPath =\n        path && path.length > 1 ? ` at ${path.slice(0, -1).join('.')}` : '';\n\n      if (firstIssue.path?.length) {\n        return `Missing property ${firstIssue.path.at(-1)}${atPath}`;\n      }\n      return `TODO Unknown missing property${atPath}`;\n    }\n\n    case 'invalid_literal':\n      return `Expected literal value ${displayList(\n        'or',\n        firstIssue.expected,\n        toDisplay,\n      )}${atPath} Got ${toDisplayAtPath(v, path)}`;\n\n    case 'invalid_length': {\n      return `Expected array with length ${\n        firstIssue.minLength === firstIssue.maxLength\n          ? firstIssue.minLength\n          : `between ${firstIssue.minLength} and ${firstIssue.maxLength}`\n      }${atPath}. Got array with length ${(v as {length: number}).length}`;\n    }\n\n    case 'unrecognized_keys':\n      if (firstIssue.keys.length === 1) {\n        return `Unexpected property ${firstIssue.keys[0]}${atPath}`;\n      }\n      return `Unexpected properties ${displayList(\n        'and',\n        firstIssue.keys,\n      )}${atPath}`;\n\n    case 'invalid_union':\n      return schema.name === 'union'\n        ? getDeepestUnionParseError(v, schema as v.UnionType, mode ?? 'strict')\n        : `Invalid union value${atPath}`;\n\n    case 'custom_error': {\n      const {error} = firstIssue;\n      const message = !error\n        ? 'unknown'\n        : typeof error === 'string'\n          ? error\n          : (error.message ?? 'unknown');\n      return `${message}${atPath}. Got ${toDisplayAtPath(v, path)}`;\n    }\n  }\n}\n\ntype FailedType = {type: v.Type; err: v.Err};\n\nfunction getDeepestUnionParseError(\n  value: unknown,\n  schema: v.UnionType,\n  mode: ParseOptionsMode,\n): string {\n  const failures: FailedType[] = [];\n  for (const type of schema.options) {\n    const r = type.try(value, {mode});\n    if (!r.ok) {\n      failures.push({type, err: r});\n    }\n  }\n  if (failures.length) {\n    // compare the first and second longest-path errors\n    failures.sort(pathCmp);\n    if (failures.length === 1 || pathCmp(failures[0], failures[1]) < 0) {\n      return getMessage(failures[0].err, value, failures[0].type, mode);\n    }\n  }\n  // paths are equivalent\n  try {\n    const str = JSON.stringify(value);\n    return `Invalid union value: ${str}`;\n  } catch (e) {\n    // fallback if the value could not be stringified\n    return `Invalid union value`;\n  }\n}\n\n// Descending-order comparison of Issue paths.\n// * [1, 'a'] sorts before [1]\n// * [1] sorts before [0]  (i.e. errors later in the tuple sort before earlier errors)\nfunction pathCmp(a: FailedType, b: FailedType) {\n  const aPath = a.err.issues[0].path;\n  const bPath = b.err.issues[0].path;\n  if (aPath.length !== bPath.length) {\n    return bPath.length - aPath.length;\n  }\n  for (let i = 0; i < aPath.length; i++) {\n    if (bPath[i] > aPath[i]) {\n      return -1;\n    }\n    if (bPath[i] < aPath[i]) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/**\n * 'strip' allows unknown properties and removes unknown properties.\n * 'strict' errors if there are unknown properties.\n * 'passthrough' allows unknown properties.\n */\nexport type ParseOptionsMode = 'passthrough' | 'strict' | 'strip';\n\nexport function parse<T>(\n  value: unknown,\n  schema: v.Type<T>,\n  mode?: ParseOptionsMode,\n): T {\n  const res = test(value, schema, mode);\n  if (!res.ok) {\n    throw new TypeError(res.error);\n  }\n  return res.value;\n}\n\nexport function is<T>(\n  value: unknown,\n  schema: v.Type<T>,\n  mode?: ParseOptionsMode,\n): value is T {\n  return test(value, schema, mode).ok;\n}\n\nexport function assert<T>(\n  value: unknown,\n  schema: v.Type<T>,\n  mode?: ParseOptionsMode,\n): asserts value is T {\n  parse(value, schema, mode);\n}\n\ntype Result<T> = {ok: true; value: T} | {ok: false; error: string};\n\nexport function test<T>(\n  value: unknown,\n  schema: v.Type<T>,\n  mode?: ParseOptionsMode,\n): Result<T> {\n  const res = schema.try(value, mode ? {mode} : undefined);\n  if (!res.ok) {\n    return {\n      ok: false,\n      error: getMessage(res, value, schema, mode),\n    };\n  }\n  return res;\n}\n\n/**\n * Similar to {@link test} but works for AbstractTypes such as Optional.\n * This is for advanced usage. Prefer {@link test} unless you really need\n * to operate directly on an Optional field.\n */\nexport function testOptional<T>(\n  value: unknown,\n  schema: v.Type<T> | v.Optional<T>,\n  mode?: ParseOptionsMode,\n): Result<T | undefined> {\n  let flags = 0x1; // FLAG_FORBID_EXTRA_KEYS;\n  if (mode === 'passthrough') {\n    flags = 0;\n  } else if (mode === 'strip') {\n    flags = 0x2; // FLAG_STRIP_EXTRA_KEYS;\n  }\n  const res = schema.func(value, flags);\n  if (res === undefined) {\n    return {ok: true, value} as Result<T>;\n  } else if (res.ok) {\n    return res;\n  }\n  const err = new v.ValitaError(res);\n  return {ok: false, error: getMessage(err, value, schema, mode)};\n}\n\n/**\n * Shallowly marks the schema as readonly.\n */\nexport function readonly<T extends v.Type>(t: T): v.Type<Readonly<v.Infer<T>>> {\n  return t as v.Type<Readonly<v.Infer<T>>>;\n}\n\nexport function readonlyObject<T extends Record<string, v.Type | v.Optional>>(\n  t: T,\n): v.ObjectType<Readonly<T>, undefined> {\n  return v.object(t);\n}\n\nexport function readonlyArray<T extends v.Type>(\n  t: T,\n): v.Type<readonly v.Infer<T>[]> {\n  return v.array(t);\n}\n\nexport function readonlyRecord<T extends v.Type>(\n  t: T,\n): v.Type<Readonly<Record<string, v.Infer<T>>>> {\n  return v.record(t);\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst AbstractType = Object.getPrototypeOf(\n  Object.getPrototypeOf(v.string().optional()),\n).constructor;\n\nexport function instanceOfAbstractType<T = unknown>(\n  obj: unknown,\n): obj is v.Type<T> | v.Optional<T> {\n  return obj instanceof AbstractType;\n}\n\ntype ObjectShape = Record<string, typeof AbstractType>;\n\n/**\n * Similar to `ObjectType.partial()` except it recurses into nested objects.\n * Rest types are not supported.\n */\nexport function deepPartial<Shape extends ObjectShape>(\n  s: v.ObjectType<Shape, undefined>,\n) {\n  const shape = {} as Record<string, unknown>;\n  for (const [key, type] of Object.entries(s.shape)) {\n    if (type.name === 'object') {\n      shape[key] = deepPartial(type as v.ObjectType).optional();\n    } else {\n      shape[key] = type.optional();\n    }\n  }\n  return v.object(shape as {[K in keyof Shape]: v.Optional<v.Infer<Shape[K]>>});\n}\n\ntype Literal = string | number | bigint | boolean;\n\nexport function literalUnion<T extends [...Literal[]]>(\n  ...literals: T\n): v.Type<T[number]> {\n  return v.union(...literals.map(v.literal));\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport type {Hash} from '../hash.ts';\nimport type {Release} from '../with-transactions.ts';\nimport type {Chunk, Refs} from './chunk.ts';\n\nexport interface Store {\n  read(): Promise<Read>;\n  write(): Promise<Write>;\n  close(): Promise<void>;\n}\n\ninterface GetChunk {\n  getChunk(hash: Hash): Promise<Chunk | undefined>;\n}\n\nexport interface MustGetChunk {\n  mustGetChunk(hash: Hash): Promise<Chunk>;\n}\n\nexport interface Read extends GetChunk, MustGetChunk, Release {\n  hasChunk(hash: Hash): Promise<boolean>;\n  getHead(name: string): Promise<Hash | undefined>;\n  get closed(): boolean;\n}\n\nexport interface Write extends Read {\n  createChunk<V>(data: V, refs: Refs): Chunk<V>;\n  putChunk<V>(c: Chunk<V>): Promise<void>;\n  setHead(name: string, hash: Hash): Promise<void>;\n  removeHead(name: string): Promise<void>;\n  assertValidHash(hash: Hash): void;\n  commit(): Promise<void>;\n}\n\nexport class ChunkNotFoundError extends Error {\n  name = 'ChunkNotFoundError';\n  readonly hash: Hash;\n  constructor(hash: Hash) {\n    super(`Chunk not found ${hash}`);\n    this.hash = hash;\n  }\n}\n\nexport async function mustGetChunk(\n  store: GetChunk,\n  hash: Hash,\n): Promise<Chunk> {\n  const chunk = await store.getChunk(hash);\n  if (chunk) {\n    return chunk;\n  }\n  throw new ChunkNotFoundError(hash);\n}\n\nexport async function mustGetHeadHash(\n  name: string,\n  store: Read,\n): Promise<Hash> {\n  const hash = await store.getHead(name);\n  assert(hash, `Missing head ${name}`);\n  return hash;\n}\n","export interface Release {\n  release(): void;\n}\n\nexport interface Commit {\n  commit(): Promise<void>;\n}\n\ninterface ReadStore<Read extends Release> {\n  read(): Promise<Read>;\n}\n\ninterface WriteStore<Write extends Release> {\n  write(): Promise<Write>;\n}\n\nexport function withRead<Read extends Release, Return>(\n  store: ReadStore<Read>,\n  fn: (read: Read) => Return | Promise<Return>,\n): Promise<Return> {\n  return using(store.read(), fn);\n}\n\nexport function withWriteNoImplicitCommit<Write extends Release, Return>(\n  store: WriteStore<Write>,\n  fn: (write: Write) => Return | Promise<Return>,\n): Promise<Return> {\n  return using(store.write(), fn);\n}\n\nexport function withWrite<Write extends Release & Commit, Return>(\n  store: WriteStore<Write>,\n  fn: (write: Write) => Return | Promise<Return>,\n): Promise<Return> {\n  return using(store.write(), async write => {\n    const result = await fn(write);\n    await write.commit();\n    return result;\n  });\n}\n\n/**\n * This function takes a promise for a resource and a function that uses that\n * resource. It will release the resource after the function returns by calling\n * the `release` function\n */\nexport async function using<TX extends Release, Return>(\n  x: Promise<TX>,\n  fn: (tx: TX) => Return | Promise<Return>,\n): Promise<Return> {\n  const write = await x;\n  try {\n    return await fn(write);\n  } finally {\n    write.release();\n  }\n}\n","import {assert, assertString} from '../../../shared/src/asserts.ts';\nimport {assertDeepFrozen} from '../frozen-json.ts';\nimport type {Hash} from '../hash.ts';\n\n// By using declare we tell the type system that there is a unique symbol.\n// However, there is no such symbol but the type system does not care.\ndeclare const refsTag: unique symbol;\n\n/**\n * Opaque type representing a Refs. The reason to use an opaque type here is to\n * make sure that Refs are always sorted and have no duplicates.\n */\nexport type Refs = [] | readonly [Hash] | (readonly Hash[] & {[refsTag]: true});\n\n/**\n * Convert to a Refs when we already know it is sorted and has no duplicates.\n */\nexport function asRefs(sortedRefs: Hash[]): Refs {\n  return sortedRefs as unknown as Refs;\n}\n\n/**\n * Sorts and tags as Refs. If an Array is passed in the array is sorted in\n * place, otherwise a copy of the iterable is created. This checks for duplicates.\n */\nexport function toRefs(refs: Hash[] | Set<Hash>): Refs {\n  if (Array.isArray(refs)) {\n    refs.sort();\n    for (let i = 1; i < refs.length; i++) {\n      assert(refs[i - 1] !== refs[i], 'Refs must not have duplicates');\n    }\n    return asRefs(refs);\n  }\n\n  const refsArray = [...refs];\n  refsArray.sort();\n  // no need to check for duplicates as Set cannot have duplicates.\n  return asRefs(refsArray);\n}\n\nexport class Chunk<V = unknown> {\n  readonly hash: Hash;\n  readonly data: V;\n\n  /**\n   * Meta is an array of refs. If there are no refs we do not write a meta\n   * chunk.\n   */\n  readonly meta: Refs;\n\n  constructor(hash: Hash, data: V, refs: Refs) {\n    assert(\n      !(refs as unknown[]).includes(hash),\n      'Chunk cannot reference itself',\n    );\n    assertDeepFrozen(data);\n    this.hash = hash;\n    this.data = data;\n    this.meta = refs;\n  }\n}\n\nexport function assertRefs(v: unknown): asserts v is Refs {\n  if (!Array.isArray(v)) {\n    throw new Error('Refs must be an array');\n  }\n  if (v.length > 0) {\n    assertString(v[0]);\n    for (let i = 1; i < v.length; i++) {\n      assertString(v[i]);\n    }\n  }\n}\n\nexport function createChunk<V>(\n  data: V,\n  refs: Refs,\n  chunkHasher: ChunkHasher,\n): Chunk<V> {\n  const hash = chunkHasher();\n  return new Chunk(hash, data, refs);\n}\n\nexport type CreateChunk = <V>(data: V, refs: Refs) => Chunk<V>;\n\nexport type ChunkHasher = () => Hash;\n\nexport function throwChunkHasher(): Hash {\n  throw new Error('unexpected call to compute chunk hash');\n}\n","export function randomUint64(): bigint {\n  // Generate two random 32-bit unsigned integers using Math.random()\n  const high = Math.floor(Math.random() * 0xffffffff); // High 32 bits\n  const low = Math.floor(Math.random() * 0xffffffff); // Low 32 bits\n\n  // Combine the high and low parts to form a 64-bit unsigned integer\n  return (BigInt(high) << 32n) | BigInt(low);\n}\n","import {assert} from '../../shared/src/asserts.ts';\nimport {randomUint64} from '../../shared/src/random-uint64.ts';\nimport * as valita from '../../shared/src/valita.ts';\n\nexport const STRING_LENGTH = 22;\n\n// We use an opaque type so that we can make sure that a hash is always a hash.\n// TypeScript does not have direct support but we can use a trick described\n// here:\n//\n// https://evertpot.com/opaque-ts-types/\n//\n// The basic idea is to declare a type that cannot be created. We then use\n// functions that cast a string to this type.\n//\n\n// By using declare we tell the type system that there is a unique symbol.\n// However, there is no such symbol but the type system does not care.\ndeclare const hashTag: unique symbol;\n\n/**\n * Opaque type representing a hash. The only way to create one is using `parse`\n * or `hashOf` (except for static unsafe cast of course).\n */\nexport type Hash = string & {[hashTag]: true};\n\n// We are no longer using hashes but due to legacy reason we still refer to\n// them as hashes. We use UUID and counters instead.\nconst hashRe = /^[0-9a-v-]+$/;\n\nexport function parse(s: string): Hash {\n  assertHash(s);\n  return s;\n}\n\nconst emptyUUID = '0'.repeat(STRING_LENGTH);\nexport const emptyHash = emptyUUID as unknown as Hash;\n\n/**\n * Creates a function that generates random hashes.\n */\nexport const newRandomHash = makeNewRandomHashFunctionInternal();\n\n/**\n * Creates a function that generates UUID hashes for tests.\n */\nexport function makeNewFakeHashFunction(hashPrefix = 'fake'): () => Hash {\n  assert(\n    /^[0-9a-v]{0,8}$/.test(hashPrefix),\n    `Invalid hash prefix: ${hashPrefix}`,\n  );\n  let i = 0;\n  return () => {\n    const count = String(i++);\n    return (hashPrefix +\n      '0'.repeat(STRING_LENGTH - hashPrefix.length - count.length) +\n      count) as Hash;\n  };\n}\n\nfunction toStringAndSlice(n: number | bigint, len: number): string {\n  return n.toString(32).slice(-len).padStart(len, '0');\n}\n\n/**\n * This creates an ID that looks like `<RANDOM><COUNTER>`. The random part is\n * a random number encoded with base 32 and the length is 12 characters. The\n * is 10 characters long and encoded as base 32. The total length is 22 characters.\n *\n * Do the math: https://devina.io/collision-calculator\n */\nfunction makeNewRandomHashFunctionInternal(): () => Hash {\n  let base = '';\n  let i = 0;\n\n  return () => {\n    if (!base) {\n      // This needs to be lazy because the cloudflare worker environment will\n      // throw an error if crypto.getRandomValues is used statically.  Specifically:\n      // Error: Some functionality, such as asynchronous I/O, timeouts, and\n      // generating random values, can only be performed while handling a\n      // request.\n      base = toStringAndSlice(randomUint64(), 12);\n    }\n    const tail = toStringAndSlice(i++, 10);\n    return (base + tail) as Hash;\n  };\n}\n\n/**\n * Generates a fake hash useful for testing.\n */\nexport function fakeHash(word: string | number): Hash {\n  if (typeof word === 'number') {\n    word = String(word);\n  }\n  return ('fake' + '0'.repeat(STRING_LENGTH - 4 - word.length) + word) as Hash;\n}\n\nexport function isHash(value: unknown): value is Hash {\n  return typeof value === 'string' && hashRe.test(value);\n}\n\nexport function assertHash(value: unknown): asserts value is Hash {\n  valita.assert(value, hashSchema);\n}\n\nexport const hashSchema = valita.string().assert(isHash, 'Invalid hash');\n","import * as valita from '../../shared/src/valita.ts';\n\n/**\n * The definition of a single index.\n */\nexport type IndexDefinition = {\n  /**\n   * The prefix, if any, to limit the index over. If not provided the values of\n   * all keys are indexed.\n   */\n  readonly prefix?: string | undefined;\n\n  /**\n   * A [JSON Pointer](https://tools.ietf.org/html/rfc6901) pointing at the sub\n   * value inside each value to index over.\n   *\n   * For example, one might index over users' ages like so:\n   * `{prefix: '/user/', jsonPointer: '/age'}`\n   */\n  readonly jsonPointer: string;\n\n  /**\n   * If `true`, indexing empty values will not emit a warning.  Defaults to `false`.\n   */\n  readonly allowEmpty?: boolean | undefined;\n};\n\nexport const indexDefinitionSchema: valita.Type<IndexDefinition> =\n  valita.readonlyObject({\n    prefix: valita.string().optional(),\n    jsonPointer: valita.string(),\n    allowEmpty: valita.boolean().optional(),\n  });\n\n/**\n * An object as a map defining the indexes. The keys are the index names and the\n * values are the index definitions.\n */\nexport type IndexDefinitions = {readonly [name: string]: IndexDefinition};\n\nexport const indexDefinitionsSchema = valita.readonlyRecord(\n  indexDefinitionSchema,\n);\n\nexport function indexDefinitionEqual(\n  a: IndexDefinition,\n  b: IndexDefinition,\n): boolean {\n  return (\n    a.jsonPointer === b.jsonPointer &&\n    (a.allowEmpty ?? false) === (b.allowEmpty ?? false) &&\n    (a.prefix ?? '') === (b.prefix ?? '')\n  );\n}\n\nexport function indexDefinitionsEqual(\n  a: IndexDefinitions,\n  b: IndexDefinitions,\n): boolean {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const [aKey, aValue] of Object.entries(a)) {\n    const bValue = b[aKey];\n    if (!bValue || !indexDefinitionEqual(aValue, bValue)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function assertIndexDefinitions(\n  value: unknown,\n): asserts value is IndexDefinitions {\n  valita.assert(value, indexDefinitionsSchema);\n}\n","import {assert, assertObject} from '../../../shared/src/asserts.ts';\nimport * as valita from '../../../shared/src/valita.ts';\nimport {toRefs} from '../dag/chunk.ts';\nimport type {Read, Write} from '../dag/store.ts';\nimport {deepFreeze, type FrozenJSONValue} from '../frozen-json.ts';\nimport {type Hash, hashSchema} from '../hash.ts';\nimport {indexDefinitionsEqual, indexDefinitionsSchema} from '../index-defs.ts';\nimport type {ClientGroupID} from '../sync/ids.ts';\n\nexport type ClientGroupMap = ReadonlyMap<ClientGroupID, ClientGroup>;\n\nconst clientGroupSchema = valita.readonlyObject({\n  /**\n   * The hash of the commit in the perdag last persisted to this client group.\n   * Should only be updated by clients assigned to this client group.\n   */\n  headHash: hashSchema,\n\n  /**\n   * Set of mutator names common to all clients assigned to this client group.\n   */\n  mutatorNames: valita.readonlyArray(valita.string()),\n\n  /**\n   * Index definitions common to all clients assigned to this client group.\n   */\n  indexes: indexDefinitionsSchema,\n\n  /**\n   * The highest mutation ID of every client assigned to this client group.\n   * Should only be updated by clients assigned to this client group. Read by\n   * other clients to determine if there are unacknowledged pending mutations\n   * for them to try to recover. This is redundant with information in the\n   * commit graph at `headHash`, but allows other clients to determine if there\n   * are unacknowledged pending mutations without having to load the commit\n   * graph.\n   */\n  mutationIDs: valita.readonlyRecord(valita.number()),\n\n  /**\n   * The highest lastMutationID received from the server for every client\n   * assigned to this client group.\n   *\n   * Should be updated by the clients assigned to this client group whenever\n   * they persist to this client group. Read by other clients to determine if\n   * there are unacknowledged pending mutations for them to recover and\n   * *updated* by other clients upon successfully recovering pending mutations\n   * to avoid redundant pushes of pending mutations.\n   *\n   * Note: This will be the same as the `lastMutationIDs` of the base snapshot\n   * of the client group's commit graph when written by clients assigned to this\n   * client group.  However, when written by another client recovering mutations\n   * it may be different because the other client does not update the commit\n   * graph.\n   */\n  lastServerAckdMutationIDs: valita.record(valita.number()),\n\n  /**\n   * If the server deletes this client group it can signal that the client group\n   * was deleted. If that happens we mark this client group as disabled so that\n   * we do not use it again when creating new clients.\n   */\n  disabled: valita.boolean(),\n});\n\nexport type ClientGroup = valita.Infer<typeof clientGroupSchema>;\n\nexport const CLIENT_GROUPS_HEAD_NAME = 'client-groups';\n\nfunction assertClientGroup(value: unknown): asserts value is ClientGroup {\n  valita.assert(value, clientGroupSchema);\n}\n\nfunction chunkDataToClientGroupMap(chunkData: unknown): ClientGroupMap {\n  assertObject(chunkData);\n  const clientGroups = new Map<ClientGroupID, ClientGroup>();\n  for (const [key, value] of Object.entries(chunkData)) {\n    if (value !== undefined) {\n      assertClientGroup(value);\n      clientGroups.set(key, value);\n    }\n  }\n  return clientGroups;\n}\n\nfunction clientGroupMapToChunkData(\n  clientGroups: ClientGroupMap,\n  dagWrite: Write,\n): FrozenJSONValue {\n  const chunkData: {[id: ClientGroupID]: ClientGroup} = {};\n  for (const [clientGroupID, clientGroup] of clientGroups.entries()) {\n    dagWrite.assertValidHash(clientGroup.headHash);\n    chunkData[clientGroupID] = {\n      ...clientGroup,\n      mutatorNames: [...clientGroup.mutatorNames.values()],\n    };\n  }\n  return deepFreeze(chunkData);\n}\n\nasync function getClientGroupsAtHash(\n  hash: Hash,\n  dagRead: Read,\n): Promise<ClientGroupMap> {\n  const chunk = await dagRead.getChunk(hash);\n  return chunkDataToClientGroupMap(chunk?.data);\n}\n\nexport async function getClientGroups(dagRead: Read): Promise<ClientGroupMap> {\n  const hash = await dagRead.getHead(CLIENT_GROUPS_HEAD_NAME);\n  if (!hash) {\n    return new Map();\n  }\n  return getClientGroupsAtHash(hash, dagRead);\n}\n\nexport async function setClientGroups(\n  clientGroups: ClientGroupMap,\n  dagWrite: Write,\n): Promise<ClientGroupMap> {\n  const currClientGroups = await getClientGroups(dagWrite);\n  for (const [clientGroupID, clientGroup] of clientGroups) {\n    const currClientGroup = currClientGroups.get(clientGroupID);\n    validateClientGroupUpdate(clientGroup, currClientGroup);\n  }\n  return setValidatedClientGroups(clientGroups, dagWrite);\n}\n\nexport async function setClientGroup(\n  clientGroupID: ClientGroupID,\n  clientGroup: ClientGroup,\n  dagWrite: Write,\n): Promise<ClientGroupMap> {\n  const currClientGroups = await getClientGroups(dagWrite);\n  const currClientGroup = currClientGroups.get(clientGroupID);\n  validateClientGroupUpdate(clientGroup, currClientGroup);\n  const newClientGroups = new Map(currClientGroups);\n  newClientGroups.set(clientGroupID, clientGroup);\n  return setValidatedClientGroups(newClientGroups, dagWrite);\n}\n\nexport async function deleteClientGroup(\n  clientGroupID: ClientGroupID,\n  dagWrite: Write,\n): Promise<ClientGroupMap> {\n  const currClientGroups = await getClientGroups(dagWrite);\n  if (!currClientGroups.has(clientGroupID)) {\n    return currClientGroups;\n  }\n  const newClientGroups = new Map(currClientGroups.entries());\n  newClientGroups.delete(clientGroupID);\n  return setValidatedClientGroups(newClientGroups, dagWrite);\n}\n\nfunction validateClientGroupUpdate(\n  clientGroup: ClientGroup,\n  currClientGroup: ClientGroup | undefined,\n) {\n  const mutatorNamesSet = new Set(clientGroup.mutatorNames);\n  assert(\n    mutatorNamesSet.size === clientGroup.mutatorNames.length,\n    \"A client group's mutatorNames must be a set.\",\n  );\n  if (currClientGroup !== undefined) {\n    assert(\n      indexDefinitionsEqual(currClientGroup.indexes, clientGroup.indexes),\n      \"A client group's index definitions must never change.\",\n    );\n    assert(\n      mutatorNamesEqual(mutatorNamesSet, currClientGroup.mutatorNames),\n      \"A client group's mutatorNames must never change.\",\n    );\n  }\n}\n\nasync function setValidatedClientGroups(\n  clientGroups: ClientGroupMap,\n  dagWrite: Write,\n): Promise<ClientGroupMap> {\n  const chunkData = clientGroupMapToChunkData(clientGroups, dagWrite);\n  const refs: Set<Hash> = new Set();\n  for (const clientGroup of clientGroups.values()) {\n    refs.add(clientGroup.headHash);\n  }\n  const chunk = dagWrite.createChunk(chunkData, toRefs(refs));\n  await dagWrite.putChunk(chunk);\n  await dagWrite.setHead(CLIENT_GROUPS_HEAD_NAME, chunk.hash);\n  return clientGroups;\n}\n\nexport function mutatorNamesEqual(\n  mutatorNamesSet: ReadonlySet<string>,\n  mutatorNames: readonly string[],\n): boolean {\n  if (mutatorNames.length !== mutatorNamesSet.size) {\n    return false;\n  }\n  for (const mutatorName of mutatorNames) {\n    if (!mutatorNamesSet.has(mutatorName)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport async function getClientGroup(\n  id: ClientGroupID,\n  dagRead: Read,\n): Promise<ClientGroup | undefined> {\n  const clientGroups = await getClientGroups(dagRead);\n  return clientGroups.get(id);\n}\n\nexport function clientGroupHasPendingMutations(clientGroup: ClientGroup) {\n  for (const [clientID, mutationID] of Object.entries(\n    clientGroup.mutationIDs,\n  )) {\n    const lastServerAckdMutationID =\n      clientGroup.lastServerAckdMutationIDs[clientID];\n    if (\n      (lastServerAckdMutationID === undefined && mutationID !== 0) ||\n      lastServerAckdMutationID < mutationID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Marks a client group as disabled. This can happen if the server deletes the\n * client group (servers should not delete clients or client groups but it often\n * happens in practice when developing).\n *\n * A disabled client group prevents pulls and pushes from happening.\n */\nexport async function disableClientGroup(\n  clientGroupID: string,\n  dagWrite: Write,\n): Promise<void> {\n  const clientGroup = await getClientGroup(clientGroupID, dagWrite);\n  if (!clientGroup) {\n    // No client group matching in the database, so nothing to do.\n    return;\n  }\n  const disabledClientGroup = {\n    ...clientGroup,\n    disabled: true,\n  };\n  await setClientGroup(clientGroupID, disabledClientGroup, dagWrite);\n}\n","import {assertObject, throwInvalidType} from './asserts.ts';\nimport {skipAssertJSONValue} from './config.ts';\nimport {hasOwn} from './has-own.ts';\n\n/** The values that can be represented in JSON */\nexport type JSONValue =\n  | null\n  | string\n  | boolean\n  | number\n  | Array<JSONValue>\n  | JSONObject;\n\n/**\n * A JSON object. This is a map from strings to JSON values or `undefined`. We\n * allow `undefined` values as a convenience... but beware that the `undefined`\n * values do not round trip to the server. For example:\n *\n * ```\n * // Time t1\n * await tx.set('a', {a: undefined});\n *\n * // time passes, in a new transaction\n * const v = await tx.get('a');\n * console.log(v); // either {a: undefined} or {}\n * ```\n */\nexport type JSONObject = {[key: string]: JSONValue | undefined};\n\n/** Like {@link JSONValue} but deeply readonly */\nexport type ReadonlyJSONValue =\n  | null\n  | string\n  | boolean\n  | number\n  | ReadonlyArray<ReadonlyJSONValue>\n  | ReadonlyJSONObject;\n\n/** Like {@link JSONObject} but deeply readonly */\nexport type ReadonlyJSONObject = {\n  readonly [key: string]: ReadonlyJSONValue | undefined;\n};\n\n/**\n * Checks deep equality of two JSON value with (almost) same semantics as\n * `JSON.stringify`. The only difference is that with `JSON.stringify` the\n * ordering of the properties in an object/map/dictionary matters. In\n * {@link deepEqual} the following two values are consider equal, even though the\n * strings JSON.stringify would produce is different:\n *\n * ```js\n * assert(deepEqual(t({a: 1, b: 2}, {b: 2, a: 1}))\n * ```\n */\nexport function deepEqual(\n  a: ReadonlyJSONValue | undefined,\n  b: ReadonlyJSONValue | undefined,\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  switch (typeof a) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return false;\n  }\n\n  // a cannot be undefined here because either a and b are undefined or their\n  // types are different.\n  // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion\n  a = a!;\n\n  // 'object'\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (a === null || b === null) {\n    return false;\n  }\n\n  if (Array.isArray(b)) {\n    return false;\n  }\n\n  // We know a and b are objects here but type inference is not smart enough.\n  a = a as ReadonlyJSONObject;\n  b = b as ReadonlyJSONObject;\n\n  // We use for-in loops instead of for of Object.keys() to make sure deepEquals\n  // does not allocate any objects.\n\n  let aSize = 0;\n  for (const key in a) {\n    if (hasOwn(a, key)) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n      aSize++;\n    }\n  }\n\n  let bSize = 0;\n  for (const key in b) {\n    if (hasOwn(b, key)) {\n      bSize++;\n    }\n  }\n\n  return aSize === bSize;\n}\n\nexport function assertJSONValue(v: unknown): asserts v is JSONValue {\n  if (skipAssertJSONValue) {\n    return;\n  }\n  switch (typeof v) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return;\n    case 'object':\n      if (v === null) {\n        return;\n      }\n      if (Array.isArray(v)) {\n        return assertJSONArray(v);\n      }\n      return assertObjectIsJSONObject(v as Record<string, unknown>);\n  }\n  throwInvalidType(v, 'JSON value');\n}\n\nexport function assertJSONObject(v: unknown): asserts v is JSONObject {\n  assertObject(v);\n  assertObjectIsJSONObject(v);\n}\n\nfunction assertObjectIsJSONObject(\n  v: Record<string, unknown>,\n): asserts v is JSONObject {\n  for (const k in v) {\n    if (hasOwn(v, k)) {\n      const value = v[k];\n      if (value !== undefined) {\n        assertJSONValue(value);\n      }\n    }\n  }\n}\n\nfunction assertJSONArray(v: unknown[]): asserts v is JSONValue[] {\n  for (const item of v) {\n    assertJSONValue(item);\n  }\n}\n\ninterface Path {\n  push(key: string | number): void;\n  pop(): void;\n}\n\n/**\n * Checks if a value is a JSON value. If there is a value that is not a JSON\n * value, the path parameter is updated to the path of the invalid value.\n */\nexport function isJSONValue(v: unknown, path: Path): v is JSONValue {\n  switch (typeof v) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return true;\n    case 'object':\n      if (v === null) {\n        return true;\n      }\n      if (Array.isArray(v)) {\n        return isJSONArray(v, path);\n      }\n      return objectIsJSONObject(v as Record<string, unknown>, path);\n  }\n  return false;\n}\n\nexport function isJSONObject(v: unknown, path: Path): v is JSONObject {\n  if (typeof v !== 'object' || v === null) {\n    return false;\n  }\n  return objectIsJSONObject(v as Record<string, unknown>, path);\n}\n\nfunction objectIsJSONObject(\n  v: Record<string, unknown>,\n  path: Path,\n): v is JSONObject {\n  for (const k in v) {\n    if (hasOwn(v, k)) {\n      path.push(k);\n      const value = v[k];\n      if (value !== undefined && !isJSONValue(value, path)) {\n        return false;\n      }\n      path.pop();\n    }\n  }\n  return true;\n}\n\nfunction isJSONArray(v: unknown[], path: Path): v is JSONValue[] {\n  for (let i = 0; i < v.length; i++) {\n    path.push(i);\n    if (!isJSONValue(v[i], path)) {\n      return false;\n    }\n    path.pop();\n  }\n  return true;\n}\n\n/** Basic deep readonly type. It works for {@link JSONValue} types. */\nexport type DeepReadonly<T> = T extends\n  | null\n  | boolean\n  | string\n  | number\n  | undefined\n  ? T\n  : {readonly [K in keyof T]: DeepReadonly<T[K]>};\n","import {hasOwn} from '../../shared/src/has-own.ts';\nimport type {ReadonlyJSONObject} from '../../shared/src/json.ts';\n\nconst SIZE_TAG = 1;\nconst SIZE_INT32 = 4;\nconst SIZE_SMI = 5;\nconst SIZE_DOUBLE = 8;\n\n/**\n * Gives a size of a value. The size is modelled after the size used by\n * Chromium/V8's structuredClone algorithm. It does not match exactly so the\n * size is just an approximation.\n * https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/value-serializer.cc;l=102;drc=f0b6f7d12ea47ad7c08fb554f678c1e73801ca36;bpv=1;bpt=1\n * For example we follow JSC/Mozilla for ints and skip the varint encoding.\n *\n * Mozilla does things similarly. Main difference is that there is no varint\n * encoding and every value uses multiples of 64bits\n * https://searchfox.org/mozilla-central/source/js/src/vm/StructuredClone.cpp#94\n *\n * And JSC:\n * https://github.com/WebKit/WebKit/blob/main/Source/WebCore/bindings/js/SerializedScriptValue.cpp#L356\n * - Use 1 byte tag\n * - Numbers are either stored as Int32 or Float64\n */\nexport function getSizeOfValue(value: unknown): number {\n  switch (typeof value) {\n    case 'string':\n      // Assumes all strings are one byte strings. V8 writes OneByteString and\n      // TwoByteString. We could check the string but it would require iterating\n      // over all the characters.\n      return SIZE_TAG + SIZE_INT32 + value.length;\n    case 'number':\n      if (isSmi(value)) {\n        if (value <= -(2 ** 30) || value >= 2 ** 30 - 1) {\n          return SIZE_TAG + SIZE_SMI;\n        }\n        return SIZE_TAG + SIZE_INT32;\n      }\n      return SIZE_TAG + SIZE_DOUBLE;\n    case 'boolean':\n      return SIZE_TAG;\n    case 'object':\n      if (value === null) {\n        return SIZE_TAG;\n      }\n\n      if (Array.isArray(value)) {\n        let sum = 2 * SIZE_TAG + SIZE_INT32;\n        for (const element of value) {\n          sum += getSizeOfValue(element);\n        }\n        return sum;\n      }\n\n      {\n        const val = value as ReadonlyJSONObject;\n        let sum: number = 2 * SIZE_TAG + SIZE_INT32;\n        for (const k in val) {\n          if (hasOwn(val, k)) {\n            // Skip undefined values. undefined values in an object gets\n            // stripped if we round trip through JSON.stringif which is what we\n            // use when syncing.\n            const propertyValue = val[k];\n            if (propertyValue !== undefined) {\n              sum += getSizeOfValue(k) + getSizeOfValue(propertyValue);\n            }\n          }\n        }\n        return sum;\n      }\n  }\n\n  throw new Error(`Invalid value. type: ${typeof value}, value: ${value}`);\n}\n\nfunction isSmi(value: number): boolean {\n  return value === (value | 0);\n}\n\nconst entryFixed = 2 * SIZE_TAG + SIZE_INT32 + SIZE_TAG + SIZE_INT32;\n\nexport function getSizeOfEntry<K, V>(key: K, value: V): number {\n  // Entries are stored as [key, value, sizeOfEntry]\n  return entryFixed + getSizeOfValue(key) + getSizeOfValue(value);\n}\n","import {compareUTF8} from 'compare-utf8';\nimport {\n  assert,\n  assertArray,\n  assertNumber,\n  assertString,\n} from '../../../shared/src/asserts.ts';\nimport {binarySearch as binarySearchWithFunc} from '../../../shared/src/binary-search.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {joinIterables} from '../../../shared/src/iterables.ts';\nimport {\n  type JSONValue,\n  type ReadonlyJSONValue,\n  assertJSONValue,\n} from '../../../shared/src/json.ts';\nimport {skipBTreeNodeAsserts} from '../config.ts';\nimport type {IndexKey} from '../db/index.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport {\n  type FrozenJSONValue,\n  type FrozenTag,\n  assertDeepFrozen,\n  deepFreeze,\n} from '../frozen-json.ts';\nimport {type Hash, emptyHash, newRandomHash} from '../hash.ts';\nimport type {BTreeRead} from './read.ts';\nimport type {BTreeWrite} from './write.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nexport type Entry<V> = readonly [key: string, value: V, sizeOfEntry: number];\n\nexport const NODE_LEVEL = 0;\nexport const NODE_ENTRIES = 1;\n\n/**\n * The type of B+Tree node chunk data\n */\ntype BaseNode<V> = FrozenTag<\n  readonly [level: number, entries: ReadonlyArray<Entry<V>>]\n>;\nexport type InternalNode = BaseNode<Hash>;\n\nexport type DataNode = BaseNode<FrozenJSONValue>;\n\nexport function makeNodeChunkData<V>(\n  level: number,\n  entries: ReadonlyArray<Entry<V>>,\n  formatVersion: FormatVersion,\n): BaseNode<V> {\n  return deepFreeze([\n    level,\n    (formatVersion >= FormatVersion.V7\n      ? entries\n      : entries.map(e => e.slice(0, 2))) as readonly ReadonlyJSONValue[],\n  ]) as BaseNode<V>;\n}\n\nexport type Node = DataNode | InternalNode;\n\n/**\n * Describes the changes that happened to Replicache after a\n * {@link WriteTransaction} was committed.\n *\n * @experimental This type is experimental and may change in the future.\n */\nexport type Diff = IndexDiff | NoIndexDiff;\n\n/**\n * @experimental This type is experimental and may change in the future.\n */\nexport type IndexDiff = readonly DiffOperation<IndexKey>[];\n\n/**\n * @experimental This type is experimental and may change in the future.\n */\nexport type NoIndexDiff = readonly DiffOperation<string>[];\n\n/**\n * InternalDiff uses string keys even for the secondary index maps.\n */\nexport type InternalDiff = readonly InternalDiffOperation[];\n\nexport type DiffOperationAdd<Key, Value = ReadonlyJSONValue> = {\n  readonly op: 'add';\n  readonly key: Key;\n  readonly newValue: Value;\n};\n\nexport type DiffOperationDel<Key, Value = ReadonlyJSONValue> = {\n  readonly op: 'del';\n  readonly key: Key;\n  readonly oldValue: Value;\n};\n\nexport type DiffOperationChange<Key, Value = ReadonlyJSONValue> = {\n  readonly op: 'change';\n  readonly key: Key;\n  readonly oldValue: Value;\n  readonly newValue: Value;\n};\n\n/**\n * The individual parts describing the changes that happened to the Replicache\n * data. There are three different kinds of operations:\n * - `add`: A new entry was added.\n * - `del`: An entry was deleted.\n * - `change`: An entry was changed.\n *\n * @experimental This type is experimental and may change in the future.\n */\nexport type DiffOperation<Key> =\n  | DiffOperationAdd<Key>\n  | DiffOperationDel<Key>\n  | DiffOperationChange<Key>;\n\n// Duplicated with DiffOperation to make the docs less confusing.\nexport type InternalDiffOperation<Key = string, Value = FrozenJSONValue> =\n  | DiffOperationAdd<Key, Value>\n  | DiffOperationDel<Key, Value>\n  | DiffOperationChange<Key, Value>;\n\n/**\n * Finds the leaf where a key is (if present) or where it should go if not\n * present.\n */\nexport async function findLeaf(\n  key: string,\n  hash: Hash,\n  source: BTreeRead,\n  expectedRootHash: Hash,\n): Promise<DataNodeImpl> {\n  const node = await source.getNode(hash);\n  // The root changed. Try again\n  if (expectedRootHash !== source.rootHash) {\n    return findLeaf(key, source.rootHash, source, source.rootHash);\n  }\n  if (isDataNodeImpl(node)) {\n    return node;\n  }\n  const {entries} = node;\n  let i = binarySearch(key, entries);\n  if (i === entries.length) {\n    i--;\n  }\n  const entry = entries[i];\n  return findLeaf(key, entry[1], source, expectedRootHash);\n}\n\ntype BinarySearchEntries = readonly Entry<unknown>[];\n\n/**\n * Does a binary search over entries\n *\n * If the key found then the return value is the index it was found at.\n *\n * If the key was *not* found then the return value is the index where it should\n * be inserted at\n */\nexport function binarySearch(\n  key: string,\n  entries: BinarySearchEntries,\n): number {\n  return binarySearchWithFunc(entries.length, i =>\n    compareUTF8(key, entries[i][0]),\n  );\n}\n\nexport function binarySearchFound(\n  i: number,\n  entries: BinarySearchEntries,\n  key: string,\n): boolean {\n  return i !== entries.length && entries[i][0] === key;\n}\n\nexport function parseBTreeNode(\n  v: unknown,\n  formatVersion: FormatVersion,\n  getSizeOfEntry: <K, V>(key: K, value: V) => number,\n): InternalNode | DataNode {\n  if (skipBTreeNodeAsserts && formatVersion >= FormatVersion.V7) {\n    return v as InternalNode | DataNode;\n  }\n\n  assertArray(v);\n  assertDeepFrozen(v);\n  // Be relaxed about what we accept.\n  assert(v.length >= 2);\n  const [level, entries] = v;\n  assertNumber(level);\n  assertArray(entries);\n\n  const f = level > 0 ? assertString : assertJSONValue;\n\n  // For V7 we do not need to change the entries. Just assert that they are correct.\n  if (formatVersion >= FormatVersion.V7) {\n    for (const e of entries) {\n      assertEntry(e, f);\n    }\n    return v as unknown as InternalNode | DataNode;\n  }\n\n  const newEntries = entries.map(e => convertNonV7Entry(e, f, getSizeOfEntry));\n  return [level, newEntries] as unknown as InternalNode | DataNode;\n}\n\nfunction assertEntry(\n  entry: unknown,\n  f:\n    | ((v: unknown) => asserts v is Hash)\n    | ((v: unknown) => asserts v is JSONValue),\n): asserts entry is Entry<Hash | JSONValue> {\n  assertArray(entry);\n  // Be relaxed about what we accept.\n  assert(entry.length >= 3);\n  assertString(entry[0]);\n  f(entry[1]);\n  assertNumber(entry[2]);\n}\n\n/**\n * Converts an entry that was from a format version before V7 to the format\n * wanted by V7.\n */\nfunction convertNonV7Entry(\n  entry: unknown,\n  f:\n    | ((v: unknown) => asserts v is Hash)\n    | ((v: unknown) => asserts v is JSONValue),\n  getSizeOfEntry: <K, V>(key: K, value: V) => number,\n): Entry<Hash | JSONValue> {\n  assertArray(entry);\n  assert(entry.length >= 2);\n  assertString(entry[0]);\n  f(entry[1]);\n  const entrySize = getSizeOfEntry(entry[0], entry[1]);\n  return [entry[0], entry[1], entrySize] as Entry<Hash | JSONValue>;\n}\n\nexport function isInternalNode(node: Node): node is InternalNode {\n  return node[NODE_LEVEL] > 0;\n}\n\nabstract class NodeImpl<Value> {\n  entries: Array<Entry<Value>>;\n  hash: Hash;\n  abstract readonly level: number;\n  readonly isMutable: boolean;\n\n  #childNodeSize = -1;\n\n  constructor(entries: Array<Entry<Value>>, hash: Hash, isMutable: boolean) {\n    this.entries = entries;\n    this.hash = hash;\n    this.isMutable = isMutable;\n  }\n\n  abstract set(\n    key: string,\n    value: FrozenJSONValue,\n    entrySize: number,\n    tree: BTreeWrite,\n  ): Promise<NodeImpl<Value>>;\n\n  abstract del(\n    key: string,\n    tree: BTreeWrite,\n  ): Promise<NodeImpl<Value> | DataNodeImpl>;\n\n  maxKey(): string {\n    return this.entries[this.entries.length - 1][0];\n  }\n\n  getChildNodeSize(tree: BTreeRead): number {\n    if (this.#childNodeSize !== -1) {\n      return this.#childNodeSize;\n    }\n\n    let sum = tree.chunkHeaderSize;\n    for (const entry of this.entries) {\n      sum += entry[2];\n    }\n    return (this.#childNodeSize = sum);\n  }\n\n  protected _updateNode(tree: BTreeWrite) {\n    this.#childNodeSize = -1;\n    tree.updateNode(\n      this as NodeImpl<unknown> as DataNodeImpl | InternalNodeImpl,\n    );\n  }\n}\n\nexport function toChunkData<V>(\n  node: NodeImpl<V>,\n  formatVersion: FormatVersion,\n): BaseNode<V> {\n  return makeNodeChunkData(node.level, node.entries, formatVersion);\n}\n\nexport class DataNodeImpl extends NodeImpl<FrozenJSONValue> {\n  readonly level = 0;\n\n  set(\n    key: string,\n    value: FrozenJSONValue,\n    entrySize: number,\n    tree: BTreeWrite,\n  ): Promise<DataNodeImpl> {\n    let deleteCount: number;\n    const i = binarySearch(key, this.entries);\n    if (!binarySearchFound(i, this.entries, key)) {\n      // Not found, insert.\n      deleteCount = 0;\n    } else {\n      deleteCount = 1;\n    }\n\n    return Promise.resolve(\n      this.#splice(tree, i, deleteCount, [key, value, entrySize]),\n    );\n  }\n\n  #splice(\n    tree: BTreeWrite,\n    start: number,\n    deleteCount: number,\n    ...items: Entry<FrozenJSONValue>[]\n  ): DataNodeImpl {\n    if (this.isMutable) {\n      this.entries.splice(start, deleteCount, ...items);\n      this._updateNode(tree);\n      return this;\n    }\n\n    const entries = readonlySplice(this.entries, start, deleteCount, ...items);\n    return tree.newDataNodeImpl(entries);\n  }\n\n  del(key: string, tree: BTreeWrite): Promise<DataNodeImpl> {\n    const i = binarySearch(key, this.entries);\n    if (!binarySearchFound(i, this.entries, key)) {\n      // Not found. Return this without changes.\n      return Promise.resolve(this);\n    }\n\n    // Found. Create new node or mutate existing one.\n    return Promise.resolve(this.#splice(tree, i, 1));\n  }\n\n  async *keys(_tree: BTreeRead): AsyncGenerator<string, void> {\n    for (const entry of this.entries) {\n      yield entry[0];\n    }\n  }\n\n  async *entriesIter(\n    _tree: BTreeRead,\n  ): AsyncGenerator<Entry<FrozenJSONValue>, void> {\n    for (const entry of this.entries) {\n      yield entry;\n    }\n  }\n}\n\nfunction readonlySplice<T>(\n  array: ReadonlyArray<T>,\n  start: number,\n  deleteCount: number,\n  ...items: T[]\n): T[] {\n  const arr = array.slice(0, start);\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n  for (let i = start + deleteCount; i < array.length; i++) {\n    arr.push(array[i]);\n  }\n  return arr;\n}\n\nexport class InternalNodeImpl extends NodeImpl<Hash> {\n  readonly level: number;\n\n  constructor(\n    entries: Array<Entry<Hash>>,\n    hash: Hash,\n    level: number,\n    isMutable: boolean,\n  ) {\n    super(entries, hash, isMutable);\n    this.level = level;\n  }\n\n  async set(\n    key: string,\n    value: FrozenJSONValue,\n    entrySize: number,\n    tree: BTreeWrite,\n  ): Promise<InternalNodeImpl> {\n    let i = binarySearch(key, this.entries);\n    if (i === this.entries.length) {\n      // We are going to insert into last (right most) leaf.\n      i--;\n    }\n\n    const childHash = this.entries[i][1];\n    const oldChildNode = await tree.getNode(childHash);\n\n    const childNode = await oldChildNode.set(key, value, entrySize, tree);\n\n    const childNodeSize = childNode.getChildNodeSize(tree);\n    if (childNodeSize > tree.maxSize || childNodeSize < tree.minSize) {\n      return this.#mergeAndPartition(tree, i, childNode);\n    }\n\n    const newEntry = createNewInternalEntryForNode(\n      childNode,\n      tree.getEntrySize,\n    );\n    return this.#replaceChild(tree, i, newEntry);\n  }\n\n  /**\n   * This merges the child node entries with previous or next sibling and then\n   * partitions the merged entries.\n   */\n  async #mergeAndPartition(\n    tree: BTreeWrite,\n    i: number,\n    childNode: DataNodeImpl | InternalNodeImpl,\n  ): Promise<InternalNodeImpl> {\n    const level = this.level - 1;\n    const thisEntries = this.entries;\n\n    type IterableHashEntries = Iterable<Entry<Hash>>;\n\n    let values: IterableHashEntries;\n    let startIndex: number;\n    let removeCount: number;\n    if (i > 0) {\n      const hash = thisEntries[i - 1][1];\n      const previousSibling = await tree.getNode(hash);\n      values = joinIterables(\n        previousSibling.entries as IterableHashEntries,\n        childNode.entries as IterableHashEntries,\n      );\n      startIndex = i - 1;\n      removeCount = 2;\n    } else if (i < thisEntries.length - 1) {\n      const hash = thisEntries[i + 1][1];\n      const nextSibling = await tree.getNode(hash);\n      values = joinIterables(\n        childNode.entries as IterableHashEntries,\n        nextSibling.entries as IterableHashEntries,\n      );\n      startIndex = i;\n      removeCount = 2;\n    } else {\n      values = childNode.entries as IterableHashEntries;\n      startIndex = i;\n      removeCount = 1;\n    }\n\n    const partitions = partition(\n      values,\n      value => value[2],\n      tree.minSize - tree.chunkHeaderSize,\n      tree.maxSize - tree.chunkHeaderSize,\n    );\n\n    // TODO: There are cases where we can reuse the old nodes. Creating new ones\n    // means more memory churn but also more writes to the underlying KV store.\n    const newEntries: Entry<Hash>[] = [];\n    for (const entries of partitions) {\n      const node = tree.newNodeImpl(entries, level);\n      const newHashEntry = createNewInternalEntryForNode(\n        node,\n        tree.getEntrySize,\n      );\n      newEntries.push(newHashEntry);\n    }\n\n    if (this.isMutable) {\n      this.entries.splice(startIndex, removeCount, ...newEntries);\n      this._updateNode(tree);\n      return this;\n    }\n\n    const entries = readonlySplice(\n      thisEntries,\n      startIndex,\n      removeCount,\n      ...newEntries,\n    );\n\n    return tree.newInternalNodeImpl(entries, this.level);\n  }\n\n  #replaceChild(\n    tree: BTreeWrite,\n    index: number,\n    newEntry: Entry<Hash>,\n  ): InternalNodeImpl {\n    if (this.isMutable) {\n      this.entries.splice(index, 1, newEntry);\n      this._updateNode(tree);\n      return this;\n    }\n    const entries = readonlySplice(this.entries, index, 1, newEntry);\n    return tree.newInternalNodeImpl(entries, this.level);\n  }\n\n  async del(\n    key: string,\n    tree: BTreeWrite,\n  ): Promise<InternalNodeImpl | DataNodeImpl> {\n    const i = binarySearch(key, this.entries);\n    if (i === this.entries.length) {\n      // Key is larger than maxKey of rightmost entry so it is not present.\n      return this;\n    }\n\n    const childHash = this.entries[i][1];\n    const oldChildNode = await tree.getNode(childHash);\n    const oldHash = oldChildNode.hash;\n\n    const childNode = await oldChildNode.del(key, tree);\n    if (childNode.hash === oldHash) {\n      // Not changed so not found.\n      return this;\n    }\n\n    if (childNode.entries.length === 0) {\n      // Subtree is now empty. Remove internal node.\n      const entries = readonlySplice(this.entries, i, 1);\n      return tree.newInternalNodeImpl(entries, this.level);\n    }\n\n    if (i === 0 && this.entries.length === 1) {\n      // There was only one node at this level and it was removed. We can return\n      // the modified subtree.\n      return childNode;\n    }\n\n    // The child node is still a good size.\n    if (childNode.getChildNodeSize(tree) > tree.minSize) {\n      // No merging needed.\n      const entry = createNewInternalEntryForNode(childNode, tree.getEntrySize);\n      return this.#replaceChild(tree, i, entry);\n    }\n\n    // Child node size is too small.\n    return this.#mergeAndPartition(tree, i, childNode);\n  }\n\n  async *keys(tree: BTreeRead): AsyncGenerator<string, void> {\n    for (const entry of this.entries) {\n      const childNode = await tree.getNode(entry[1]);\n      yield* childNode.keys(tree);\n    }\n  }\n\n  async *entriesIter(\n    tree: BTreeRead,\n  ): AsyncGenerator<Entry<FrozenJSONValue>, void> {\n    for (const entry of this.entries) {\n      const childNode = await tree.getNode(entry[1]);\n      yield* childNode.entriesIter(tree);\n    }\n  }\n\n  getChildren(\n    start: number,\n    length: number,\n    tree: BTreeRead,\n  ): Promise<Array<InternalNodeImpl | DataNodeImpl>> {\n    const ps: Promise<DataNodeImpl | InternalNodeImpl>[] = [];\n    for (let i = start; i < length && i < this.entries.length; i++) {\n      ps.push(tree.getNode(this.entries[i][1]));\n    }\n    return Promise.all(ps);\n  }\n\n  async getCompositeChildren(\n    start: number,\n    length: number,\n    tree: BTreeRead,\n  ): Promise<InternalNodeImpl | DataNodeImpl> {\n    const {level} = this;\n\n    if (length === 0) {\n      return new InternalNodeImpl([], newRandomHash(), level - 1, true);\n    }\n\n    const output = await this.getChildren(start, start + length, tree);\n\n    if (level > 1) {\n      const entries: Entry<Hash>[] = [];\n      for (const child of output as InternalNodeImpl[]) {\n        entries.push(...child.entries);\n      }\n      return new InternalNodeImpl(entries, newRandomHash(), level - 1, true);\n    }\n\n    assert(level === 1);\n    const entries: Entry<FrozenJSONValue>[] = [];\n    for (const child of output as DataNodeImpl[]) {\n      entries.push(...child.entries);\n    }\n    return new DataNodeImpl(entries, newRandomHash(), true);\n  }\n}\n\nexport function newNodeImpl(\n  entries: Array<Entry<FrozenJSONValue>>,\n  hash: Hash,\n  level: number,\n  isMutable: boolean,\n): DataNodeImpl;\nexport function newNodeImpl(\n  entries: Array<Entry<Hash>>,\n  hash: Hash,\n  level: number,\n  isMutable: boolean,\n): InternalNodeImpl;\nexport function newNodeImpl(\n  entries: Array<Entry<FrozenJSONValue>> | Array<Entry<Hash>>,\n  hash: Hash,\n  level: number,\n  isMutable: boolean,\n): DataNodeImpl | InternalNodeImpl;\nexport function newNodeImpl(\n  entries: Array<Entry<FrozenJSONValue>> | Array<Entry<Hash>>,\n  hash: Hash,\n  level: number,\n  isMutable: boolean,\n): DataNodeImpl | InternalNodeImpl {\n  if (level === 0) {\n    return new DataNodeImpl(\n      entries as Entry<FrozenJSONValue>[],\n      hash,\n      isMutable,\n    );\n  }\n  return new InternalNodeImpl(entries as Entry<Hash>[], hash, level, isMutable);\n}\n\nexport function isDataNodeImpl(\n  node: DataNodeImpl | InternalNodeImpl,\n): node is DataNodeImpl {\n  return node.level === 0;\n}\n\nexport function partition<T>(\n  values: Iterable<T>,\n  // This is the size of each Entry\n  getSizeOfEntry: (v: T) => number,\n  min: number,\n  max: number,\n): T[][] {\n  const partitions: T[][] = [];\n  const sizes: number[] = [];\n  let sum = 0;\n  let accum: T[] = [];\n  for (const value of values) {\n    const size = getSizeOfEntry(value);\n    if (size >= max) {\n      if (accum.length > 0) {\n        partitions.push(accum);\n        sizes.push(sum);\n      }\n      partitions.push([value]);\n      sizes.push(size);\n      sum = 0;\n      accum = [];\n    } else if (sum + size >= min) {\n      accum.push(value);\n      partitions.push(accum);\n      sizes.push(sum + size);\n      sum = 0;\n      accum = [];\n    } else {\n      sum += size;\n      accum.push(value);\n    }\n  }\n\n  if (sum > 0) {\n    if (sizes.length > 0 && sum + sizes[sizes.length - 1] <= max) {\n      partitions[partitions.length - 1].push(...accum);\n    } else {\n      partitions.push(accum);\n    }\n  }\n\n  return partitions;\n}\n\nexport const emptyDataNode = makeNodeChunkData<ReadonlyJSONValue>(\n  0,\n  [],\n  FormatVersion.Latest,\n);\nexport const emptyDataNodeImpl = new DataNodeImpl([], emptyHash, false);\n\nexport function createNewInternalEntryForNode(\n  node: NodeImpl<unknown>,\n  getSizeOfEntry: <K, V>(k: K, v: V) => number,\n): [string, Hash, number] {\n  const key = node.maxKey();\n  const value = node.hash;\n  const size = getSizeOfEntry(key, value);\n  return [key, value, size];\n}\n","/**\n * This is a binary search that returns the index of the first element in the\n * array that is greater than or equal to the given value.\n *\n * Typical usage:\n *\n * ```\n * const haystack = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n * const needle = 3;\n * const index = binarySearch(haystack.length, i => needle - haystack[i]);\n * const found = index < haystack.length && haystack[index] === needle;\n * ```\n */\nexport function binarySearch(high: number, compare: (i: number) => number) {\n  let low = 0;\n  while (low < high) {\n    const mid = low + ((high - low) >> 1);\n    const i = compare(mid);\n    if (i === 0) {\n      return mid;\n    }\n    if (i > 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n","import {assert} from './asserts.ts';\n\nexport function* joinIterables<T>(...iters: Iterable<T>[]) {\n  for (const iter of iters) {\n    yield* iter;\n  }\n}\n\nfunction* filterIter<T>(\n  iter: Iterable<T>,\n  p: (t: T, index: number) => boolean,\n): Iterable<T> {\n  let index = 0;\n  for (const t of iter) {\n    if (p(t, index++)) {\n      yield t;\n    }\n  }\n}\n\nfunction* mapIter<T, U>(\n  iter: Iterable<T>,\n  f: (t: T, index: number) => U,\n): Iterable<U> {\n  let index = 0;\n  for (const t of iter) {\n    yield f(t, index++);\n  }\n}\n\nexport function first<T>(stream: Iterable<T>): T | undefined {\n  const it = stream[Symbol.iterator]();\n  const {value} = it.next();\n  it.return?.();\n  return value;\n}\n\nexport function* once<T>(stream: Iterable<T>): Iterable<T> {\n  const it = stream[Symbol.iterator]();\n  const {value} = it.next();\n  if (value !== undefined) {\n    yield value;\n  }\n  it.return?.();\n}\n\n// TODO(arv): Use ES2024 Iterable.from when available\n// https://github.com/tc39/proposal-iterator-helpers\n\nclass IterWrapper<T> implements Iterable<T> {\n  iter: Iterable<T>;\n  constructor(iter: Iterable<T>) {\n    this.iter = iter;\n  }\n\n  [Symbol.iterator]() {\n    return this.iter[Symbol.iterator]();\n  }\n\n  map<U>(f: (t: T, index: number) => U): IterWrapper<U> {\n    return new IterWrapper(mapIter(this.iter, f));\n  }\n\n  filter(p: (t: T, index: number) => boolean): IterWrapper<T> {\n    return new IterWrapper(filterIter(this.iter, p));\n  }\n}\n\nexport function wrapIterable<T>(iter: Iterable<T>): IterWrapper<T> {\n  return new IterWrapper(iter);\n}\n\nexport function* mergeIterables<T>(\n  iterables: Iterable<T>[],\n  comparator: (l: T, r: T) => number,\n  distinct = false,\n): IterableIterator<T> {\n  const iterators = iterables.map(i => i[Symbol.iterator]());\n  try {\n    const current = iterators.map(i => i.next());\n    let lastYielded: T | undefined;\n    while (current.some(c => !c.done)) {\n      const min = current.reduce(\n        (acc: [T, number] | undefined, c, i): [T, number] | undefined => {\n          if (c.done) {\n            return acc;\n          }\n          if (acc === undefined || comparator(c.value, acc[0]) < 0) {\n            return [c.value, i];\n          }\n          return acc;\n        },\n        undefined,\n      );\n\n      assert(min !== undefined, 'min is undefined');\n      current[min[1]] = iterators[min[1]].next();\n      if (\n        lastYielded !== undefined &&\n        distinct &&\n        comparator(lastYielded, min[0]) === 0\n      ) {\n        continue;\n      }\n      lastYielded = min[0];\n      yield min[0];\n    }\n  } finally {\n    for (const it of iterators) {\n      it.return?.();\n    }\n  }\n}\n","import {deepEqual, type ReadonlyJSONValue} from '../../../shared/src/json.ts';\n\nexport type Splice = [at: number, removed: number, added: number, from: number];\n\nconst SPLICE_UNASSIGNED = -1;\nexport const SPLICE_AT = 0;\nexport const SPLICE_REMOVED = 1;\nexport const SPLICE_ADDED = 2;\nexport const SPLICE_FROM = 3;\n\nconst KEY = 0;\nconst VALUE = 1;\n\ntype Entry<V> = readonly [key: string, value: V, ...rest: unknown[]];\n\nexport function* computeSplices<T>(\n  previous: readonly Entry<T>[],\n  current: readonly Entry<T>[],\n): Generator<Splice, void> {\n  let previousIndex = 0;\n  let currentIndex = 0;\n  let splice: Splice | undefined;\n\n  function ensureAssigned(splice: Splice, index: number): void {\n    if (splice[SPLICE_FROM] === SPLICE_UNASSIGNED) {\n      splice[SPLICE_FROM] = index;\n    }\n  }\n\n  function newSplice(): Splice {\n    return [previousIndex, 0, 0, SPLICE_UNASSIGNED];\n  }\n\n  while (previousIndex < previous.length && currentIndex < current.length) {\n    if (previous[previousIndex][KEY] === current[currentIndex][KEY]) {\n      if (\n        deepEqual(\n          // These are really Hash | InternalValue\n          previous[previousIndex][VALUE] as ReadonlyJSONValue,\n          current[currentIndex][VALUE] as ReadonlyJSONValue,\n        )\n      ) {\n        if (splice) {\n          ensureAssigned(splice, 0);\n          yield splice;\n          splice = undefined;\n        }\n      } else {\n        if (!splice) {\n          splice = newSplice();\n        }\n        splice[SPLICE_ADDED]++;\n        splice[SPLICE_REMOVED]++;\n        ensureAssigned(splice, currentIndex);\n      }\n      previousIndex++;\n      currentIndex++;\n    } else if (previous[previousIndex][KEY] < current[currentIndex][KEY]) {\n      // previous was removed\n      if (!splice) {\n        splice = newSplice();\n      }\n      splice[SPLICE_REMOVED]++;\n\n      previousIndex++;\n    } else {\n      // current was added\n      if (!splice) {\n        splice = newSplice();\n      }\n      splice[SPLICE_ADDED]++;\n      ensureAssigned(splice, currentIndex);\n\n      currentIndex++;\n    }\n  }\n\n  if (currentIndex < current.length) {\n    if (!splice) {\n      splice = newSplice();\n    }\n    splice[SPLICE_ADDED] += current.length - currentIndex;\n    ensureAssigned(splice, currentIndex);\n  }\n\n  if (previousIndex < previous.length) {\n    if (!splice) {\n      splice = newSplice();\n    }\n    splice[SPLICE_REMOVED] += previous.length - previousIndex;\n  }\n\n  if (splice) {\n    ensureAssigned(splice, 0);\n    yield splice;\n  }\n}\n","import type {Enum} from '../../../shared/src/enum.ts';\nimport {deepEqual} from '../../../shared/src/json.ts';\nimport type {Read} from '../dag/store.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {type Hash, emptyHash} from '../hash.ts';\nimport {getSizeOfEntry} from '../size-of-value.ts';\nimport {\n  DataNodeImpl,\n  type Entry,\n  type InternalDiff,\n  type InternalDiffOperation,\n  InternalNodeImpl,\n  NODE_ENTRIES,\n  NODE_LEVEL,\n  binarySearch,\n  binarySearchFound,\n  emptyDataNodeImpl,\n  findLeaf,\n  isDataNodeImpl,\n  newNodeImpl,\n  parseBTreeNode,\n} from './node.ts';\nimport {\n  SPLICE_ADDED,\n  SPLICE_AT,\n  SPLICE_FROM,\n  SPLICE_REMOVED,\n  computeSplices,\n} from './splice.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\n/**\n * The size of the header of a node. (If we had compile time\n * constants we would have used that).\n *\n * There is a test ensuring this is correct.\n */\nexport const NODE_HEADER_SIZE = 11;\n\nexport class BTreeRead implements AsyncIterable<Entry<FrozenJSONValue>> {\n  protected readonly _cache: Map<Hash, DataNodeImpl | InternalNodeImpl> =\n    new Map();\n\n  protected readonly _dagRead: Read;\n  protected readonly _formatVersion: FormatVersion;\n  rootHash: Hash;\n  readonly getEntrySize: <K, V>(k: K, v: V) => number;\n  readonly chunkHeaderSize: number;\n\n  constructor(\n    dagRead: Read,\n    formatVersion: FormatVersion,\n    root: Hash = emptyHash,\n    getEntrySize: <K, V>(k: K, v: V) => number = getSizeOfEntry,\n    chunkHeaderSize = NODE_HEADER_SIZE,\n  ) {\n    this._dagRead = dagRead;\n    this._formatVersion = formatVersion;\n    this.rootHash = root;\n    this.getEntrySize = getEntrySize;\n    this.chunkHeaderSize = chunkHeaderSize;\n  }\n\n  async getNode(hash: Hash): Promise<DataNodeImpl | InternalNodeImpl> {\n    if (hash === emptyHash) {\n      return emptyDataNodeImpl;\n    }\n\n    const cached = this._cache.get(hash);\n    if (cached) {\n      return cached;\n    }\n\n    const chunk = await this._dagRead.mustGetChunk(hash);\n    const data = parseBTreeNode(\n      chunk.data,\n      this._formatVersion,\n      this.getEntrySize,\n    );\n    const impl = newNodeImpl(\n      data[NODE_ENTRIES] as Entry<FrozenJSONValue>[],\n      hash,\n      data[NODE_LEVEL],\n      false,\n    );\n    this._cache.set(hash, impl);\n    return impl;\n  }\n\n  async get(key: string): Promise<FrozenJSONValue | undefined> {\n    const leaf = await findLeaf(key, this.rootHash, this, this.rootHash);\n    const index = binarySearch(key, leaf.entries);\n    if (!binarySearchFound(index, leaf.entries, key)) {\n      return undefined;\n    }\n    return leaf.entries[index][1];\n  }\n\n  async has(key: string): Promise<boolean> {\n    const leaf = await findLeaf(key, this.rootHash, this, this.rootHash);\n    const index = binarySearch(key, leaf.entries);\n    return binarySearchFound(index, leaf.entries, key);\n  }\n\n  async isEmpty(): Promise<boolean> {\n    const {rootHash} = this;\n    const node = await this.getNode(this.rootHash);\n    // The root hash has changed, so the tree has been modified.\n    if (this.rootHash !== rootHash) {\n      return this.isEmpty();\n    }\n    return node.entries.length === 0;\n  }\n\n  // We don't do any encoding of the key in the map, so we have no way of\n  // determining from an entry.key alone whether it is a regular key or an\n  // encoded IndexKey in an index map. Without encoding regular map keys the\n  // caller has to deal with encoding and decoding the keys for the index map.\n  scan(fromKey: string): AsyncIterableIterator<Entry<FrozenJSONValue>> {\n    return scanForHash(\n      this.rootHash,\n      () => this.rootHash,\n      this.rootHash,\n      fromKey,\n      async hash => {\n        const cached = await this.getNode(hash);\n        if (cached) {\n          return [\n            cached.level,\n            cached.isMutable ? cached.entries.slice() : cached.entries,\n          ];\n        }\n        const chunk = await this._dagRead.mustGetChunk(hash);\n        return parseBTreeNode(\n          chunk.data,\n          this._formatVersion,\n          this.getEntrySize,\n        );\n      },\n    );\n  }\n\n  async *keys(): AsyncIterableIterator<string> {\n    const node = await this.getNode(this.rootHash);\n    yield* node.keys(this);\n  }\n\n  async *entries(): AsyncIterableIterator<Entry<FrozenJSONValue>> {\n    const node = await this.getNode(this.rootHash);\n    yield* node.entriesIter(this);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<Entry<FrozenJSONValue>> {\n    return this.entries();\n  }\n\n  async *diff(last: BTreeRead): AsyncIterableIterator<InternalDiffOperation> {\n    const [currentNode, lastNode] = await Promise.all([\n      this.getNode(this.rootHash),\n      last.getNode(last.rootHash),\n    ]);\n    yield* diffNodes(lastNode, currentNode, last, this);\n  }\n}\n\nasync function* diffNodes(\n  last: InternalNodeImpl | DataNodeImpl,\n  current: InternalNodeImpl | DataNodeImpl,\n  lastTree: BTreeRead,\n  currentTree: BTreeRead,\n): AsyncIterableIterator<InternalDiffOperation> {\n  if (last.level > current.level) {\n    // merge all of last's children into a new node\n    // We know last is an internal node because level > 0.\n    const lastChild = (await (last as InternalNodeImpl).getCompositeChildren(\n      0,\n      last.entries.length,\n      lastTree,\n    )) as InternalNodeImpl;\n    yield* diffNodes(lastChild, current, lastTree, currentTree);\n    return;\n  }\n\n  if (current.level > last.level) {\n    // We know current is an internal node because level > 0.\n    const currentChild = (await (\n      current as InternalNodeImpl\n    ).getCompositeChildren(\n      0,\n      current.entries.length,\n      currentTree,\n    )) as InternalNodeImpl;\n    yield* diffNodes(last, currentChild, lastTree, currentTree);\n    return;\n  }\n\n  if (isDataNodeImpl(last) && isDataNodeImpl(current)) {\n    yield* diffEntries(\n      (last as DataNodeImpl).entries,\n      (current as DataNodeImpl).entries,\n    );\n    return;\n  }\n\n  // Now we have two internal nodes with the same level. We compute the diff as\n  // splices for the internal node entries. We then flatten these and call diff\n  // recursively.\n  const initialSplices = computeSplices(\n    (last as InternalNodeImpl).entries,\n    (current as InternalNodeImpl).entries,\n  );\n  for (const splice of initialSplices) {\n    const [lastChild, currentChild] = await Promise.all([\n      (last as InternalNodeImpl).getCompositeChildren(\n        splice[SPLICE_AT],\n        splice[SPLICE_REMOVED],\n        lastTree,\n      ),\n      (current as InternalNodeImpl).getCompositeChildren(\n        splice[SPLICE_FROM],\n        splice[SPLICE_ADDED],\n        currentTree,\n      ),\n    ]);\n    yield* diffNodes(lastChild, currentChild, lastTree, currentTree);\n  }\n}\n\nfunction* diffEntries(\n  lastEntries: readonly Entry<FrozenJSONValue>[],\n  currentEntries: readonly Entry<FrozenJSONValue>[],\n): IterableIterator<InternalDiffOperation> {\n  const lastLength = lastEntries.length;\n  const currentLength = currentEntries.length;\n  let i = 0;\n  let j = 0;\n  while (i < lastLength && j < currentLength) {\n    const lastKey = lastEntries[i][0];\n    const currentKey = currentEntries[j][0];\n    if (lastKey === currentKey) {\n      if (!deepEqual(lastEntries[i][1], currentEntries[j][1])) {\n        yield {\n          op: 'change',\n          key: lastKey,\n          oldValue: lastEntries[i][1],\n          newValue: currentEntries[j][1],\n        };\n      }\n      i++;\n      j++;\n    } else if (lastKey < currentKey) {\n      yield {\n        op: 'del',\n        key: lastKey,\n        oldValue: lastEntries[i][1],\n      };\n      i++;\n    } else {\n      yield {\n        op: 'add',\n        key: currentKey,\n        newValue: currentEntries[j][1],\n      };\n      j++;\n    }\n  }\n  for (; i < lastLength; i++) {\n    yield {\n      op: 'del',\n      key: lastEntries[i][0],\n      oldValue: lastEntries[i][1],\n    };\n  }\n  for (; j < currentLength; j++) {\n    yield {\n      op: 'add',\n      key: currentEntries[j][0],\n      newValue: currentEntries[j][1],\n    };\n  }\n}\n\n// Redefine the type here to allow the optional size in the tuple.\ntype ReadNodeResult = readonly [\n  level: number,\n  data: readonly Entry<FrozenJSONValue>[] | readonly Entry<Hash>[],\n];\n\ntype ReadNode = (hash: Hash) => Promise<ReadNodeResult>;\n\nasync function* scanForHash(\n  expectedRootHash: Hash,\n  getRootHash: () => Hash,\n  hash: Hash,\n  fromKey: string,\n  readNode: ReadNode,\n): AsyncIterableIterator<Entry<FrozenJSONValue>> {\n  if (hash === emptyHash) {\n    return;\n  }\n\n  const data = await readNode(hash);\n  const entries = data[NODE_ENTRIES];\n  let i = 0;\n  if (fromKey) {\n    i = binarySearch(fromKey, entries);\n  }\n  if (data[NODE_LEVEL] > 0) {\n    for (; i < entries.length; i++) {\n      yield* scanForHash(\n        expectedRootHash,\n        getRootHash,\n        (entries[i] as Entry<Hash>)[1],\n        fromKey,\n        readNode,\n      );\n      fromKey = '';\n    }\n  } else {\n    for (; i < entries.length; i++) {\n      const rootHash = getRootHash();\n      // If rootHash changed then we start a new iterator from the key.\n      if (expectedRootHash !== rootHash) {\n        yield* scanForHash(\n          rootHash,\n          getRootHash,\n          rootHash,\n          entries[i][0],\n          readNode,\n        );\n        return;\n      }\n      yield entries[i] as Entry<FrozenJSONValue>;\n    }\n  }\n}\n\nexport async function allEntriesAsDiff(\n  map: BTreeRead,\n  op: 'add' | 'del',\n): Promise<InternalDiff> {\n  const diff: InternalDiffOperation[] = [];\n  const make: (entry: Entry<FrozenJSONValue>) => InternalDiffOperation =\n    op === 'add'\n      ? entry => ({\n          op: 'add',\n          key: entry[0],\n          newValue: entry[1],\n        })\n      : entry => ({\n          op: 'del',\n          key: entry[0],\n          oldValue: entry[1],\n        });\n\n  for await (const entry of map.entries()) {\n    diff.push(make(entry));\n  }\n  return diff;\n}\n","export function stringCompare(a: string, b: string): number {\n  if (a === b) {\n    return 0;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 1;\n}\n","import {\n  assertJSONObject,\n  type ReadonlyJSONValue,\n} from '../../shared/src/json.ts';\nimport {stringCompare} from '../../shared/src/string-compare.ts';\nimport type {FrozenJSONValue} from './frozen-json.ts';\n\n/**\n * A cookie is a value that is used to determine the order of snapshots. It\n * needs to be comparable. This can be a `string`, `number` or if you want to\n * use a more complex value, you can use an object with an `order` property. The\n * value `null` is considered to be less than any other cookie and it is used\n * for the first pull when no cookie has been set.\n *\n * The order is the natural order of numbers and strings. If one of the cookies\n * is an object then the value of the `order` property is treated as the cookie\n * when doing comparison.\n *\n * If one of the cookies is a string and the other is a number, the number is\n * fist converted to a string (using `toString()`).\n */\nexport type Cookie =\n  | null\n  | string\n  | number\n  | (ReadonlyJSONValue & {readonly order: number | string});\n\nexport type FrozenCookie =\n  | null\n  | string\n  | number\n  | (FrozenJSONValue & {readonly order: number | string});\n\n/**\n * Compare two cookies.\n * `null` is considered to be less than any other cookie.\n */\nexport function compareCookies(a: Cookie, b: Cookie): number {\n  if (a === b) {\n    return 0;\n  }\n  if (a === null) {\n    return -1;\n  }\n  if (b === null) {\n    return 1;\n  }\n\n  const cva = getCompareValue(a);\n  const cvb = getCompareValue(b);\n\n  // If either a or b is a string. Compare by string.\n  if (typeof cva === 'string' || typeof cvb === 'string') {\n    return stringCompare(String(cva), String(cvb));\n  }\n\n  return cva - cvb;\n}\n\ntype NonNull<T> = T extends null ? never : T;\n\nfunction getCompareValue(cookie: NonNull<Cookie>): string | number {\n  if (typeof cookie === 'string' || typeof cookie === 'number') {\n    return cookie;\n  }\n  return cookie.order;\n}\n\nexport function assertCookie(v: unknown): asserts v is Cookie {\n  if (v === null || typeof v === 'string' || typeof v === 'number') {\n    return;\n  }\n\n  assertJSONObject(v);\n  if (typeof v.order === 'string' || typeof v.order === 'number') {\n    return;\n  }\n\n  throw new Error('Invalid cookie');\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\n// These three were used before...\n// IndexChangeSDD = 1;\n// LocalSDD = 2;\n// SnapshotSDD = 3;\nexport const LocalDD31 = 4;\nexport const SnapshotDD31 = 5;\n\nexport type LocalDD31 = typeof LocalDD31;\nexport type SnapshotDD31 = typeof SnapshotDD31;\n","import {\n  assert,\n  assertArray,\n  assertBoolean,\n  assertNumber,\n  assertObject,\n  assertString,\n  unreachable,\n} from '../../../shared/src/asserts.ts';\nimport {assertJSONValue} from '../../../shared/src/json.ts';\nimport {skipCommitDataAsserts} from '../config.ts';\nimport {type FrozenCookie, compareCookies} from '../cookies.ts';\nimport {type Chunk, type CreateChunk, type Refs, toRefs} from '../dag/chunk.ts';\nimport {type MustGetChunk, type Read, mustGetHeadHash} from '../dag/store.ts';\nimport {\n  type FrozenJSONValue,\n  type FrozenTag,\n  assertDeepFrozen,\n  deepFreeze,\n} from '../frozen-json.ts';\nimport {type Hash, assertHash} from '../hash.ts';\nimport type {IndexDefinition} from '../index-defs.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport * as MetaType from './meta-type-enum.ts';\n\nexport const DEFAULT_HEAD_NAME = 'main';\n\nexport function commitIsLocalDD31(\n  commit: Commit<Meta>,\n): commit is Commit<LocalMetaDD31> {\n  return isLocalMetaDD31(commit.meta);\n}\n\nexport function commitIsLocal(\n  commit: Commit<Meta>,\n): commit is Commit<LocalMetaDD31> {\n  return commitIsLocalDD31(commit);\n}\n\nexport function commitIsSnapshot(\n  commit: Commit<Meta>,\n): commit is Commit<SnapshotMetaDD31> {\n  return isSnapshotMetaDD31(commit.meta);\n}\n\nexport class Commit<M extends Meta> {\n  readonly chunk: Chunk<CommitData<M>>;\n\n  constructor(chunk: Chunk<CommitData<M>>) {\n    this.chunk = chunk;\n  }\n\n  get meta(): M {\n    return this.chunk.data.meta;\n  }\n\n  get valueHash(): Hash {\n    // Already validated!\n    return this.chunk.data.valueHash;\n  }\n\n  getMutationID(clientID: ClientID, dagRead: MustGetChunk): Promise<number> {\n    return getMutationID(clientID, dagRead, this.meta);\n  }\n\n  async getNextMutationID(\n    clientID: ClientID,\n    dagRead: MustGetChunk,\n  ): Promise<number> {\n    return (await this.getMutationID(clientID, dagRead)) + 1;\n  }\n\n  get indexes(): readonly IndexRecord[] {\n    // Already validated!\n    return this.chunk.data.indexes;\n  }\n}\n\nexport async function getMutationID(\n  clientID: ClientID,\n  dagRead: MustGetChunk,\n  meta: Meta,\n): Promise<number> {\n  switch (meta.type) {\n    case MetaType.SnapshotDD31:\n      return meta.lastMutationIDs[clientID] ?? 0;\n\n    case MetaType.LocalDD31: {\n      if (meta.clientID === clientID) {\n        return meta.mutationID;\n      }\n      const {basisHash} = meta;\n      const basisCommit = await commitFromHash(basisHash, dagRead);\n      return getMutationID(clientID, dagRead, basisCommit.meta);\n    }\n\n    default:\n      unreachable(meta);\n  }\n}\n\n/**\n * Returns the set of local commits from the given `fromCommitHash` back to but not\n * including its base snapshot. If `fromCommitHash` is a snapshot, the returned vector\n * will be empty. When, as typical, `fromCommitHash` is the head of the default chain\n * then the returned commits are the set of pending commits, ie the set of local commits\n * that have not yet been pushed to the data layer.\n *\n * The vector of commits is returned in reverse chain order, that is, starting\n * with the commit with hash `fromCommitHash` and walking backwards.\n */\nexport async function localMutations(\n  fromCommitHash: Hash,\n  dagRead: Read,\n): Promise<Commit<LocalMetaDD31>[]> {\n  const commits = await commitChain(fromCommitHash, dagRead);\n  // Filter does not deal with type narrowing.\n  return commits.filter(c => commitIsLocal(c)) as Commit<LocalMetaDD31>[];\n}\n\nexport async function localMutationsDD31(\n  fromCommitHash: Hash,\n  dagRead: Read,\n): Promise<Commit<LocalMetaDD31>[]> {\n  const commits = await commitChain(fromCommitHash, dagRead);\n  // Filter does not deal with type narrowing.\n  return commits.filter(c => commitIsLocalDD31(c)) as Commit<LocalMetaDD31>[];\n}\n\nexport async function localMutationsGreaterThan(\n  commit: Commit<Meta>,\n  mutationIDLimits: Record<ClientID, number>,\n  dagRead: Read,\n): Promise<Commit<LocalMetaDD31>[]> {\n  const commits: Commit<LocalMetaDD31>[] = [];\n  const remainingMutationIDLimits = new Map(Object.entries(mutationIDLimits));\n  while (!commitIsSnapshot(commit) && remainingMutationIDLimits.size > 0) {\n    if (commitIsLocalDD31(commit)) {\n      const {meta} = commit;\n      const mutationIDLowerLimit = remainingMutationIDLimits.get(meta.clientID);\n      if (mutationIDLowerLimit !== undefined) {\n        if (meta.mutationID <= mutationIDLowerLimit) {\n          remainingMutationIDLimits.delete(meta.clientID);\n        } else {\n          commits.push(commit as Commit<LocalMetaDD31>);\n        }\n      }\n    }\n    const {basisHash} = commit.meta;\n    if (basisHash === null) {\n      throw new Error(`Commit ${commit.chunk.hash} has no basis`);\n    }\n    commit = await commitFromHash(basisHash, dagRead);\n  }\n  return commits;\n}\n\nexport async function baseSnapshotFromHead(\n  name: string,\n  dagRead: Read,\n): Promise<Commit<SnapshotMetaDD31>> {\n  const hash = await dagRead.getHead(name);\n  assert(hash, `Missing head ${name}`);\n  return baseSnapshotFromHash(hash, dagRead);\n}\n\nexport async function baseSnapshotHashFromHash(\n  hash: Hash,\n  dagRead: Read,\n): Promise<Hash> {\n  return (await baseSnapshotFromHash(hash, dagRead)).chunk.hash;\n}\n\nexport async function baseSnapshotFromHash(\n  hash: Hash,\n  dagRead: Read,\n): Promise<Commit<SnapshotMetaDD31>> {\n  const commit = await commitFromHash(hash, dagRead);\n  return baseSnapshotFromCommit(commit, dagRead);\n}\n\nexport async function baseSnapshotFromCommit(\n  commit: Commit<Meta>,\n  dagRead: Read,\n): Promise<Commit<SnapshotMetaDD31>> {\n  while (!commitIsSnapshot(commit)) {\n    const {meta} = commit;\n    if (isLocalMetaDD31(meta)) {\n      commit = await commitFromHash(meta.baseSnapshotHash, dagRead);\n    } else {\n      const {basisHash} = meta;\n      if (basisHash === null) {\n        throw new Error(`Commit ${commit.chunk.hash} has no basis`);\n      }\n      commit = await commitFromHash(basisHash, dagRead);\n    }\n  }\n  return commit;\n}\n\nexport function snapshotMetaParts(\n  c: Commit<SnapshotMetaDD31>,\n  clientID: ClientID,\n): [lastMutationID: number, cookie: FrozenCookie | FrozenJSONValue] {\n  const m = c.meta;\n  const lmid = m.lastMutationIDs[clientID] ?? 0;\n  return [lmid, m.cookieJSON];\n}\n\nexport function compareCookiesForSnapshots(\n  a: Commit<SnapshotMetaDD31>,\n  b: Commit<SnapshotMetaDD31>,\n): number {\n  return compareCookies(a.meta.cookieJSON, b.meta.cookieJSON);\n}\n\n/**\n * Returns all commits from the commit with fromCommitHash to its base snapshot,\n * inclusive of both. Resulting vector is in chain-head-first order (so snapshot\n * comes last).\n */\nexport async function commitChain(\n  fromCommitHash: Hash,\n  dagRead: Read,\n): Promise<Commit<Meta>[]> {\n  let commit = await commitFromHash(fromCommitHash, dagRead);\n  const commits = [];\n  while (!commitIsSnapshot(commit)) {\n    const {meta} = commit;\n    const {basisHash} = meta;\n    if (basisHash === null) {\n      throw new Error(`Commit ${commit.chunk.hash} has no basis`);\n    }\n    commits.push(commit);\n    commit = await commitFromHash(basisHash, dagRead);\n  }\n  commits.push(commit);\n  return commits;\n}\n\nexport async function commitFromHash(\n  hash: Hash,\n  dagRead: MustGetChunk,\n): Promise<Commit<Meta>> {\n  const chunk = await dagRead.mustGetChunk(hash);\n  return fromChunk(chunk);\n}\n\nexport async function commitFromHead(\n  name: string,\n  dagRead: Read,\n): Promise<Commit<Meta>> {\n  const hash = await mustGetHeadHash(name, dagRead);\n  return commitFromHash(hash, dagRead);\n}\n\nexport type LocalMetaDD31 = {\n  readonly type: MetaType.LocalDD31;\n  readonly basisHash: Hash;\n  readonly mutationID: number;\n  readonly mutatorName: string;\n  readonly mutatorArgsJSON: FrozenJSONValue;\n  readonly originalHash: Hash | null;\n  readonly timestamp: number;\n  readonly clientID: ClientID;\n  readonly baseSnapshotHash: Hash;\n};\n\nexport type LocalMeta = LocalMetaDD31;\n\nexport function assertLocalMetaDD31(\n  v: Record<string, unknown>,\n): asserts v is LocalMetaDD31 {\n  // type already asserted\n  assertString(v.clientID);\n  assertNumber(v.mutationID);\n  assertString(v.mutatorName);\n  if (!v.mutatorName) {\n    throw new Error('Missing mutator name');\n  }\n  assertJSONValue(v.mutatorArgsJSON);\n  if (v.originalHash !== null) {\n    assertHash(v.originalHash);\n  }\n  assertNumber(v.timestamp);\n}\n\nexport function isLocalMetaDD31(meta: Meta): meta is LocalMetaDD31 {\n  return meta.type === MetaType.LocalDD31;\n}\n\nexport function assertLocalCommitDD31(\n  c: Commit<Meta>,\n): asserts c is Commit<LocalMetaDD31> {\n  assertLocalMetaDD31(c.meta);\n}\n\nexport type SnapshotMetaDD31 = {\n  readonly type: MetaType.SnapshotDD31;\n  readonly basisHash: Hash | null;\n  readonly lastMutationIDs: Record<ClientID, number>;\n  readonly cookieJSON: FrozenCookie;\n};\n\nexport type SnapshotMeta = SnapshotMetaDD31;\n\nexport function assertSnapshotMetaDD31(\n  v: Record<string, unknown>,\n): asserts v is SnapshotMetaDD31 {\n  // type already asserted\n  if (v.basisHash !== null) {\n    assertHash(v.basisHash);\n  }\n  assertJSONValue(v.cookieJSON);\n  assertLastMutationIDs(v.lastMutationIDs);\n}\n\nfunction assertLastMutationIDs(\n  v: unknown,\n): asserts v is Record<ClientID, number> {\n  assertObject(v);\n  for (const e of Object.values(v)) {\n    assertNumber(e);\n  }\n}\n\nexport type Meta = LocalMetaDD31 | SnapshotMetaDD31;\n\nexport function assertSnapshotCommitDD31(\n  c: Commit<Meta>,\n): asserts c is Commit<SnapshotMetaDD31> {\n  assertSnapshotMetaDD31(c.meta);\n}\n\nfunction isSnapshotMetaDD31(meta: Meta): meta is SnapshotMetaDD31 {\n  return meta.type === MetaType.SnapshotDD31;\n}\n\nfunction assertMeta(v: unknown): asserts v is Meta {\n  assertObject(v);\n  assertDeepFrozen(v);\n  if (v.basisHash !== null) {\n    assertString(v.basisHash);\n  }\n\n  assertNumber(v.type);\n  switch (v.type) {\n    case MetaType.LocalDD31:\n      assertLocalMetaDD31(v);\n      break;\n    case MetaType.SnapshotDD31:\n      assertSnapshotMetaDD31(v);\n      break;\n    default:\n      throw new Error(`Invalid enum value ${v.type}`);\n  }\n}\n\n/**\n * This is the type used for index definitions as defined in the Commit chunk data.\n *\n * Changing this requires a REPLICACHE_FORMAT_VERSION bump.\n */\nexport type ChunkIndexDefinition = {\n  readonly name: string;\n  readonly keyPrefix: string;\n  readonly jsonPointer: string;\n  // Used to not exist\n  readonly allowEmpty?: boolean;\n};\n\nexport function chunkIndexDefinitionEqualIgnoreName(\n  a: ChunkIndexDefinition,\n  b: ChunkIndexDefinition,\n): boolean {\n  return (\n    a.jsonPointer === b.jsonPointer &&\n    (a.allowEmpty ?? false) === (b.allowEmpty ?? false) &&\n    a.keyPrefix === b.keyPrefix\n  );\n}\n\nfunction assertChunkIndexDefinition(\n  v: unknown,\n): asserts v is ChunkIndexDefinition {\n  assertObject(v);\n  assertDeepFrozen(v);\n  assertString(v.name);\n  assertString(v.keyPrefix);\n  assertString(v.jsonPointer);\n  if (v.allowEmpty !== undefined) {\n    assertBoolean(v.allowEmpty);\n  }\n}\n\nexport function toChunkIndexDefinition(\n  name: string,\n  indexDefinition: IndexDefinition,\n): Required<ChunkIndexDefinition> {\n  return {\n    name,\n    keyPrefix: indexDefinition.prefix ?? '',\n    jsonPointer: indexDefinition.jsonPointer,\n    allowEmpty: indexDefinition.allowEmpty ?? false,\n  };\n}\n\nexport type IndexRecord = {\n  readonly definition: ChunkIndexDefinition;\n  readonly valueHash: Hash;\n};\n\nfunction assertIndexRecord(v: unknown): asserts v is IndexRecord {\n  assertObject(v);\n  assertDeepFrozen(v);\n  assertChunkIndexDefinition(v.definition);\n  assertString(v.valueHash);\n}\n\nfunction assertIndexRecords(v: unknown): asserts v is IndexRecord[] {\n  assertArray(v);\n  assertDeepFrozen(v);\n  for (const ir of v) {\n    assertIndexRecord(ir);\n  }\n}\n\nexport function newLocalDD31(\n  createChunk: CreateChunk,\n  basisHash: Hash,\n  baseSnapshotHash: Hash,\n  mutationID: number,\n  mutatorName: string,\n  mutatorArgsJSON: FrozenJSONValue,\n  originalHash: Hash | null,\n  valueHash: Hash,\n  indexes: readonly IndexRecord[],\n  timestamp: number,\n  clientID: ClientID,\n): Commit<LocalMetaDD31> {\n  const meta: LocalMetaDD31 = {\n    type: MetaType.LocalDD31,\n    basisHash,\n    baseSnapshotHash,\n    mutationID,\n    mutatorName,\n    mutatorArgsJSON,\n    originalHash,\n    timestamp,\n    clientID,\n  };\n  return commitFromCommitData(\n    createChunk,\n    makeCommitData(meta, valueHash, indexes),\n  );\n}\n\nexport function newSnapshotDD31(\n  createChunk: CreateChunk,\n  basisHash: Hash | null,\n  lastMutationIDs: Record<ClientID, number>,\n  cookieJSON: FrozenCookie,\n  valueHash: Hash,\n  indexes: readonly IndexRecord[],\n): Commit<SnapshotMetaDD31> {\n  return commitFromCommitData(\n    createChunk,\n    newSnapshotCommitDataDD31(\n      basisHash,\n      lastMutationIDs,\n      cookieJSON,\n      valueHash,\n      indexes,\n    ),\n  );\n}\n\nexport function newSnapshotCommitDataDD31(\n  basisHash: Hash | null,\n  lastMutationIDs: Record<ClientID, number>,\n  cookieJSON: FrozenCookie,\n  valueHash: Hash,\n  indexes: readonly IndexRecord[],\n): CommitData<SnapshotMetaDD31> {\n  const meta: SnapshotMetaDD31 = {\n    type: MetaType.SnapshotDD31,\n    basisHash,\n    lastMutationIDs,\n    cookieJSON,\n  };\n  return makeCommitData(meta, valueHash, indexes);\n}\n\nexport function fromChunk(chunk: Chunk): Commit<Meta> {\n  validateChunk(chunk);\n  return new Commit(chunk);\n}\n\nfunction commitFromCommitData<M extends Meta>(\n  createChunk: CreateChunk,\n  data: CommitData<M>,\n): Commit<M> {\n  return new Commit(createChunk(data, getRefs(data)));\n}\n\nexport function getRefs(data: CommitData<Meta>): Refs {\n  const refs: Set<Hash> = new Set();\n  refs.add(data.valueHash);\n  const {meta} = data;\n  switch (meta.type) {\n    case MetaType.LocalDD31:\n      meta.basisHash && refs.add(meta.basisHash);\n      // Local has weak originalHash\n      break;\n    case MetaType.SnapshotDD31:\n      // Snapshot has weak basisHash\n      break;\n    default:\n      unreachable(meta);\n  }\n\n  for (const index of data.indexes) {\n    refs.add(index.valueHash);\n  }\n\n  return toRefs(refs);\n}\n\nexport type CommitData<M extends Meta> = FrozenTag<{\n  readonly meta: M;\n  readonly valueHash: Hash;\n  readonly indexes: readonly IndexRecord[];\n}>;\n\nexport function makeCommitData<M extends Meta>(\n  meta: M,\n  valueHash: Hash,\n  indexes: readonly IndexRecord[],\n): CommitData<M> {\n  return deepFreeze({\n    meta,\n    valueHash,\n    indexes,\n  }) as unknown as CommitData<M>;\n}\n\nexport function assertCommitData(v: unknown): asserts v is CommitData<Meta> {\n  if (skipCommitDataAsserts) {\n    return;\n  }\n\n  assertObject(v);\n  assertDeepFrozen(v);\n  assertMeta(v.meta);\n  assertString(v.valueHash);\n  assertIndexRecords(v.indexes);\n}\n\nfunction validateChunk(chunk: Chunk): asserts chunk is Chunk<CommitData<Meta>> {\n  const {data} = chunk;\n  assertCommitData(data);\n\n  const seen = new Set();\n  for (const index of data.indexes) {\n    const {name} = index.definition;\n    if (seen.has(name)) {\n      throw new Error(`Duplicate index ${name}`);\n    }\n    seen.add(name);\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const Add = 0;\nexport const Remove = 1;\n\nexport type Add = typeof Add;\nexport type Remove = typeof Remove;\n","import type {LogContext} from '@rocicorp/logger';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport type {BTreeRead} from '../btree/read.ts';\nimport type {BTreeWrite} from '../btree/write.ts';\nimport type {FrozenJSONObject, FrozenJSONValue} from '../frozen-json.ts';\nimport type {Hash} from '../hash.ts';\nimport type {IndexRecord} from './commit.ts';\nimport * as IndexOperation from './index-operation-enum.ts';\n\ntype IndexOperation = Enum<typeof IndexOperation>;\n\nexport class IndexRead<BTree = BTreeRead> {\n  readonly meta: IndexRecord;\n  readonly map: BTree;\n\n  constructor(meta: IndexRecord, map: BTree) {\n    this.meta = meta;\n    this.map = map;\n  }\n}\n\nexport class IndexWrite extends IndexRead<BTreeWrite> {\n  // Note: does not update self.meta.valueHash (doesn't need to at this point as flush\n  // is only called during commit.)\n  flush(): Promise<Hash> {\n    return this.map.flush();\n  }\n\n  clear(): Promise<void> {\n    return this.map.clear();\n  }\n}\n\n// Index or de-index a single primary entry.\nexport async function indexValue(\n  lc: LogContext,\n  index: BTreeWrite,\n  op: IndexOperation,\n  key: string,\n  val: FrozenJSONValue,\n  jsonPointer: string,\n  allowEmpty: boolean,\n): Promise<void> {\n  try {\n    for (const entry of getIndexKeys(key, val, jsonPointer, allowEmpty)) {\n      switch (op) {\n        case IndexOperation.Add:\n          await index.put(entry, val);\n          break;\n        case IndexOperation.Remove:\n          await index.del(entry);\n          break;\n      }\n    }\n  } catch (e) {\n    // Right now all the errors that index_value() returns are customers dev\n    // problems: either the value is not json, the pointer is into nowhere, etc.\n    // So we ignore them.\n    lc.info?.('Not indexing value', val, ':', e);\n  }\n}\n\n// Gets the set of index keys for a given primary key and value.\nexport function getIndexKeys(\n  primary: string,\n  value: FrozenJSONValue,\n  jsonPointer: string,\n  allowEmpty: boolean,\n): string[] {\n  const target = evaluateJSONPointer(value, jsonPointer);\n  if (target === undefined) {\n    if (allowEmpty) {\n      return [];\n    }\n    throw new Error(`No value at path: ${jsonPointer}`);\n  }\n\n  const values = Array.isArray(target) ? target : [target];\n\n  const indexKeys: string[] = [];\n  for (const value of values) {\n    if (typeof value === 'string') {\n      indexKeys.push(encodeIndexKey([value, primary]));\n    } else {\n      throw new Error('Unsupported target type');\n    }\n  }\n\n  return indexKeys;\n}\n\nexport const KEY_VERSION_0 = '\\u0000';\nexport const KEY_SEPARATOR = '\\u0000';\n\n/**\n * When using indexes the key is a tuple of the secondary key and the primary\n * key.\n */\nexport type IndexKey = readonly [secondary: string, primary: string];\n\n// An index key is encoded to vec of bytes in the following order:\n//   - key version byte(s), followed by\n//   - the secondary key bytes (which for now is a UTF8 encoded string), followed by\n//   - the key separator, a null byte, followed by\n//   - the primary key bytes\n//\n// The null separator byte ensures that if a secondary key A is longer than B then\n// A always sorts after B. Appending the primary key ensures index keys with\n// identical secondary keys sort in primary key order. Secondary keys must not\n// contain a zero (null) byte.\nexport function encodeIndexKey(indexKey: IndexKey): string {\n  const secondary = indexKey[0];\n  const primary = indexKey[1];\n\n  if (secondary.includes('\\u0000')) {\n    throw new Error('Secondary key cannot contain null byte');\n  }\n  return KEY_VERSION_0 + secondary + KEY_SEPARATOR + primary;\n}\n\n// Returns bytes that can be used to scan for the given secondary index value.\n//\n// Consider a scan for start_secondary_key=\"a\" (97). We want to scan with scan\n// key [0, 97]. We could also scan with [0, 97, 0], but then we couldn't use\n// this function for prefix scans, so we lop off the null byte. If we want\n// the scan to be exclusive, we scan with the next greater value, [0, 97, 1]\n// (we disallow zero bytes in secondary keys).\n//\n// Now it gets a little tricky. We also want to be able to scan using the\n// primary key, start_key. When we do this we have to encode the scan key\n// a little differently We essentially have to fix the value of the\n// secondary key so we can vary the start_key. That is, the match on\n// start_secondary_key becomes an exact match.\n//\n// Consider the scan for start_secondary_key=\"a\" and start_key=[2]. We want\n// to scan with [0, 97, 0, 2]. If we want exclusive we want to scan with\n// the next highest value, [0, 97, 0, 2, 0] (zero bytes are allowed in primary\n// keys). So far so good. It is important to notice that we need to\n// be able to distinguish between not wanting use start_key and wanting to\n// use start_key=[]. In the former case we want to scan with the secondary\n// key value, possibly followed by a 1 with no trailing zero byte ([0, 97]\n// or [0, 97, 1]). In the latter case we want to scan by the secondary\n// key value, followed by the zero byte, followed by the primary key value\n// and another zero if it is exclusive ([0, 97, 0] or [0, 97, 0, 0]).\n// This explains why we need the Option around start_key.\nexport function encodeIndexScanKey(\n  secondary: string,\n  primary: string | undefined,\n): string {\n  const k = encodeIndexKey([secondary, primary || '']);\n  if (primary === undefined) {\n    return k.slice(0, k.length - 1);\n  }\n  return k;\n}\n\n// Decodes an IndexKey encoded by encode_index_key.\nexport function decodeIndexKey(encodedIndexKey: string): IndexKey {\n  if (encodedIndexKey[0] !== KEY_VERSION_0) {\n    throw new Error('Invalid version');\n  }\n\n  const versionLen = KEY_VERSION_0.length;\n  const separatorLen = KEY_SEPARATOR.length;\n  const separatorOffset = encodedIndexKey.indexOf(KEY_SEPARATOR, versionLen);\n  if (separatorOffset === -1) {\n    throw new Error('Invalid formatting');\n  }\n\n  const secondary = encodedIndexKey.slice(versionLen, separatorOffset);\n  const primary = encodedIndexKey.slice(separatorOffset + separatorLen);\n  return [secondary, primary];\n}\n\nexport function evaluateJSONPointer(\n  value: FrozenJSONValue,\n  pointer: string,\n): FrozenJSONValue | undefined {\n  function parseIndex(s: string): number | undefined {\n    if (s.startsWith('+') || (s.startsWith('0') && s.length !== 1)) {\n      return undefined;\n    }\n    return parseInt(s, 10);\n  }\n\n  if (pointer === '') {\n    return value;\n  }\n  if (!pointer.startsWith('/')) {\n    throw new Error(`Invalid JSON pointer: ${pointer}`);\n  }\n\n  const tokens = pointer\n    .split('/')\n    .slice(1)\n    .map(x => x.replace(/~1/g, '/').replace(/~0/g, '~'));\n\n  let target = value;\n  for (const token of tokens) {\n    let targetOpt;\n    if (Array.isArray(target)) {\n      const i = parseIndex(token);\n      if (i === undefined) {\n        return undefined;\n      }\n      targetOpt = target[i];\n    } else if (target === null) {\n      return undefined;\n    } else if (typeof target === 'object') {\n      target = target as FrozenJSONObject;\n      targetOpt = target[token];\n    }\n    if (targetOpt === undefined) {\n      return undefined;\n    }\n    target = targetOpt;\n  }\n  return target;\n}\n","import type {Enum} from '../../../shared/src/enum.ts';\nimport {BTreeRead} from '../btree/read.ts';\nimport type {Read as DagRead} from '../dag/store.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport type {Hash} from '../hash.ts';\nimport {\n  Commit,\n  DEFAULT_HEAD_NAME,\n  type Meta,\n  commitFromHash,\n  commitFromHead,\n} from './commit.ts';\nimport {IndexRead} from './index.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nexport class Read {\n  readonly #dagRead: DagRead;\n  map: BTreeRead;\n  readonly indexes: Map<string, IndexRead>;\n\n  constructor(\n    dagRead: DagRead,\n    map: BTreeRead,\n    indexes: Map<string, IndexRead>,\n  ) {\n    this.#dagRead = dagRead;\n    this.map = map;\n    this.indexes = indexes;\n  }\n\n  has(key: string): Promise<boolean> {\n    return this.map.has(key);\n  }\n\n  get(key: string): Promise<FrozenJSONValue | undefined> {\n    return this.map.get(key);\n  }\n\n  isEmpty(): Promise<boolean> {\n    return this.map.isEmpty();\n  }\n\n  getMapForIndex(indexName: string): BTreeRead {\n    const idx = this.indexes.get(indexName);\n    if (idx === undefined) {\n      throw new Error(`Unknown index name: ${indexName}`);\n    }\n    return idx.map;\n  }\n\n  get closed(): boolean {\n    return this.#dagRead.closed;\n  }\n\n  close(): void {\n    this.#dagRead.release();\n  }\n}\n\nexport function readFromDefaultHead(\n  dagRead: DagRead,\n  formatVersion: FormatVersion,\n): Promise<Read> {\n  return readFromHead(DEFAULT_HEAD_NAME, dagRead, formatVersion);\n}\n\nexport async function readFromHead(\n  name: string,\n  dagRead: DagRead,\n  formatVersion: FormatVersion,\n): Promise<Read> {\n  const commit = await commitFromHead(name, dagRead);\n  return readFromCommit(commit, dagRead, formatVersion);\n}\n\nexport async function readFromHash(\n  hash: Hash,\n  dagRead: DagRead,\n  formatVersion: FormatVersion,\n): Promise<Read> {\n  const commit = await commitFromHash(hash, dagRead);\n  return readFromCommit(commit, dagRead, formatVersion);\n}\n\nfunction readFromCommit(\n  commit: Commit<Meta>,\n  dagRead: DagRead,\n  formatVersion: FormatVersion,\n): Read {\n  const indexes = readIndexesForRead(commit, dagRead, formatVersion);\n  const map = new BTreeRead(dagRead, formatVersion, commit.valueHash);\n  return new Read(dagRead, map, indexes);\n}\n\nexport function readIndexesForRead(\n  commit: Commit<Meta>,\n  dagRead: DagRead,\n  formatVersion: FormatVersion,\n): Map<string, IndexRead> {\n  const m = new Map();\n  for (const index of commit.indexes) {\n    m.set(\n      index.definition.name,\n      new IndexRead(\n        index,\n        new BTreeRead(dagRead, formatVersion, index.valueHash),\n      ),\n    );\n  }\n  return m;\n}\n","export async function asyncIterableToArray<T>(\n  it: AsyncIterable<T>,\n): Promise<T[]> {\n  const arr: T[] = [];\n  for await (const v of it) {\n    arr.push(v);\n  }\n  return arr;\n}\n","import {asyncIterableToArray} from '../async-iterable-to-array.ts';\nimport type {InternalDiff} from './node.ts';\nimport type {BTreeRead} from './read.ts';\n\nexport function diff(\n  oldMap: BTreeRead,\n  newMap: BTreeRead,\n): Promise<InternalDiff> {\n  // Return an array to ensure we do not compute the diff more than once.\n  return asyncIterableToArray(newMap.diff(oldMap));\n}\n","import {Lock} from '@rocicorp/lock';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {type Chunk, type CreateChunk, toRefs} from '../dag/chunk.ts';\nimport type {Write} from '../dag/store.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {type Hash, emptyHash, newRandomHash} from '../hash.ts';\nimport {getSizeOfEntry} from '../size-of-value.ts';\nimport {\n  DataNodeImpl,\n  type Entry,\n  InternalNodeImpl,\n  createNewInternalEntryForNode,\n  emptyDataNode,\n  isDataNodeImpl,\n  newNodeImpl,\n  partition,\n  toChunkData,\n} from './node.ts';\nimport {BTreeRead} from './read.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nexport class BTreeWrite extends BTreeRead {\n  /**\n   * This rw lock is used to ensure we do not mutate the btree in parallel. It\n   * would be a problem if we didn't have the lock in cases like this:\n   *\n   * ```ts\n   * const p1 = tree.put('a', 0);\n   * const p2 = tree.put('b', 1);\n   * await p1;\n   * await p2;\n   * ```\n   *\n   * because both `p1` and `p2` would start from the old root hash but a put\n   * changes the root hash so the two concurrent puts would lead to only one of\n   * them actually working, and it is not deterministic which one would finish\n   * last.\n   */\n  readonly #lock = new Lock();\n  readonly #modified: Map<Hash, DataNodeImpl | InternalNodeImpl> = new Map();\n\n  declare protected _dagRead: Write;\n\n  readonly minSize: number;\n  readonly maxSize: number;\n\n  constructor(\n    dagWrite: Write,\n    formatVersion: FormatVersion,\n    root: Hash = emptyHash,\n    minSize = 8 * 1024,\n    maxSize = 16 * 1024,\n    getEntrySize: <K, V>(k: K, v: V) => number = getSizeOfEntry,\n    chunkHeaderSize?: number,\n  ) {\n    super(dagWrite, formatVersion, root, getEntrySize, chunkHeaderSize);\n\n    this.minSize = minSize;\n    this.maxSize = maxSize;\n  }\n\n  #addToModified(node: DataNodeImpl | InternalNodeImpl): void {\n    assert(node.isMutable);\n    this.#modified.set(node.hash, node);\n    this._cache.set(node.hash, node);\n  }\n\n  updateNode(node: DataNodeImpl | InternalNodeImpl): void {\n    assert(node.isMutable);\n    this.#modified.delete(node.hash);\n    node.hash = newRandomHash();\n    this.#addToModified(node);\n  }\n\n  newInternalNodeImpl(\n    entries: Array<Entry<Hash>>,\n    level: number,\n  ): InternalNodeImpl {\n    const n = new InternalNodeImpl(entries, newRandomHash(), level, true);\n    this.#addToModified(n);\n    return n;\n  }\n\n  newDataNodeImpl(entries: Entry<FrozenJSONValue>[]): DataNodeImpl {\n    const n = new DataNodeImpl(entries, newRandomHash(), true);\n    this.#addToModified(n);\n    return n;\n  }\n\n  newNodeImpl(entries: Entry<FrozenJSONValue>[], level: number): DataNodeImpl;\n  newNodeImpl(entries: Entry<Hash>[], level: number): InternalNodeImpl;\n  newNodeImpl(\n    entries: Entry<Hash>[] | Entry<FrozenJSONValue>[],\n    level: number,\n  ): InternalNodeImpl | DataNodeImpl;\n  newNodeImpl(\n    entries: Entry<Hash>[] | Entry<FrozenJSONValue>[],\n    level: number,\n  ): InternalNodeImpl | DataNodeImpl {\n    const n = newNodeImpl(entries, newRandomHash(), level, true);\n    this.#addToModified(n);\n    return n;\n  }\n\n  put(key: string, value: FrozenJSONValue): Promise<void> {\n    return this.#lock.withLock(async () => {\n      const oldRootNode = await this.getNode(this.rootHash);\n      const entrySize = this.getEntrySize(key, value);\n      const rootNode = await oldRootNode.set(key, value, entrySize, this);\n\n      // We do the rebalancing in the parent so we need to do it here as well.\n      if (rootNode.getChildNodeSize(this) > this.maxSize) {\n        const headerSize = this.chunkHeaderSize;\n        const partitions = partition(\n          rootNode.entries,\n          value => value[2],\n          this.minSize - headerSize,\n          this.maxSize - headerSize,\n        );\n        const {level} = rootNode;\n        const entries: Entry<Hash>[] = partitions.map(entries => {\n          const node = this.newNodeImpl(entries, level);\n          return createNewInternalEntryForNode(node, this.getEntrySize);\n        });\n        const newRoot = this.newInternalNodeImpl(entries, level + 1);\n        this.rootHash = newRoot.hash;\n        return;\n      }\n\n      this.rootHash = rootNode.hash;\n    });\n  }\n\n  del(key: string): Promise<boolean> {\n    return this.#lock.withLock(async () => {\n      const oldRootNode = await this.getNode(this.rootHash);\n      const newRootNode = await oldRootNode.del(key, this);\n\n      // No need to rebalance here since if root gets too small there is nothing\n      // we can do about that.\n      const found = this.rootHash !== newRootNode.hash;\n      if (found) {\n        // Flatten one layer.\n        if (newRootNode.level > 0 && newRootNode.entries.length === 1) {\n          this.rootHash = (newRootNode as InternalNodeImpl).entries[0][1];\n        } else {\n          this.rootHash = newRootNode.hash;\n        }\n      }\n\n      return found;\n    });\n  }\n\n  clear(): Promise<void> {\n    return this.#lock.withLock(() => {\n      this.#modified.clear();\n      this.rootHash = emptyHash;\n    });\n  }\n\n  flush(): Promise<Hash> {\n    return this.#lock.withLock(async () => {\n      const dagWrite = this._dagRead;\n\n      if (this.rootHash === emptyHash) {\n        // Write a chunk for the empty tree.\n        const chunk = dagWrite.createChunk(emptyDataNode, []);\n        await dagWrite.putChunk(chunk as Chunk<ReadonlyJSONValue>);\n        return chunk.hash;\n      }\n\n      const newChunks: Chunk[] = [];\n      const newRoot = gatherNewChunks(\n        this.rootHash,\n        newChunks,\n        dagWrite.createChunk,\n        this.#modified,\n        this._formatVersion,\n      );\n      await Promise.all(newChunks.map(chunk => dagWrite.putChunk(chunk)));\n      this.#modified.clear();\n      this.rootHash = newRoot;\n      return newRoot;\n    });\n  }\n}\n\nfunction gatherNewChunks(\n  hash: Hash,\n  newChunks: Chunk[],\n  createChunk: CreateChunk,\n  modified: Map<Hash, DataNodeImpl | InternalNodeImpl>,\n  formatVersion: FormatVersion,\n): Hash {\n  const node = modified.get(hash);\n  if (node === undefined) {\n    // Not modified, use the original.\n    return hash;\n  }\n\n  if (isDataNodeImpl(node)) {\n    const chunk = createChunk(toChunkData(node, formatVersion), []);\n    newChunks.push(chunk);\n    return chunk.hash;\n  }\n\n  // The BTree cannot have duplicate keys so the child entry hashes are unique.\n  // No need fot a set to dedupe here.\n  const refs: Hash[] = [];\n  const {entries} = node;\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    const childHash = entry[1];\n    const newChildHash = gatherNewChunks(\n      childHash,\n      newChunks,\n      createChunk,\n      modified,\n      formatVersion,\n    );\n    if (newChildHash !== childHash) {\n      // MUTATES the entries!\n      // Hashes do not change the size of the entry because all hashes have the same length\n      entries[i] = [entry[0], newChildHash, entry[2]];\n    }\n    refs.push(newChildHash);\n  }\n  const chunk = createChunk(toChunkData(node, formatVersion), toRefs(refs));\n  newChunks.push(chunk);\n  return chunk.hash;\n}\n","export function lazy<T>(factory: () => T): () => T {\n  let value: T | undefined;\n  return () => {\n    if (value === undefined) {\n      value = factory();\n    }\n    return value;\n  };\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {diff as btreeDiff} from '../btree/diff.ts';\nimport type {InternalDiff} from '../btree/node.ts';\nimport {allEntriesAsDiff, BTreeRead} from '../btree/read.ts';\nimport type {Read} from '../dag/store.ts';\nimport {Commit, commitFromHash, type Meta} from '../db/commit.ts';\nimport {readIndexesForRead} from '../db/read.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\n/**\n * Interface allowing different diff functions to skip costly diff computations.\n */\nexport interface DiffComputationConfig {\n  shouldComputeDiffs(): boolean;\n  shouldComputeDiffsForIndex(name: string): boolean;\n}\n\n/**\n * The diffs in different indexes. The key of the map is the index name.\n * \"\" is used for the primary index.\n */\nexport class DiffsMap extends Map<string, InternalDiff> {\n  override set(key: string, value: InternalDiff): this {\n    if (value.length === 0) {\n      return this;\n    }\n    return super.set(key, value);\n  }\n}\n\n/**\n * Diffs the state of the db at two different hashes.\n * It will include the primary indexes as well as all the secondary indexes.\n */\nexport async function diff(\n  oldHash: Hash,\n  newHash: Hash,\n  read: Read,\n  diffConfig: DiffComputationConfig,\n  formatVersion: FormatVersion,\n): Promise<DiffsMap> {\n  const [oldCommit, newCommit] = await Promise.all([\n    commitFromHash(oldHash, read),\n    commitFromHash(newHash, read),\n  ]);\n\n  return diffCommits(oldCommit, newCommit, read, diffConfig, formatVersion);\n}\n\n/**\n * Diffs the state of the db at two different commits.\n * It will include the primary indexes as well as all the secondary indexes.\n */\n// TODO: this should probably move to db/\nexport async function diffCommits(\n  oldCommit: Commit<Meta>,\n  newCommit: Commit<Meta>,\n  read: Read,\n  diffConfig: DiffComputationConfig,\n  formatVersion: FormatVersion,\n): Promise<DiffsMap> {\n  const diffsMap = new DiffsMap();\n  if (!diffConfig.shouldComputeDiffs()) {\n    return diffsMap;\n  }\n\n  const oldMap = new BTreeRead(read, formatVersion, oldCommit.valueHash);\n  const newMap = new BTreeRead(read, formatVersion, newCommit.valueHash);\n  const valueDiff = await btreeDiff(oldMap, newMap);\n  diffsMap.set('', valueDiff);\n\n  await addDiffsForIndexes(\n    oldCommit,\n    newCommit,\n    read,\n    diffsMap,\n    diffConfig,\n    formatVersion,\n  );\n\n  return diffsMap;\n}\n\nexport async function addDiffsForIndexes(\n  mainCommit: Commit<Meta>,\n  syncCommit: Commit<Meta>,\n  read: Read,\n  diffsMap: DiffsMap,\n  diffConfig: DiffComputationConfig,\n  formatVersion: FormatVersion,\n) {\n  const oldIndexes = readIndexesForRead(mainCommit, read, formatVersion);\n  const newIndexes = readIndexesForRead(syncCommit, read, formatVersion);\n\n  for (const [oldIndexName, oldIndex] of oldIndexes) {\n    if (!diffConfig.shouldComputeDiffsForIndex(oldIndexName)) {\n      continue;\n    }\n\n    const newIndex = newIndexes.get(oldIndexName);\n    if (newIndex !== undefined) {\n      assert(newIndex !== oldIndex);\n      const diffs = await btreeDiff(oldIndex.map, newIndex.map);\n      newIndexes.delete(oldIndexName);\n      diffsMap.set(oldIndexName, diffs);\n    } else {\n      // old index name is not in the new indexes. All entries removed!\n      const diffs = await allEntriesAsDiff(oldIndex.map, 'del');\n      diffsMap.set(oldIndexName, diffs);\n    }\n  }\n\n  for (const [newIndexName, newIndex] of newIndexes) {\n    if (!diffConfig.shouldComputeDiffsForIndex(newIndexName)) {\n      continue;\n    }\n    // new index name is not in the old indexes. All keys added!\n    const diffs = await allEntriesAsDiff(newIndex.map, 'add');\n    diffsMap.set(newIndexName, diffs);\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {diff} from '../btree/diff.ts';\nimport type {InternalDiff} from '../btree/node.ts';\nimport {BTreeRead, allEntriesAsDiff} from '../btree/read.ts';\nimport {BTreeWrite} from '../btree/write.ts';\nimport type {FrozenCookie} from '../cookies.ts';\nimport type {Write as DagWrite} from '../dag/store.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {type Hash, emptyHash} from '../hash.ts';\nimport {lazy} from '../lazy.ts';\nimport type {DiffComputationConfig} from '../sync/diff.ts';\nimport {DiffsMap} from '../sync/diff.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {\n  Commit,\n  type Meta as CommitMeta,\n  type IndexRecord,\n  type Meta,\n  baseSnapshotHashFromHash,\n  commitFromHash,\n  newLocalDD31 as commitNewLocalDD31,\n  newSnapshotDD31 as commitNewSnapshotDD31,\n  getMutationID,\n} from './commit.ts';\nimport * as IndexOperation from './index-operation-enum.ts';\nimport {IndexRead, IndexWrite, indexValue} from './index.ts';\nimport * as MetaType from './meta-type-enum.ts';\nimport {Read, readIndexesForRead} from './read.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nexport class Write extends Read {\n  readonly #dagWrite: DagWrite;\n  readonly #basis: Commit<CommitMeta> | undefined;\n  readonly #meta: CommitMeta;\n\n  declare map: BTreeWrite;\n\n  declare readonly indexes: Map<string, IndexWrite>;\n  readonly #clientID: ClientID;\n  readonly #formatVersion: FormatVersion;\n\n  constructor(\n    dagWrite: DagWrite,\n    map: BTreeWrite,\n    basis: Commit<CommitMeta> | undefined,\n    meta: CommitMeta,\n    indexes: Map<string, IndexWrite>,\n    clientID: ClientID,\n    formatVersion: FormatVersion,\n  ) {\n    // TypeScript has trouble\n    super(dagWrite, map, indexes);\n    this.#dagWrite = dagWrite;\n    this.#basis = basis;\n    this.#meta = meta;\n    this.#clientID = clientID;\n    this.#formatVersion = formatVersion;\n\n    // TODO(arv): if (DEBUG) { ...\n    if (basis === undefined) {\n      assert(meta.basisHash === emptyHash);\n    } else {\n      assert(meta.basisHash === basis.chunk.hash);\n    }\n  }\n\n  /**\n   * The value needs to be frozen since it is kept in memory and used later for\n   * comparison as well as returned in `get`.\n   */\n  async put(\n    lc: LogContext,\n    key: string,\n    value: FrozenJSONValue,\n  ): Promise<void> {\n    const oldVal = lazy(() => this.map.get(key));\n    await updateIndexes(lc, this.indexes, key, oldVal, value);\n\n    await this.map.put(key, value);\n  }\n\n  getMutationID(): Promise<number> {\n    return getMutationID(this.#clientID, this.#dagWrite, this.#meta);\n  }\n\n  async del(lc: LogContext, key: string): Promise<boolean> {\n    // TODO(arv): This does the binary search twice. We can do better.\n    const oldVal = lazy(() => this.map.get(key));\n    if (oldVal !== undefined) {\n      await updateIndexes(lc, this.indexes, key, oldVal, undefined);\n    }\n    return this.map.del(key);\n  }\n\n  async clear(): Promise<void> {\n    await this.map.clear();\n    const ps = [];\n    for (const idx of this.indexes.values()) {\n      ps.push(idx.clear());\n    }\n    await Promise.all(ps);\n  }\n\n  async putCommit(): Promise<Commit<CommitMeta>> {\n    const valueHash = await this.map.flush();\n    const indexRecords: IndexRecord[] = [];\n\n    for (const index of this.indexes.values()) {\n      const valueHash = await index.flush();\n      const indexRecord: IndexRecord = {\n        definition: index.meta.definition,\n        valueHash,\n      };\n      indexRecords.push(indexRecord);\n    }\n\n    let commit: Commit<Meta>;\n    const meta = this.#meta;\n    switch (meta.type) {\n      case MetaType.LocalDD31: {\n        assert(this.#formatVersion >= FormatVersion.DD31);\n        const {\n          basisHash,\n          mutationID,\n          mutatorName,\n          mutatorArgsJSON,\n          originalHash,\n          timestamp,\n        } = meta;\n        commit = commitNewLocalDD31(\n          this.#dagWrite.createChunk,\n          basisHash,\n          await baseSnapshotHashFromHash(basisHash, this.#dagWrite),\n          mutationID,\n          mutatorName,\n          mutatorArgsJSON,\n          originalHash,\n          valueHash,\n          indexRecords,\n          timestamp,\n          this.#clientID,\n        );\n        break;\n      }\n\n      case MetaType.SnapshotDD31: {\n        assert(this.#formatVersion > FormatVersion.DD31);\n        const {basisHash, lastMutationIDs, cookieJSON} = meta;\n        commit = commitNewSnapshotDD31(\n          this.#dagWrite.createChunk,\n          basisHash,\n          lastMutationIDs,\n          cookieJSON,\n          valueHash,\n          indexRecords,\n        );\n        break;\n      }\n    }\n    await this.#dagWrite.putChunk(commit.chunk);\n    return commit;\n  }\n\n  // Return value is the hash of the new commit.\n  async commit(headName: string): Promise<Hash> {\n    const commit = await this.putCommit();\n    const commitHash = commit.chunk.hash;\n    await this.#dagWrite.setHead(headName, commitHash);\n    await this.#dagWrite.commit();\n    return commitHash;\n  }\n\n  async commitWithDiffs(\n    headName: string,\n    diffConfig: DiffComputationConfig,\n  ): Promise<[Hash, DiffsMap]> {\n    const commit = this.putCommit();\n    const diffMap = await this.#generateDiffs(diffConfig);\n    const commitHash = (await commit).chunk.hash;\n    await this.#dagWrite.setHead(headName, commitHash);\n    await this.#dagWrite.commit();\n    return [commitHash, diffMap];\n  }\n\n  async #generateDiffs(diffConfig: DiffComputationConfig): Promise<DiffsMap> {\n    const diffsMap = new DiffsMap();\n    if (!diffConfig.shouldComputeDiffs()) {\n      return diffsMap;\n    }\n\n    let valueDiff: InternalDiff = [];\n    if (this.#basis) {\n      const basisMap = new BTreeRead(\n        this.#dagWrite,\n        this.#formatVersion,\n        this.#basis.valueHash,\n      );\n      valueDiff = await diff(basisMap, this.map);\n    }\n    diffsMap.set('', valueDiff);\n    let basisIndexes: Map<string, IndexRead>;\n    if (this.#basis) {\n      basisIndexes = readIndexesForRead(\n        this.#basis,\n        this.#dagWrite,\n        this.#formatVersion,\n      );\n    } else {\n      basisIndexes = new Map();\n    }\n\n    for (const [name, index] of this.indexes) {\n      if (!diffConfig.shouldComputeDiffsForIndex(name)) {\n        continue;\n      }\n      const basisIndex = basisIndexes.get(name);\n      assert(index !== basisIndex);\n\n      const indexDiffResult = await (basisIndex\n        ? diff(basisIndex.map, index.map)\n        : // No basis. All keys are new.\n          allEntriesAsDiff(index.map, 'add'));\n      diffsMap.set(name, indexDiffResult);\n    }\n\n    // Handle indexes in basisIndex but not in this.indexes. All keys are\n    // deleted.\n    for (const [name, basisIndex] of basisIndexes) {\n      if (\n        !this.indexes.has(name) &&\n        diffConfig.shouldComputeDiffsForIndex(name)\n      ) {\n        const indexDiffResult = await allEntriesAsDiff(basisIndex.map, 'del');\n        diffsMap.set(name, indexDiffResult);\n      }\n    }\n    return diffsMap;\n  }\n\n  close(): void {\n    this.#dagWrite.release();\n  }\n}\n\nexport async function newWriteLocal(\n  basisHash: Hash,\n  mutatorName: string,\n  mutatorArgsJSON: FrozenJSONValue,\n  originalHash: Hash | null,\n  dagWrite: DagWrite,\n  timestamp: number,\n  clientID: ClientID,\n  formatVersion: FormatVersion,\n): Promise<Write> {\n  const basis = await commitFromHash(basisHash, dagWrite);\n  const bTreeWrite = new BTreeWrite(dagWrite, formatVersion, basis.valueHash);\n  const mutationID = await basis.getNextMutationID(clientID, dagWrite);\n  const indexes = readIndexesForWrite(basis, dagWrite, formatVersion);\n  assert(formatVersion >= FormatVersion.DD31);\n  return new Write(\n    dagWrite,\n    bTreeWrite,\n    basis,\n\n    {\n      type: MetaType.LocalDD31,\n      basisHash,\n      baseSnapshotHash: await baseSnapshotHashFromHash(basisHash, dagWrite),\n      mutatorName,\n      mutatorArgsJSON,\n      mutationID,\n      originalHash,\n      timestamp,\n      clientID,\n    },\n    indexes,\n    clientID,\n    formatVersion,\n  );\n}\n\nexport async function newWriteSnapshotDD31(\n  basisHash: Hash,\n  lastMutationIDs: Record<ClientID, number>,\n  cookieJSON: FrozenCookie,\n  dagWrite: DagWrite,\n  clientID: ClientID,\n  formatVersion: FormatVersion,\n): Promise<Write> {\n  const basis = await commitFromHash(basisHash, dagWrite);\n  const bTreeWrite = new BTreeWrite(dagWrite, formatVersion, basis.valueHash);\n  return new Write(\n    dagWrite,\n    bTreeWrite,\n    basis,\n    {basisHash, type: MetaType.SnapshotDD31, lastMutationIDs, cookieJSON},\n    readIndexesForWrite(basis, dagWrite, formatVersion),\n    clientID,\n    formatVersion,\n  );\n}\n\nexport async function updateIndexes(\n  lc: LogContext,\n  indexes: Map<string, IndexWrite>,\n  key: string,\n  oldValGetter: () => Promise<FrozenJSONValue | undefined>,\n  newVal: FrozenJSONValue | undefined,\n): Promise<void> {\n  const ps: Promise<void>[] = [];\n  for (const idx of indexes.values()) {\n    const {keyPrefix} = idx.meta.definition;\n    if (!keyPrefix || key.startsWith(keyPrefix)) {\n      const oldVal = await oldValGetter();\n      if (oldVal !== undefined) {\n        ps.push(\n          indexValue(\n            lc,\n            idx.map,\n            IndexOperation.Remove,\n            key,\n            oldVal,\n            idx.meta.definition.jsonPointer,\n            idx.meta.definition.allowEmpty ?? false,\n          ),\n        );\n      }\n      if (newVal !== undefined) {\n        ps.push(\n          indexValue(\n            lc,\n            idx.map,\n            IndexOperation.Add,\n            key,\n            newVal,\n            idx.meta.definition.jsonPointer,\n            idx.meta.definition.allowEmpty ?? false,\n          ),\n        );\n      }\n    }\n  }\n  await Promise.all(ps);\n}\n\nexport function readIndexesForWrite(\n  commit: Commit<CommitMeta>,\n  dagWrite: DagWrite,\n  formatVersion: FormatVersion,\n): Map<string, IndexWrite> {\n  const m = new Map();\n  for (const index of commit.indexes) {\n    m.set(\n      index.definition.name,\n      new IndexWrite(\n        index,\n        new BTreeWrite(dagWrite, formatVersion, index.valueHash),\n      ),\n    );\n  }\n  return m;\n}\n\nexport async function createIndexBTree(\n  lc: LogContext,\n  dagWrite: DagWrite,\n  valueMap: BTreeRead,\n  prefix: string,\n  jsonPointer: string,\n  allowEmpty: boolean,\n  formatVersion: FormatVersion,\n): Promise<BTreeWrite> {\n  const indexMap = new BTreeWrite(dagWrite, formatVersion);\n  for await (const entry of valueMap.scan(prefix)) {\n    const key = entry[0];\n    if (!key.startsWith(prefix)) {\n      break;\n    }\n    await indexValue(\n      lc,\n      indexMap,\n      IndexOperation.Add,\n      key,\n      entry[1],\n      jsonPointer,\n      allowEmpty,\n    );\n  }\n  return indexMap;\n}\n","import * as valita from '../../../shared/src/valita.ts';\n\n/**\n * The ID describing a group of clients. All clients in the same group share a\n * persistent storage (IDB).\n */\nexport type ClientGroupID = string;\n\nexport const clientGroupIDSchema: valita.Type<ClientGroupID> = valita.string();\n\n/**\n * The ID describing a client.\n */\nexport type ClientID = string;\n\nexport const clientIDSchema: valita.Type<ClientID> = valita.string();\n","import {randomUint64} from '../../../shared/src/random-uint64.ts';\n\n/**\n * Returns a random 18 character string encoded in base32 suitable as a client\n * ID.\n */\nexport function makeClientID(): string {\n  const length = 18;\n  const high = randomUint64();\n  const low = randomUint64();\n  const combined = (high << 64n) | low;\n  return combined.toString(32).slice(-length).padStart(length, '0');\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert, assertObject} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {hasOwn} from '../../../shared/src/has-own.ts';\nimport * as valita from '../../../shared/src/valita.ts';\nimport {emptyDataNode} from '../btree/node.ts';\nimport {BTreeRead} from '../btree/read.ts';\nimport {type FrozenCookie, compareCookies} from '../cookies.ts';\nimport {type Refs, toRefs} from '../dag/chunk.ts';\nimport type {Read, Store, Write} from '../dag/store.ts';\nimport {\n  type ChunkIndexDefinition,\n  Commit,\n  type IndexRecord,\n  type SnapshotMetaDD31,\n  assertSnapshotCommitDD31,\n  baseSnapshotFromHash,\n  chunkIndexDefinitionEqualIgnoreName,\n  getRefs,\n  newSnapshotCommitDataDD31,\n  toChunkIndexDefinition,\n} from '../db/commit.ts';\nimport {createIndexBTree} from '../db/write.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport {type FrozenJSONValue, deepFreeze} from '../frozen-json.ts';\nimport {type Hash, hashSchema} from '../hash.ts';\nimport {type IndexDefinitions, indexDefinitionsEqual} from '../index-defs.ts';\nimport {\n  type ClientGroupID,\n  type ClientID,\n  clientGroupIDSchema,\n} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport {\n  type ClientGroup,\n  getClientGroup,\n  getClientGroups,\n  mutatorNamesEqual,\n  setClientGroup,\n} from './client-groups.ts';\nimport {makeClientID} from './make-client-id.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nexport type ClientMap = ReadonlyMap<ClientID, ClientV5 | ClientV6>;\n\nconst clientV5Schema = valita.readonlyObject({\n  heartbeatTimestampMs: valita.number(),\n\n  headHash: hashSchema,\n\n  /**\n   * The hash of a commit we are in the middle of refreshing into this client's\n   * memdag.\n   */\n  tempRefreshHash: hashSchema.nullable(),\n\n  /**\n   * ID of this client's perdag client group. This needs to be sent in pull\n   * request (to enable syncing all last mutation ids in the client group).\n   */\n  clientGroupID: clientGroupIDSchema,\n});\n\nexport type ClientV5 = valita.Infer<typeof clientV5Schema>;\n\nconst clientV6Schema = valita.readonlyObject({\n  heartbeatTimestampMs: valita.number(),\n\n  /**\n   * A set of hashes, which contains:\n   * 1. The hash of the last commit this client refreshed from its client group\n   *    (this is the commit it bootstrapped from until it completes its first\n   *    refresh).\n   * 2. One or more hashes that were added to retain chunks of a commit while it\n   *    was being refreshed into this client's memdag. (This can be one or more\n   *    because refresh's cleanup step is a separate transaction and can fail).\n   * Upon refresh completing and successfully running its clean up step, this\n   * set will contain a single hash: the hash of the last commit this client\n   * refreshed.\n   */\n  refreshHashes: valita.readonlyArray(hashSchema),\n\n  /**\n   * The hash of the last snapshot commit persisted by this client to this\n   * client's client group, or null if has never persisted a snapshot.\n   */\n  persistHash: hashSchema.nullable(),\n\n  /**\n   * ID of this client's perdag client group. This needs to be sent in pull\n   * request (to enable syncing all last mutation ids in the client group).\n   */\n  clientGroupID: clientGroupIDSchema,\n});\n\nexport type ClientV6 = valita.Infer<typeof clientV6Schema>;\n\nexport type Client = ClientV5 | ClientV6;\n\nfunction isClientV6(client: Client): client is ClientV6 {\n  return (client as ClientV6).refreshHashes !== undefined;\n}\n\nexport const CLIENTS_HEAD_NAME = 'clients';\n\nconst clientSchema = valita.union(clientV5Schema, clientV6Schema);\n\nfunction assertClient(value: unknown): asserts value is Client {\n  valita.assert(value, clientSchema);\n}\n\nexport function assertClientV6(value: unknown): asserts value is ClientV6 {\n  valita.assert(value, clientV6Schema);\n}\n\nfunction chunkDataToClientMap(chunkData: unknown): ClientMap {\n  assertObject(chunkData);\n  const clients = new Map();\n  for (const key in chunkData) {\n    if (hasOwn(chunkData, key)) {\n      const value = chunkData[key];\n      if (value !== undefined) {\n        assertClient(value);\n        clients.set(key, value);\n      }\n    }\n  }\n  return clients;\n}\n\nfunction clientMapToChunkData(\n  clients: ClientMap,\n  dagWrite: Write,\n): FrozenJSONValue {\n  for (const client of clients.values()) {\n    if (isClientV6(client)) {\n      client.refreshHashes.forEach(dagWrite.assertValidHash);\n      if (client.persistHash) {\n        dagWrite.assertValidHash(client.persistHash);\n      }\n    } else {\n      dagWrite.assertValidHash(client.headHash);\n      if (client.tempRefreshHash) {\n        dagWrite.assertValidHash(client.tempRefreshHash);\n      }\n    }\n  }\n  return deepFreeze(Object.fromEntries(clients));\n}\n\nexport async function getClients(dagRead: Read): Promise<ClientMap> {\n  const hash = await dagRead.getHead(CLIENTS_HEAD_NAME);\n  return getClientsAtHash(hash, dagRead);\n}\n\nasync function getClientsAtHash(\n  hash: Hash | undefined,\n  dagRead: Read,\n): Promise<ClientMap> {\n  if (!hash) {\n    return new Map();\n  }\n  const chunk = await dagRead.getChunk(hash);\n  return chunkDataToClientMap(chunk?.data);\n}\n\n/**\n * Used to signal that a client does not exist. Maybe it was garbage collected?\n */\nexport class ClientStateNotFoundError extends Error {\n  name = 'ClientStateNotFoundError';\n  readonly id: string;\n  constructor(id: ClientID) {\n    super(`Client state not found, id: ${id}`);\n    this.id = id;\n  }\n}\n\n/**\n * Throws a `ClientStateNotFoundError` if the client does not exist.\n */\nexport async function assertHasClientState(\n  id: ClientID,\n  dagRead: Read,\n): Promise<void> {\n  if (!(await hasClientState(id, dagRead))) {\n    throw new ClientStateNotFoundError(id);\n  }\n}\n\nexport async function hasClientState(\n  id: ClientID,\n  dagRead: Read,\n): Promise<boolean> {\n  return !!(await getClient(id, dagRead));\n}\n\nexport async function getClient(\n  id: ClientID,\n  dagRead: Read,\n): Promise<Client | undefined> {\n  const clients = await getClients(dagRead);\n  return clients.get(id);\n}\n\nexport async function mustGetClient(\n  id: ClientID,\n  dagRead: Read,\n): Promise<Client> {\n  const client = await getClient(id, dagRead);\n  if (!client) {\n    throw new ClientStateNotFoundError(id);\n  }\n  return client;\n}\n\ntype InitClientV6Result = [\n  client: ClientV6,\n  hash: Hash,\n  clientMap: ClientMap,\n  newClientGroup: boolean,\n];\n\nexport function initClientV6(\n  newClientID: ClientID,\n  lc: LogContext,\n  perdag: Store,\n  mutatorNames: string[],\n  indexes: IndexDefinitions,\n  formatVersion: FormatVersion,\n  enableClientGroupForking: boolean,\n): Promise<InitClientV6Result> {\n  return withWrite(perdag, async dagWrite => {\n    async function setClientsAndClientGroupAndCommit(\n      basisHash: Hash | null,\n      cookieJSON: FrozenCookie,\n      valueHash: Hash,\n      indexRecords: readonly IndexRecord[],\n    ): Promise<InitClientV6Result> {\n      const newSnapshotData = newSnapshotCommitDataDD31(\n        basisHash,\n        {},\n        cookieJSON,\n        valueHash,\n        indexRecords,\n      );\n      const chunk = dagWrite.createChunk(\n        newSnapshotData,\n        getRefs(newSnapshotData),\n      );\n\n      const newClientGroupID = makeClientID();\n\n      const newClient: ClientV6 = {\n        heartbeatTimestampMs: Date.now(),\n        refreshHashes: [chunk.hash],\n        persistHash: null,\n        clientGroupID: newClientGroupID,\n      };\n\n      const newClients = new Map(clients).set(newClientID, newClient);\n\n      const clientGroup: ClientGroup = {\n        headHash: chunk.hash,\n        mutatorNames,\n        indexes,\n        mutationIDs: {},\n        lastServerAckdMutationIDs: {},\n        disabled: false,\n      };\n\n      await Promise.all([\n        dagWrite.putChunk(chunk),\n        setClients(newClients, dagWrite),\n        setClientGroup(newClientGroupID, clientGroup, dagWrite),\n      ]);\n\n      return [newClient, chunk.hash, newClients, true];\n    }\n\n    const clients = await getClients(dagWrite);\n\n    const res = await findMatchingClient(dagWrite, mutatorNames, indexes);\n    if (res.type === FIND_MATCHING_CLIENT_TYPE_HEAD) {\n      // We found a client group with matching mutators and indexes. We can\n      // reuse it.\n      const {clientGroupID, headHash} = res;\n\n      const newClient: ClientV6 = {\n        clientGroupID,\n        refreshHashes: [headHash],\n        heartbeatTimestampMs: Date.now(),\n        persistHash: null,\n      };\n      const newClients = new Map(clients).set(newClientID, newClient);\n      await setClients(newClients, dagWrite);\n\n      return [newClient, headHash, newClients, false];\n    }\n\n    if (\n      !enableClientGroupForking ||\n      res.type === FIND_MATCHING_CLIENT_TYPE_NEW\n    ) {\n      // No client group to fork from. Create empty snapshot.\n      const emptyBTreeChunk = dagWrite.createChunk(emptyDataNode, []);\n      await dagWrite.putChunk(emptyBTreeChunk);\n\n      // Create indexes\n      const indexRecords: IndexRecord[] = [];\n\n      // At this point the value of replicache is the empty tree so all index\n      // maps will also be the empty tree.\n      for (const [name, indexDefinition] of Object.entries(indexes)) {\n        const chunkIndexDefinition = toChunkIndexDefinition(\n          name,\n          indexDefinition,\n        );\n        indexRecords.push({\n          definition: chunkIndexDefinition,\n          valueHash: emptyBTreeChunk.hash,\n        });\n      }\n\n      return setClientsAndClientGroupAndCommit(\n        null,\n        null,\n        emptyBTreeChunk.hash,\n        indexRecords,\n      );\n    }\n\n    // Now we create a new client and client group that we fork from the found\n    // snapshot.\n    assert(res.type === FIND_MATCHING_CLIENT_TYPE_FORK);\n\n    const {snapshot} = res;\n\n    // Create indexes\n    const indexRecords: IndexRecord[] = [];\n    const {valueHash, indexes: oldIndexes} = snapshot;\n    const map = new BTreeRead(dagWrite, formatVersion, valueHash);\n\n    for (const [name, indexDefinition] of Object.entries(indexes)) {\n      const {prefix = '', jsonPointer, allowEmpty = false} = indexDefinition;\n      const chunkIndexDefinition: ChunkIndexDefinition = {\n        name,\n        keyPrefix: prefix,\n        jsonPointer,\n        allowEmpty,\n      };\n\n      const oldIndex = findMatchingOldIndex(oldIndexes, chunkIndexDefinition);\n      if (oldIndex) {\n        indexRecords.push({\n          definition: chunkIndexDefinition,\n          valueHash: oldIndex.valueHash,\n        });\n      } else {\n        const indexBTree = await createIndexBTree(\n          lc,\n          dagWrite,\n          map,\n          prefix,\n          jsonPointer,\n          allowEmpty,\n          formatVersion,\n        );\n        indexRecords.push({\n          definition: chunkIndexDefinition,\n          valueHash: await indexBTree.flush(),\n        });\n      }\n    }\n\n    return setClientsAndClientGroupAndCommit(\n      snapshot.meta.basisHash,\n      snapshot.meta.cookieJSON,\n      snapshot.valueHash,\n      indexRecords,\n    );\n  });\n}\n\nfunction findMatchingOldIndex(\n  oldIndexes: readonly IndexRecord[],\n  chunkIndexDefinition: ChunkIndexDefinition,\n) {\n  return oldIndexes.find(index =>\n    chunkIndexDefinitionEqualIgnoreName(index.definition, chunkIndexDefinition),\n  );\n}\n\nexport const FIND_MATCHING_CLIENT_TYPE_NEW = 0;\nexport const FIND_MATCHING_CLIENT_TYPE_FORK = 1;\nexport const FIND_MATCHING_CLIENT_TYPE_HEAD = 2;\n\nexport type FindMatchingClientResult =\n  | {\n      type: typeof FIND_MATCHING_CLIENT_TYPE_NEW;\n    }\n  | {\n      type: typeof FIND_MATCHING_CLIENT_TYPE_FORK;\n      snapshot: Commit<SnapshotMetaDD31>;\n    }\n  | {\n      type: typeof FIND_MATCHING_CLIENT_TYPE_HEAD;\n      clientGroupID: ClientGroupID;\n      headHash: Hash;\n    };\n\nexport async function findMatchingClient(\n  dagRead: Read,\n  mutatorNames: string[],\n  indexes: IndexDefinitions,\n): Promise<FindMatchingClientResult> {\n  let newestCookie: FrozenCookie | undefined;\n  let bestSnapshot: Commit<SnapshotMetaDD31> | undefined;\n  const mutatorNamesSet = new Set(mutatorNames);\n\n  const clientGroups = await getClientGroups(dagRead);\n  for (const [clientGroupID, clientGroup] of clientGroups) {\n    if (\n      !clientGroup.disabled &&\n      mutatorNamesEqual(mutatorNamesSet, clientGroup.mutatorNames) &&\n      indexDefinitionsEqual(indexes, clientGroup.indexes)\n    ) {\n      // exact match\n      return {\n        type: FIND_MATCHING_CLIENT_TYPE_HEAD,\n        clientGroupID,\n        headHash: clientGroup.headHash,\n      };\n    }\n\n    const clientGroupSnapshotCommit = await baseSnapshotFromHash(\n      clientGroup.headHash,\n      dagRead,\n    );\n    assertSnapshotCommitDD31(clientGroupSnapshotCommit);\n\n    const {cookieJSON} = clientGroupSnapshotCommit.meta;\n    if (\n      newestCookie === undefined ||\n      compareCookies(cookieJSON, newestCookie) > 0\n    ) {\n      newestCookie = cookieJSON;\n      bestSnapshot = clientGroupSnapshotCommit;\n    }\n  }\n\n  if (bestSnapshot) {\n    return {\n      type: FIND_MATCHING_CLIENT_TYPE_FORK,\n      snapshot: bestSnapshot,\n    };\n  }\n\n  return {type: FIND_MATCHING_CLIENT_TYPE_NEW};\n}\n\nfunction getRefsForClients(clients: ClientMap): Refs {\n  const refs: Set<Hash> = new Set();\n  for (const client of clients.values()) {\n    if (isClientV6(client)) {\n      for (const hash of client.refreshHashes) {\n        refs.add(hash);\n      }\n      if (client.persistHash) {\n        refs.add(client.persistHash);\n      }\n    } else {\n      refs.add(client.headHash);\n      if (client.tempRefreshHash) {\n        refs.add(client.tempRefreshHash);\n      }\n    }\n  }\n  return toRefs(refs);\n}\n\nexport async function getClientGroupForClient(\n  clientID: ClientID,\n  read: Read,\n): Promise<ClientGroup | undefined> {\n  const clientGroupID = await getClientGroupIDForClient(clientID, read);\n  if (!clientGroupID) {\n    return undefined;\n  }\n  return getClientGroup(clientGroupID, read);\n}\n\nexport async function getClientGroupIDForClient(\n  clientID: ClientID,\n  read: Read,\n): Promise<ClientGroupID | undefined> {\n  const client = await getClient(clientID, read);\n  return client?.clientGroupID;\n}\n\n/**\n * Adds a Client to the ClientMap and updates the 'clients' head to point at\n * the updated clients.\n */\nexport async function setClient(\n  clientID: ClientID,\n  client: Client,\n  dagWrite: Write,\n): Promise<Hash> {\n  const clients = await getClients(dagWrite);\n  const newClients = new Map(clients).set(clientID, client);\n  return setClients(newClients, dagWrite);\n}\n\n/**\n * Sets the ClientMap and updates the 'clients' head top point at the new\n * clients.\n */\nexport async function setClients(\n  clients: ClientMap,\n  dagWrite: Write,\n): Promise<Hash> {\n  const chunkData = clientMapToChunkData(clients, dagWrite);\n  const chunk = dagWrite.createChunk(chunkData, getRefsForClients(clients));\n  await dagWrite.putChunk(chunk);\n  await dagWrite.setHead(CLIENTS_HEAD_NAME, chunk.hash);\n  return chunk.hash;\n}\n\n/**\n * Callback function for when Replicache has deleted one or more clients.\n */\nexport type OnClientsDeleted = (\n  clientIDs: readonly ClientID[],\n  clientGroupIDs: readonly ClientGroupID[],\n) => void;\n","export function mapValues<T extends Record<string, unknown>, U>(\n  input: T,\n  mapper: (value: T[keyof T]) => U,\n): {[K in keyof T]: U} {\n  return mapEntries(input, (k, v) => [k, mapper(v as T[keyof T])]) as {\n    [K in keyof T]: U;\n  };\n}\n\nexport function mapEntries<T, U>(\n  input: Record<string, T>,\n  mapper: (key: string, val: T) => [key: string, val: U],\n): Record<string, U> {\n  // Direct assignment is faster than Object.fromEntries()\n  // https://github.com/rocicorp/mono/pull/3927#issuecomment-2706059475\n  const output: Record<string, U> = {};\n\n  // In chrome Object.entries is faster than for-in (13x) or Object.keys (15x)\n  // https://gist.github.com/arv/1b4e113724f6a14e2d4742bcc760d1fa\n  for (const entry of Object.entries(input)) {\n    const mapped = mapper(entry[0], entry[1]);\n    output[mapped[0]] = mapped[1];\n  }\n  return output;\n}\n\nexport function mapAllEntries<T, U>(\n  input: Record<string, T>,\n  mapper: (entries: [key: string, val: T][]) => [key: string, val: U][],\n): Record<string, U> {\n  // Direct assignment is faster than Object.fromEntries()\n  // https://github.com/rocicorp/mono/pull/3927#issuecomment-2706059475\n  const output: Record<string, U> = {};\n  for (const mapped of mapper(Object.entries(input))) {\n    output[mapped[0]] = mapped[1];\n  }\n  return output;\n}\n","export function must<T>(v: T | undefined | null, msg?: string): T {\n  // eslint-disable-next-line eqeqeq\n  if (v == null) {\n    throw new Error(msg ?? `Unexpected ${v} value`);\n  }\n  return v;\n}\n","import {compareUTF8} from 'compare-utf8';\nimport {\n  assertBoolean,\n  assertNumber,\n  assertString,\n} from '../../../shared/src/asserts.ts';\nimport type {Ordering} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {Stream} from './stream.ts';\n\n/**\n * A row flowing through the pipeline, plus its relationships.\n * Relationships are generated lazily as read.\n */\nexport type Node = {\n  row: Row;\n  relationships: Record<string, () => Stream<Node>>;\n};\n\n/**\n * Compare two values. The values must be of the same type. This function\n * throws at runtime if the types differ.\n *\n * Note, this function considers `null === null` and\n * `undefined === undefined`. This is different than SQL. In join code,\n * null must be treated separately.\n *\n * See: https://github.com/rocicorp/mono/pull/2116/files#r1704811479\n *\n * @returns < 0 if a < b, 0 if a === b, > 0 if a > b\n */\nexport function compareValues(a: Value, b: Value): number {\n  a = normalizeUndefined(a);\n  b = normalizeUndefined(b);\n\n  if (a === b) {\n    return 0;\n  }\n  if (a === null) {\n    return -1;\n  }\n  if (b === null) {\n    return 1;\n  }\n  if (typeof a === 'boolean') {\n    assertBoolean(b);\n    return a ? 1 : -1;\n  }\n  if (typeof a === 'number') {\n    assertNumber(b);\n    return a - b;\n  }\n  if (typeof a === 'string') {\n    assertString(b);\n    // We compare all strings in Zero as UTF-8. This is the default on SQLite\n    // and we need to match it. See:\n    // https://blog.replicache.dev/blog/replicache-11-adventures-in-text-encoding.\n    //\n    // TODO: We could change this since SQLite supports UTF-16. Microbenchmark\n    // to see if there's a big win.\n    //\n    // https://www.sqlite.org/c3ref/create_collation.html\n    return compareUTF8(a, b);\n  }\n  throw new Error(`Unsupported type: ${a}`);\n}\n\nexport type NormalizedValue = Exclude<Value, undefined>;\n\n/**\n * We allow undefined to be passed for the convenience of developers, but we\n * treat it equivalently to null. It's better for perf to not create an copy\n * of input values, so we just normalize at use when necessary.\n */\nexport function normalizeUndefined(v: Value): NormalizedValue {\n  return v ?? null;\n}\n\nexport type Comparator = (r1: Row, r2: Row) => number;\n\nexport function makeComparator(\n  order: Ordering,\n  reverse?: boolean | undefined,\n): Comparator {\n  return (a, b) => {\n    // Skip destructuring here since it is hot code.\n    for (const ord of order) {\n      const field = ord[0];\n      const comp = compareValues(a[field], b[field]);\n      if (comp !== 0) {\n        const result = ord[1] === 'asc' ? comp : -comp;\n        return reverse ? -result : result;\n      }\n    }\n    return 0;\n  };\n}\n\n/**\n * Determine if two values are equal. Note that unlike compareValues() above,\n * this function treats `null` as unequal to itself (and same for `undefined`).\n * This is required to make joins work correctly, but may not be the right\n * semantic for your application.\n */\nexport function valuesEqual(a: Value, b: Value): boolean {\n  // eslint-disable-next-line eqeqeq\n  if (a == null || b == null) {\n    return false;\n  }\n  return a === b;\n}\n\nexport function drainStreams(node: Node) {\n  for (const stream of Object.values(node.relationships)) {\n    for (const node of stream()) {\n      drainStreams(node);\n    }\n  }\n}\n","import {\n  assert,\n  assertArray,\n  assertNumber,\n  unreachable,\n} from '../../../shared/src/asserts.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {Writable} from '../../../shared/src/writable.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport {drainStreams, type Comparator, type Node} from './data.ts';\nimport type {SourceSchema} from './schema.ts';\nimport type {Entry, Format} from './view.ts';\n\nexport const refCountSymbol = Symbol('rc');\nexport const idSymbol = Symbol('id');\n\ntype MetaEntry = Writable<Entry> & {\n  [refCountSymbol]: number;\n  [idSymbol]?: string | undefined;\n};\ntype MetaEntryList = MetaEntry[];\n\n/**\n * `applyChange` does not consume the `relationships` of `ChildChange#node`,\n * `EditChange#node` and `EditChange#oldNode`.  The `ViewChange` type\n * documents and enforces this via the type system.\n */\nexport type ViewChange =\n  | AddViewChange\n  | RemoveViewChange\n  | ChildViewChange\n  | EditViewChange;\n\nexport type RowOnlyNode = {row: Row};\n\nexport type AddViewChange = {\n  type: 'add';\n  node: Node;\n};\n\nexport type RemoveViewChange = {\n  type: 'remove';\n  node: Node;\n};\n\ntype ChildViewChange = {\n  type: 'child';\n  node: RowOnlyNode;\n  child: {\n    relationshipName: string;\n    change: ViewChange;\n  };\n};\n\ntype EditViewChange = {\n  type: 'edit';\n  node: RowOnlyNode;\n  oldNode: RowOnlyNode;\n};\n\n/**\n * This is a subset of WeakMap but restricted to what we need.\n * @deprecated Not used anymore. This will be removed in the future.\n */\nexport interface RefCountMap {\n  get(entry: Entry): number | undefined;\n  set(entry: Entry, refCount: number): void;\n  delete(entry: Entry): boolean;\n}\n\nexport function applyChange(\n  parentEntry: Entry,\n  change: ViewChange,\n  schema: SourceSchema,\n  relationship: string,\n  format: Format,\n  withIDs = false,\n): void {\n  if (schema.isHidden) {\n    switch (change.type) {\n      case 'add':\n      case 'remove':\n        for (const [relationship, children] of Object.entries(\n          change.node.relationships,\n        )) {\n          const childSchema = must(schema.relationships[relationship]);\n          for (const node of children()) {\n            applyChange(\n              parentEntry,\n              {type: change.type, node},\n              childSchema,\n              relationship,\n              format,\n              withIDs,\n            );\n          }\n        }\n        return;\n      case 'edit':\n        // If hidden at this level it means that the hidden row was changed. If\n        // the row was changed in such a way that it would change the\n        // relationships then the edit would have been split into remove and\n        // add.\n        return;\n      case 'child': {\n        const childSchema = must(\n          schema.relationships[change.child.relationshipName],\n        );\n        applyChange(\n          parentEntry,\n          change.child.change,\n          childSchema,\n          relationship,\n          format,\n          withIDs,\n        );\n        return;\n      }\n      default:\n        unreachable(change);\n    }\n  }\n\n  const {singular, relationships: childFormats} = format;\n  switch (change.type) {\n    case 'add': {\n      let newEntry: MetaEntry | undefined;\n\n      if (singular) {\n        const oldEntry = parentEntry[relationship] as MetaEntry | undefined;\n        if (oldEntry !== undefined) {\n          assert(\n            schema.compareRows(oldEntry, change.node.row) === 0,\n            `Singular relationship '${relationship}' should not have multiple rows. You may need to declare this relationship with the \\`many\\` helper instead of the \\`one\\` helper in your schema.`,\n          );\n          // adding same again.\n          oldEntry[refCountSymbol]++;\n        } else {\n          newEntry = makeNewMetaEntry(change.node.row, schema, withIDs, 1);\n\n          (parentEntry as Writable<Entry>)[relationship] = newEntry;\n        }\n      } else {\n        newEntry = add(\n          change.node.row,\n          getChildEntryList(parentEntry, relationship),\n          schema,\n          withIDs,\n        );\n      }\n\n      if (newEntry) {\n        for (const [relationship, children] of Object.entries(\n          change.node.relationships,\n        )) {\n          // TODO: Is there a flag to make TypeScript complain that dictionary access might be undefined?\n          const childSchema = must(schema.relationships[relationship]);\n          const childFormat = childFormats[relationship];\n          if (childFormat === undefined) {\n            continue;\n          }\n\n          const newView = childFormat.singular\n            ? undefined\n            : ([] as MetaEntryList);\n          newEntry[relationship] = newView;\n\n          for (const node of children()) {\n            applyChange(\n              newEntry,\n              {type: 'add', node},\n              childSchema,\n              relationship,\n              childFormat,\n              withIDs,\n            );\n          }\n        }\n      }\n      break;\n    }\n    case 'remove': {\n      if (singular) {\n        const oldEntry = parentEntry[relationship] as MetaEntry | undefined;\n        assert(oldEntry !== undefined, 'node does not exist');\n        const rc = oldEntry[refCountSymbol];\n        if (rc === 1) {\n          (parentEntry as Writable<Entry>)[relationship] = undefined;\n        }\n        oldEntry[refCountSymbol]--;\n      } else {\n        removeAndUpdateRefCount(\n          getChildEntryList(parentEntry, relationship),\n          change.node.row,\n          schema.compareRows,\n        );\n      }\n      // Needed to ensure cleanup of operator state is fully done.\n      drainStreams(change.node);\n      break;\n    }\n    case 'child': {\n      let existing: MetaEntry;\n      if (singular) {\n        existing = getSingularEntry(parentEntry, relationship);\n      } else {\n        const view = getChildEntryList(parentEntry, relationship);\n        const {pos, found} = binarySearch(\n          view,\n          change.node.row,\n          schema.compareRows,\n        );\n        assert(found, 'node does not exist');\n        existing = view[pos];\n      }\n\n      const childSchema = must(\n        schema.relationships[change.child.relationshipName],\n      );\n      const childFormat = format.relationships[change.child.relationshipName];\n      if (childFormat !== undefined) {\n        applyChange(\n          existing,\n          change.child.change,\n          childSchema,\n          change.child.relationshipName,\n          childFormat,\n          withIDs,\n        );\n      }\n      break;\n    }\n    case 'edit': {\n      if (singular) {\n        const existing = parentEntry[relationship];\n        assertMetaEntry(existing);\n        applyEdit(existing, change, schema, withIDs);\n      } else {\n        const view = getChildEntryList(parentEntry, relationship);\n        // The position of the row in the list may have changed due to the edit.\n        if (schema.compareRows(change.oldNode.row, change.node.row) !== 0) {\n          const {pos: oldPos, found: oldFound} = binarySearch(\n            view,\n            change.oldNode.row,\n            schema.compareRows,\n          );\n          assert(oldFound, 'old node does not exist');\n          const oldEntry = view[oldPos];\n          const {pos, found} = binarySearch(\n            view,\n            change.node.row,\n            schema.compareRows,\n          );\n          // A special case:\n          // when refCount is 1 (so the row is being moved\n          // without leaving a placeholder behind), and the new pos is\n          // the same as the old, or directly after the old (so after the remove\n          // of the old it would be in the same pos):\n          // the row does not need to be moved, it can just be edited in place.\n          if (\n            oldEntry[refCountSymbol] === 1 &&\n            (pos === oldPos || pos - 1 === oldPos)\n          ) {\n            applyEdit(oldEntry, change, schema, withIDs);\n          } else {\n            // Move the row.  If the row has > 1 ref count, an edit should\n            // be received for each ref count.  On the first edit, the original\n            // row is moved, the edit is applied to it and its ref count is set\n            // to 1.  A shallow copy of the row is left at the old pos for\n            // processing of the remaining edit, and the copy's ref count\n            // is decremented.  As each edit is received the ref count of the\n            // copy is decrement, and the ref count of the row at the new\n            // position is incremented.  When the copy's ref count goes to 0,\n            // it is removed.\n            oldEntry[refCountSymbol]--;\n            let adjustedPos = pos;\n            if (oldEntry[refCountSymbol] === 0) {\n              view.splice(oldPos, 1);\n              adjustedPos = oldPos < pos ? pos - 1 : pos;\n            }\n\n            let entryToEdit;\n            if (found) {\n              entryToEdit = view[adjustedPos];\n            } else {\n              view.splice(adjustedPos, 0, oldEntry);\n              entryToEdit = oldEntry;\n              if (oldEntry[refCountSymbol] > 0) {\n                const oldEntryCopy = {...oldEntry};\n                view[oldPos] = oldEntryCopy;\n              }\n            }\n            entryToEdit[refCountSymbol]++;\n            applyEdit(entryToEdit, change, schema, withIDs);\n          }\n        } else {\n          // Position could not have changed, so simply edit in place.\n          const {pos, found} = binarySearch(\n            view,\n            change.oldNode.row,\n            schema.compareRows,\n          );\n          assert(found, 'node does not exist');\n          applyEdit(view[pos], change, schema, withIDs);\n        }\n      }\n\n      break;\n    }\n    default:\n      unreachable(change);\n  }\n}\n\nfunction applyEdit(\n  existing: MetaEntry,\n  change: EditViewChange,\n  schema: SourceSchema,\n  withIDs: boolean,\n) {\n  Object.assign(existing, change.node.row);\n  if (withIDs) {\n    existing[idSymbol] = makeID(change.node.row, schema);\n  }\n}\n\nfunction add(\n  row: Row,\n  view: MetaEntryList,\n  schema: SourceSchema,\n  withIDs: boolean,\n): MetaEntry | undefined {\n  const {pos, found} = binarySearch(view, row, schema.compareRows);\n\n  if (found) {\n    view[pos][refCountSymbol]++;\n    return undefined;\n  }\n  const newEntry = makeNewMetaEntry(row, schema, withIDs, 1);\n  view.splice(pos, 0, newEntry);\n  return newEntry;\n}\n\nfunction removeAndUpdateRefCount(\n  view: MetaEntryList,\n  row: Row,\n  compareRows: Comparator,\n): MetaEntry {\n  const {pos, found} = binarySearch(view, row, compareRows);\n  assert(found, 'node does not exist');\n  const oldEntry = view[pos];\n  const rc = oldEntry[refCountSymbol];\n  if (rc === 1) {\n    view.splice(pos, 1);\n  }\n  oldEntry[refCountSymbol]--;\n\n  return oldEntry;\n}\n\n// TODO: Do not return an object. It puts unnecessary pressure on the GC.\nfunction binarySearch(\n  view: MetaEntryList,\n  target: Row,\n  comparator: Comparator,\n) {\n  let low = 0;\n  let high = view.length - 1;\n  while (low <= high) {\n    const mid = (low + high) >>> 1;\n    const comparison = comparator(view[mid] as Row, target as Row);\n    if (comparison < 0) {\n      low = mid + 1;\n    } else if (comparison > 0) {\n      high = mid - 1;\n    } else {\n      return {pos: mid, found: true};\n    }\n  }\n  return {pos: low, found: false};\n}\n\nfunction getChildEntryList(\n  parentEntry: Entry,\n  relationship: string,\n): MetaEntryList {\n  const view = parentEntry[relationship];\n  assertArray(view);\n  return view as MetaEntryList;\n}\n\nfunction assertMetaEntry(v: unknown): asserts v is MetaEntry {\n  assertNumber((v as Partial<MetaEntry>)[refCountSymbol]);\n}\n\nfunction getSingularEntry(parentEntry: Entry, relationship: string): MetaEntry {\n  const e = parentEntry[relationship];\n  assertNumber((e as Partial<MetaEntry>)[refCountSymbol]);\n  return e as MetaEntry;\n}\n\nfunction makeNewMetaEntry(\n  row: Row,\n  schema: SourceSchema,\n  withIDs: boolean,\n  rc: number,\n): MetaEntry {\n  if (withIDs) {\n    return {...row, [refCountSymbol]: rc, [idSymbol]: makeID(row, schema)};\n  }\n  return {...row, [refCountSymbol]: rc};\n}\nfunction makeID(row: Row, schema: SourceSchema) {\n  // optimization for case of non-compound primary key\n  if (schema.primaryKey.length === 1) {\n    return JSON.stringify(row[schema.primaryKey[0]]);\n  }\n  return JSON.stringify(schema.primaryKey.map(k => row[k]));\n}\n","import type {LogContext} from '@rocicorp/logger';\n\nexport type TimeUnit = 's' | 'm' | 'h' | 'd' | 'y';\n\n/**\n * Time To Live. This is used for query expiration.\n * - `forever` means the query will never expire.\n * - `none` means the query will expire immediately.\n * - A number means the query will expire after that many milliseconds.\n * - A negative number means the query will never expire, this is same as 'forever'.\n * - A string like `1s` means the query will expire after that many seconds.\n * - A string like `1m` means the query will expire after that many minutes.\n * - A string like `1h` means the query will expire after that many hours.\n * - A string like `1d` means the query will expire after that many days.\n * - A string like `1y` means the query will expire after that many years.\n */\nexport type TTL = `${number}${TimeUnit}` | 'forever' | 'none' | number;\n\nexport const DEFAULT_TTL: TTL = '5m';\nexport const DEFAULT_TTL_MS = 1_000 * 60 * 5;\n\nexport const DEFAULT_PRELOAD_TTL: TTL = 'none';\nexport const DEFAULT_PRELOAD_TTL_MS = 0;\n\nexport const MAX_TTL: TTL = '10m';\nexport const MAX_TTL_MS = 1_000 * 60 * 10;\n\nconst multiplier = {\n  s: 1000,\n  m: 60 * 1000,\n  h: 60 * 60 * 1000,\n  d: 24 * 60 * 60 * 1000,\n  y: 365 * 24 * 60 * 60 * 1000,\n} as const;\n\nexport function parseTTL(ttl: TTL): number {\n  if (typeof ttl === 'number') {\n    return Number.isNaN(ttl) ? 0 : !Number.isFinite(ttl) || ttl < 0 ? -1 : ttl;\n  }\n  if (ttl === 'none') {\n    return 0;\n  }\n  if (ttl === 'forever') {\n    return -1;\n  }\n  const multi = multiplier[ttl[ttl.length - 1] as TimeUnit];\n  return Number(ttl.slice(0, -1)) * multi;\n}\n\nexport function compareTTL(a: TTL, b: TTL): number {\n  const ap = parseTTL(a);\n  const bp = parseTTL(b);\n  if (ap === -1 && bp !== -1) {\n    return 1;\n  }\n  if (ap !== -1 && bp === -1) {\n    return -1;\n  }\n  return ap - bp;\n}\n\nexport function normalizeTTL(ttl: TTL): TTL {\n  if (typeof ttl === 'string') {\n    return ttl;\n  }\n\n  if (ttl < 0) {\n    return 'forever';\n  }\n\n  if (ttl === 0) {\n    return 'none';\n  }\n\n  let shortest = ttl.toString();\n  const lengthOfNumber = shortest.length;\n  for (const unit of ['y', 'd', 'h', 'm', 's'] as const) {\n    const multi = multiplier[unit];\n    const value = ttl / multi;\n    const candidate = `${value}${unit}`;\n    if (candidate.length < shortest.length) {\n      shortest = candidate;\n    }\n  }\n\n  return (shortest.length < lengthOfNumber ? shortest : ttl) as TTL;\n}\n\nexport function clampTTL(ttl: TTL, lc?: Pick<LogContext, 'warn'>): number {\n  const parsedTTL = parseTTL(ttl);\n  if (parsedTTL === -1 || parsedTTL > 10 * 60 * 1000) {\n    // 10 minutes in milliseconds\n    lc?.warn?.(`TTL (${ttl}) is too high, clamping to ${MAX_TTL}`);\n    return parseTTL(MAX_TTL);\n  }\n  return parsedTTL;\n}\n","import * as valita from '@badrap/valita';\nimport {skipAssertJSONValue} from './config.ts';\nimport type {ReadonlyJSONObject, ReadonlyJSONValue} from './json.ts';\nimport {isJSONObject, isJSONValue} from './json.ts';\nimport * as v from './valita.ts';\n\nconst path: (string | number)[] = [];\n\nexport const jsonSchema: valita.Type<ReadonlyJSONValue> = v\n  .unknown()\n  .chain(v => {\n    if (skipAssertJSONValue) {\n      return valita.ok(v as ReadonlyJSONValue);\n    }\n    const rv = isJSONValue(v, path)\n      ? valita.ok(v)\n      : valita.err({\n          message: `Not a JSON value`,\n          path: path.slice(),\n        });\n    path.length = 0;\n    return rv;\n  });\n\nexport const jsonObjectSchema: valita.Type<ReadonlyJSONObject> = v\n  .unknown()\n  .chain(v => {\n    if (skipAssertJSONValue) {\n      return valita.ok(v as ReadonlyJSONObject);\n    }\n    const rv = isJSONObject(v, path)\n      ? valita.ok(v)\n      : valita.err({\n          message: `Not a JSON object`,\n          path: path.slice(),\n        });\n    path.length = 0;\n    return rv;\n  });\n","import * as v from './valita.ts';\n\n/**\n * Valita schema for TDigest JSON representation.\n * Matches the structure returned by TDigest.toJSON().\n */\nexport const tdigestSchema = v.tuple([v.number()]).concat(v.array(v.number()));\n\nexport type TDigestJSON = v.Infer<typeof tdigestSchema>;\n","/**\n * Wire-format representation of the zql AST interface.\n *\n * `v.Type<...>` types are explicitly declared to facilitate Typescript verification\n * that the schemas satisfy the zql type definitions. (Incidentally, explicit types\n * are also required for recursive schema definitions.)\n */\n\nimport {compareUTF8} from 'compare-utf8';\nimport {defined} from '../../shared/src/arrays.ts';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {must} from '../../shared/src/must.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport type {NameMapper} from '../../zero-schema/src/name-mapper.ts';\nimport {rowSchema, type Row} from './data.ts';\n\nexport const selectorSchema = v.string();\nexport const toStaticParam = Symbol();\n\nconst orderingElementSchema = v.readonly(\n  v.tuple([selectorSchema, v.literalUnion('asc', 'desc')]),\n);\n\nexport const orderingSchema = v.readonlyArray(orderingElementSchema);\nexport type System = 'permissions' | 'client' | 'test';\n\nexport const primitiveSchema = v.union(\n  v.string(),\n  v.number(),\n  v.boolean(),\n  v.null(),\n);\n\nexport const equalityOpsSchema = v.literalUnion('=', '!=', 'IS', 'IS NOT');\n\nexport const orderOpsSchema = v.literalUnion('<', '>', '<=', '>=');\n\nexport const likeOpsSchema = v.literalUnion(\n  'LIKE',\n  'NOT LIKE',\n  'ILIKE',\n  'NOT ILIKE',\n);\n\nexport const inOpsSchema = v.literalUnion('IN', 'NOT IN');\n\nexport const simpleOperatorSchema = v.union(\n  equalityOpsSchema,\n  orderOpsSchema,\n  likeOpsSchema,\n  inOpsSchema,\n);\n\nconst literalReferenceSchema: v.Type<LiteralReference> = v.readonlyObject({\n  type: v.literal('literal'),\n  value: v.union(\n    v.string(),\n    v.number(),\n    v.boolean(),\n    v.null(),\n    v.readonlyArray(v.union(v.string(), v.number(), v.boolean())),\n  ),\n});\nconst columnReferenceSchema: v.Type<ColumnReference> = v.readonlyObject({\n  type: v.literal('column'),\n  name: v.string(),\n});\n\n/**\n * A parameter is a value that is not known at the time the query is written\n * and is resolved at runtime.\n *\n * Static parameters refer to something provided by the caller.\n * Static parameters are injected when the query pipeline is built from the AST\n * and do not change for the life of that pipeline.\n *\n * An example static parameter is the current authentication data.\n * When a user is authenticated, queries on the server have access\n * to the user's authentication data in order to evaluate authorization rules.\n * Authentication data doesn't change over the life of a query as a change\n * in auth data would represent a log-in / log-out of the user.\n *\n * AncestorParameters refer to rows encountered while running the query.\n * They are used by subqueries to refer to rows emitted by parent queries.\n */\nconst parameterReferenceSchema = v.readonlyObject({\n  type: v.literal('static'),\n  // The \"namespace\" of the injected parameter.\n  // Write authorization will send the value of a row\n  // prior to the mutation being run (preMutationRow).\n  // Read and write authorization will both send the\n  // current authentication data (authData).\n  anchor: v.literalUnion('authData', 'preMutationRow'),\n  field: v.union(v.string(), v.array(v.string())),\n});\n\nconst conditionValueSchema = v.union(\n  literalReferenceSchema,\n  columnReferenceSchema,\n  parameterReferenceSchema,\n);\n\nexport type Parameter = v.Infer<typeof parameterReferenceSchema>;\n\nexport const simpleConditionSchema: v.Type<SimpleCondition> = v.readonlyObject({\n  type: v.literal('simple'),\n  op: simpleOperatorSchema,\n  left: conditionValueSchema,\n  right: v.union(parameterReferenceSchema, literalReferenceSchema),\n});\n\ntype ConditionValue = v.Infer<typeof conditionValueSchema>;\n\nexport const correlatedSubqueryConditionOperatorSchema: v.Type<CorrelatedSubqueryConditionOperator> =\n  v.literalUnion('EXISTS', 'NOT EXISTS');\n\nexport const correlatedSubqueryConditionSchema: v.Type<CorrelatedSubqueryCondition> =\n  v.readonlyObject({\n    type: v.literal('correlatedSubquery'),\n    related: v.lazy(() => correlatedSubquerySchema),\n    op: correlatedSubqueryConditionOperatorSchema,\n  });\n\nexport const conditionSchema: v.Type<Condition> = v.union(\n  simpleConditionSchema,\n  v.lazy(() => conjunctionSchema),\n  v.lazy(() => disjunctionSchema),\n  correlatedSubqueryConditionSchema,\n);\n\nconst conjunctionSchema: v.Type<Conjunction> = v.readonlyObject({\n  type: v.literal('and'),\n  conditions: v.readonlyArray(conditionSchema),\n});\n\nconst disjunctionSchema: v.Type<Disjunction> = v.readonlyObject({\n  type: v.literal('or'),\n  conditions: v.readonlyArray(conditionSchema),\n});\n\nexport type CompoundKey = readonly [string, ...string[]];\n\nfunction mustCompoundKey(field: readonly string[]): CompoundKey {\n  assert(Array.isArray(field) && field.length >= 1);\n  return field as unknown as CompoundKey;\n}\n\nexport const compoundKeySchema: v.Type<CompoundKey> = v.readonly(\n  v.tuple([v.string()]).concat(v.array(v.string())),\n);\n\nconst correlationSchema = v.readonlyObject({\n  parentField: compoundKeySchema,\n  childField: compoundKeySchema,\n});\n\n// Split out so that its inferred type can be checked against\n// Omit<CorrelatedSubquery, 'correlation'> in ast-type-test.ts.\n// The mutually-recursive reference of the 'other' field to astSchema\n// is the only thing added in v.lazy.  The v.lazy is necessary due to the\n// mutually-recursive types, but v.lazy prevents inference of the resulting\n// type.\nexport const correlatedSubquerySchemaOmitSubquery = v.readonlyObject({\n  correlation: correlationSchema,\n  hidden: v.boolean().optional(),\n  system: v.literalUnion('permissions', 'client', 'test').optional(),\n});\n\nexport const correlatedSubquerySchema: v.Type<CorrelatedSubquery> =\n  correlatedSubquerySchemaOmitSubquery.extend({\n    subquery: v.lazy(() => astSchema),\n  });\n\nexport const astSchema: v.Type<AST> = v.readonlyObject({\n  schema: v.string().optional(),\n  table: v.string(),\n  alias: v.string().optional(),\n  where: conditionSchema.optional(),\n  related: v.readonlyArray(correlatedSubquerySchema).optional(),\n  limit: v.number().optional(),\n  orderBy: orderingSchema.optional(),\n  start: v\n    .object({\n      row: rowSchema,\n      exclusive: v.boolean(),\n    })\n    .optional(),\n});\n\nexport type Bound = {\n  row: Row;\n  exclusive: boolean;\n};\n\n/**\n * As in SQL you can have multiple orderings. We don't currently\n * support ordering on anything other than the root query.\n */\nexport type OrderPart = readonly [field: string, direction: 'asc' | 'desc'];\nexport type Ordering = readonly OrderPart[];\n\nexport type SimpleOperator = EqualityOps | OrderOps | LikeOps | InOps;\nexport type EqualityOps = '=' | '!=' | 'IS' | 'IS NOT';\nexport type OrderOps = '<' | '>' | '<=' | '>=';\nexport type LikeOps = 'LIKE' | 'NOT LIKE' | 'ILIKE' | 'NOT ILIKE';\nexport type InOps = 'IN' | 'NOT IN';\n\nexport type AST = {\n  readonly schema?: string | undefined;\n  readonly table: string;\n\n  // A query would be aliased if the AST is a subquery.\n  // e.g., when two subqueries select from the same table\n  // they need an alias to differentiate them.\n  // `SELECT\n  //   [SELECT * FROM issue WHERE issue.id = outer.parentId] AS parent\n  //   [SELECT * FROM issue WHERE issue.parentId = outer.id] AS children\n  //  FROM issue as outer`\n  readonly alias?: string | undefined;\n\n  // `select` is missing given we return all columns for now.\n\n  // The PipelineBuilder will pick what to use to correlate\n  // a subquery with a parent query. It can choose something from the\n  // where conditions or choose the _first_ `related` entry.\n  // Choosing the first `related` entry is almost always the best choice if\n  // one exists.\n  readonly where?: Condition | undefined;\n\n  readonly related?: readonly CorrelatedSubquery[] | undefined;\n  readonly start?: Bound | undefined;\n  readonly limit?: number | undefined;\n  readonly orderBy?: Ordering | undefined;\n};\n\nexport type Correlation = {\n  readonly parentField: CompoundKey;\n  readonly childField: CompoundKey;\n};\n\nexport type CorrelatedSubquery = {\n  /**\n   * Only equality correlation are supported for now.\n   * E.g., direct foreign key relationships.\n   */\n  readonly correlation: Correlation;\n  readonly subquery: AST;\n  readonly system?: System | undefined;\n  // If a hop in the subquery chain should be hidden from the output view.\n  // A common example is junction edges. The query API provides the illusion\n  // that they don't exist: `issue.related('labels')` instead of `issue.related('issue_labels').related('labels')`.\n  // To maintain this illusion, the junction edge should be hidden.\n  // When `hidden` is set to true, this hop will not be included in the output view\n  // but its children will be.\n  readonly hidden?: boolean | undefined;\n};\n\nexport type ValuePosition = LiteralReference | Parameter | ColumnReference;\n\nexport type ColumnReference = {\n  readonly type: 'column';\n  /**\n   * Not a path yet as we're currently not allowing\n   * comparisons across tables. This will need to\n   * be a path through the tree in the near future.\n   */\n  readonly name: string;\n};\n\nexport type LiteralReference = {\n  readonly type: 'literal';\n  readonly value: LiteralValue;\n};\n\nexport type LiteralValue =\n  | string\n  | number\n  | boolean\n  | null\n  | ReadonlyArray<string | number | boolean>;\n\n/**\n * Starting only with SimpleCondition for now.\n * ivm1 supports Conjunctions and Disjunctions.\n * We'll support them in the future.\n */\nexport type Condition =\n  | SimpleCondition\n  | Conjunction\n  | Disjunction\n  | CorrelatedSubqueryCondition;\n\nexport type SimpleCondition = {\n  readonly type: 'simple';\n  readonly op: SimpleOperator;\n  readonly left: ValuePosition;\n\n  /**\n   * `null` is absent since we do not have an `IS` or `IS NOT`\n   * operator defined and `null != null` in SQL.\n   */\n  readonly right: Exclude<ValuePosition, ColumnReference>;\n};\n\nexport type Conjunction = {\n  type: 'and';\n  conditions: readonly Condition[];\n};\n\nexport type Disjunction = {\n  type: 'or';\n  conditions: readonly Condition[];\n};\n\nexport type CorrelatedSubqueryCondition = {\n  type: 'correlatedSubquery';\n  related: CorrelatedSubquery;\n  op: CorrelatedSubqueryConditionOperator;\n};\n\nexport type CorrelatedSubqueryConditionOperator = 'EXISTS' | 'NOT EXISTS';\n\ninterface ASTTransform {\n  tableName(orig: string): string;\n  columnName(origTable: string, origColumn: string): string;\n  related(subqueries: CorrelatedSubquery[]): readonly CorrelatedSubquery[];\n  where(cond: Condition): Condition | undefined;\n  // conjunction or disjunction, called when traversing the return value of where()\n  conditions(conds: Condition[]): readonly Condition[];\n}\n\nfunction transformAST(ast: AST, transform: ASTTransform): Required<AST> {\n  // Name mapping functions (e.g. to server names)\n  const {tableName, columnName} = transform;\n  const colName = (c: string) => columnName(ast.table, c);\n  const key = (table: string, k: CompoundKey) => {\n    const serverKey = k.map(col => columnName(table, col));\n    return mustCompoundKey(serverKey);\n  };\n\n  const where = ast.where ? transform.where(ast.where) : undefined;\n  const transformed = {\n    schema: ast.schema,\n    table: tableName(ast.table),\n    alias: ast.alias,\n    where: where ? transformWhere(where, ast.table, transform) : undefined,\n    related: ast.related\n      ? transform.related(\n          ast.related.map(\n            r =>\n              ({\n                correlation: {\n                  parentField: key(ast.table, r.correlation.parentField),\n                  childField: key(r.subquery.table, r.correlation.childField),\n                },\n                hidden: r.hidden,\n                subquery: transformAST(r.subquery, transform),\n                system: r.system,\n              }) satisfies Required<CorrelatedSubquery>,\n          ),\n        )\n      : undefined,\n    start: ast.start\n      ? {\n          ...ast.start,\n          row: Object.fromEntries(\n            Object.entries(ast.start.row).map(([col, val]) => [\n              colName(col),\n              val,\n            ]),\n          ),\n        }\n      : undefined,\n    limit: ast.limit,\n    orderBy: ast.orderBy?.map(([col, dir]) => [colName(col), dir] as const),\n  };\n\n  return transformed;\n}\n\nfunction transformWhere(\n  where: Condition,\n  table: string,\n  transform: ASTTransform,\n): Condition {\n  // Name mapping functions (e.g. to server names)\n  const {columnName} = transform;\n  const condValue = (c: ConditionValue) =>\n    c.type !== 'column' ? c : {...c, name: columnName(table, c.name)};\n  const key = (table: string, k: CompoundKey) => {\n    const serverKey = k.map(col => columnName(table, col));\n    return mustCompoundKey(serverKey);\n  };\n\n  if (where.type === 'simple') {\n    return {...where, left: condValue(where.left)};\n  } else if (where.type === 'correlatedSubquery') {\n    const {correlation, subquery} = where.related;\n    return {\n      ...where,\n      related: {\n        ...where.related,\n        correlation: {\n          parentField: key(table, correlation.parentField),\n          childField: key(subquery.table, correlation.childField),\n        },\n        subquery: transformAST(subquery, transform),\n      },\n    };\n  }\n\n  return {\n    type: where.type,\n    conditions: transform.conditions(\n      where.conditions.map(c => transformWhere(c, table, transform)),\n    ),\n  };\n}\n\nconst normalizeCache = new WeakMap<AST, Required<AST>>();\n\nconst NORMALIZE_TRANSFORM: ASTTransform = {\n  tableName: t => t,\n  columnName: (_, c) => c,\n  related: sortedRelated,\n  where: flattened,\n  conditions: c => c.sort(cmpCondition),\n};\n\nexport function normalizeAST(ast: AST): Required<AST> {\n  let normalized = normalizeCache.get(ast);\n  if (!normalized) {\n    normalized = transformAST(ast, NORMALIZE_TRANSFORM);\n    normalizeCache.set(ast, normalized);\n  }\n  return normalized;\n}\n\nexport function mapAST(ast: AST, mapper: NameMapper) {\n  return transformAST(ast, {\n    tableName: table => mapper.tableName(table),\n    columnName: (table, col) => mapper.columnName(table, col),\n    related: r => r,\n    where: w => w,\n    conditions: c => c,\n  });\n}\n\nexport function mapCondition(\n  cond: Condition,\n  table: string,\n  mapper: NameMapper,\n) {\n  return transformWhere(cond, table, {\n    tableName: table => mapper.tableName(table),\n    columnName: (table, col) => mapper.columnName(table, col),\n    related: r => r,\n    where: w => w,\n    conditions: c => c,\n  });\n}\n\nfunction sortedRelated(\n  related: CorrelatedSubquery[],\n): readonly CorrelatedSubquery[] {\n  return related.sort(cmpRelated);\n}\n\nfunction cmpCondition(a: Condition, b: Condition): number {\n  if (a.type === 'simple') {\n    if (b.type !== 'simple') {\n      return -1; // Order SimpleConditions first\n    }\n\n    return (\n      compareValuePosition(a.left, b.left) ||\n      compareUTF8MaybeNull(a.op, b.op) ||\n      compareValuePosition(a.right, b.right)\n    );\n  }\n\n  if (b.type === 'simple') {\n    return 1; // Order SimpleConditions first\n  }\n\n  if (a.type === 'correlatedSubquery') {\n    if (b.type !== 'correlatedSubquery') {\n      return -1; // Order subquery before conjuctions/disjuctions\n    }\n    return cmpRelated(a.related, b.related) || compareUTF8MaybeNull(a.op, b.op);\n  }\n  if (b.type === 'correlatedSubquery') {\n    return -1; // Order correlatedSubquery before conjuctions/disjuctions\n  }\n\n  const val = compareUTF8MaybeNull(a.type, b.type);\n  if (val !== 0) {\n    return val;\n  }\n  for (\n    let l = 0, r = 0;\n    l < a.conditions.length && r < b.conditions.length;\n    l++, r++\n  ) {\n    const val = cmpCondition(a.conditions[l], b.conditions[r]);\n    if (val !== 0) {\n      return val;\n    }\n  }\n  // prefixes first\n  return a.conditions.length - b.conditions.length;\n}\n\nfunction compareValuePosition(a: ValuePosition, b: ValuePosition): number {\n  if (a.type !== b.type) {\n    return compareUTF8(a.type, b.type);\n  }\n  switch (a.type) {\n    case 'literal':\n      assert(b.type === 'literal');\n      return compareUTF8(String(a.value), String(b.value));\n    case 'column':\n      assert(b.type === 'column');\n      return compareUTF8(a.name, b.name);\n    case 'static':\n      throw new Error(\n        'Static parameters should be resolved before normalization',\n      );\n  }\n}\n\nfunction cmpRelated(a: CorrelatedSubquery, b: CorrelatedSubquery): number {\n  return compareUTF8(must(a.subquery.alias), must(b.subquery.alias));\n}\n\n/**\n * Returns a flattened version of the Conditions in which nested Conjunctions with\n * the same operation ('AND' or 'OR') are flattened to the same level. e.g.\n *\n * ```\n * ((a AND b) AND (c AND (d OR (e OR f)))) -> (a AND b AND c AND (d OR e OR f))\n * ```\n *\n * Also flattens singleton Conjunctions regardless of operator, and removes\n * empty Conjunctions.\n */\nfunction flattened(cond: Condition): Condition | undefined {\n  if (cond.type === 'simple' || cond.type === 'correlatedSubquery') {\n    return cond;\n  }\n  const conditions = defined(\n    cond.conditions.flatMap(c =>\n      c.type === cond.type ? c.conditions.map(c => flattened(c)) : flattened(c),\n    ),\n  );\n\n  switch (conditions.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return conditions[0];\n    default:\n      return {\n        type: cond.type,\n        conditions,\n      };\n  }\n}\n\nfunction compareUTF8MaybeNull(a: string | null, b: string | null): number {\n  if (a !== null && b !== null) {\n    return compareUTF8(a, b);\n  }\n  if (b !== null) {\n    return -1;\n  }\n  if (a !== null) {\n    return 1;\n  }\n  return 0;\n}\n","import {assert} from './asserts.ts';\n\n/**\n * Returns `arr` as is if none of the elements are `undefined`.\n * Otherwise returns a new array with only defined elements in `arr`.\n */\nexport function defined<T>(arr: (T | undefined)[]): T[] {\n  // avoid an array copy if possible\n  let i = arr.findIndex(x => x === undefined);\n  if (i < 0) {\n    return arr as T[];\n  }\n  const defined: T[] = arr.slice(0, i) as T[];\n  for (i++; i < arr.length; i++) {\n    const x = arr[i];\n    if (x !== undefined) {\n      defined.push(x);\n    }\n  }\n  return defined;\n}\n\nexport function areEqual<T>(arr1: readonly T[], arr2: readonly T[]): boolean {\n  return arr1.length === arr2.length && arr1.every((e, i) => e === arr2[i]);\n}\n\nexport function zip<T1, T2>(a1: readonly T1[], a2: readonly T2[]): [T1, T2][] {\n  assert(a1.length === a2.length);\n  const result: [T1, T2][] = [];\n  for (let i = 0; i < a1.length; i++) {\n    result.push([a1[i], a2[i]]);\n  }\n  return result;\n}\n\nexport function last<T>(arr: T[]): T | undefined {\n  if (arr.length === 0) {\n    return undefined;\n  }\n  return arr[arr.length - 1];\n}\n\nexport function groupBy<T, K>(\n  arr: readonly T[],\n  keyFn: (el: T) => K,\n): Map<K, T[]> {\n  const groups = new Map<K, T[]>();\n  for (const el of arr) {\n    const key = keyFn(el);\n    let group = groups.get(key);\n    if (group === undefined) {\n      group = [];\n      groups.set(key, group);\n    }\n    group.push(el);\n  }\n  return groups;\n}\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\n\nexport const valueSchema = v.union(jsonSchema, v.undefined());\n\nexport const rowSchema = v.readonlyRecord(valueSchema);\n\n/**\n * The data types that Zero can represent are limited by two things:\n *\n * 1. The underlying Replicache sync layer currently can only represent JSON\n *    types. This could possibly be expanded in the future, but we do want to be\n *    careful of adding encoding overhead. By using JSON, we are taking\n *    advantage of IndexedDB’s fast native JSValue [de]serialization which has\n *    historically been a perf advantage for us.\n *\n * 2. IDs in Zero need to be comparable because we use them for sorting and row\n *    identity. We could expand the set of allowed value types (to include,\n *    i.e., Objects) but we would then need to restrict IDs to only comparable\n *    types.\n *\n * These two facts leave us with the following allowed types. Zero's replication\n * layer must convert other types into these for tables to be used with Zero.\n *\n * For developer convenience we also allow `undefined`, which we treat\n * equivalently to `null`.\n */\nexport type Value = v.Infer<typeof valueSchema>;\n\n/**\n * A Row is represented as a JS Object.\n *\n * We do everything in IVM as loosely typed values because these pipelines are\n * going to be constructed at runtime by other code, so type-safety can't buy us\n * anything.\n *\n * Also since the calling code on the client ultimately wants objects to work\n * with we end up with a lot less copies by using objects throughout.\n */\nexport type Row = v.Infer<typeof rowSchema>;\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport {tdigestSchema} from '../../shared/src/tdigest-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {astSchema} from './ast.ts';\n\nconst serverMetricsSchema = v.object({\n  'query-materialization-server': tdigestSchema,\n  'query-update-server': tdigestSchema,\n});\n\nexport type ServerMetrics = v.Infer<typeof serverMetricsSchema>;\n\nconst inspectQueryRowSchema = v.object({\n  clientID: v.string(),\n  queryID: v.string(),\n  // This is the server return AST for custom queries\n  // TODO: Return server generated AST\n  ast: astSchema.nullable(),\n  // not null for custom queries\n  name: v.string().nullable(),\n  // not null for custom queries\n  args: v.readonlyArray(jsonSchema).nullable(),\n  got: v.boolean(),\n  deleted: v.boolean(),\n  ttl: v.number(),\n  inactivatedAt: v.number().nullable(),\n  rowCount: v.number(),\n  metrics: serverMetricsSchema.nullable().optional(),\n});\n\nexport type InspectQueryRow = v.Infer<typeof inspectQueryRowSchema>;\n\nconst inspectBaseDownSchema = v.object({\n  id: v.string(),\n});\n\nexport const inspectQueriesDownSchema = inspectBaseDownSchema.extend({\n  op: v.literal('queries'),\n  value: v.array(inspectQueryRowSchema),\n});\n\nexport type InspectQueriesDown = v.Infer<typeof inspectQueriesDownSchema>;\n\nexport const inspectMetricsDownSchema = inspectBaseDownSchema.extend({\n  op: v.literal('metrics'),\n  value: serverMetricsSchema,\n});\n\nexport type InspectMetricsDown = v.Infer<typeof inspectMetricsDownSchema>;\n\nexport const inspectVersionDownSchema = inspectBaseDownSchema.extend({\n  op: v.literal('version'),\n  value: v.string(),\n});\n\nexport const inspectDownBodySchema = v.union(\n  inspectQueriesDownSchema,\n  inspectMetricsDownSchema,\n  inspectVersionDownSchema,\n);\n\nexport const inspectDownMessageSchema = v.tuple([\n  v.literal('inspect'),\n  inspectDownBodySchema,\n]);\n\nexport type InspectDownMessage = v.Infer<typeof inspectDownMessageSchema>;\n\nexport type InspectDownBody = v.Infer<typeof inspectDownBodySchema>;\n","export function getNonCryptoRandomValues(array: Uint8Array) {\n  if (array === null) {\n    throw new TypeError('array cannot be null');\n  }\n\n  // Fill the array with random values\n  for (let i = 0; i < array.length; i++) {\n    array[i] = Math.floor(Math.random() * 256); // Random byte (0-255)\n  }\n\n  return array;\n}\n\nexport function randomCharacters(length: number) {\n  let result = '';\n  const characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  let counter = 0;\n  while (counter < length) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    counter += 1;\n  }\n  return result;\n}\n","// This is taken from https://github.com/ai/nanoid/blob/main/index.browser.js We\n// copy this because we want to use `--platform=neutral` which doesn't work with\n// the npm package.\n// Also we changed the random number generator to use Math.random() for compat\n// with React Native.\n\nimport {getNonCryptoRandomValues} from '../../../shared/src/random-values.ts';\n\nexport function nanoid(size = 21): string {\n  // Use our custom getRandomValues function to fill a Uint8Array with random values.\n  const randomBytes = getNonCryptoRandomValues(new Uint8Array(size));\n\n  return randomBytes.reduce((id, byte) => {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    byte &= 63;\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36);\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase();\n    } else if (byte > 62) {\n      id += '-';\n    } else {\n      id += '_';\n    }\n    return id;\n  }, '');\n}\n","import {xxHash32} from 'js-xxhash';\n\nexport const h32 = (s: string) => xxHash32(s, 0);\nexport const h64 = (s: string) => hash(s, 2);\nexport const h128 = (s: string) => hash(s, 4);\n\n/**\n * xxHash32 only computes 32-bit values. Run it n times with different seeds to\n * get a larger hash with better collision resistance.\n */\nfunction hash(str: string, words: number): bigint {\n  let hash = 0n;\n  for (let i = 0; i < words; i++) {\n    hash = (hash << 32n) + BigInt(xxHash32(str, i));\n  }\n  return hash;\n}\n","import * as v from '../../shared/src/valita.ts';\n\nexport const primaryKeySchema = v.readonly(\n  v.tuple([v.string()]).concat(v.array(v.string())),\n);\n\nexport type PrimaryKey = v.Infer<typeof primaryKeySchema>;\n\nexport const primaryKeyValueSchema = v.union(\n  v.string(),\n  v.number(),\n  v.boolean(),\n);\n\nexport type PrimaryKeyValue = v.Infer<typeof primaryKeyValueSchema>;\n\nexport const primaryKeyValueRecordSchema = v.readonlyRecord(\n  primaryKeyValueSchema,\n);\n\nexport type PrimaryKeyValueRecord = v.Infer<typeof primaryKeyValueRecordSchema>;\n","import {h128} from '../../../shared/src/hash.ts';\nimport * as v from '../../../shared/src/valita.ts';\nimport type {CompoundKey} from '../../../zero-protocol/src/ast.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport {primaryKeyValueSchema} from '../../../zero-protocol/src/primary-key.ts';\nimport type {MutationID} from '../../../zero-protocol/src/push.ts';\n\nexport const DESIRED_QUERIES_KEY_PREFIX = 'd/';\nexport const GOT_QUERIES_KEY_PREFIX = 'g/';\nexport const ENTITIES_KEY_PREFIX = 'e/';\nexport const MUTATIONS_KEY_PREFIX = 'm/';\n\nexport function toDesiredQueriesKey(clientID: string, hash: string): string {\n  return DESIRED_QUERIES_KEY_PREFIX + clientID + '/' + hash;\n}\n\nexport function desiredQueriesPrefixForClient(clientID: string): string {\n  return DESIRED_QUERIES_KEY_PREFIX + clientID + '/';\n}\n\nexport function toGotQueriesKey(hash: string): string {\n  return GOT_QUERIES_KEY_PREFIX + hash;\n}\n\nexport function toMutationResponseKey(mid: MutationID): string {\n  return MUTATIONS_KEY_PREFIX + mid.clientID + '/' + mid.id;\n}\n\nexport function toPrimaryKeyString(\n  tableName: string,\n  primaryKey: CompoundKey,\n  value: Row,\n): string {\n  if (primaryKey.length === 1) {\n    return (\n      ENTITIES_KEY_PREFIX +\n      tableName +\n      '/' +\n      v.parse(value[primaryKey[0]], primaryKeyValueSchema)\n    );\n  }\n\n  const values = primaryKey.map(k => v.parse(value[k], primaryKeyValueSchema));\n  const str = JSON.stringify(values);\n\n  const idSegment = h128(str);\n  return ENTITIES_KEY_PREFIX + tableName + '/' + idSegment;\n}\n\nexport function sourceNameFromKey(key: string): string {\n  const slash = key.indexOf('/', ENTITIES_KEY_PREFIX.length);\n  return key.slice(ENTITIES_KEY_PREFIX.length, slash);\n}\n","// Apache License 2.0\n// https://github.com/influxdata/tdigest\n\n// Centroid average position of all points in a shape\nexport class Centroid {\n  mean: number;\n  weight: number;\n\n  constructor(mean: number, weight: number) {\n    this.mean = mean;\n    this.weight = weight;\n  }\n\n  add(r: Centroid): void {\n    if (r.weight < 0) {\n      throw new Error('centroid weight cannot be less than zero');\n    }\n    if (this.weight !== 0) {\n      this.weight += r.weight;\n      this.mean += (r.weight * (r.mean - this.mean)) / this.weight;\n    } else {\n      this.weight = r.weight;\n      this.mean = r.mean;\n    }\n  }\n}\n\n/** CentroidList is sorted by the mean of the centroid, ascending. */\nexport type CentroidList = Centroid[];\n\nexport function sortCentroidList(centroids: CentroidList): void {\n  centroids.sort((a, b) => a.mean - b.mean);\n}\n","// Apache License 2.0\n// https://github.com/influxdata/tdigest\n\nimport {binarySearch} from './binary-search.ts';\nimport {Centroid, sortCentroidList, type CentroidList} from './centroid.ts';\nimport type {TDigestJSON} from './tdigest-schema.ts';\n\nexport interface ReadonlyTDigest {\n  readonly count: () => number;\n  readonly quantile: (q: number) => number;\n  readonly cdf: (x: number) => number;\n}\n\n// TDigest is a data structure for accurate on-line accumulation of\n// rank-based statistics such as quantiles and trimmed means.\nexport class TDigest {\n  readonly compression: number;\n\n  #maxProcessed: number;\n  #maxUnprocessed: number;\n  #processed!: CentroidList;\n  #unprocessed!: CentroidList;\n  #cumulative!: number[];\n  #processedWeight!: number;\n  #unprocessedWeight!: number;\n  #min!: number;\n  #max!: number;\n\n  constructor(compression: number = 1000) {\n    this.compression = compression;\n    this.#maxProcessed = processedSize(0, this.compression);\n    this.#maxUnprocessed = unprocessedSize(0, this.compression);\n    this.reset();\n  }\n\n  /**\n   * fromJSON creates a TDigest from a JSON-serializable representation.\n   * The data should be an object with compression and centroids array.\n   */\n  static fromJSON(data: Readonly<TDigestJSON>): TDigest {\n    const digest = new TDigest(data[0]);\n    if (data.length % 2 !== 1) {\n      throw new Error('Invalid centroids array');\n    }\n    for (let i = 1; i < data.length; i += 2) {\n      digest.add(data[i], data[i + 1]);\n    }\n    return digest;\n  }\n\n  reset(): void {\n    this.#processed = [];\n    this.#unprocessed = [];\n    this.#cumulative = [];\n    this.#processedWeight = 0;\n    this.#unprocessedWeight = 0;\n    this.#min = Number.MAX_VALUE;\n    this.#max = -Number.MAX_VALUE;\n  }\n\n  add(mean: number, weight: number = 1) {\n    this.addCentroid(new Centroid(mean, weight));\n  }\n\n  /** AddCentroidList can quickly add multiple centroids. */\n  addCentroidList(centroidList: CentroidList) {\n    for (const c of centroidList) {\n      this.addCentroid(c);\n    }\n  }\n\n  /**\n   * AddCentroid adds a single centroid.\n   * Weights which are not a number or are <= 0 are ignored, as are NaN means.\n   */\n  addCentroid(c: Centroid): void {\n    if (\n      Number.isNaN(c.mean) ||\n      c.weight <= 0 ||\n      Number.isNaN(c.weight) ||\n      !Number.isFinite(c.weight)\n    ) {\n      return;\n    }\n\n    this.#unprocessed.push(new Centroid(c.mean, c.weight));\n    this.#unprocessedWeight += c.weight;\n\n    if (\n      this.#processed.length > this.#maxProcessed ||\n      this.#unprocessed.length > this.#maxUnprocessed\n    ) {\n      this.#process();\n    }\n  }\n\n  /**\n   *  Merges the supplied digest into this digest. Functionally equivalent to\n   * calling t.AddCentroidList(t2.Centroids(nil)), but avoids making an extra\n   * copy of the CentroidList.\n   **/\n  merge(t2: TDigest) {\n    t2.#process();\n    this.addCentroidList(t2.#processed);\n  }\n\n  #process() {\n    if (\n      this.#unprocessed.length > 0 ||\n      this.#processed.length > this.#maxProcessed\n    ) {\n      // Append all processed centroids to the unprocessed list and sort\n      this.#unprocessed.push(...this.#processed);\n      sortCentroidList(this.#unprocessed);\n\n      // Reset processed list with first centroid\n      this.#processed.length = 0;\n      this.#processed.push(this.#unprocessed[0]);\n\n      this.#processedWeight += this.#unprocessedWeight;\n      this.#unprocessedWeight = 0;\n      let soFar = this.#unprocessed[0].weight;\n      let limit = this.#processedWeight * this.#integratedQ(1);\n      for (let i = 1; i < this.#unprocessed.length; i++) {\n        const centroid = this.#unprocessed[i];\n        const projected = soFar + centroid.weight;\n        if (projected <= limit) {\n          soFar = projected;\n          this.#processed[this.#processed.length - 1].add(centroid);\n        } else {\n          const k1 = this.#integratedLocation(soFar / this.#processedWeight);\n          limit = this.#processedWeight * this.#integratedQ(k1 + 1);\n          soFar += centroid.weight;\n          this.#processed.push(centroid);\n        }\n      }\n      this.#min = Math.min(this.#min, this.#processed[0].mean);\n      this.#max = Math.max(\n        this.#max,\n        this.#processed[this.#processed.length - 1].mean,\n      );\n      this.#unprocessed.length = 0;\n    }\n  }\n\n  /**\n   * Centroids returns a copy of processed centroids.\n   * Useful when aggregating multiple t-digests.\n   *\n   * Centroids are appended to the passed CentroidList; if you're re-using a\n   * buffer, be sure to pass cl[:0].\n   */\n  centroids(cl: CentroidList = []): CentroidList {\n    this.#process();\n    return cl.concat(this.#processed);\n  }\n\n  count(): number {\n    this.#process();\n\n    // this.process always updates this.processedWeight to the total count of all\n    // centroids, so we don't need to re-count here.\n    return this.#processedWeight;\n  }\n\n  /**\n   * toJSON returns a JSON-serializable representation of the digest.\n   * This processes the digest and returns an object with compression and centroid data.\n   */\n  toJSON(): TDigestJSON {\n    this.#process();\n    const data: TDigestJSON = [this.compression];\n    for (const centroid of this.#processed) {\n      data.push(centroid.mean, centroid.weight);\n    }\n    return data;\n  }\n\n  #updateCumulative() {\n    // Weight can only increase, so the final cumulative value will always be\n    // either equal to, or less than, the total weight. If they are the same,\n    // then nothing has changed since the last update.\n    if (\n      this.#cumulative.length > 0 &&\n      this.#cumulative[this.#cumulative.length - 1] === this.#processedWeight\n    ) {\n      return;\n    }\n    const n = this.#processed.length + 1;\n    if (this.#cumulative.length > n) {\n      this.#cumulative.length = n;\n    }\n\n    let prev = 0;\n    for (let i = 0; i < this.#processed.length; i++) {\n      const centroid = this.#processed[i];\n      const cur = centroid.weight;\n      this.#cumulative[i] = prev + cur / 2;\n      prev += cur;\n    }\n    this.#cumulative[this.#processed.length] = prev;\n  }\n\n  // Quantile returns the (approximate) quantile of\n  // the distribution. Accepted values for q are between 0 and 1.\n  // Returns NaN if Count is zero or bad inputs.\n  quantile(q: number): number {\n    this.#process();\n    this.#updateCumulative();\n    if (q < 0 || q > 1 || this.#processed.length === 0) {\n      return NaN;\n    }\n    if (this.#processed.length === 1) {\n      return this.#processed[0].mean;\n    }\n    const index = q * this.#processedWeight;\n    if (index <= this.#processed[0].weight / 2) {\n      return (\n        this.#min +\n        ((2 * index) / this.#processed[0].weight) *\n          (this.#processed[0].mean - this.#min)\n      );\n    }\n\n    const lower = binarySearch(\n      this.#cumulative.length,\n      (i: number) => -this.#cumulative[i] + index,\n    );\n\n    if (lower + 1 !== this.#cumulative.length) {\n      const z1 = index - this.#cumulative[lower - 1];\n      const z2 = this.#cumulative[lower] - index;\n      return weightedAverage(\n        this.#processed[lower - 1].mean,\n        z2,\n        this.#processed[lower].mean,\n        z1,\n      );\n    }\n\n    const z1 =\n      index - this.#processedWeight - this.#processed[lower - 1].weight / 2;\n    const z2 = this.#processed[lower - 1].weight / 2 - z1;\n    return weightedAverage(\n      this.#processed[this.#processed.length - 1].mean,\n      z1,\n      this.#max,\n      z2,\n    );\n  }\n\n  /**\n   * CDF returns the cumulative distribution function for a given value x.\n   */\n  cdf(x: number): number {\n    this.#process();\n    this.#updateCumulative();\n    switch (this.#processed.length) {\n      case 0:\n        return 0;\n      case 1: {\n        const width = this.#max - this.#min;\n        if (x <= this.#min) {\n          return 0;\n        }\n        if (x >= this.#max) {\n          return 1;\n        }\n        if (x - this.#min <= width) {\n          // min and max are too close together to do any viable interpolation\n          return 0.5;\n        }\n        return (x - this.#min) / width;\n      }\n    }\n\n    if (x <= this.#min) {\n      return 0;\n    }\n    if (x >= this.#max) {\n      return 1;\n    }\n    const m0 = this.#processed[0].mean;\n    // Left Tail\n    if (x <= m0) {\n      if (m0 - this.#min > 0) {\n        return (\n          (((x - this.#min) / (m0 - this.#min)) * this.#processed[0].weight) /\n          this.#processedWeight /\n          2\n        );\n      }\n      return 0;\n    }\n    // Right Tail\n    const mn = this.#processed[this.#processed.length - 1].mean;\n    if (x >= mn) {\n      if (this.#max - mn > 0) {\n        return (\n          1 -\n          (((this.#max - x) / (this.#max - mn)) *\n            this.#processed[this.#processed.length - 1].weight) /\n            this.#processedWeight /\n            2\n        );\n      }\n      return 1;\n    }\n\n    const upper = binarySearch(\n      this.#processed.length,\n      // Treat equals as greater than, so we can use the upper index\n      // This is equivalent to:\n      //   i => this.#processed[i].mean > x ? -1 : 1,\n      i => x - this.#processed[i].mean || 1,\n    );\n\n    const z1 = x - this.#processed[upper - 1].mean;\n    const z2 = this.#processed[upper].mean - x;\n    return (\n      weightedAverage(\n        this.#cumulative[upper - 1],\n        z2,\n        this.#cumulative[upper],\n        z1,\n      ) / this.#processedWeight\n    );\n  }\n\n  #integratedQ(k: number): number {\n    return (\n      (Math.sin(\n        (Math.min(k, this.compression) * Math.PI) / this.compression -\n          Math.PI / 2,\n      ) +\n        1) /\n      2\n    );\n  }\n\n  #integratedLocation(q: number): number {\n    return (this.compression * (Math.asin(2 * q - 1) + Math.PI / 2)) / Math.PI;\n  }\n}\n\n// Calculate number of bytes needed for a tdigest of size c,\n// where c is the compression value\nexport function byteSizeForCompression(comp: number): number {\n  const c = comp | 0;\n  // // A centroid is 2 float64s, so we need 16 bytes for each centroid\n  // float_size := 8\n  // centroid_size := 2 * float_size\n\n  // // Unprocessed and processed can grow up to length c\n  // unprocessed_size := centroid_size * c\n  // processed_size := unprocessed_size\n\n  // // the cumulative field can also be of length c, but each item is a single float64\n  // cumulative_size := float_size * c // <- this could also be unprocessed_size / 2\n\n  // return unprocessed_size + processed_size + cumulative_size\n\n  // // or, more succinctly:\n  // return float_size * c * 5\n\n  // or even more succinctly\n  return c * 40;\n}\n\nfunction weightedAverage(\n  x1: number,\n  w1: number,\n  x2: number,\n  w2: number,\n): number {\n  if (x1 <= x2) {\n    return weightedAverageSorted(x1, w1, x2, w2);\n  }\n  return weightedAverageSorted(x2, w2, x1, w1);\n}\n\nfunction weightedAverageSorted(\n  x1: number,\n  w1: number,\n  x2: number,\n  w2: number,\n): number {\n  const x = (x1 * w1 + x2 * w2) / (w1 + w2);\n  return Math.max(x1, Math.min(x, x2));\n}\n\nfunction processedSize(size: number, compression: number): number {\n  if (size === 0) {\n    return Math.ceil(compression) * 2;\n  }\n  return size;\n}\n\nfunction unprocessedSize(size: number, compression: number): number {\n  if (size === 0) {\n    return Math.ceil(compression) * 8;\n  }\n  return size;\n}\n","import type {ValueType} from '../../zero-protocol/src/client-schema.ts';\nimport type {PrimaryKey} from '../../zero-protocol/src/primary-key.ts';\n\nexport type {ValueType} from '../../zero-protocol/src/client-schema.ts';\n\n/**\n * `related` calls need to know what the available relationships are.\n * The `schema` type encodes this information.\n */\nexport type SchemaValue<T = unknown> =\n  | {\n      type: ValueType;\n      serverName?: string | undefined;\n      optional?: boolean | undefined;\n    }\n  | SchemaValueWithCustomType<T>;\n\nexport type SchemaValueWithCustomType<T> = {\n  type: ValueType;\n  serverName?: string | undefined;\n  optional?: boolean;\n  customType: T;\n};\n\nexport type TableSchema = {\n  readonly name: string;\n  readonly serverName?: string | undefined;\n  readonly columns: Record<string, SchemaValue>;\n  readonly primaryKey: PrimaryKey;\n};\n\nexport type RelationshipsSchema = {\n  readonly [name: string]: Relationship;\n};\n\nexport type TypeNameToTypeMap = {\n  string: string;\n  number: number;\n  boolean: boolean;\n  null: null;\n\n  // In schema-v2, the user will be able to specify the TS type that\n  // the JSON should match and `any`` will no\n  // longer be used here.\n  // ReadOnlyJSONValue is not used as it causes\n  // infinite depth errors to pop up for users of our APIs.\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  json: any;\n};\n\nexport type ColumnTypeName<T extends SchemaValue | ValueType> =\n  T extends SchemaValue ? T['type'] : T;\n\n/**\n * Given a schema value, return the TypeScript type.\n *\n * This allows us to create the correct return type for a\n * query that has a selection.\n */\nexport type SchemaValueToTSType<T extends SchemaValue | ValueType> =\n  T extends ValueType\n    ? TypeNameToTypeMap[T]\n    : T extends {\n          optional: true;\n        }\n      ?\n          | (T extends SchemaValueWithCustomType<infer V>\n              ? V\n              : TypeNameToTypeMap[ColumnTypeName<T>])\n          | null\n      : T extends SchemaValueWithCustomType<infer V>\n        ? V\n        : TypeNameToTypeMap[ColumnTypeName<T>];\n\ntype Connection = {\n  readonly sourceField: readonly string[];\n  readonly destField: readonly string[];\n  readonly destSchema: string;\n  readonly cardinality: Cardinality;\n};\n\nexport type Cardinality = 'one' | 'many';\n\nexport type Relationship =\n  | readonly [Connection]\n  | readonly [Connection, Connection];\n// | readonly [Connection, Connection, Connection];\n\nexport type LastInTuple<T extends Relationship> = T extends readonly [infer L]\n  ? L\n  : T extends readonly [unknown, infer L]\n    ? L\n    : T extends readonly [unknown, unknown, infer L]\n      ? L\n      : never;\n\nexport type AtLeastOne<T> = readonly [T, ...T[]];\n\nexport function atLeastOne<T>(arr: readonly T[]): AtLeastOne<T> {\n  if (arr.length === 0) {\n    throw new Error('Expected at least one element');\n  }\n  return arr as AtLeastOne<T>;\n}\n\nexport function isOneHop(r: Relationship): r is readonly [Connection] {\n  return r.length === 1;\n}\n\nexport function isTwoHop(\n  r: Relationship,\n): r is readonly [Connection, Connection] {\n  return r.length === 2;\n}\n\nexport type Opaque<BaseType, BrandType = unknown> = BaseType & {\n  readonly [base]: BaseType;\n  readonly [brand]: BrandType;\n};\n\ndeclare const base: unique symbol;\ndeclare const brand: unique symbol;\n\nexport type IsOpaque<T> = T extends {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [brand]: any;\n}\n  ? true\n  : false;\n\nexport type ExpandRecursiveSkipOpaque<T> =\n  IsOpaque<T> extends true\n    ? T\n    : T extends object\n      ? T extends infer O\n        ? {[K in keyof O]: ExpandRecursiveSkipOpaque<O[K]>}\n        : never\n      : T;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {Expand, ExpandRecursive} from '../../../shared/src/expand.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {type AST, type SimpleOperator} from '../../../zero-protocol/src/ast.ts';\nimport type {Schema as ZeroSchema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {\n  LastInTuple,\n  SchemaValueToTSType,\n  SchemaValueWithCustomType,\n  TableSchema,\n} from '../../../zero-schema/src/table-schema.ts';\nimport type {Format, ViewFactory} from '../ivm/view.ts';\nimport type {ExpressionFactory, ParameterReference} from './expression.ts';\nimport type {CustomQueryID} from './named.ts';\nimport type {QueryDelegate} from './query-delegate.ts';\nimport type {TTL} from './ttl.ts';\nimport type {TypedView} from './typed-view.ts';\n\ntype Selector<E extends TableSchema> = keyof E['columns'];\nexport type NoCompoundTypeSelector<T extends TableSchema> = Exclude<\n  Selector<T>,\n  JsonSelectors<T> | ArraySelectors<T>\n>;\n\ntype JsonSelectors<E extends TableSchema> = {\n  [K in keyof E['columns']]: E['columns'][K] extends {type: 'json'} ? K : never;\n}[keyof E['columns']];\n\ntype ArraySelectors<E extends TableSchema> = {\n  [K in keyof E['columns']]: E['columns'][K] extends SchemaValueWithCustomType<\n    any[]\n  >\n    ? K\n    : never;\n}[keyof E['columns']];\n\nexport type QueryReturn<Q> = Q extends Query<any, any, infer R> ? R : never;\nexport type QueryTable<Q> = Q extends Query<any, infer T, any> ? T : never;\nexport const delegateSymbol = Symbol('delegate');\n\nexport type GetFilterType<\n  TSchema extends TableSchema,\n  TColumn extends keyof TSchema['columns'],\n  TOperator extends SimpleOperator,\n> = TOperator extends 'IS' | 'IS NOT'\n  ? // SchemaValueToTSType adds null if the type is optional, but we add null\n    // no matter what for dx reasons. See:\n    // https://github.com/rocicorp/mono/pull/3576#discussion_r1925792608\n    SchemaValueToTSType<TSchema['columns'][TColumn]> | null\n  : TOperator extends 'IN' | 'NOT IN'\n    ? // We don't want to compare to null in where clauses because it causes\n      // confusing results:\n      // https://zero.rocicorp.dev/docs/reading-data#comparing-to-null\n      readonly Exclude<SchemaValueToTSType<TSchema['columns'][TColumn]>, null>[]\n    : Exclude<SchemaValueToTSType<TSchema['columns'][TColumn]>, null>;\n\nexport type AvailableRelationships<\n  TTable extends string,\n  TSchema extends ZeroSchema,\n> = keyof TSchema['relationships'][TTable] & string;\n\nexport type DestTableName<\n  TTable extends string,\n  TSchema extends ZeroSchema,\n  TRelationship extends string,\n> = LastInTuple<TSchema['relationships'][TTable][TRelationship]>['destSchema'];\n\ntype DestRow<\n  TTable extends string,\n  TSchema extends ZeroSchema,\n  TRelationship extends string,\n> = TSchema['relationships'][TTable][TRelationship][0]['cardinality'] extends 'many'\n  ? PullRow<DestTableName<TTable, TSchema, TRelationship>, TSchema>\n  : PullRow<DestTableName<TTable, TSchema, TRelationship>, TSchema> | undefined;\n\ntype AddSubreturn<TExistingReturn, TSubselectReturn, TAs extends string> = {\n  readonly [K in TAs]: undefined extends TSubselectReturn\n    ? TSubselectReturn\n    : readonly TSubselectReturn[];\n} extends infer TNewRelationship\n  ? undefined extends TExistingReturn\n    ? (Exclude<TExistingReturn, undefined> & TNewRelationship) | undefined\n    : TExistingReturn & TNewRelationship\n  : never;\n\nexport type PullTableSchema<\n  TTable extends string,\n  TSchemas extends ZeroSchema,\n> = TSchemas['tables'][TTable];\n\nexport type PullRow<TTable extends string, TSchema extends ZeroSchema> = {\n  readonly [K in keyof PullTableSchema<\n    TTable,\n    TSchema\n  >['columns']]: SchemaValueToTSType<\n    PullTableSchema<TTable, TSchema>['columns'][K]\n  >;\n};\n\nexport type Row<T extends TableSchema | Query<ZeroSchema, string, any>> =\n  T extends TableSchema\n    ? {\n        readonly [K in keyof T['columns']]: SchemaValueToTSType<\n          T['columns'][K]\n        >;\n      }\n    : T extends Query<ZeroSchema, string, infer TReturn>\n      ? TReturn\n      : never;\n\n/**\n * A hybrid query that runs on both client and server.\n * Results are returned immediately from the client followed by authoritative\n * results from the server.\n *\n * Queries are transactional in that all queries update at once when a new transaction\n * has been committed on the client or server. No query results will reflect stale state.\n *\n * A query can be:\n * - {@linkcode materialize | materialize}\n * - awaited (`then`/{@linkcode run})\n * - {@linkcode preload | preloaded}\n *\n * The normal way to use a query would be through your UI framework's bindings (e.g., useQuery(q))\n * or within a custom mutator.\n *\n * `materialize` and `run/then` are provided for more advanced use cases.\n * Remember that any `view` returned by `materialize` must be destroyed.\n *\n * A query can be run as a 1-shot query by awaiting it. E.g.,\n *\n * ```ts\n * const result = await z.query.issue.limit(10);\n * ```\n *\n * For more information on how to use queries, see the documentation:\n * https://zero.rocicorp.dev/docs/reading-data\n *\n * @typeParam TSchema The database schema type extending ZeroSchema\n * @typeParam TTable The name of the table being queried, must be a key of TSchema['tables']\n * @typeParam TReturn The return type of the query, defaults to PullRow<TTable, TSchema>\n */\nexport interface Query<\n  TSchema extends ZeroSchema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn = PullRow<TTable, TSchema>,\n> extends PromiseLike<HumanReadable<TReturn>> {\n  /**\n   * Format is used to specify the shape of the query results. This is used by\n   * {@linkcode one} and it also describes the shape when using\n   * {@linkcode related}.\n   */\n  readonly format: Format;\n\n  /**\n   * A string that uniquely identifies this query. This can be used to determine\n   * if two queries are the same.\n   *\n   * The hash of a custom query, on the client, is the hash of its AST.\n   * The hash of a custom query, on the server, is the hash of its name and args.\n   *\n   * The first allows many client-side queries to be pinned to the same backend query.\n   * The second ensures we do not invoke a named query on the backend more than once for the same `name:arg` pairing.\n   *\n   * If the query.hash was of `name:args` then `useQuery` would de-dupe\n   * queries with divergent ASTs.\n   *\n   * QueryManager will hash based on `name:args` since it is speaking with\n   * the server which tracks queries by `name:args`.\n   */\n  hash(): string;\n  readonly ast: AST;\n  readonly customQueryID: CustomQueryID | undefined;\n\n  nameAndArgs(\n    name: string,\n    args: ReadonlyArray<ReadonlyJSONValue>,\n  ): Query<TSchema, TTable, TReturn>;\n  [delegateSymbol](delegate: QueryDelegate): Query<TSchema, TTable, TReturn>;\n\n  /**\n   * Related is used to add a related query to the current query. This is used\n   * for subqueries and joins. These relationships are defined in the\n   * relationships section of the schema. The result of the query will\n   * include the related rows in the result set as a sub object of the row.\n   *\n   * ```typescript\n   * const row = await z.query.users\n   *   .related('posts');\n   * // {\n   * //   id: '1',\n   * //   posts: [\n   * //     ...\n   * //   ]\n   * // }\n   * ```\n   * If you want to add a subquery to the related query, you can do so by\n   * providing a callback function that receives the related query as an argument.\n   *\n   * ```typescript\n   * const row = await z.query.users\n   *   .related('posts', q => q.where('published', true));\n   * // {\n   * //   id: '1',\n   * //   posts: [\n   * //     {published: true, ...},\n   * //     ...\n   * //   ]\n   * // }\n   * ```\n   *\n   * @param relationship The name of the relationship\n   */\n  related<TRelationship extends AvailableRelationships<TTable, TSchema>>(\n    relationship: TRelationship,\n  ): Query<\n    TSchema,\n    TTable,\n    AddSubreturn<\n      TReturn,\n      DestRow<TTable, TSchema, TRelationship>,\n      TRelationship\n    >\n  >;\n  related<\n    TRelationship extends AvailableRelationships<TTable, TSchema>,\n    TSub extends Query<TSchema, string, any>,\n  >(\n    relationship: TRelationship,\n    cb: (\n      q: Query<\n        TSchema,\n        DestTableName<TTable, TSchema, TRelationship>,\n        DestRow<TTable, TSchema, TRelationship>\n      >,\n    ) => TSub,\n  ): Query<\n    TSchema,\n    TTable,\n    AddSubreturn<\n      TReturn,\n      TSub extends Query<TSchema, string, infer TSubReturn>\n        ? TSubReturn\n        : never,\n      TRelationship\n    >\n  >;\n\n  /**\n   * Represents a condition to filter the query results.\n   *\n   * @param field The column name to filter on.\n   * @param op The operator to use for filtering.\n   * @param value The value to compare against.\n   *\n   * @returns A new query instance with the applied filter.\n   *\n   * @example\n   *\n   * ```typescript\n   * const query = db.query('users')\n   *   .where('age', '>', 18)\n   *   .where('name', 'LIKE', '%John%');\n   * ```\n   */\n  where<\n    TSelector extends NoCompoundTypeSelector<PullTableSchema<TTable, TSchema>>,\n    TOperator extends SimpleOperator,\n  >(\n    field: TSelector,\n    op: TOperator,\n    value:\n      | GetFilterType<PullTableSchema<TTable, TSchema>, TSelector, TOperator>\n      | ParameterReference,\n  ): Query<TSchema, TTable, TReturn>;\n  /**\n   * Represents a condition to filter the query results.\n   *\n   * This overload is used when the operator is '='.\n   *\n   * @param field The column name to filter on.\n   * @param value The value to compare against.\n   *\n   * @returns A new query instance with the applied filter.\n   *\n   * @example\n   * ```typescript\n   * const query = db.query('users')\n   *  .where('age', 18)\n   * ```\n   */\n  where<\n    TSelector extends NoCompoundTypeSelector<PullTableSchema<TTable, TSchema>>,\n  >(\n    field: TSelector,\n    value:\n      | GetFilterType<PullTableSchema<TTable, TSchema>, TSelector, '='>\n      | ParameterReference,\n  ): Query<TSchema, TTable, TReturn>;\n\n  /**\n   * Represents a condition to filter the query results.\n   *\n   * @param expressionFactory A function that takes a query builder and returns an expression.\n   *\n   * @returns A new query instance with the applied filter.\n   *\n   * @example\n   * ```typescript\n   * const query = db.query('users')\n   *   .where(({cmp, or}) => or(cmp('age', '>', 18), cmp('name', 'LIKE', '%John%')));\n   * ```\n   */\n  where(\n    expressionFactory: ExpressionFactory<TSchema, TTable>,\n  ): Query<TSchema, TTable, TReturn>;\n\n  whereExists(\n    relationship: AvailableRelationships<TTable, TSchema>,\n  ): Query<TSchema, TTable, TReturn>;\n  whereExists<TRelationship extends AvailableRelationships<TTable, TSchema>>(\n    relationship: TRelationship,\n    cb: (\n      q: Query<TSchema, DestTableName<TTable, TSchema, TRelationship>>,\n    ) => Query<TSchema, string>,\n  ): Query<TSchema, TTable, TReturn>;\n\n  /**\n   * Skips the rows of the query until row matches the given row. If opts is\n   * provided, it determines whether the match is inclusive.\n   *\n   * @param row The row to start from. This is a partial row object and only the provided\n   *            fields will be used for the comparison.\n   * @param opts Optional options object that specifies whether the match is inclusive.\n   *             If `inclusive` is true, the row will be included in the result.\n   *             If `inclusive` is false, the row will be excluded from the result and the result\n   *             will start from the next row.\n   *\n   * @returns A new query instance with the applied start condition.\n   */\n  start(\n    row: Partial<PullRow<TTable, TSchema>>,\n    opts?: {inclusive: boolean} | undefined,\n  ): Query<TSchema, TTable, TReturn>;\n\n  /**\n   * Limits the number of rows returned by the query.\n   * @param limit The maximum number of rows to return.\n   *\n   * @returns A new query instance with the applied limit.\n   */\n  limit(limit: number): Query<TSchema, TTable, TReturn>;\n\n  /**\n   * Orders the results by a specified column. If multiple orderings are\n   * specified, the results will be ordered by the first column, then the\n   * second column, and so on.\n   *\n   * @param field The column name to order by.\n   * @param direction The direction to order the results (ascending or descending).\n   *\n   * @returns A new query instance with the applied order.\n   */\n  orderBy<TSelector extends Selector<PullTableSchema<TTable, TSchema>>>(\n    field: TSelector,\n    direction: 'asc' | 'desc',\n  ): Query<TSchema, TTable, TReturn>;\n\n  /**\n   * Limits the number of rows returned by the query to a single row and then\n   * unpacks the result so that you do not get an array of rows but a single\n   * row. This is useful when you expect only one row to be returned and want to\n   * work with the row directly.\n   *\n   * If the query returns no rows, the result will be `undefined`.\n   *\n   * @returns A new query instance with the applied limit to one row.\n   */\n  one(): Query<TSchema, TTable, TReturn | undefined>;\n\n  /**\n   * Creates a materialized view of the query. This is a view that will be kept\n   * in memory and updated as the query results change.\n   *\n   * Most of the time you will want to use the `useQuery` hook or the\n   * `run`/`then` method to get the results of a query. This method is only\n   * needed if you want to access to lower level APIs of the view.\n   *\n   * @param ttl Time To Live. This is the amount of time to keep the rows\n   *            associated with this query after `TypedView.destroy`\n   *            has been called.\n   */\n  materialize(ttl?: TTL): TypedView<HumanReadable<TReturn>>;\n  /**\n   * Creates a custom materialized view using a provided factory function. This\n   * allows framework-specific bindings (like SolidJS, Vue, etc.) to create\n   * optimized views.\n   *\n   * @param factory A function that creates a custom view implementation\n   * @param ttl Optional Time To Live for the view's data after destruction\n   * @returns A custom view instance of type {@linkcode T}\n   *\n   * @example\n   * ```ts\n   * const view = query.materialize(createSolidViewFactory, '1m');\n   * ```\n   */\n  materialize<T>(\n    factory: ViewFactory<TSchema, TTable, TReturn, T>,\n    ttl?: TTL,\n  ): T;\n\n  /**\n   * Executes the query and returns the result once. The `options` parameter\n   * specifies whether to wait for complete results or return immediately,\n   * and the time to live for the query.\n   *\n   * - `{type: 'unknown'}`: Returns a snapshot of the data immediately.\n   * - `{type: 'complete'}`: Waits for the latest, complete results from the server.\n   *\n   * By default, `run` uses `{type: 'unknown'}` to avoid waiting for the server.\n   *\n   * `Query` implements `PromiseLike`, and calling `then` on it will invoke `run`\n   * with the default behavior (`unknown`).\n   *\n   * @param options Options to control the result type.\n   * @param options.type The type of result to return.\n   * @param options.ttl Time To Live. This is the amount of time to keep the rows\n   *                  associated with this query after the returned promise has\n   *                  resolved.\n   * @returns A promise resolving to the query result.\n   *\n   * @example\n   * ```js\n   * const result = await query.run({type: 'complete', ttl: '1m'});\n   * ```\n   */\n  run(options?: RunOptions): Promise<HumanReadable<TReturn>>;\n\n  /**\n   * Preload loads the data into the clients cache without keeping it in memory.\n   * This is useful for preloading data that will be used later.\n   *\n   * @param options Options for preloading the query.\n   * @param options.ttl Time To Live. This is the amount of time to keep the rows\n   *                  associated with this query after {@linkcode cleanup} has\n   *                  been called.\n   */\n  preload(options?: PreloadOptions): {\n    cleanup: () => void;\n    complete: Promise<void>;\n  };\n}\n\nexport type PreloadOptions = {\n  /**\n   * Time To Live. This is the amount of time to keep the rows associated with\n   * this query after {@linkcode cleanup} has been called.\n   */\n  ttl?: TTL | undefined;\n};\n\nexport type MaterializeOptions = PreloadOptions;\n\n/**\n * A helper type that tries to make the type more readable.\n */\nexport type HumanReadable<T> = undefined extends T ? Expand<T> : Expand<T>[];\n\n/**\n * A helper type that tries to make the type more readable.\n */\n// Note: opaque types expand incorrectly.\nexport type HumanReadableRecursive<T> = undefined extends T\n  ? ExpandRecursive<T>\n  : ExpandRecursive<T>[];\n\n/**\n * The kind of results we want to wait for when using {@linkcode run} on {@linkcode Query}.\n *\n * `unknown` means we don't want to wait for the server to return results. The result is a\n * snapshot of the data at the time the query was run.\n *\n * `complete` means we want to ensure that we have the latest result from the server. The\n * result is a complete and up-to-date view of the data. In some cases this means that we\n * have to wait for the server to return results. To ensure that we have the result for\n * this query you can preload it before calling run. See {@link preload}.\n *\n * By default, `run` uses `{type: 'unknown'}` to avoid waiting for the server.\n *\n * The `ttl` option is used to specify the time to live for the query. This is the amount of\n * time to keep the rows associated with this query after the promise has resolved.\n */\nexport type RunOptions = {\n  type: 'unknown' | 'complete';\n  ttl?: TTL;\n};\n\nexport const DEFAULT_RUN_OPTIONS_UNKNOWN = {\n  type: 'unknown',\n} as const;\n\nexport const DEFAULT_RUN_OPTIONS_COMPLETE = {\n  type: 'complete',\n} as const;\n","/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {resolver} from '@rocicorp/resolver';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {Writable} from '../../../shared/src/writable.ts';\nimport type {\n  AST,\n  CompoundKey,\n  Condition,\n  Ordering,\n  Parameter,\n  SimpleOperator,\n  System,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row as IVMRow} from '../../../zero-protocol/src/data.ts';\nimport {\n  hashOfAST,\n  hashOfNameAndArgs,\n} from '../../../zero-protocol/src/query-hash.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {\n  isOneHop,\n  isTwoHop,\n  type TableSchema,\n} from '../../../zero-schema/src/table-schema.ts';\nimport {buildPipeline} from '../builder/builder.ts';\nimport {NotImplementedError} from '../error.ts';\nimport {ArrayView} from '../ivm/array-view.ts';\nimport type {Input} from '../ivm/operator.ts';\nimport type {Format, ViewFactory} from '../ivm/view.ts';\nimport {assertNoNotExists} from './assert-no-not-exists.ts';\nimport {\n  and,\n  cmp,\n  ExpressionBuilder,\n  simplifyCondition,\n  type ExpressionFactory,\n} from './expression.ts';\nimport type {CustomQueryID} from './named.ts';\nimport type {GotCallback, QueryDelegate} from './query-delegate.ts';\nimport {\n  delegateSymbol,\n  type GetFilterType,\n  type HumanReadable,\n  type MaterializeOptions,\n  type PreloadOptions,\n  type PullRow,\n  type Query,\n  type QueryReturn,\n  type QueryTable,\n  type RunOptions,\n} from './query.ts';\nimport {DEFAULT_PRELOAD_TTL_MS, DEFAULT_TTL_MS, type TTL} from './ttl.ts';\nimport type {TypedView} from './typed-view.ts';\n\nexport type AnyQuery = Query<Schema, string, any>;\n\nexport function materialize<S extends Schema, T, Q>(\n  query: Q,\n  delegate: QueryDelegate,\n  factoryOrOptions?:\n    | ViewFactory<S, QueryTable<Q>, QueryReturn<Q>, T>\n    | MaterializeOptions\n    | undefined,\n  maybeOptions?: MaterializeOptions | undefined,\n) {\n  if (typeof factoryOrOptions === 'function') {\n    return (\n      (query as AnyQuery)\n        // eslint-disable-next-line no-unexpected-multiline\n        [delegateSymbol](delegate)\n        .materialize(factoryOrOptions, maybeOptions?.ttl)\n    );\n  }\n  return (\n    (query as AnyQuery)\n      // eslint-disable-next-line no-unexpected-multiline\n      [delegateSymbol](delegate)\n      .materialize(factoryOrOptions?.ttl)\n  );\n}\n\nconst astSymbol = Symbol();\n\nexport function ast(query: AnyQuery): AST {\n  return (query as AbstractQuery<Schema, string>)[astSymbol];\n}\n\nexport function newQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  delegate: QueryDelegate | undefined,\n  schema: TSchema,\n  table: TTable,\n): Query<TSchema, TTable> {\n  return new QueryImpl(\n    delegate,\n    schema,\n    table,\n    {table},\n    defaultFormat,\n    undefined,\n  );\n}\n\nexport function staticParam(\n  anchorClass: 'authData' | 'preMutationRow',\n  field: string | string[],\n): Parameter {\n  return {\n    type: 'static',\n    anchor: anchorClass,\n    // for backwards compatibility\n    field: field.length === 1 ? field[0] : field,\n  };\n}\n\nexport const SUBQ_PREFIX = 'zsubq_';\n\nexport const defaultFormat = {singular: false, relationships: {}} as const;\n\nexport const newQuerySymbol = Symbol();\n\nexport abstract class AbstractQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn = PullRow<TTable, TSchema>,\n> implements Query<TSchema, TTable, TReturn>\n{\n  readonly #schema: TSchema;\n  protected readonly _delegate: QueryDelegate | undefined;\n  readonly #tableName: TTable;\n  readonly _ast: AST;\n  readonly format: Format;\n  #hash: string = '';\n  readonly #system: System;\n  readonly #currentJunction: string | undefined;\n  readonly customQueryID: CustomQueryID | undefined;\n\n  constructor(\n    delegate: QueryDelegate | undefined,\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST,\n    format: Format,\n    system: System,\n    customQueryID: CustomQueryID | undefined,\n    currentJunction?: string | undefined,\n  ) {\n    this.#schema = schema;\n    this._delegate = delegate;\n    this.#tableName = tableName;\n    this._ast = ast;\n    this.format = format;\n    this.#system = system;\n    this.#currentJunction = currentJunction;\n    this.customQueryID = customQueryID;\n  }\n\n  [delegateSymbol](delegate: QueryDelegate): Query<TSchema, TTable, TReturn> {\n    return this[newQuerySymbol](\n      delegate,\n      this.#schema,\n      this.#tableName,\n      this._ast,\n      this.format,\n      this.customQueryID,\n      this.#currentJunction,\n    );\n  }\n\n  nameAndArgs(\n    name: string,\n    args: ReadonlyArray<ReadonlyJSONValue>,\n  ): Query<TSchema, TTable, TReturn> {\n    return this[newQuerySymbol](\n      this._delegate,\n      this.#schema,\n      this.#tableName,\n      this._ast,\n      this.format,\n      {\n        name,\n        args: args as ReadonlyArray<ReadonlyJSONValue>,\n      },\n      this.#currentJunction,\n    );\n  }\n\n  get [astSymbol](): AST {\n    return this._ast;\n  }\n\n  get ast() {\n    return this._completeAst();\n  }\n\n  hash(): string {\n    if (!this.#hash) {\n      this.#hash = hashOfAST(this._completeAst());\n    }\n    return this.#hash;\n  }\n\n  // TODO(arv): Put this in the delegate?\n  protected abstract [newQuerySymbol]<\n    TSchema extends Schema,\n    TTable extends keyof TSchema['tables'] & string,\n    TReturn,\n  >(\n    delegate: QueryDelegate | undefined,\n    schema: TSchema,\n    table: TTable,\n    ast: AST,\n    format: Format,\n    customQueryID: CustomQueryID | undefined,\n    currentJunction: string | undefined,\n  ): AbstractQuery<TSchema, TTable, TReturn>;\n\n  one = (): Query<TSchema, TTable, TReturn | undefined> =>\n    this[newQuerySymbol](\n      this._delegate,\n      this.#schema,\n      this.#tableName,\n      {\n        ...this._ast,\n        limit: 1,\n      },\n      {\n        ...this.format,\n        singular: true,\n      },\n      this.customQueryID,\n      this.#currentJunction,\n    );\n\n  whereExists = (\n    relationship: string,\n    cb?: (q: AnyQuery) => AnyQuery,\n  ): Query<TSchema, TTable, TReturn> =>\n    this.where(({exists}) => exists(relationship, cb));\n\n  related = (\n    relationship: string,\n    cb?: (q: AnyQuery) => AnyQuery,\n  ): AnyQuery => {\n    if (relationship.startsWith(SUBQ_PREFIX)) {\n      throw new Error(\n        `Relationship names may not start with \"${SUBQ_PREFIX}\". That is a reserved prefix.`,\n      );\n    }\n    cb = cb ?? (q => q);\n\n    const related = this.#schema.relationships[this.#tableName][relationship];\n    assert(related, 'Invalid relationship');\n    if (isOneHop(related)) {\n      const {destSchema, destField, sourceField, cardinality} = related[0];\n      let q: AnyQuery = this[newQuerySymbol](\n        this._delegate,\n        this.#schema,\n        destSchema,\n        {\n          table: destSchema,\n          alias: relationship,\n        },\n        {\n          relationships: {},\n          singular: cardinality === 'one',\n        },\n        this.customQueryID,\n        undefined,\n      ) as AnyQuery;\n      if (cardinality === 'one') {\n        q = q.one();\n      }\n      const sq = cb(q) as AbstractQuery<Schema, string>;\n      assert(\n        isCompoundKey(sourceField),\n        'The source of a relationship must specify at last 1 field',\n      );\n      assert(\n        isCompoundKey(destField),\n        'The destination of a relationship must specify at last 1 field',\n      );\n      assert(\n        sourceField.length === destField.length,\n        'The source and destination of a relationship must have the same number of fields',\n      );\n\n      return this[newQuerySymbol](\n        this._delegate,\n        this.#schema,\n        this.#tableName,\n        {\n          ...this._ast,\n          related: [\n            ...(this._ast.related ?? []),\n            {\n              system: this.#system,\n              correlation: {\n                parentField: sourceField,\n                childField: destField,\n              },\n              subquery: addPrimaryKeysToAst(\n                this.#schema.tables[destSchema],\n                sq._ast,\n              ),\n            },\n          ],\n        },\n        {\n          ...this.format,\n          relationships: {\n            ...this.format.relationships,\n            [relationship]: sq.format,\n          },\n        },\n        this.customQueryID,\n        this.#currentJunction,\n      );\n    }\n\n    if (isTwoHop(related)) {\n      const [firstRelation, secondRelation] = related;\n      const {destSchema} = secondRelation;\n      const junctionSchema = firstRelation.destSchema;\n      const sq = cb(\n        this[newQuerySymbol](\n          this._delegate,\n          this.#schema,\n          destSchema,\n          {\n            table: destSchema,\n            alias: relationship,\n          },\n          {\n            relationships: {},\n            singular: secondRelation.cardinality === 'one',\n          },\n          this.customQueryID,\n          relationship,\n        ),\n      ) as unknown as QueryImpl<Schema, string>;\n\n      assert(isCompoundKey(firstRelation.sourceField), 'Invalid relationship');\n      assert(isCompoundKey(firstRelation.destField), 'Invalid relationship');\n      assert(isCompoundKey(secondRelation.sourceField), 'Invalid relationship');\n      assert(isCompoundKey(secondRelation.destField), 'Invalid relationship');\n\n      return this[newQuerySymbol](\n        this._delegate,\n        this.#schema,\n        this.#tableName,\n        {\n          ...this._ast,\n          related: [\n            ...(this._ast.related ?? []),\n            {\n              system: this.#system,\n              correlation: {\n                parentField: firstRelation.sourceField,\n                childField: firstRelation.destField,\n              },\n              hidden: true,\n              subquery: {\n                table: junctionSchema,\n                alias: relationship,\n                orderBy: addPrimaryKeys(\n                  this.#schema.tables[junctionSchema],\n                  undefined,\n                ),\n                related: [\n                  {\n                    system: this.#system,\n                    correlation: {\n                      parentField: secondRelation.sourceField,\n                      childField: secondRelation.destField,\n                    },\n                    subquery: addPrimaryKeysToAst(\n                      this.#schema.tables[destSchema],\n                      sq._ast,\n                    ),\n                  },\n                ],\n              },\n            },\n          ],\n        },\n        {\n          ...this.format,\n          relationships: {\n            ...this.format.relationships,\n            [relationship]: sq.format,\n          },\n        },\n        this.customQueryID,\n        this.#currentJunction,\n      );\n    }\n\n    throw new Error(`Invalid relationship ${relationship}`);\n  };\n\n  where = (\n    fieldOrExpressionFactory: string | ExpressionFactory<TSchema, TTable>,\n    opOrValue?: SimpleOperator | GetFilterType<any, any, any> | Parameter,\n    value?: GetFilterType<any, any, any> | Parameter,\n  ): Query<TSchema, TTable, TReturn> => {\n    let cond: Condition;\n\n    if (typeof fieldOrExpressionFactory === 'function') {\n      cond = fieldOrExpressionFactory(\n        new ExpressionBuilder(this._exists) as ExpressionBuilder<\n          TSchema,\n          TTable\n        >,\n      );\n    } else {\n      assert(opOrValue !== undefined, 'Invalid condition');\n      cond = cmp(fieldOrExpressionFactory, opOrValue, value);\n    }\n\n    const existingWhere = this._ast.where;\n    if (existingWhere) {\n      cond = and(existingWhere, cond);\n    }\n\n    const where = simplifyCondition(cond);\n\n    if (this.#system === 'client') {\n      // We need to do this after the DNF since the DNF conversion might change\n      // an EXISTS to a NOT EXISTS condition (and vice versa).\n      assertNoNotExists(where);\n    }\n\n    return this[newQuerySymbol](\n      this._delegate,\n      this.#schema,\n      this.#tableName,\n      {\n        ...this._ast,\n        where,\n      },\n      this.format,\n      this.customQueryID,\n      this.#currentJunction,\n    );\n  };\n\n  start = (\n    row: Partial<PullRow<TTable, TSchema>>,\n    opts?: {inclusive: boolean} | undefined,\n  ): Query<TSchema, TTable, TReturn> =>\n    this[newQuerySymbol](\n      this._delegate,\n      this.#schema,\n      this.#tableName,\n      {\n        ...this._ast,\n        start: {\n          row,\n          exclusive: !opts?.inclusive,\n        },\n      },\n      this.format,\n      this.customQueryID,\n      this.#currentJunction,\n    );\n\n  limit = (limit: number): Query<TSchema, TTable, TReturn> => {\n    if (limit < 0) {\n      throw new Error('Limit must be non-negative');\n    }\n    if ((limit | 0) !== limit) {\n      throw new Error('Limit must be an integer');\n    }\n    if (this.#currentJunction) {\n      throw new NotImplementedError(\n        'Limit is not supported in junction relationships yet. Junction relationship being limited: ' +\n          this.#currentJunction,\n      );\n    }\n\n    return this[newQuerySymbol](\n      this._delegate,\n      this.#schema,\n      this.#tableName,\n      {\n        ...this._ast,\n        limit,\n      },\n      this.format,\n      this.customQueryID,\n      this.#currentJunction,\n    );\n  };\n\n  orderBy = <TSelector extends keyof TSchema['tables'][TTable]['columns']>(\n    field: TSelector,\n    direction: 'asc' | 'desc',\n  ): Query<TSchema, TTable, TReturn> => {\n    if (this.#currentJunction) {\n      throw new NotImplementedError(\n        'Order by is not supported in junction relationships yet. Junction relationship being ordered: ' +\n          this.#currentJunction,\n      );\n    }\n    return this[newQuerySymbol](\n      this._delegate,\n      this.#schema,\n      this.#tableName,\n      {\n        ...this._ast,\n        orderBy: [...(this._ast.orderBy ?? []), [field as string, direction]],\n      },\n      this.format,\n      this.customQueryID,\n      this.#currentJunction,\n    );\n  };\n\n  protected _exists = (\n    relationship: string,\n    cb: (query: AnyQuery) => AnyQuery = q => q,\n  ): Condition => {\n    const related = this.#schema.relationships[this.#tableName][relationship];\n    assert(related, 'Invalid relationship');\n\n    if (isOneHop(related)) {\n      const {destSchema, sourceField, destField} = related[0];\n      assert(isCompoundKey(sourceField), 'Invalid relationship');\n      assert(isCompoundKey(destField), 'Invalid relationship');\n\n      const sq = cb(\n        this[newQuerySymbol](\n          this._delegate,\n          this.#schema,\n          destSchema,\n          {\n            table: destSchema,\n            alias: `${SUBQ_PREFIX}${relationship}`,\n          },\n          defaultFormat,\n          this.customQueryID,\n          undefined,\n        ),\n      ) as unknown as QueryImpl<any, any>;\n      return {\n        type: 'correlatedSubquery',\n        related: {\n          system: this.#system,\n          correlation: {\n            parentField: sourceField,\n            childField: destField,\n          },\n          subquery: addPrimaryKeysToAst(\n            this.#schema.tables[destSchema],\n            sq._ast,\n          ),\n        },\n        op: 'EXISTS',\n      };\n    }\n\n    if (isTwoHop(related)) {\n      const [firstRelation, secondRelation] = related;\n      assert(isCompoundKey(firstRelation.sourceField), 'Invalid relationship');\n      assert(isCompoundKey(firstRelation.destField), 'Invalid relationship');\n      assert(isCompoundKey(secondRelation.sourceField), 'Invalid relationship');\n      assert(isCompoundKey(secondRelation.destField), 'Invalid relationship');\n      const {destSchema} = secondRelation;\n      const junctionSchema = firstRelation.destSchema;\n      const queryToDest = cb(\n        this[newQuerySymbol](\n          this._delegate,\n          this.#schema,\n          destSchema,\n          {\n            table: destSchema,\n            alias: `${SUBQ_PREFIX}zhidden_${relationship}`,\n          },\n          defaultFormat,\n          this.customQueryID,\n          relationship,\n        ) as AnyQuery,\n      );\n\n      return {\n        type: 'correlatedSubquery',\n        related: {\n          system: this.#system,\n          correlation: {\n            parentField: firstRelation.sourceField,\n            childField: firstRelation.destField,\n          },\n          subquery: {\n            table: junctionSchema,\n            alias: `${SUBQ_PREFIX}${relationship}`,\n            orderBy: addPrimaryKeys(\n              this.#schema.tables[junctionSchema],\n              undefined,\n            ),\n            where: {\n              type: 'correlatedSubquery',\n              related: {\n                system: this.#system,\n                correlation: {\n                  parentField: secondRelation.sourceField,\n                  childField: secondRelation.destField,\n                },\n\n                subquery: addPrimaryKeysToAst(\n                  this.#schema.tables[destSchema],\n                  (queryToDest as QueryImpl<any, any>)._ast,\n                ),\n              },\n              op: 'EXISTS',\n            },\n          },\n        },\n        op: 'EXISTS',\n      };\n    }\n\n    throw new Error(`Invalid relationship ${relationship}`);\n  };\n\n  #completedAST: AST | undefined;\n\n  protected _completeAst(): AST {\n    if (!this.#completedAST) {\n      const finalOrderBy = addPrimaryKeys(\n        this.#schema.tables[this.#tableName],\n        this._ast.orderBy,\n      );\n      if (this._ast.start) {\n        const {row} = this._ast.start;\n        const narrowedRow: Writable<IVMRow> = {};\n        for (const [field] of finalOrderBy) {\n          narrowedRow[field] = row[field];\n        }\n        this.#completedAST = {\n          ...this._ast,\n          start: {\n            ...this._ast.start,\n            row: narrowedRow,\n          },\n          orderBy: finalOrderBy,\n        };\n      } else {\n        this.#completedAST = {\n          ...this._ast,\n          orderBy: addPrimaryKeys(\n            this.#schema.tables[this.#tableName],\n            this._ast.orderBy,\n          ),\n        };\n      }\n    }\n    return this.#completedAST;\n  }\n\n  then<TResult1 = HumanReadable<TReturn>, TResult2 = never>(\n    onFulfilled?:\n      | ((value: HumanReadable<TReturn>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onRejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): PromiseLike<TResult1 | TResult2> {\n    return this.run().then(onFulfilled, onRejected);\n  }\n\n  abstract materialize(\n    ttl?: TTL | undefined,\n  ): TypedView<HumanReadable<TReturn>>;\n  abstract materialize<T>(\n    factory: ViewFactory<TSchema, TTable, TReturn, T>,\n    ttl?: TTL | undefined,\n  ): T;\n\n  abstract run(options?: RunOptions): Promise<HumanReadable<TReturn>>;\n\n  abstract preload(): {\n    cleanup: () => void;\n    complete: Promise<void>;\n  };\n}\n\nconst completedAstSymbol = Symbol();\n\nexport function completedAST(q: Query<Schema, string, any>) {\n  return (q as QueryImpl<Schema, string>)[completedAstSymbol];\n}\n\nexport class QueryImpl<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn = PullRow<TTable, TSchema>,\n> extends AbstractQuery<TSchema, TTable, TReturn> {\n  readonly #system: System;\n\n  constructor(\n    delegate: QueryDelegate | undefined,\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST = {table: tableName},\n    format: Format = defaultFormat,\n    system: System = 'client',\n    customQueryID?: CustomQueryID | undefined,\n    currentJunction?: string | undefined,\n  ) {\n    super(\n      delegate,\n      schema,\n      tableName,\n      ast,\n      format,\n      system,\n      customQueryID,\n      currentJunction,\n    );\n    this.#system = system;\n  }\n\n  get [completedAstSymbol](): AST {\n    return this._completeAst();\n  }\n\n  protected [newQuerySymbol]<\n    TSchema extends Schema,\n    TTable extends string,\n    TReturn,\n  >(\n    delegate: QueryDelegate | undefined,\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST,\n    format: Format,\n    customQueryID: CustomQueryID | undefined,\n    currentJunction: string | undefined,\n  ): QueryImpl<TSchema, TTable, TReturn> {\n    return new QueryImpl(\n      delegate,\n      schema,\n      tableName,\n      ast,\n      format,\n      this.#system,\n      customQueryID,\n      currentJunction,\n    );\n  }\n\n  materialize<T>(\n    factoryOrTTL?: ViewFactory<TSchema, TTable, TReturn, T> | TTL,\n    ttl: TTL = DEFAULT_TTL_MS,\n  ): T {\n    const delegate = must(\n      this._delegate,\n      'materialize requires a query delegate to be set',\n    );\n    let factory: ViewFactory<TSchema, TTable, TReturn, T> | undefined;\n    if (typeof factoryOrTTL === 'function') {\n      factory = factoryOrTTL;\n    } else {\n      ttl = factoryOrTTL ?? DEFAULT_TTL_MS;\n    }\n    const ast = this._completeAst();\n    const queryID = this.customQueryID\n      ? hashOfNameAndArgs(this.customQueryID.name, this.customQueryID.args)\n      : this.hash();\n    const queryCompleteResolver = resolver<true>();\n    let queryComplete = delegate.defaultQueryComplete;\n    const updateTTL = (newTTL: TTL) => {\n      this.customQueryID\n        ? delegate.updateCustomQuery(this.customQueryID, newTTL)\n        : delegate.updateServerQuery(ast, newTTL);\n    };\n\n    const gotCallback: GotCallback = got => {\n      if (got) {\n        delegate.addMetric(\n          'query-materialization-end-to-end',\n          performance.now() - t0,\n          queryID,\n          ast,\n        );\n        queryComplete = true;\n        queryCompleteResolver.resolve(true);\n      }\n    };\n\n    let removeCommitObserver: (() => void) | undefined;\n    const onDestroy = () => {\n      input.destroy();\n      removeCommitObserver?.();\n      removeAddedQuery();\n    };\n\n    const t0 = performance.now();\n\n    const removeAddedQuery = this.customQueryID\n      ? delegate.addCustomQuery(ast, this.customQueryID, ttl, gotCallback)\n      : delegate.addServerQuery(ast, ttl, gotCallback);\n\n    const input = buildPipeline(ast, delegate, queryID);\n\n    const view = delegate.batchViewUpdates(() =>\n      (factory ?? arrayViewFactory)(\n        this,\n        input,\n        this.format,\n        onDestroy,\n        cb => {\n          removeCommitObserver = delegate.onTransactionCommit(cb);\n        },\n        queryComplete || queryCompleteResolver.promise,\n        updateTTL,\n      ),\n    );\n\n    delegate.addMetric(\n      'query-materialization-client',\n      performance.now() - t0,\n      queryID,\n    );\n\n    return view as T;\n  }\n\n  run(options?: RunOptions): Promise<HumanReadable<TReturn>> {\n    const delegate = must(\n      this._delegate,\n      'run requires a query delegate to be set',\n    );\n    delegate.assertValidRunOptions(options);\n    const v: TypedView<HumanReadable<TReturn>> = this.materialize(options?.ttl);\n    if (options?.type === 'complete') {\n      return new Promise(resolve => {\n        v.addListener((data, type) => {\n          if (type === 'complete') {\n            v.destroy();\n            resolve(data as HumanReadable<TReturn>);\n          }\n        });\n      });\n    }\n\n    options?.type satisfies 'unknown' | undefined;\n\n    const ret = v.data;\n    v.destroy();\n    return Promise.resolve(ret);\n  }\n\n  preload(options?: PreloadOptions): {\n    cleanup: () => void;\n    complete: Promise<void>;\n  } {\n    const delegate = must(\n      this._delegate,\n      'preload requires a query delegate to be set',\n    );\n    const ttl = options?.ttl ?? DEFAULT_PRELOAD_TTL_MS;\n    const ast = this._completeAst();\n    const {resolve, promise: complete} = resolver<void>();\n    if (this.customQueryID) {\n      const cleanup = delegate.addCustomQuery(\n        ast,\n        this.customQueryID,\n        ttl,\n        got => {\n          if (got) {\n            resolve();\n          }\n        },\n      );\n      return {\n        cleanup,\n        complete,\n      };\n    }\n\n    const cleanup = delegate.addServerQuery(ast, ttl, got => {\n      if (got) {\n        resolve();\n      }\n    });\n    return {\n      cleanup,\n      complete,\n    };\n  }\n}\n\nfunction addPrimaryKeys(\n  schema: TableSchema,\n  orderBy: Ordering | undefined,\n): Ordering {\n  orderBy = orderBy ?? [];\n  const {primaryKey} = schema;\n  const primaryKeysToAdd = new Set(primaryKey);\n\n  for (const [field] of orderBy) {\n    primaryKeysToAdd.delete(field);\n  }\n\n  if (primaryKeysToAdd.size === 0) {\n    return orderBy;\n  }\n\n  return [\n    ...orderBy,\n    ...[...primaryKeysToAdd].map(key => [key, 'asc'] as [string, 'asc']),\n  ];\n}\n\nfunction addPrimaryKeysToAst(schema: TableSchema, ast: AST): AST {\n  return {\n    ...ast,\n    orderBy: addPrimaryKeys(schema, ast.orderBy),\n  };\n}\n\nfunction arrayViewFactory<\n  TSchema extends Schema,\n  TTable extends string,\n  TReturn,\n>(\n  _query: AbstractQuery<TSchema, TTable, TReturn>,\n  input: Input,\n  format: Format,\n  onDestroy: () => void,\n  onTransactionCommit: (cb: () => void) => void,\n  queryComplete: true | Promise<true>,\n  updateTTL: (ttl: TTL) => void,\n): TypedView<HumanReadable<TReturn>> {\n  const v = new ArrayView<HumanReadable<TReturn>>(\n    input,\n    format,\n    queryComplete,\n    updateTTL,\n  );\n  v.onDestroy = onDestroy;\n  onTransactionCommit(() => {\n    v.flush();\n  });\n  return v;\n}\n\nfunction isCompoundKey(field: readonly string[]): field is CompoundKey {\n  return Array.isArray(field) && field.length >= 1;\n}\n","import {h64} from '../../shared/src/hash.ts';\nimport {normalizeAST, type AST} from './ast.ts';\n\nconst hashCache = new WeakMap<AST, string>();\n\nexport function hashOfAST(ast: AST): string {\n  const normalized = normalizeAST(ast);\n  const cached = hashCache.get(normalized);\n  if (cached) {\n    return cached;\n  }\n  const hash = h64(JSON.stringify(normalized)).toString(36);\n  hashCache.set(normalized, hash);\n  return hash;\n}\n\nexport function hashOfNameAndArgs(\n  name: string,\n  args: readonly unknown[],\n): string {\n  const argsString = JSON.stringify(args);\n  return h64(`${name}:${argsString}`).toString(36);\n}\n","import type {FetchRequest, Input, InputBase, Output} from './operator.ts';\nimport {drainStreams, type Node} from './data.ts';\nimport type {Change} from './change.ts';\nimport type {SourceSchema} from './schema.ts';\nimport type {Stream} from './stream.ts';\nimport type {BuilderDelegate} from '../builder/builder.ts';\n\n/**\n * The `where` clause of a ZQL query is implemented using a sub-graph of\n * `FilterOperators`.  This sub-graph starts with a `FilterStart` operator,\n * that adapts from the normal `Operator` `Output`, to the\n * `FilterOperator` `FilterInput`, and ends with a `FilterEnd` operator that\n * adapts from a `FilterOperator` `FilterOutput` to a normal `Operator` `Input`.\n * `FilterOperator'`s do not have `fetch` or `cleanup` instead they have a\n * `filter(node: Node, cleanup: boolean): boolean` method.\n * They also have `push` which is just like normal `Operator` push.\n * Not having a `fetch` means these `FilterOperator`'s cannot modify\n * `Node` `row`s or `relationship`s, but they shouldn't, they should just\n * filter.\n *\n * This `FilterOperator` abstraction enables much more efficient processing of\n * `fetch` for `where` clauses containing OR conditions.\n *\n * See https://github.com/rocicorp/mono/pull/4339\n */\n\nexport interface FilterInput extends InputBase {\n  /** Tell the input where to send its output. */\n  setFilterOutput(output: FilterOutput): void;\n}\n\nexport interface FilterOutput extends Output {\n  filter(node: Node, cleanup: boolean): boolean;\n}\n\nexport interface FilterOperator extends FilterInput, FilterOutput {}\n\n/**\n * An implementation of FilterOutput that throws if push or filter is called.\n * It is used as the initial value for for an operator's output before it is\n * set.\n */\nexport const throwFilterOutput: FilterOutput = {\n  push(_change: Change): void {\n    throw new Error('Output not set');\n  },\n\n  filter(_node: Node, _cleanup): boolean {\n    throw new Error('Output not set');\n  },\n};\n\nexport class FilterStart implements FilterInput, Output {\n  readonly #input: Input;\n  #output: FilterOutput = throwFilterOutput;\n\n  constructor(input: Input) {\n    this.#input = input;\n    input.setOutput(this);\n  }\n\n  setFilterOutput(output: FilterOutput) {\n    this.#output = output;\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  push(change: Change) {\n    this.#output.push(change);\n  }\n\n  *fetch(req: FetchRequest): Stream<Node> {\n    for (const node of this.#input.fetch(req)) {\n      if (this.#output.filter(node, false)) {\n        yield node;\n      }\n    }\n  }\n\n  *cleanup(req: FetchRequest): Stream<Node> {\n    for (const node of this.#input.cleanup(req)) {\n      if (this.#output.filter(node, true)) {\n        yield node;\n      } else {\n        drainStreams(node);\n      }\n    }\n  }\n}\n\nexport class FilterEnd implements Input, FilterOutput {\n  readonly #start: FilterStart;\n  readonly #input: FilterInput;\n\n  #output: Output = throwFilterOutput;\n\n  constructor(start: FilterStart, input: FilterInput) {\n    this.#start = start;\n    this.#input = input;\n    input.setFilterOutput(this);\n  }\n\n  *fetch(req: FetchRequest): Stream<Node> {\n    for (const node of this.#start.fetch(req)) {\n      yield node;\n    }\n  }\n\n  *cleanup(req: FetchRequest): Stream<Node> {\n    for (const node of this.#start.cleanup(req)) {\n      yield node;\n    }\n  }\n\n  filter(_node: Node, _cleanup: boolean) {\n    return true;\n  }\n\n  setOutput(output: Output) {\n    this.#output = output;\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  push(change: Change) {\n    this.#output.push(change);\n  }\n}\n\nexport function buildFilterPipeline(\n  input: Input,\n  delegate: BuilderDelegate,\n  pipeline: (filterInput: FilterInput) => FilterInput,\n): Input {\n  const filterStart = new FilterStart(input);\n  delegate.addEdge(input, filterStart);\n  const middle = pipeline(filterStart);\n  delegate.addEdge(filterStart, middle);\n  const filterEnd = new FilterEnd(filterStart, middle);\n  delegate.addEdge(middle, filterEnd);\n  return filterEnd;\n}\n","import type {JSONValue} from '../../../shared/src/json.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport type {Change} from './change.ts';\nimport type {Constraint} from './constraint.ts';\nimport type {Node} from './data.ts';\nimport type {SourceSchema} from './schema.ts';\nimport type {Stream} from './stream.ts';\n\n/**\n * Input to an operator.\n */\nexport interface InputBase {\n  /** The schema of the data this input returns. */\n  getSchema(): SourceSchema;\n\n  /**\n   * Completely destroy the input. Destroying an input\n   * causes it to call destroy on its upstreams, fully\n   * cleaning up a pipeline.\n   */\n  destroy(): void;\n}\n\nexport interface Input extends InputBase {\n  /** Tell the input where to send its output. */\n  setOutput(output: Output): void;\n\n  /**\n   * Fetch data. May modify the data in place.\n   * Returns nodes sorted in order of `SourceSchema.compareRows`.\n   */\n  fetch(req: FetchRequest): Stream<Node>;\n\n  /**\n   * Cleanup maintained state. This is called when `output` will no longer need\n   * the data returned by {@linkcode fetch}. The receiving operator should clean up any\n   * resources it has allocated to service such requests.\n   *\n   * This is different from {@linkcode destroy} which means this input will no longer\n   * be called at all, for any input.\n   *\n   * Returns the same thing as {@linkcode fetch}. This allows callers to properly\n   * propagate the cleanup message through the graph.\n   */\n  cleanup(req: FetchRequest): Stream<Node>;\n}\n\nexport type FetchRequest = {\n  readonly constraint?: Constraint | undefined;\n  /** If supplied, `start.row` must have previously been output by fetch or push. */\n  readonly start?: Start | undefined;\n\n  /** Whether to fetch in reverse order of the SourceSchema's sort. */\n  readonly reverse?: boolean | undefined;\n};\n\nexport type Start = {\n  readonly row: Row;\n  readonly basis: 'at' | 'after';\n};\n\n/**\n * An output for an operator. Typically another Operator but can also be\n * the code running the pipeline.\n */\nexport interface Output {\n  /**\n   * Push incremental changes to data previously received with fetch().\n   * Consumers must apply all pushed changes or incremental result will\n   * be incorrect.\n   * Callers must maintain some invariants for correct operation:\n   * - Only add rows which do not already exist (by deep equality).\n   * - Only remove rows which do exist (by deep equality).\n   */\n  push(change: Change): void;\n}\n\n/**\n * An implementation of Output that throws if pushed to. It is used as the\n * initial value for for an operator's output before it is set.\n */\nexport const throwOutput: Output = {\n  push(_change: Change): void {\n    throw new Error('Output not set');\n  },\n};\n\n/**\n * Operators are arranged into pipelines.\n * They are stateful.\n * Each operator is an input to the next operator in the chain and an output\n * to the previous.\n */\nexport interface Operator extends Input, Output {}\n\n/**\n * Operators get access to storage that they can store their internal\n * state in.\n */\nexport interface Storage {\n  set(key: string, value: JSONValue): void;\n  get(key: string, def?: JSONValue): JSONValue | undefined;\n  /**\n   * If options is not specified, defaults to scanning all entries.\n   */\n  scan(options?: {prefix: string}): Stream<[string, JSONValue]>;\n  del(key: string): void;\n}\n","/**\n * streams are lazy forward-only iterables.\n * Once a stream reaches the end it can't be restarted.\n * They are iterable, not iterator, so that they can be used in for-each,\n * and so that we know when consumer has stopped iterating the stream. This allows us\n * to clean up resources like sql statements.\n */\nexport type Stream<T> = Iterable<T>;\n\nexport function* take<T>(stream: Stream<T>, limit: number): Stream<T> {\n  if (limit < 1) {\n    return;\n  }\n  let count = 0;\n  for (const v of stream) {\n    yield v;\n    if (++count === limit) {\n      break;\n    }\n  }\n}\n\nexport function first<T>(stream: Stream<T>): T | undefined {\n  const it = stream[Symbol.iterator]();\n  const {value} = it.next();\n  it.return?.();\n  return value;\n}\n","import {areEqual} from '../../../shared/src/arrays.ts';\nimport {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport type {CompoundKey} from '../../../zero-protocol/src/ast.ts';\nimport {type Change} from './change.ts';\nimport {normalizeUndefined, type Node, type NormalizedValue} from './data.ts';\nimport {\n  throwFilterOutput,\n  type FilterInput,\n  type FilterOperator,\n  type FilterOutput,\n} from './filter-operators.ts';\nimport {type Storage} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport {first} from './stream.ts';\n\ntype SizeStorageKeyPrefix = `row/${string}/`;\n/**\n * Key is of format\n * `row/${JSON.stringify(parentJoinKeyValues)}/${JSON.stringify(primaryKeyValues)}`\n * This format allows us to look up an existing cached size for a given set of\n * `parentJoinKeyValues` by scanning for prefix\n * `row/${JSON.stringify(parentJoinKeyValues)}/` and using the first result, and\n * to look up the cached size for a specific row by the full key.\n * If the parent join and primary key are the same, then format is changed to\n * `row//${JSON.stringify(primaryKeyValues)}` to shorten the key, since there\n * is no point in looking up an existing cached size by\n * `parentJoinKeyValues` if the specific rows cached size is missing.\n */\ntype SizeStorageKey = `${SizeStorageKeyPrefix}${string}`;\n\ninterface ExistsStorage {\n  get(key: SizeStorageKey): number | undefined;\n  set(key: SizeStorageKey, value: number): void;\n  del(key: SizeStorageKey): void;\n  scan({prefix}: {prefix: SizeStorageKeyPrefix}): Iterable<[string, number]>;\n}\n\n/**\n * The Exists operator filters data based on whether or not a relationship is\n * non-empty.\n */\nexport class Exists implements FilterOperator {\n  readonly #input: FilterInput;\n  readonly #relationshipName: string;\n  readonly #storage: ExistsStorage;\n  readonly #not: boolean;\n  readonly #parentJoinKey: CompoundKey;\n  readonly #noSizeReuse: boolean;\n\n  #output: FilterOutput = throwFilterOutput;\n\n  /**\n   * This instance variable is `true` when this operator is processing a `push`,\n   * and is used to disable reuse of cached sizes across rows with the\n   * same parent join key value.\n   * This is necessary because during a push relationships can be inconsistent\n   * due to push communicating changes (which may change multiple Nodes) one\n   * Node at a time.\n   */\n  #inPush = false;\n\n  constructor(\n    input: FilterInput,\n    storage: Storage,\n    relationshipName: string,\n    parentJoinKey: CompoundKey,\n    type: 'EXISTS' | 'NOT EXISTS',\n  ) {\n    this.#input = input;\n    this.#relationshipName = relationshipName;\n    this.#input.setFilterOutput(this);\n    this.#storage = storage as ExistsStorage;\n    assert(\n      this.#input.getSchema().relationships[relationshipName],\n      `Input schema missing ${relationshipName}`,\n    );\n    this.#not = type === 'NOT EXISTS';\n    this.#parentJoinKey = parentJoinKey;\n\n    // If the parentJoinKey is the primary key, no sense in trying to reuse.\n    this.#noSizeReuse = areEqual(\n      parentJoinKey,\n      this.#input.getSchema().primaryKey,\n    );\n  }\n\n  setFilterOutput(output: FilterOutput): void {\n    this.#output = output;\n  }\n\n  filter(node: Node, cleanup: boolean): boolean {\n    const result = this.#filter(node) && this.#output.filter(node, cleanup);\n    if (cleanup) {\n      this.#delSize(node);\n    }\n    return result;\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  push(change: Change) {\n    assert(!this.#inPush, 'Unexpected re-entrancy');\n    this.#inPush = true;\n    try {\n      switch (change.type) {\n        // add, remove and edit cannot change the size of the\n        // this.#relationshipName relationship, so simply #pushWithFilter\n        case 'add':\n        case 'edit': {\n          this.#pushWithFilter(change);\n          return;\n        }\n        case 'remove': {\n          const size = this.#getSize(change.node);\n          // If size is undefined, this operator has not output\n          // this row before and so it is unnecessary to output a remove for\n          // it.\n          if (size === undefined) {\n            return;\n          }\n          this.#pushWithFilter(change, size);\n          this.#delSize(change.node);\n          return;\n        }\n        case 'child':\n          // Only add and remove child changes for the\n          // this.#relationshipName relationship, can change the size\n          // of the this.#relationshipName relationship, for other\n          // child changes simply #pushWithFilter\n          if (\n            change.child.relationshipName !== this.#relationshipName ||\n            change.child.change.type === 'edit' ||\n            change.child.change.type === 'child'\n          ) {\n            this.#pushWithFilter(change);\n            return;\n          }\n          switch (change.child.change.type) {\n            case 'add': {\n              let size = this.#getSize(change.node);\n              if (size !== undefined) {\n                size++;\n                this.#setSize(change.node, size);\n              } else {\n                size = this.#fetchSize(change.node);\n              }\n              if (size === 1) {\n                if (this.#not) {\n                  // Since the add child change currently being processed is not\n                  // pushed to output, the added child needs to be excluded from\n                  // the remove being pushed to output (since the child has\n                  // never been added to the output).\n                  this.#output.push({\n                    type: 'remove',\n                    node: {\n                      row: change.node.row,\n                      relationships: {\n                        ...change.node.relationships,\n                        [this.#relationshipName]: () => [],\n                      },\n                    },\n                  });\n                } else {\n                  this.#output.push({\n                    type: 'add',\n                    node: change.node,\n                  });\n                }\n              } else {\n                this.#pushWithFilter(change, size);\n              }\n              return;\n            }\n            case 'remove': {\n              let size = this.#getSize(change.node);\n              if (size !== undefined) {\n                assert(size > 0);\n                size--;\n                this.#setSize(change.node, size);\n              } else {\n                size = this.#fetchSize(change.node);\n              }\n              if (size === 0) {\n                if (this.#not) {\n                  this.#output.push({\n                    type: 'add',\n                    node: change.node,\n                  });\n                } else {\n                  // Since the remove child change currently being processed is\n                  // not pushed to output, the removed child needs to be added to\n                  // the remove being pushed to output.\n                  this.#output.push({\n                    type: 'remove',\n                    node: {\n                      row: change.node.row,\n                      relationships: {\n                        ...change.node.relationships,\n                        [this.#relationshipName]: () => [\n                          change.child.change.node,\n                        ],\n                      },\n                    },\n                  });\n                }\n              } else {\n                this.#pushWithFilter(change, size);\n              }\n              return;\n            }\n          }\n          return;\n        default:\n          unreachable(change);\n      }\n    } finally {\n      this.#inPush = false;\n    }\n  }\n\n  /**\n   * Returns whether or not the node's this.#relationshipName\n   * relationship passes the exist/not exists filter condition.\n   * If the optional `size` is passed it is used.\n   * Otherwise, if there is a stored size for the row it is used.\n   * Otherwise the size is computed by streaming the node's\n   * relationship with this.#relationshipName (this computed size is also\n   * stored).\n   */\n  #filter(node: Node, size?: number): boolean {\n    const exists = (size ?? this.#getOrFetchSize(node)) > 0;\n    return this.#not ? !exists : exists;\n  }\n\n  /**\n   * Pushes a change if this.#filter is true for its row.\n   */\n  #pushWithFilter(change: Change, size?: number): void {\n    if (this.#filter(change.node, size)) {\n      this.#output.push(change);\n    }\n  }\n\n  #getSize(node: Node): number | undefined {\n    return this.#storage.get(this.#makeSizeStorageKey(node));\n  }\n\n  #setSize(node: Node, size: number) {\n    this.#storage.set(this.#makeSizeStorageKey(node), size);\n  }\n\n  #delSize(node: Node) {\n    this.#storage.del(this.#makeSizeStorageKey(node));\n  }\n\n  #getOrFetchSize(node: Node): number {\n    const size = this.#getSize(node);\n    if (size !== undefined) {\n      return size;\n    }\n    return this.#fetchSize(node);\n  }\n\n  #fetchSize(node: Node): number {\n    if (!this.#noSizeReuse && !this.#inPush) {\n      const cachedSizeEntry = first(\n        this.#storage.scan({\n          prefix: this.#makeSizeStorageKeyPrefix(node),\n        }),\n      );\n      if (cachedSizeEntry !== undefined) {\n        this.#setSize(node, cachedSizeEntry[1]);\n        return cachedSizeEntry[1];\n      }\n    }\n\n    const relationship = node.relationships[this.#relationshipName];\n    assert(relationship);\n    let size = 0;\n    for (const _relatedNode of relationship()) {\n      size++;\n    }\n\n    this.#setSize(node, size);\n    return size;\n  }\n\n  #makeSizeStorageKeyPrefix(node: Node): SizeStorageKeyPrefix {\n    return `row/${\n      this.#noSizeReuse\n        ? ''\n        : JSON.stringify(this.#getKeyValues(node, this.#parentJoinKey))\n    }/`;\n  }\n\n  #makeSizeStorageKey(node: Node): SizeStorageKey {\n    return `${this.#makeSizeStorageKeyPrefix(node)}${JSON.stringify(\n      this.#getKeyValues(node, this.#input.getSchema().primaryKey),\n    )}`;\n  }\n\n  #getKeyValues(node: Node, def: CompoundKey): NormalizedValue[] {\n    const values: NormalizedValue[] = [];\n    for (const key of def) {\n      values.push(normalizeUndefined(node.row[key]));\n    }\n    return values;\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {Change} from './change.ts';\nimport {type Node} from './data.ts';\nimport type {FanOut} from './fan-out.ts';\nimport {\n  throwFilterOutput,\n  type FilterInput,\n  type FilterOperator,\n  type FilterOutput,\n} from './filter-operators.ts';\nimport type {SourceSchema} from './schema.ts';\n\n/**\n * The FanIn operator merges multiple streams into one.\n * It eliminates duplicates and must be paired with a fan-out operator\n * somewhere upstream of the fan-in.\n *\n *  issue\n *    |\n * fan-out\n * /      \\\n * a      b\n *  \\    /\n * fan-in\n *   |\n */\nexport class FanIn implements FilterOperator {\n  readonly #inputs: readonly FilterInput[];\n  readonly #schema: SourceSchema;\n  #output: FilterOutput = throwFilterOutput;\n  #accumulatedPushes: Change[] = [];\n\n  constructor(fanOut: FanOut, inputs: FilterInput[]) {\n    this.#inputs = inputs;\n    this.#schema = fanOut.getSchema();\n    for (const input of inputs) {\n      input.setFilterOutput(this);\n      assert(this.#schema === input.getSchema(), `Schema mismatch in fan-in`);\n    }\n  }\n\n  setFilterOutput(output: FilterOutput): void {\n    this.#output = output;\n  }\n\n  destroy(): void {\n    for (const input of this.#inputs) {\n      input.destroy();\n    }\n  }\n\n  getSchema() {\n    return this.#schema;\n  }\n\n  filter(node: Node, cleanup: boolean): boolean {\n    return this.#output.filter(node, cleanup);\n  }\n\n  push(change: Change) {\n    this.#accumulatedPushes.push(change);\n  }\n\n  fanOutDonePushingToAllBranches(fanOutChangeType: Change['type']) {\n    if (this.#inputs.length === 0) {\n      assert(\n        this.#accumulatedPushes.length === 0,\n        'If there are no inputs then fan-in should not receive any pushes.',\n      );\n      return;\n    }\n\n    if (this.#accumulatedPushes.length === 0) {\n      // It is possible for no forks to pass along the push.\n      // E.g., if no filters match in any fork.\n      return;\n    }\n\n    // collapse down to a single change per type\n    const candidatesToPush = new Map<Change['type'], Change>();\n    for (const change of this.#accumulatedPushes) {\n      if (fanOutChangeType === 'child' && change.type !== 'child') {\n        assert(\n          candidatesToPush.has(change.type) === false,\n          () =>\n            `Fan-in:child expected at most one ${change.type} when fan-out is of type child`,\n        );\n      }\n      candidatesToPush.set(change.type, change);\n    }\n\n    this.#accumulatedPushes = [];\n\n    const types = [...candidatesToPush.keys()];\n    /**\n     * Based on the received `fanOutChangeType` only certain output types are valid.\n     *\n     * - remove must result in all removes\n     * - add must result in all adds\n     * - edit must result in add or removes or edits\n     * - child must result in a single add or single remove or many child changes\n     */\n    switch (fanOutChangeType) {\n      case 'remove':\n        assert(\n          types.length === 1 && types[0] === 'remove',\n          'Fan-in:remove expected all removes',\n        );\n        this.#output.push(must(candidatesToPush.get('remove')));\n        return;\n      case 'add':\n        assert(\n          types.length === 1 && types[0] === 'add',\n          'Fan-in:add expected all adds',\n        );\n        this.#output.push(must(candidatesToPush.get('add')));\n        return;\n      case 'edit': {\n        assert(\n          types.every(\n            type => type === 'add' || type === 'remove' || type === 'edit',\n          ),\n          'Fan-in:edit expected all adds, removes, or edits',\n        );\n        const addChange = candidatesToPush.get('add');\n        const removeChange = candidatesToPush.get('remove');\n        const editChange = candidatesToPush.get('edit');\n\n        // If an `edit` is present, it supersedes `add` and `remove`\n        // as it semantically represents both.\n        if (editChange) {\n          this.#output.push(editChange);\n          return;\n        }\n\n        // If `edit` didn't make it through but both `add` and `remove` did,\n        // convert back to an edit.\n        //\n        // When can this happen?\n        //\n        //  EDIT old: a=1, new: a=2\n        //            |\n        //          FanOut\n        //          /    \\\n        //         a=1   a=2\n        //          |     |\n        //        remove  add\n        //          \\     /\n        //           FanIn\n        //\n        // The left filter converts the edit into a remove.\n        // The right filter converts the edit into an add.\n        if (addChange && removeChange) {\n          this.#output.push({\n            type: 'edit',\n            node: addChange.node,\n            oldNode: removeChange.node,\n          } as const);\n          return;\n        }\n\n        this.#output.push(must(addChange ?? removeChange));\n        return;\n      }\n      case 'child': {\n        assert(\n          types.every(\n            type =>\n              type === 'add' || // exists can change child to add or remove\n              type === 'remove' || // exists can change child to add or remove\n              type === 'child', // other operators may preserve the child change\n          ),\n          'Fan-in:child expected all adds, removes, or children',\n        );\n        assert(\n          types.length <= 2,\n          'Fan-in:child expected at most 2 types on a child change from fan-out',\n        );\n\n        // If any branch preserved the original child change, that takes precedence over all other changes.\n        const childChange = candidatesToPush.get('child');\n        if (childChange) {\n          this.#output.push(childChange);\n          return;\n        }\n\n        const addChange = candidatesToPush.get('add');\n        const removeChange = candidatesToPush.get('remove');\n\n        assert(\n          addChange === undefined || removeChange === undefined,\n          'Fan-in:child expected either add or remove, not both',\n        );\n\n        this.#output.push(must(addChange ?? removeChange));\n        return;\n      }\n      default:\n        fanOutChangeType satisfies never;\n    }\n  }\n}\n","import {must} from '../../../shared/src/must.ts';\nimport type {Change} from './change.ts';\nimport type {FanIn} from './fan-in.ts';\nimport type {Node} from './data.ts';\nimport type {\n  FilterInput,\n  FilterOperator,\n  FilterOutput,\n} from './filter-operators.ts';\n\n/**\n * Forks a stream into multiple streams.\n * Is meant to be paired with a `FanIn` operator which will\n * later merge the forks back together.\n */\nexport class FanOut implements FilterOperator {\n  readonly #input: FilterInput;\n  readonly #outputs: FilterOutput[] = [];\n  #fanIn: FanIn | undefined;\n  #destroyCount: number = 0;\n\n  constructor(input: FilterInput) {\n    this.#input = input;\n    input.setFilterOutput(this);\n  }\n\n  setFanIn(fanIn: FanIn) {\n    this.#fanIn = fanIn;\n  }\n\n  setFilterOutput(output: FilterOutput): void {\n    this.#outputs.push(output);\n  }\n\n  destroy(): void {\n    if (this.#destroyCount < this.#outputs.length) {\n      if (this.#destroyCount === 0) {\n        this.#input.destroy();\n      }\n      ++this.#destroyCount;\n    } else {\n      throw new Error('FanOut already destroyed once for each output');\n    }\n  }\n\n  getSchema() {\n    return this.#input.getSchema();\n  }\n\n  filter(node: Node, cleanup: boolean): boolean {\n    let result = false;\n    for (const output of this.#outputs) {\n      result = output.filter(node, cleanup) || result;\n      // Cleanup needs to be forwarded to all outputs, don't short circuit\n      // cleanup.  For non-cleanup we can short-circuit on first true.\n      if (!cleanup && result) {\n        return true;\n      }\n    }\n    return result;\n  }\n\n  push(change: Change) {\n    for (const out of this.#outputs) {\n      out.push(change);\n    }\n    must(\n      this.#fanIn,\n      'fan-out must have a corresponding fan-in set!',\n    ).fanOutDonePushingToAllBranches(change.type);\n  }\n}\n","import type {Row} from '../../../zero-protocol/src/data.ts';\nimport type {EditChange} from './change.ts';\nimport type {Output} from './operator.ts';\n\n/**\n * This takes an {@linkcode EditChange} and a predicate that determines if a row\n * should be present based on the row's data. It then splits the change and\n * pushes the appropriate changes to the output based on the predicate.\n */\nexport function maybeSplitAndPushEditChange(\n  change: EditChange,\n  predicate: (row: Row) => boolean,\n  output: Output,\n) {\n  const oldWasPresent = predicate(change.oldNode.row);\n  const newIsPresent = predicate(change.node.row);\n\n  if (oldWasPresent && newIsPresent) {\n    output.push(change);\n  } else if (oldWasPresent && !newIsPresent) {\n    output.push({\n      type: 'remove',\n      node: change.oldNode,\n    });\n  } else if (!oldWasPresent && newIsPresent) {\n    output.push({\n      type: 'add',\n      node: change.node,\n    });\n  }\n}\n","import {unreachable} from '../../../shared/src/asserts.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport type {Change} from './change.ts';\nimport {maybeSplitAndPushEditChange} from './maybe-split-and-push-edit-change.ts';\nimport type {Output} from './operator.ts';\n\nexport function filterPush(\n  change: Change,\n  output: Output,\n  predicate?: ((row: Row) => boolean) | undefined,\n) {\n  if (!predicate) {\n    output.push(change);\n    return;\n  }\n  switch (change.type) {\n    case 'add':\n    case 'remove':\n      if (predicate(change.node.row)) {\n        output.push(change);\n      }\n      break;\n    case 'child':\n      if (predicate(change.node.row)) {\n        output.push(change);\n      }\n      break;\n    case 'edit':\n      maybeSplitAndPushEditChange(change, predicate, output);\n      break;\n    default:\n      unreachable(change);\n  }\n}\n","import type {Row} from '../../../zero-protocol/src/data.ts';\nimport type {Change} from './change.ts';\nimport {\n  throwFilterOutput,\n  type FilterInput,\n  type FilterOperator,\n  type FilterOutput,\n} from './filter-operators.ts';\nimport {filterPush} from './filter-push.ts';\nimport {type Node} from './data.ts';\nimport type {SourceSchema} from './schema.ts';\n\n/**\n * The Filter operator filters data through a predicate. It is stateless.\n *\n * The predicate must be pure.\n */\nexport class Filter implements FilterOperator {\n  readonly #input: FilterInput;\n  readonly #predicate: (row: Row) => boolean;\n\n  #output: FilterOutput = throwFilterOutput;\n\n  constructor(input: FilterInput, predicate: (row: Row) => boolean) {\n    this.#input = input;\n    this.#predicate = predicate;\n    input.setFilterOutput(this);\n  }\n\n  filter(node: Node, cleanup: boolean): boolean {\n    return this.#predicate(node.row) && this.#output.filter(node, cleanup);\n  }\n\n  setFilterOutput(output: FilterOutput) {\n    this.#output = output;\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  push(change: Change) {\n    filterPush(change, this.#output, this.#predicate);\n  }\n}\n","import {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport type {CompoundKey, System} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport type {Change, ChildChange} from './change.ts';\nimport {compareValues, valuesEqual, type Node} from './data.ts';\nimport {\n  throwOutput,\n  type FetchRequest,\n  type Input,\n  type Output,\n  type Storage,\n} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport {take, type Stream} from './stream.ts';\n\ntype Args = {\n  parent: Input;\n  child: Input;\n  storage: Storage;\n  // The order of the keys does not have to match but the length must match.\n  // The nth key in parentKey corresponds to the nth key in childKey.\n  parentKey: CompoundKey;\n  childKey: CompoundKey;\n\n  // TODO: Change parentKey & childKey to a correlation\n\n  relationshipName: string;\n  hidden: boolean;\n  system: System;\n};\n\ntype ChildChangeOverlay = {\n  change: Change;\n  position: Row | undefined;\n};\n\n/**\n * The Join operator joins the output from two upstream inputs. Zero's join\n * is a little different from SQL's join in that we output hierarchical data,\n * not a flat table. This makes it a lot more useful for UI programming and\n * avoids duplicating tons of data like left join would.\n *\n * The Nodes output from Join have a new relationship added to them, which has\n * the name #relationshipName. The value of the relationship is a stream of\n * child nodes which are the corresponding values from the child source.\n */\nexport class Join implements Input {\n  readonly #parent: Input;\n  readonly #child: Input;\n  readonly #storage: Storage;\n  readonly #parentKey: CompoundKey;\n  readonly #childKey: CompoundKey;\n  readonly #relationshipName: string;\n  readonly #schema: SourceSchema;\n\n  #output: Output = throwOutput;\n\n  #inprogressChildChange: ChildChangeOverlay | undefined;\n\n  constructor({\n    parent,\n    child,\n    storage,\n    parentKey,\n    childKey,\n    relationshipName,\n    hidden,\n    system,\n  }: Args) {\n    assert(parent !== child, 'Parent and child must be different operators');\n    assert(\n      parentKey.length === childKey.length,\n      'The parentKey and childKey keys must have same length',\n    );\n    this.#parent = parent;\n    this.#child = child;\n    this.#storage = storage;\n    this.#parentKey = parentKey;\n    this.#childKey = childKey;\n    this.#relationshipName = relationshipName;\n\n    const parentSchema = parent.getSchema();\n    const childSchema = child.getSchema();\n    this.#schema = {\n      ...parentSchema,\n      relationships: {\n        ...parentSchema.relationships,\n        [relationshipName]: {\n          ...childSchema,\n          isHidden: hidden,\n          system,\n        },\n      },\n    };\n\n    parent.setOutput({\n      push: (change: Change) => this.#pushParent(change),\n    });\n    child.setOutput({\n      push: (change: Change) => this.#pushChild(change),\n    });\n  }\n\n  destroy(): void {\n    this.#parent.destroy();\n    this.#child.destroy();\n  }\n\n  setOutput(output: Output): void {\n    this.#output = output;\n  }\n\n  getSchema(): SourceSchema {\n    return this.#schema;\n  }\n\n  *fetch(req: FetchRequest): Stream<Node> {\n    for (const parentNode of this.#parent.fetch(req)) {\n      yield this.#processParentNode(\n        parentNode.row,\n        parentNode.relationships,\n        'fetch',\n      );\n    }\n  }\n\n  *cleanup(req: FetchRequest): Stream<Node> {\n    for (const parentNode of this.#parent.cleanup(req)) {\n      yield this.#processParentNode(\n        parentNode.row,\n        parentNode.relationships,\n        'cleanup',\n      );\n    }\n  }\n\n  #pushParent(change: Change): void {\n    switch (change.type) {\n      case 'add':\n        this.#output.push({\n          type: 'add',\n          node: this.#processParentNode(\n            change.node.row,\n            change.node.relationships,\n            'fetch',\n          ),\n        });\n        break;\n      case 'remove':\n        this.#output.push({\n          type: 'remove',\n          node: this.#processParentNode(\n            change.node.row,\n            change.node.relationships,\n            'cleanup',\n          ),\n        });\n        break;\n      case 'child':\n        this.#output.push({\n          type: 'child',\n          node: this.#processParentNode(\n            change.node.row,\n            change.node.relationships,\n            'fetch',\n          ),\n          child: change.child,\n        });\n        break;\n      case 'edit': {\n        // Assert the edit could not change the relationship.\n        assert(\n          rowEqualsForCompoundKey(\n            change.oldNode.row,\n            change.node.row,\n            this.#parentKey,\n          ),\n          `Parent edit must not change relationship.`,\n        );\n        this.#output.push({\n          type: 'edit',\n          oldNode: this.#processParentNode(\n            change.oldNode.row,\n            change.oldNode.relationships,\n            'cleanup',\n          ),\n          node: this.#processParentNode(\n            change.node.row,\n            change.node.relationships,\n            'fetch',\n          ),\n        });\n        break;\n      }\n      default:\n        unreachable(change);\n    }\n  }\n\n  #pushChild(change: Change): void {\n    const pushChildChange = (childRow: Row, change: Change) => {\n      this.#inprogressChildChange = {\n        change,\n        position: undefined,\n      };\n      try {\n        const parentNodes = this.#parent.fetch({\n          constraint: Object.fromEntries(\n            this.#parentKey.map((key, i) => [key, childRow[this.#childKey[i]]]),\n          ),\n        });\n\n        for (const parentNode of parentNodes) {\n          this.#inprogressChildChange.position = parentNode.row;\n          const childChange: ChildChange = {\n            type: 'child',\n            node: this.#processParentNode(\n              parentNode.row,\n              parentNode.relationships,\n              'fetch',\n            ),\n            child: {\n              relationshipName: this.#relationshipName,\n              change,\n            },\n          };\n          this.#output.push(childChange);\n        }\n      } finally {\n        this.#inprogressChildChange = undefined;\n      }\n    };\n\n    switch (change.type) {\n      case 'add':\n      case 'remove':\n        pushChildChange(change.node.row, change);\n        break;\n      case 'child':\n        pushChildChange(change.node.row, change);\n        break;\n      case 'edit': {\n        const childRow = change.node.row;\n        const oldChildRow = change.oldNode.row;\n        // Assert the edit could not change the relationship.\n        assert(\n          rowEqualsForCompoundKey(oldChildRow, childRow, this.#childKey),\n          'Child edit must not change relationship.',\n        );\n        pushChildChange(childRow, change);\n        break;\n      }\n\n      default:\n        unreachable(change);\n    }\n  }\n\n  *#generateChildStreamWithOverlay(\n    stream: Stream<Node>,\n    overlay: Change,\n  ): Stream<Node> {\n    let applied = false;\n    let editOldApplied = false;\n    let editNewApplied = false;\n    for (const child of stream) {\n      let yieldChild = true;\n      if (!applied) {\n        switch (overlay.type) {\n          case 'add': {\n            if (\n              this.#child\n                .getSchema()\n                .compareRows(overlay.node.row, child.row) === 0\n            ) {\n              applied = true;\n              yieldChild = false;\n            }\n            break;\n          }\n          case 'remove': {\n            if (\n              this.#child.getSchema().compareRows(overlay.node.row, child.row) <\n              0\n            ) {\n              applied = true;\n              yield overlay.node;\n            }\n            break;\n          }\n          case 'edit': {\n            if (\n              this.#child\n                .getSchema()\n                .compareRows(overlay.oldNode.row, child.row) < 0\n            ) {\n              editOldApplied = true;\n              if (editNewApplied) {\n                applied = true;\n              }\n              yield overlay.oldNode;\n            }\n            if (\n              this.#child\n                .getSchema()\n                .compareRows(overlay.node.row, child.row) === 0\n            ) {\n              editNewApplied = true;\n              if (editOldApplied) {\n                applied = true;\n              }\n              yieldChild = false;\n            }\n            break;\n          }\n          case 'child': {\n            if (\n              this.#child\n                .getSchema()\n                .compareRows(overlay.node.row, child.row) === 0\n            ) {\n              applied = true;\n              yield {\n                row: child.row,\n                relationships: {\n                  ...child.relationships,\n                  [overlay.child.relationshipName]: () =>\n                    this.#generateChildStreamWithOverlay(\n                      child.relationships[overlay.child.relationshipName](),\n                      overlay.child.change,\n                    ),\n                },\n              };\n              yieldChild = false;\n            }\n            break;\n          }\n        }\n      }\n      if (yieldChild) {\n        yield child;\n      }\n    }\n    if (!applied) {\n      if (overlay.type === 'remove') {\n        applied = true;\n        yield overlay.node;\n      } else if (overlay.type === 'edit') {\n        assert(editNewApplied);\n        editOldApplied = true;\n        applied = true;\n        yield overlay.oldNode;\n      }\n    }\n\n    assert(applied);\n  }\n\n  #processParentNode(\n    parentNodeRow: Row,\n    parentNodeRelations: Record<string, () => Stream<Node>>,\n    mode: ProcessParentMode,\n  ): Node {\n    let method: ProcessParentMode = mode;\n    let storageUpdated = false;\n    const childStream = () => {\n      if (!storageUpdated) {\n        if (mode === 'cleanup') {\n          this.#storage.del(\n            makeStorageKey(\n              this.#parentKey,\n              this.#parent.getSchema().primaryKey,\n              parentNodeRow,\n            ),\n          );\n          const empty =\n            [\n              ...take(\n                this.#storage.scan({\n                  prefix: makeStorageKeyPrefix(parentNodeRow, this.#parentKey),\n                }),\n                1,\n              ),\n            ].length === 0;\n          method = empty ? 'cleanup' : 'fetch';\n        }\n\n        storageUpdated = true;\n        // Defer the work to update storage until the child stream\n        // is actually accessed\n        if (mode === 'fetch') {\n          this.#storage.set(\n            makeStorageKey(\n              this.#parentKey,\n              this.#parent.getSchema().primaryKey,\n              parentNodeRow,\n            ),\n            true,\n          );\n        }\n      }\n\n      const stream = this.#child[method]({\n        constraint: Object.fromEntries(\n          this.#childKey.map((key, i) => [\n            key,\n            parentNodeRow[this.#parentKey[i]],\n          ]),\n        ),\n      });\n\n      if (\n        this.#inprogressChildChange &&\n        this.#isJoinMatch(\n          parentNodeRow,\n          this.#inprogressChildChange.change.node.row,\n        ) &&\n        this.#inprogressChildChange.position &&\n        this.#schema.compareRows(\n          parentNodeRow,\n          this.#inprogressChildChange.position,\n        ) > 0\n      ) {\n        return this.#generateChildStreamWithOverlay(\n          stream,\n          this.#inprogressChildChange.change,\n        );\n      }\n      return stream;\n    };\n\n    return {\n      row: parentNodeRow,\n      relationships: {\n        ...parentNodeRelations,\n        [this.#relationshipName]: childStream,\n      },\n    };\n  }\n\n  #isJoinMatch(parent: Row, child: Row) {\n    for (let i = 0; i < this.#parentKey.length; i++) {\n      if (!valuesEqual(parent[this.#parentKey[i]], child[this.#childKey[i]])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\ntype ProcessParentMode = 'fetch' | 'cleanup';\n\n/** Exported for testing. */\nexport function makeStorageKeyForValues(values: readonly Value[]): string {\n  const json = JSON.stringify(['pKeySet', ...values]);\n  return json.substring(1, json.length - 1) + ',';\n}\n\n/** Exported for testing. */\nexport function makeStorageKeyPrefix(row: Row, key: CompoundKey): string {\n  return makeStorageKeyForValues(key.map(k => row[k]));\n}\n\n/** Exported for testing.\n * This storage key tracks the primary keys seen for each unique\n * value joined on. This is used to know when to cleanup a child's state.\n */\nexport function makeStorageKey(\n  key: CompoundKey,\n  primaryKey: PrimaryKey,\n  row: Row,\n): string {\n  const values: Value[] = key.map(k => row[k]);\n  for (const key of primaryKey) {\n    values.push(row[key]);\n  }\n  return makeStorageKeyForValues(values);\n}\n\nfunction rowEqualsForCompoundKey(a: Row, b: Row, key: CompoundKey): boolean {\n  for (let i = 0; i < key.length; i++) {\n    if (compareValues(a[key[i]], b[key[i]]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n","import type {Row} from '../../../zero-protocol/src/data.ts';\nimport type {AddChange, Change, ChildChange, RemoveChange} from './change.ts';\nimport type {Comparator, Node} from './data.ts';\nimport {maybeSplitAndPushEditChange} from './maybe-split-and-push-edit-change.ts';\nimport {\n  throwOutput,\n  type FetchRequest,\n  type Input,\n  type Operator,\n  type Output,\n  type Start,\n} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport type {Stream} from './stream.ts';\n\nexport type Bound = {\n  row: Row;\n  exclusive: boolean;\n};\n\n/**\n * Skip sets the start position for the pipeline. No rows before the bound will\n * be output.\n */\nexport class Skip implements Operator {\n  readonly #input: Input;\n  readonly #bound: Bound;\n  readonly #comparator: Comparator;\n\n  #output: Output = throwOutput;\n\n  constructor(input: Input, bound: Bound) {\n    this.#input = input;\n    this.#bound = bound;\n    this.#comparator = input.getSchema().compareRows;\n    input.setOutput(this);\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  fetch(req: FetchRequest): Stream<Node> {\n    return this.#fetchOrCleanup('fetch', req);\n  }\n\n  cleanup(req: FetchRequest): Stream<Node> {\n    return this.#fetchOrCleanup('fetch', req);\n  }\n\n  *#fetchOrCleanup(method: 'fetch' | 'cleanup', req: FetchRequest) {\n    const start = this.#getStart(req);\n    if (start === 'empty') {\n      return;\n    }\n    const nodes = this.#input[method]({...req, start});\n    if (!req.reverse) {\n      yield* nodes;\n      return;\n    }\n    for (const node of nodes) {\n      if (!this.#shouldBePresent(node.row)) {\n        return;\n      }\n      yield node;\n    }\n  }\n\n  setOutput(output: Output): void {\n    this.#output = output;\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  #shouldBePresent(row: Row): boolean {\n    const cmp = this.#comparator(this.#bound.row, row);\n    return cmp < 0 || (cmp === 0 && !this.#bound.exclusive);\n  }\n\n  push(change: Change): void {\n    const shouldBePresent = (row: Row) => this.#shouldBePresent(row);\n    if (change.type === 'edit') {\n      maybeSplitAndPushEditChange(change, shouldBePresent, this.#output);\n      return;\n    }\n\n    change satisfies AddChange | RemoveChange | ChildChange;\n\n    if (shouldBePresent(change.node.row)) {\n      this.#output.push(change);\n    }\n  }\n\n  #getStart(req: FetchRequest): Start | undefined | 'empty' {\n    const boundStart = {\n      row: this.#bound.row,\n      basis: this.#bound.exclusive ? 'after' : 'at',\n    } as const;\n\n    if (!req.start) {\n      if (req.reverse) {\n        return undefined;\n      }\n      return boundStart;\n    }\n\n    const cmp = this.#comparator(this.#bound.row, req.start.row);\n\n    if (!req.reverse) {\n      // The skip bound is after the requested bound. The requested bound cannot\n      // be relevant because even if it was basis: 'after', the skip bound is\n      // itself after the requested bound. Return the skip bound.\n      if (cmp > 0) {\n        return boundStart;\n      }\n\n      // The skip bound and requested bound are equal. If either is exclusive,\n      // return that bound with exclusive. Otherwise, return the skip bound.\n      if (cmp === 0) {\n        if (this.#bound.exclusive || req.start.basis === 'after') {\n          return {\n            row: this.#bound.row,\n            basis: 'after',\n          };\n        }\n        return boundStart;\n      }\n\n      return req.start;\n    }\n\n    req.reverse satisfies true;\n\n    // bound is after the start, but request is for reverse so results\n    // must be empty\n    if (cmp > 0) {\n      return 'empty';\n    }\n\n    if (cmp === 0) {\n      // if both are inclusive, the result can be the single row at bound\n      // return it as start\n      if (!this.#bound.exclusive && req.start.basis === 'at') {\n        return boundStart;\n      }\n      // otherwise the results must be empty, one or both are exclusive\n      // in opposite directions\n      return 'empty';\n    }\n\n    // bound is before the start, return start\n    return req.start;\n  }\n}\n","import {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport {hasOwn} from '../../../shared/src/has-own.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport {assertOrderingIncludesPK} from '../builder/builder.ts';\nimport {type Change, type EditChange, type RemoveChange} from './change.ts';\nimport type {Constraint} from './constraint.ts';\nimport {compareValues, type Comparator, type Node} from './data.ts';\nimport {\n  throwOutput,\n  type FetchRequest,\n  type Input,\n  type Operator,\n  type Output,\n  type Storage,\n} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport {first, take, type Stream} from './stream.ts';\n\nconst MAX_BOUND_KEY = 'maxBound';\n\ntype TakeState = {\n  size: number;\n  bound: Row | undefined;\n};\n\ninterface TakeStorage {\n  get(key: typeof MAX_BOUND_KEY): Row | undefined;\n  get(key: string): TakeState | undefined;\n  set(key: typeof MAX_BOUND_KEY, value: Row): void;\n  set(key: string, value: TakeState): void;\n  del(key: string): void;\n}\n\nexport type PartitionKey = PrimaryKey;\n\n/**\n * The Take operator is for implementing limit queries. It takes the first n\n * nodes of its input as determined by the input’s comparator. It then keeps\n * a *bound* of the last item it has accepted so that it can evaluate whether\n * new incoming pushes should be accepted or rejected.\n *\n * Take can count rows globally or by unique value of some field.\n *\n * Maintains the invariant that its output size is always <= limit, even\n * mid processing of a push.\n */\nexport class Take implements Operator {\n  readonly #input: Input;\n  readonly #storage: TakeStorage;\n  readonly #limit: number;\n  readonly #partitionKey: PartitionKey | undefined;\n  readonly #partitionKeyComparator: Comparator | undefined;\n  // Fetch overlay needed for some split push cases.\n  #rowHiddenFromFetch: Row | undefined;\n\n  #output: Output = throwOutput;\n\n  constructor(\n    input: Input,\n    storage: Storage,\n    limit: number,\n    partitionKey?: PartitionKey | undefined,\n  ) {\n    assert(limit >= 0);\n    assertOrderingIncludesPK(\n      input.getSchema().sort,\n      input.getSchema().primaryKey,\n    );\n    input.setOutput(this);\n    this.#input = input;\n    this.#storage = storage as TakeStorage;\n    this.#limit = limit;\n    this.#partitionKey = partitionKey;\n    this.#partitionKeyComparator =\n      partitionKey && makePartitionKeyComparator(partitionKey);\n  }\n\n  setOutput(output: Output): void {\n    this.#output = output;\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  *fetch(req: FetchRequest): Stream<Node> {\n    if (\n      !this.#partitionKey ||\n      (req.constraint &&\n        constraintMatchesPartitionKey(req.constraint, this.#partitionKey))\n    ) {\n      const takeStateKey = getTakeStateKey(this.#partitionKey, req.constraint);\n      const takeState = this.#storage.get(takeStateKey);\n      if (!takeState) {\n        yield* this.#initialFetch(req);\n        return;\n      }\n      if (takeState.bound === undefined) {\n        return;\n      }\n      for (const inputNode of this.#input.fetch(req)) {\n        if (this.getSchema().compareRows(takeState.bound, inputNode.row) < 0) {\n          return;\n        }\n        if (\n          this.#rowHiddenFromFetch &&\n          this.getSchema().compareRows(\n            this.#rowHiddenFromFetch,\n            inputNode.row,\n          ) === 0\n        ) {\n          continue;\n        }\n        yield inputNode;\n      }\n      return;\n    }\n    // There is a partition key, but the fetch is not constrained or constrained\n    // on a different key.  Thus we don't have a single take state to bound by.\n    // This currently only happens with nested sub-queries\n    // e.g. issues include issuelabels include label.  We could remove this\n    // case if we added a translation layer (powered by some state) in join.\n    // Specifically we need joinKeyValue => parent constraint key\n    const maxBound = this.#storage.get(MAX_BOUND_KEY);\n    if (maxBound === undefined) {\n      return;\n    }\n    for (const inputNode of this.#input.fetch(req)) {\n      if (this.getSchema().compareRows(inputNode.row, maxBound) > 0) {\n        return;\n      }\n      const takeStateKey = getTakeStateKey(this.#partitionKey, inputNode.row);\n      const takeState = this.#storage.get(takeStateKey);\n      if (\n        takeState?.bound !== undefined &&\n        this.getSchema().compareRows(takeState.bound, inputNode.row) >= 0\n      ) {\n        yield inputNode;\n      }\n    }\n  }\n\n  *#initialFetch(req: FetchRequest): Stream<Node> {\n    assert(req.start === undefined);\n    assert(!req.reverse);\n    assert(constraintMatchesPartitionKey(req.constraint, this.#partitionKey));\n\n    if (this.#limit === 0) {\n      return;\n    }\n\n    const takeStateKey = getTakeStateKey(this.#partitionKey, req.constraint);\n    assert(this.#storage.get(takeStateKey) === undefined);\n\n    let size = 0;\n    let bound: Row | undefined;\n    let downstreamEarlyReturn = true;\n    let exceptionThrown = false;\n    try {\n      for (const inputNode of this.#input.fetch(req)) {\n        yield inputNode;\n        bound = inputNode.row;\n        size++;\n        if (size === this.#limit) {\n          break;\n        }\n      }\n      downstreamEarlyReturn = false;\n    } catch (e) {\n      exceptionThrown = true;\n      throw e;\n    } finally {\n      if (!exceptionThrown) {\n        this.#setTakeState(\n          takeStateKey,\n          size,\n          bound,\n          this.#storage.get(MAX_BOUND_KEY),\n        );\n        // If it becomes necessary to support downstream early return, this\n        // assert should be removed, and replaced with code that consumes\n        // the input stream until limit is reached or the input stream is\n        // exhausted so that takeState is properly hydrated.\n        assert(\n          !downstreamEarlyReturn,\n          'Unexpected early return prevented full hydration',\n        );\n      }\n    }\n  }\n\n  *cleanup(req: FetchRequest): Stream<Node> {\n    assert(req.start === undefined);\n    assert(constraintMatchesPartitionKey(req.constraint, this.#partitionKey));\n    const takeStateKey = getTakeStateKey(this.#partitionKey, req.constraint);\n    this.#storage.del(takeStateKey);\n    let size = 0;\n    for (const inputNode of this.#input.cleanup(req)) {\n      if (size === this.#limit) {\n        return;\n      }\n      size++;\n      yield inputNode;\n    }\n  }\n\n  #getStateAndConstraint(row: Row) {\n    const takeStateKey = getTakeStateKey(this.#partitionKey, row);\n    const takeState = this.#storage.get(takeStateKey);\n    let maxBound: Row | undefined;\n    let constraint: Constraint | undefined;\n    if (takeState) {\n      maxBound = this.#storage.get(MAX_BOUND_KEY);\n      constraint =\n        this.#partitionKey &&\n        Object.fromEntries(\n          this.#partitionKey.map(key => [key, row[key]] as const),\n        );\n    }\n\n    return {takeState, takeStateKey, maxBound, constraint} as\n      | {\n          takeState: undefined;\n          takeStateKey: string;\n          maxBound: undefined;\n          constraint: undefined;\n        }\n      | {\n          takeState: TakeState;\n          takeStateKey: string;\n          maxBound: Row | undefined;\n          constraint: Constraint | undefined;\n        };\n  }\n\n  push(change: Change): void {\n    if (change.type === 'edit') {\n      this.#pushEditChange(change);\n      return;\n    }\n\n    const {takeState, takeStateKey, maxBound, constraint} =\n      this.#getStateAndConstraint(change.node.row);\n    if (!takeState) {\n      return;\n    }\n\n    const {compareRows} = this.getSchema();\n\n    if (change.type === 'add') {\n      if (takeState.size < this.#limit) {\n        this.#setTakeState(\n          takeStateKey,\n          takeState.size + 1,\n          takeState.bound === undefined ||\n            compareRows(takeState.bound, change.node.row) < 0\n            ? change.node.row\n            : takeState.bound,\n          maxBound,\n        );\n        this.#output.push(change);\n        return;\n      }\n      // size === limit\n      if (\n        takeState.bound === undefined ||\n        compareRows(change.node.row, takeState.bound) >= 0\n      ) {\n        return;\n      }\n      // added row < bound\n      let beforeBoundNode: Node | undefined;\n      let boundNode: Node;\n      if (this.#limit === 1) {\n        boundNode = must(\n          first(\n            this.#input.fetch({\n              start: {\n                row: takeState.bound,\n                basis: 'at',\n              },\n              constraint,\n            }),\n          ),\n        );\n      } else {\n        [boundNode, beforeBoundNode] = take(\n          this.#input.fetch({\n            start: {\n              row: takeState.bound,\n              basis: 'at',\n            },\n            constraint,\n            reverse: true,\n          }),\n          2,\n        );\n      }\n      const removeChange: RemoveChange = {\n        type: 'remove',\n        node: boundNode,\n      };\n      // Remove before add to maintain invariant that\n      // output size <= limit.\n      this.#setTakeState(\n        takeStateKey,\n        takeState.size,\n        beforeBoundNode === undefined ||\n          compareRows(change.node.row, beforeBoundNode.row) > 0\n          ? change.node.row\n          : beforeBoundNode.row,\n        maxBound,\n      );\n      this.#withRowHiddenFromFetch(change.node.row, () => {\n        this.#output.push(removeChange);\n      });\n      this.#output.push(change);\n    } else if (change.type === 'remove') {\n      if (takeState.bound === undefined) {\n        // change is after bound\n        return;\n      }\n      const compToBound = compareRows(change.node.row, takeState.bound);\n      if (compToBound > 0) {\n        // change is after bound\n        return;\n      }\n      const [beforeBoundNode] = take(\n        this.#input.fetch({\n          start: {\n            row: takeState.bound,\n            basis: 'after',\n          },\n          constraint,\n          reverse: true,\n        }),\n        1,\n      );\n\n      let newBound: {node: Node; push: boolean} | undefined;\n      if (beforeBoundNode) {\n        const push = compareRows(beforeBoundNode.row, takeState.bound) > 0;\n        newBound = {\n          node: beforeBoundNode,\n          push,\n        };\n      }\n      if (!newBound?.push) {\n        for (const node of this.#input.fetch({\n          start: {\n            row: takeState.bound,\n            basis: 'at',\n          },\n          constraint,\n        })) {\n          const push = compareRows(node.row, takeState.bound) > 0;\n          newBound = {\n            node,\n            push,\n          };\n          if (push) {\n            break;\n          }\n        }\n      }\n\n      if (newBound?.push) {\n        this.#output.push(change);\n        this.#setTakeState(\n          takeStateKey,\n          takeState.size,\n          newBound.node.row,\n          maxBound,\n        );\n        this.#output.push({\n          type: 'add',\n          node: newBound.node,\n        });\n        return;\n      }\n      this.#setTakeState(\n        takeStateKey,\n        takeState.size - 1,\n        newBound?.node.row,\n        maxBound,\n      );\n      this.#output.push(change);\n    } else if (change.type === 'child') {\n      // A 'child' change should be pushed to output if its row\n      // is <= bound.\n      if (\n        takeState.bound &&\n        compareRows(change.node.row, takeState.bound) <= 0\n      ) {\n        this.#output.push(change);\n      }\n    }\n  }\n\n  #pushEditChange(change: EditChange): void {\n    assert(\n      !this.#partitionKeyComparator ||\n        this.#partitionKeyComparator(change.oldNode.row, change.node.row) === 0,\n      'Unexpected change of partition key',\n    );\n\n    const {takeState, takeStateKey, maxBound, constraint} =\n      this.#getStateAndConstraint(change.oldNode.row);\n    if (!takeState) {\n      return;\n    }\n\n    assert(takeState.bound, 'Bound should be set');\n    const {compareRows} = this.getSchema();\n    const oldCmp = compareRows(change.oldNode.row, takeState.bound);\n    const newCmp = compareRows(change.node.row, takeState.bound);\n\n    const replaceBoundAndForwardChange = () => {\n      this.#setTakeState(\n        takeStateKey,\n        takeState.size,\n        change.node.row,\n        maxBound,\n      );\n      this.#output.push(change);\n    };\n\n    // The bounds row was changed.\n    if (oldCmp === 0) {\n      // The new row is the new bound.\n      if (newCmp === 0) {\n        // no need to update the state since we are keeping the bounds\n        this.#output.push(change);\n        return;\n      }\n\n      if (newCmp < 0) {\n        if (this.#limit === 1) {\n          replaceBoundAndForwardChange();\n          return;\n        }\n\n        // New row will be in the result but it might not be the bounds any\n        // more. We need to find the row before the bounds to determine the new\n        // bounds.\n\n        const beforeBoundNode = must(\n          first(\n            this.#input.fetch({\n              start: {\n                row: takeState.bound,\n                basis: 'after',\n              },\n              constraint,\n              reverse: true,\n            }),\n          ),\n        );\n\n        this.#setTakeState(\n          takeStateKey,\n          takeState.size,\n          beforeBoundNode.row,\n          maxBound,\n        );\n        this.#output.push(change);\n        return;\n      }\n\n      assert(newCmp > 0);\n      // Find the first item at the old bounds. This will be the new bounds.\n      const newBoundNode = must(\n        first(\n          this.#input.fetch({\n            start: {\n              row: takeState.bound,\n              basis: 'at',\n            },\n            constraint,\n          }),\n        ),\n      );\n\n      // The next row is the new row. We can replace the bounds and keep the\n      // edit change.\n      if (compareRows(newBoundNode.row, change.node.row) === 0) {\n        replaceBoundAndForwardChange();\n        return;\n      }\n\n      // The new row is now outside the bounds, so we need to remove the old\n      // row and add the new bounds row.\n      this.#setTakeState(\n        takeStateKey,\n        takeState.size,\n        newBoundNode.row,\n        maxBound,\n      );\n      this.#withRowHiddenFromFetch(newBoundNode.row, () => {\n        this.#output.push({\n          type: 'remove',\n          node: change.oldNode,\n        });\n      });\n      this.#output.push({\n        type: 'add',\n        node: newBoundNode,\n      });\n      return;\n    }\n\n    if (oldCmp > 0) {\n      assert(newCmp !== 0, 'Invalid state. Row has duplicate primary key');\n\n      // Both old and new outside of bounds\n      if (newCmp > 0) {\n        return;\n      }\n\n      // old was outside, new is inside. Pushing out the old bounds\n      assert(newCmp < 0);\n\n      const [oldBoundNode, newBoundNode] = take(\n        this.#input.fetch({\n          start: {\n            row: takeState.bound,\n            basis: 'at',\n          },\n          constraint,\n          reverse: true,\n        }),\n        2,\n      );\n      // Remove before add to maintain invariant that\n      // output size <= limit.\n      this.#setTakeState(\n        takeStateKey,\n        takeState.size,\n        newBoundNode.row,\n        maxBound,\n      );\n      this.#withRowHiddenFromFetch(change.node.row, () => {\n        this.#output.push({\n          type: 'remove',\n          node: oldBoundNode,\n        });\n      });\n      this.#output.push({\n        type: 'add',\n        node: change.node,\n      });\n\n      return;\n    }\n\n    if (oldCmp < 0) {\n      assert(newCmp !== 0, 'Invalid state. Row has duplicate primary key');\n\n      // Both old and new inside of bounds\n      if (newCmp < 0) {\n        this.#output.push(change);\n        return;\n      }\n\n      // old was inside, new is larger than old bound\n\n      assert(newCmp > 0);\n\n      // at this point we need to find the row after the bound and use that or\n      // the newRow as the new bound.\n      const afterBoundNode = must(\n        first(\n          this.#input.fetch({\n            start: {\n              row: takeState.bound,\n              basis: 'after',\n            },\n            constraint,\n          }),\n        ),\n      );\n\n      // The new row is the new bound. Use an edit change.\n      if (compareRows(afterBoundNode.row, change.node.row) === 0) {\n        replaceBoundAndForwardChange();\n        return;\n      }\n\n      this.#output.push({\n        type: 'remove',\n        node: change.oldNode,\n      });\n      this.#setTakeState(\n        takeStateKey,\n        takeState.size,\n        afterBoundNode.row,\n        maxBound,\n      );\n      this.#output.push({\n        type: 'add',\n        node: afterBoundNode,\n      });\n      return;\n    }\n\n    unreachable();\n  }\n\n  #withRowHiddenFromFetch(row: Row, fn: () => void) {\n    this.#rowHiddenFromFetch = row;\n    try {\n      fn();\n    } finally {\n      this.#rowHiddenFromFetch = undefined;\n    }\n  }\n\n  #setTakeState(\n    takeStateKey: string,\n    size: number,\n    bound: Row | undefined,\n    maxBound: Row | undefined,\n  ) {\n    this.#storage.set(takeStateKey, {\n      size,\n      bound,\n    });\n    if (\n      bound !== undefined &&\n      (maxBound === undefined ||\n        this.getSchema().compareRows(bound, maxBound) > 0)\n    ) {\n      this.#storage.set(MAX_BOUND_KEY, bound);\n    }\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n}\n\nfunction getTakeStateKey(\n  partitionKey: PartitionKey | undefined,\n  rowOrConstraint: Row | Constraint | undefined,\n): string {\n  // The order must be consistent. We always use the order as defined by the\n  // partition key.\n  const partitionValues: Value[] = [];\n\n  if (partitionKey && rowOrConstraint) {\n    for (const key of partitionKey) {\n      partitionValues.push(rowOrConstraint[key]);\n    }\n  }\n\n  return JSON.stringify(['take', ...partitionValues]);\n}\n\nfunction constraintMatchesPartitionKey(\n  constraint: Constraint | undefined,\n  partitionKey: PartitionKey | undefined,\n): boolean {\n  if (constraint === undefined || partitionKey === undefined) {\n    return constraint === partitionKey;\n  }\n  if (partitionKey.length !== Object.keys(constraint).length) {\n    return false;\n  }\n  for (const key of partitionKey) {\n    if (!hasOwn(constraint, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction makePartitionKeyComparator(partitionKey: PartitionKey): Comparator {\n  return (a, b) => {\n    for (const key of partitionKey) {\n      const cmp = compareValues(a[key], b[key]);\n      if (cmp !== 0) {\n        return cmp;\n      }\n    }\n    return 0;\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {must} from '../../../shared/src/must.ts';\nimport {\n  toStaticParam,\n  type Condition,\n  type LiteralValue,\n  type Parameter,\n  type SimpleOperator,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {\n  AvailableRelationships,\n  DestTableName,\n  GetFilterType,\n  NoCompoundTypeSelector,\n  PullTableSchema,\n  Query,\n} from './query.ts';\n\nexport type ParameterReference = {\n  [toStaticParam](): Parameter;\n};\n\n/**\n * A factory function that creates a condition. This is used to create\n * complex conditions that can be passed to the `where` method of a query.\n *\n * @example\n *\n * ```ts\n * const condition: ExpressionFactory<User> = ({and, cmp, or}) =>\n *   and(\n *     cmp('name', '=', 'Alice'),\n *     or(cmp('age', '>', 18), cmp('isStudent', '=', true)),\n *   );\n *\n * const query = z.query.user.where(condition);\n * ```\n */\nexport interface ExpressionFactory<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n> {\n  (eb: ExpressionBuilder<TSchema, TTable>): Condition;\n}\n\nexport class ExpressionBuilder<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n> {\n  readonly #exists: (\n    relationship: string,\n    cb?: (query: Query<TSchema, TTable>) => Query<TSchema, any>,\n  ) => Condition;\n\n  constructor(\n    exists: (\n      relationship: string,\n      cb?: (query: Query<TSchema, TTable>) => Query<TSchema, any>,\n    ) => Condition,\n  ) {\n    this.#exists = exists;\n    this.exists = this.exists.bind(this);\n  }\n\n  get eb() {\n    return this;\n  }\n\n  cmp<\n    TSelector extends NoCompoundTypeSelector<PullTableSchema<TTable, TSchema>>,\n    TOperator extends SimpleOperator,\n  >(\n    field: TSelector,\n    op: TOperator,\n    value:\n      | GetFilterType<PullTableSchema<TTable, TSchema>, TSelector, TOperator>\n      | ParameterReference,\n  ): Condition;\n  cmp<\n    TSelector extends NoCompoundTypeSelector<PullTableSchema<TTable, TSchema>>,\n  >(\n    field: TSelector,\n    value:\n      | GetFilterType<PullTableSchema<TTable, TSchema>, TSelector, '='>\n      | ParameterReference,\n  ): Condition;\n  cmp(\n    field: string,\n    opOrValue: SimpleOperator | ParameterReference | LiteralValue,\n    value?: ParameterReference | LiteralValue,\n  ): Condition {\n    return cmp(field, opOrValue, value);\n  }\n\n  cmpLit(\n    left: ParameterReference | LiteralValue,\n    op: SimpleOperator,\n    right: ParameterReference | LiteralValue,\n  ): Condition {\n    return {\n      type: 'simple',\n      left: isParameterReference(left)\n        ? left[toStaticParam]()\n        : {type: 'literal', value: left},\n      right: isParameterReference(right)\n        ? right[toStaticParam]()\n        : {type: 'literal', value: right},\n      op,\n    };\n  }\n\n  and = and;\n  or = or;\n  not = not;\n\n  exists = <TRelationship extends AvailableRelationships<TTable, TSchema>>(\n    relationship: TRelationship,\n    cb?: (\n      query: Query<TSchema, DestTableName<TTable, TSchema, TRelationship>>,\n    ) => Query<TSchema, any>,\n  ): Condition => this.#exists(relationship, cb);\n}\n\nexport function and(...conditions: (Condition | undefined)[]): Condition {\n  const expressions = filterTrue(filterUndefined(conditions));\n\n  if (expressions.length === 1) {\n    return expressions[0];\n  }\n\n  if (expressions.some(isAlwaysFalse)) {\n    return FALSE;\n  }\n\n  return {type: 'and', conditions: expressions};\n}\n\nexport function or(...conditions: (Condition | undefined)[]): Condition {\n  const expressions = filterFalse(filterUndefined(conditions));\n\n  if (expressions.length === 1) {\n    return expressions[0];\n  }\n\n  if (expressions.some(isAlwaysTrue)) {\n    return TRUE;\n  }\n\n  return {type: 'or', conditions: expressions};\n}\n\nexport function not(expression: Condition): Condition {\n  switch (expression.type) {\n    case 'and':\n      return {\n        type: 'or',\n        conditions: expression.conditions.map(not),\n      };\n    case 'or':\n      return {\n        type: 'and',\n        conditions: expression.conditions.map(not),\n      };\n    case 'correlatedSubquery':\n      return {\n        type: 'correlatedSubquery',\n        related: expression.related,\n        op: negateOperator(expression.op),\n      };\n    case 'simple':\n      return {\n        type: 'simple',\n        op: negateOperator(expression.op),\n        left: expression.left,\n        right: expression.right,\n      };\n  }\n}\n\nexport function cmp(\n  field: string,\n  opOrValue: SimpleOperator | ParameterReference | LiteralValue,\n  value?: ParameterReference | LiteralValue,\n): Condition {\n  let op: SimpleOperator;\n  if (value === undefined) {\n    value = opOrValue;\n    op = '=';\n  } else {\n    op = opOrValue as SimpleOperator;\n  }\n\n  return {\n    type: 'simple',\n    left: {type: 'column', name: field},\n    right: isParameterReference(value)\n      ? value[toStaticParam]()\n      : {type: 'literal', value},\n    op,\n  };\n}\n\nfunction isParameterReference(\n  value: ParameterReference | LiteralValue | null,\n): value is ParameterReference {\n  return (\n    value !== null && typeof value === 'object' && (value as any)[toStaticParam]\n  );\n}\n\nexport const TRUE: Condition = {\n  type: 'and',\n  conditions: [],\n};\n\nconst FALSE: Condition = {\n  type: 'or',\n  conditions: [],\n};\n\nfunction isAlwaysTrue(condition: Condition): boolean {\n  return condition.type === 'and' && condition.conditions.length === 0;\n}\n\nfunction isAlwaysFalse(condition: Condition): boolean {\n  return condition.type === 'or' && condition.conditions.length === 0;\n}\n\nexport function simplifyCondition(c: Condition): Condition {\n  if (c.type === 'simple' || c.type === 'correlatedSubquery') {\n    return c;\n  }\n  if (c.conditions.length === 1) {\n    return simplifyCondition(c.conditions[0]);\n  }\n  const conditions = flatten(c.type, c.conditions.map(simplifyCondition));\n  if (c.type === 'and' && conditions.some(isAlwaysFalse)) {\n    return FALSE;\n  }\n  if (c.type === 'or' && conditions.some(isAlwaysTrue)) {\n    return TRUE;\n  }\n  return {\n    type: c.type,\n    conditions,\n  };\n}\n\nexport function flatten(\n  type: 'and' | 'or',\n  conditions: readonly Condition[],\n): Condition[] {\n  const flattened: Condition[] = [];\n  for (const c of conditions) {\n    if (c.type === type) {\n      flattened.push(...c.conditions);\n    } else {\n      flattened.push(c);\n    }\n  }\n\n  return flattened;\n}\n\nconst negateSimpleOperatorMap = {\n  ['=']: '!=',\n  ['!=']: '=',\n  ['<']: '>=',\n  ['>']: '<=',\n  ['>=']: '<',\n  ['<=']: '>',\n  ['IN']: 'NOT IN',\n  ['NOT IN']: 'IN',\n  ['LIKE']: 'NOT LIKE',\n  ['NOT LIKE']: 'LIKE',\n  ['ILIKE']: 'NOT ILIKE',\n  ['NOT ILIKE']: 'ILIKE',\n  ['IS']: 'IS NOT',\n  ['IS NOT']: 'IS',\n} as const;\n\nconst negateOperatorMap = {\n  ...negateSimpleOperatorMap,\n  ['EXISTS']: 'NOT EXISTS',\n  ['NOT EXISTS']: 'EXISTS',\n} as const;\n\nexport function negateOperator<OP extends keyof typeof negateOperatorMap>(\n  op: OP,\n): (typeof negateOperatorMap)[OP] {\n  return must(negateOperatorMap[op]);\n}\n\nfunction filterUndefined<T>(array: (T | undefined)[]): T[] {\n  return array.filter(e => e !== undefined);\n}\n\nfunction filterTrue(conditions: Condition[]): Condition[] {\n  return conditions.filter(c => !isAlwaysTrue(c));\n}\n\nfunction filterFalse(conditions: Condition[]): Condition[] {\n  return conditions.filter(c => !isAlwaysFalse(c));\n}\n","import {assertString} from '../../../shared/src/asserts.ts';\nimport type {NonNullValue, SimplePredicateNoNull} from './filter.ts';\n\nexport function getLikePredicate(\n  pattern: NonNullValue,\n  flags: 'i' | '',\n): SimplePredicateNoNull {\n  const op = getLikeOp(String(pattern), flags);\n  return (lhs: NonNullValue) => {\n    assertString(lhs);\n    return op(String(lhs));\n  };\n}\n\nfunction getLikeOp(pattern: string, flags: 'i' | ''): (lhs: string) => boolean {\n  // if lhs does not contain '%' or '_' then it is a simple string comparison.\n  // if it does contain '%' or '_' then it is a regex comparison.\n  // '%' is a wildcard for any number of characters\n  // '_' is a wildcard for a single character\n  // Postgres SQL allows escaping using `\\`.\n\n  if (!/_|%|\\\\/.test(pattern)) {\n    if (flags === 'i') {\n      const rhsLower = pattern.toLowerCase();\n      return (lhs: string) => lhs.toLowerCase() === rhsLower;\n    }\n    return (lhs: string) => lhs === pattern;\n  }\n  const re = patternToRegExp(pattern, flags);\n  return (lhs: string) => re.test(lhs);\n}\n\nconst specialCharsRe = /[$()*+.?[\\]\\\\^{|}]/;\n\nfunction patternToRegExp(source: string, flags: '' | 'i' = ''): RegExp {\n  // There are a few cases:\n  // % => .*\n  // _ => .\n  // \\x => \\x for any x except special regexp chars\n  // special regexp chars => \\special regexp chars\n  let pattern = '^';\n  for (let i = 0; i < source.length; i++) {\n    let c = source[i];\n    switch (c) {\n      case '%':\n        pattern += '.*';\n        break;\n      case '_':\n        pattern += '.';\n        break;\n\n      // @ts-expect-error fallthrough\n      case '\\\\':\n        if (i === source.length - 1) {\n          throw new Error('LIKE pattern must not end with escape character');\n        }\n        i++;\n        c = source[i];\n\n      // fall through\n      default:\n        if (specialCharsRe.test(c)) {\n          pattern += '\\\\';\n        }\n        pattern += c;\n\n        break;\n    }\n  }\n  return new RegExp(pattern + '$', flags + 'm');\n}\n","import {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport type {\n  Condition,\n  SimpleCondition,\n  SimpleOperator,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport {simplifyCondition} from '../query/expression.ts';\nimport {getLikePredicate} from './like.ts';\n\nexport type NonNullValue = Exclude<Value, null | undefined>;\nexport type SimplePredicate = (rhs: Value) => boolean;\nexport type SimplePredicateNoNull = (rhs: NonNullValue) => boolean;\n\nexport type NoSubqueryCondition =\n  | SimpleCondition\n  | {\n      type: 'and';\n      conditions: readonly NoSubqueryCondition[];\n    }\n  | {\n      type: 'or';\n      conditions: readonly NoSubqueryCondition[];\n    };\n\nexport function createPredicate(\n  condition: NoSubqueryCondition,\n): (row: Row) => boolean {\n  if (condition.type !== 'simple') {\n    const predicates = condition.conditions.map(c => createPredicate(c));\n    return condition.type === 'and'\n      ? (row: Row) => {\n          // and\n          for (const predicate of predicates) {\n            if (!predicate(row)) {\n              return false;\n            }\n          }\n          return true;\n        }\n      : (row: Row) => {\n          // or\n          for (const predicate of predicates) {\n            if (predicate(row)) {\n              return true;\n            }\n          }\n          return false;\n        };\n  }\n  const {left} = condition;\n  const {right} = condition;\n  assert(\n    right.type !== 'static',\n    'static values should be resolved before creating predicates',\n  );\n  assert(\n    left.type !== 'static',\n    'static values should be resolved before creating predicates',\n  );\n\n  switch (condition.op) {\n    case 'IS':\n    case 'IS NOT': {\n      const impl = createIsPredicate(right.value, condition.op);\n      if (left.type === 'literal') {\n        const result = impl(left.value);\n        return () => result;\n      }\n      return (row: Row) => impl(row[left.name]);\n    }\n  }\n\n  if (right.value === null || right.value === undefined) {\n    return (_row: Row) => false;\n  }\n\n  const impl = createPredicateImpl(right.value, condition.op);\n  if (left.type === 'literal') {\n    if (left.value === null || left.value === undefined) {\n      return (_row: Row) => false;\n    }\n    const result = impl(left.value);\n    return () => result;\n  }\n\n  return (row: Row) => {\n    const lhs = row[left.name];\n    if (lhs === null || lhs === undefined) {\n      return false;\n    }\n    return impl(lhs);\n  };\n}\n\nfunction createIsPredicate(\n  rhs: Value | readonly Value[],\n  operator: 'IS' | 'IS NOT',\n): SimplePredicate {\n  switch (operator) {\n    case 'IS':\n      return lhs => lhs === rhs;\n    case 'IS NOT':\n      return lhs => lhs !== rhs;\n  }\n}\n\nfunction createPredicateImpl(\n  rhs: NonNullValue | readonly NonNullValue[],\n  operator: Exclude<SimpleOperator, 'IS' | 'IS NOT'>,\n): SimplePredicateNoNull {\n  switch (operator) {\n    case '=':\n      return lhs => lhs === rhs;\n    case '!=':\n      return lhs => lhs !== rhs;\n    case '<':\n      return lhs => lhs < rhs;\n    case '<=':\n      return lhs => lhs <= rhs;\n    case '>':\n      return lhs => lhs > rhs;\n    case '>=':\n      return lhs => lhs >= rhs;\n    case 'LIKE':\n      return getLikePredicate(rhs, '');\n    case 'NOT LIKE':\n      return not(getLikePredicate(rhs, ''));\n    case 'ILIKE':\n      return getLikePredicate(rhs, 'i');\n    case 'NOT ILIKE':\n      return not(getLikePredicate(rhs, 'i'));\n    case 'IN': {\n      assert(Array.isArray(rhs));\n      const set = new Set(rhs);\n      return lhs => set.has(lhs);\n    }\n    case 'NOT IN': {\n      assert(Array.isArray(rhs));\n      const set = new Set(rhs);\n      return lhs => !set.has(lhs);\n    }\n    default:\n      operator satisfies never;\n      throw new Error(`Unexpected operator: ${operator}`);\n  }\n}\n\nfunction not<T>(f: (lhs: T) => boolean) {\n  return (lhs: T) => !f(lhs);\n}\n\n/**\n * If the condition contains any CorrelatedSubqueryConditions, returns a\n * transformed condition which contains no CorrelatedSubqueryCondition(s) but\n * which will filter a subset of the rows that would be filtered by the original\n * condition, or undefined if no such transformation exists.\n *\n * If the condition does not contain any CorrelatedSubqueryConditions\n * returns the condition unmodified and `conditionsRemoved: false`.\n */\nexport function transformFilters(filters: Condition | undefined): {\n  filters: NoSubqueryCondition | undefined;\n  conditionsRemoved: boolean;\n} {\n  if (!filters) {\n    return {filters: undefined, conditionsRemoved: false};\n  }\n  switch (filters.type) {\n    case 'simple':\n      return {filters, conditionsRemoved: false};\n    case 'correlatedSubquery':\n      return {filters: undefined, conditionsRemoved: true};\n    case 'and':\n    case 'or': {\n      const transformedConditions: NoSubqueryCondition[] = [];\n      let conditionsRemoved = false;\n      for (const cond of filters.conditions) {\n        const transformed = transformFilters(cond);\n        // If any branch of the OR ends up empty, the entire OR needs\n        // to be removed.\n        if (transformed.filters === undefined && filters.type === 'or') {\n          return {filters: undefined, conditionsRemoved: true};\n        }\n        conditionsRemoved = conditionsRemoved || transformed.conditionsRemoved;\n        if (transformed.filters) {\n          transformedConditions.push(transformed.filters);\n        }\n      }\n      return {\n        filters: simplifyCondition({\n          type: filters.type,\n          conditions: transformedConditions,\n        }) as NoSubqueryCondition,\n        conditionsRemoved,\n      };\n    }\n    default:\n      unreachable(filters);\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport type {JSONValue} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {\n  AST,\n  ColumnReference,\n  CompoundKey,\n  Condition,\n  Conjunction,\n  CorrelatedSubquery,\n  CorrelatedSubqueryCondition,\n  Disjunction,\n  LiteralValue,\n  Ordering,\n  Parameter,\n  SimpleCondition,\n  ValuePosition,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport {Exists} from '../ivm/exists.ts';\nimport {FanIn} from '../ivm/fan-in.ts';\nimport {FanOut} from '../ivm/fan-out.ts';\nimport {\n  buildFilterPipeline,\n  type FilterInput,\n} from '../ivm/filter-operators.ts';\nimport {Filter} from '../ivm/filter.ts';\nimport {Join} from '../ivm/join.ts';\nimport type {Input, InputBase, Storage} from '../ivm/operator.ts';\nimport {Skip} from '../ivm/skip.ts';\nimport type {Source, SourceInput} from '../ivm/source.ts';\nimport {Take} from '../ivm/take.ts';\nimport type {DebugDelegate} from './debug-delegate.ts';\nimport {createPredicate, type NoSubqueryCondition} from './filter.ts';\n\nexport type StaticQueryParameters = {\n  authData: Record<string, JSONValue>;\n  preMutationRow?: Row | undefined;\n};\n\n/**\n * Interface required of caller to buildPipeline. Connects to constructed\n * pipeline to delegate environment to provide sources and storage.\n */\nexport interface BuilderDelegate {\n  readonly applyFiltersAnyway?: boolean | undefined;\n  readonly debug?: DebugDelegate | undefined;\n\n  /**\n   * Called once for each source needed by the AST.\n   * Might be called multiple times with same tableName. It is OK to return\n   * same storage instance in that case.\n   */\n  getSource(tableName: string): Source | undefined;\n\n  /**\n   * Called once for each operator that requires storage. Should return a new\n   * unique storage object for each call.\n   */\n  createStorage(name: string): Storage;\n\n  decorateInput(input: Input, name: string): Input;\n\n  addEdge(source: InputBase, dest: InputBase): void;\n\n  decorateFilterInput(input: FilterInput, name: string): FilterInput;\n\n  decorateSourceInput(input: SourceInput, queryID: string): Input;\n\n  /**\n   * The AST is mapped on-the-wire between client and server names.\n   *\n   * There is no \"wire\" for zqlite tests so this function is provided\n   * to allow tests to remap the AST.\n   */\n  mapAst?: ((ast: AST) => AST) | undefined;\n}\n\n/**\n * Builds a pipeline from an AST. Caller must provide a delegate to create source\n * and storage interfaces as necessary.\n *\n * Usage:\n *\n * ```ts\n * class MySink implements Output {\n *   readonly #input: Input;\n *\n *   constructor(input: Input) {\n *     this.#input = input;\n *     input.setOutput(this);\n *   }\n *\n *   push(change: Change, _: Operator) {\n *     console.log(change);\n *   }\n * }\n *\n * const input = buildPipeline(ast, myDelegate, hash(ast));\n * const sink = new MySink(input);\n * ```\n */\nexport function buildPipeline(\n  ast: AST,\n  delegate: BuilderDelegate,\n  queryID: string,\n): Input {\n  return buildPipelineInternal(\n    delegate.mapAst ? delegate.mapAst(ast) : ast,\n    delegate,\n    queryID,\n    '',\n  );\n}\n\nexport function bindStaticParameters(\n  ast: AST,\n  staticQueryParameters: StaticQueryParameters | undefined,\n) {\n  const visit = (node: AST): AST => ({\n    ...node,\n    where: node.where ? bindCondition(node.where) : undefined,\n    related: node.related?.map(sq => ({\n      ...sq,\n      subquery: visit(sq.subquery),\n    })),\n  });\n\n  function bindCondition(condition: Condition): Condition {\n    if (condition.type === 'simple') {\n      return {\n        ...condition,\n        left: bindValue(condition.left),\n        right: bindValue(condition.right) as Exclude<\n          ValuePosition,\n          ColumnReference\n        >,\n      };\n    }\n    if (condition.type === 'correlatedSubquery') {\n      return {\n        ...condition,\n        related: {\n          ...condition.related,\n          subquery: visit(condition.related.subquery),\n        },\n      };\n    }\n    return {\n      ...condition,\n      conditions: condition.conditions.map(bindCondition),\n    };\n  }\n\n  const bindValue = (value: ValuePosition): ValuePosition => {\n    if (isParameter(value)) {\n      const anchor = must(\n        staticQueryParameters,\n        'Static query params do not exist',\n      )[value.anchor];\n      const resolvedValue = resolveField(anchor, value.field);\n      return {\n        type: 'literal',\n        value: resolvedValue as LiteralValue,\n      };\n    }\n    return value;\n  };\n\n  return visit(ast);\n}\n\nfunction resolveField(\n  anchor: Record<string, JSONValue> | Row | undefined,\n  field: string | string[],\n): unknown {\n  if (anchor === undefined) {\n    return null;\n  }\n\n  if (Array.isArray(field)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return field.reduce((acc, f) => (acc as any)?.[f], anchor) ?? null;\n  }\n\n  return anchor[field] ?? null;\n}\n\nfunction isParameter(value: ValuePosition): value is Parameter {\n  return value.type === 'static';\n}\n\nfunction buildPipelineInternal(\n  ast: AST,\n  delegate: BuilderDelegate,\n  queryID: string,\n  name: string,\n  partitionKey?: CompoundKey | undefined,\n): Input {\n  const source = delegate.getSource(ast.table);\n  if (!source) {\n    throw new Error(`Source not found: ${ast.table}`);\n  }\n  ast = uniquifyCorrelatedSubqueryConditionAliases(ast);\n\n  const csqsFromCondition = gatherCorrelatedSubqueryQueriesFromCondition(\n    ast.where,\n  );\n  const splitEditKeys: Set<string> = partitionKey\n    ? new Set(partitionKey)\n    : new Set();\n  const aliases = new Set<string>();\n  for (const csq of csqsFromCondition) {\n    aliases.add(csq.subquery.alias || '');\n    for (const key of csq.correlation.parentField) {\n      splitEditKeys.add(key);\n    }\n  }\n  if (ast.related) {\n    for (const csq of ast.related) {\n      for (const key of csq.correlation.parentField) {\n        splitEditKeys.add(key);\n      }\n    }\n  }\n  const conn = source.connect(\n    must(ast.orderBy),\n    ast.where,\n    splitEditKeys,\n    delegate.debug,\n  );\n\n  let end: Input = delegate.decorateSourceInput(conn, queryID);\n  end = delegate.decorateInput(end, `${name}:source(${ast.table})`);\n  const {fullyAppliedFilters} = conn;\n\n  if (ast.start) {\n    const skip = new Skip(end, ast.start);\n    delegate.addEdge(end, skip);\n    end = delegate.decorateInput(skip, `${name}:skip)`);\n  }\n\n  for (const csq of csqsFromCondition) {\n    end = applyCorrelatedSubQuery(csq, delegate, queryID, end, name, true);\n  }\n\n  if (ast.where && (!fullyAppliedFilters || delegate.applyFiltersAnyway)) {\n    end = applyWhere(end, ast.where, delegate, name);\n  }\n\n  if (ast.limit !== undefined) {\n    const takeName = `${name}:take`;\n    const take = new Take(\n      end,\n      delegate.createStorage(takeName),\n      ast.limit,\n      partitionKey,\n    );\n    delegate.addEdge(end, take);\n    end = delegate.decorateInput(take, takeName);\n  }\n\n  if (ast.related) {\n    for (const csq of ast.related) {\n      end = applyCorrelatedSubQuery(csq, delegate, queryID, end, name, false);\n    }\n  }\n\n  return end;\n}\n\nfunction applyWhere(\n  input: Input,\n  condition: Condition,\n  delegate: BuilderDelegate,\n  name: string,\n): Input {\n  return buildFilterPipeline(input, delegate, filterInput =>\n    applyFilter(filterInput, condition, delegate, name),\n  );\n}\n\nfunction applyFilter(\n  input: FilterInput,\n  condition: Condition,\n  delegate: BuilderDelegate,\n  name: string,\n) {\n  switch (condition.type) {\n    case 'and':\n      return applyAnd(input, condition, delegate, name);\n    case 'or':\n      return applyOr(input, condition, delegate, name);\n    case 'correlatedSubquery':\n      return applyCorrelatedSubqueryCondition(input, condition, delegate, name);\n    case 'simple':\n      return applySimpleCondition(input, delegate, condition);\n  }\n}\n\nfunction applyAnd(\n  input: FilterInput,\n  condition: Conjunction,\n  delegate: BuilderDelegate,\n  name: string,\n): FilterInput {\n  for (const subCondition of condition.conditions) {\n    input = applyFilter(input, subCondition, delegate, name);\n  }\n  return input;\n}\n\nexport function applyOr(\n  input: FilterInput,\n  condition: Disjunction,\n  delegate: BuilderDelegate,\n  name: string,\n): FilterInput {\n  const [subqueryConditions, otherConditions] =\n    groupSubqueryConditions(condition);\n  // if there are no subquery conditions, no fan-in / fan-out is needed\n  if (subqueryConditions.length === 0) {\n    const filter = new Filter(\n      input,\n      createPredicate({\n        type: 'or',\n        conditions: otherConditions,\n      }),\n    );\n    delegate.addEdge(input, filter);\n    return filter;\n  }\n\n  const fanOut = new FanOut(input);\n  delegate.addEdge(input, fanOut);\n  const branches = subqueryConditions.map(subCondition =>\n    applyFilter(fanOut, subCondition, delegate, name),\n  );\n  if (otherConditions.length > 0) {\n    const filter = new Filter(\n      fanOut,\n      createPredicate({\n        type: 'or',\n        conditions: otherConditions,\n      }),\n    );\n    delegate.addEdge(fanOut, filter);\n    branches.push(filter);\n  }\n  const ret = new FanIn(fanOut, branches);\n  for (const branch of branches) {\n    delegate.addEdge(branch, ret);\n  }\n  fanOut.setFanIn(ret);\n  return ret;\n}\n\nexport function groupSubqueryConditions(condition: Disjunction) {\n  const partitioned: [\n    subqueryConditions: Condition[],\n    otherConditions: NoSubqueryCondition[],\n  ] = [[], []];\n  for (const subCondition of condition.conditions) {\n    if (isNotAndDoesNotContainSubquery(subCondition)) {\n      partitioned[1].push(subCondition);\n    } else {\n      partitioned[0].push(subCondition);\n    }\n  }\n  return partitioned;\n}\n\nexport function isNotAndDoesNotContainSubquery(\n  condition: Condition,\n): condition is NoSubqueryCondition {\n  if (condition.type === 'correlatedSubquery') {\n    return false;\n  }\n  if (condition.type === 'simple') {\n    return true;\n  }\n  return condition.conditions.every(isNotAndDoesNotContainSubquery);\n}\n\nfunction applySimpleCondition(\n  input: FilterInput,\n  delegate: BuilderDelegate,\n  condition: SimpleCondition,\n): FilterInput {\n  const filter = new Filter(input, createPredicate(condition));\n  delegate.decorateFilterInput(\n    filter,\n    `${valuePosName(condition.left)}:${condition.op}:${valuePosName(condition.right)}`,\n  );\n  delegate.addEdge(input, filter);\n  return filter;\n}\n\nfunction valuePosName(left: ValuePosition) {\n  switch (left.type) {\n    case 'static':\n      return left.field;\n    case 'literal':\n      return left.value;\n    case 'column':\n      return left.name;\n  }\n}\n\nfunction applyCorrelatedSubQuery(\n  sq: CorrelatedSubquery,\n  delegate: BuilderDelegate,\n  queryID: string,\n  end: Input,\n  name: string,\n  fromCondition: boolean,\n) {\n  // TODO: we only omit the join if the CSQ if from a condition since\n  // we want to create an empty array for `related` fields that are `limit(0)`\n  if (sq.subquery.limit === 0 && fromCondition) {\n    return end;\n  }\n\n  assert(sq.subquery.alias, 'Subquery must have an alias');\n  const child = buildPipelineInternal(\n    sq.subquery,\n    delegate,\n    queryID,\n    `${name}.${sq.subquery.alias}`,\n    sq.correlation.childField,\n  );\n  const joinName = `${name}:join(${sq.subquery.alias})`;\n  const join = new Join({\n    parent: end,\n    child,\n    storage: delegate.createStorage(joinName),\n    parentKey: sq.correlation.parentField,\n    childKey: sq.correlation.childField,\n    relationshipName: sq.subquery.alias,\n    hidden: sq.hidden ?? false,\n    system: sq.system ?? 'client',\n  });\n  delegate.addEdge(end, join);\n  delegate.addEdge(child, join);\n  return delegate.decorateInput(join, joinName);\n}\n\nfunction applyCorrelatedSubqueryCondition(\n  input: FilterInput,\n  condition: CorrelatedSubqueryCondition,\n  delegate: BuilderDelegate,\n  name: string,\n): FilterInput {\n  assert(condition.op === 'EXISTS' || condition.op === 'NOT EXISTS');\n  if (condition.related.subquery.limit === 0) {\n    if (condition.op === 'EXISTS') {\n      const filter = new Filter(input, () => false);\n      delegate.addEdge(input, filter);\n      return filter;\n    }\n    const filter = new Filter(input, () => true);\n    delegate.addEdge(input, filter);\n    return filter;\n  }\n  const existsName = `${name}:exists(${condition.related.subquery.alias})`;\n  const exists = new Exists(\n    input,\n    delegate.createStorage(existsName),\n    must(condition.related.subquery.alias),\n    condition.related.correlation.parentField,\n    condition.op,\n  );\n  delegate.addEdge(input, exists);\n  return delegate.decorateFilterInput(exists, existsName);\n}\n\nfunction gatherCorrelatedSubqueryQueriesFromCondition(\n  condition: Condition | undefined,\n) {\n  const csqs: CorrelatedSubquery[] = [];\n  const gather = (condition: Condition) => {\n    if (condition.type === 'correlatedSubquery') {\n      assert(condition.op === 'EXISTS' || condition.op === 'NOT EXISTS');\n      csqs.push({\n        ...condition.related,\n        subquery: {\n          ...condition.related.subquery,\n          limit:\n            condition.related.system === 'permissions'\n              ? PERMISSIONS_EXISTS_LIMIT\n              : EXISTS_LIMIT,\n        },\n      });\n      return;\n    }\n    if (condition.type === 'and' || condition.type === 'or') {\n      for (const c of condition.conditions) {\n        gather(c);\n      }\n      return;\n    }\n  };\n  if (condition) {\n    gather(condition);\n  }\n  return csqs;\n}\n\nconst EXISTS_LIMIT = 3;\nconst PERMISSIONS_EXISTS_LIMIT = 1;\n\nexport function assertOrderingIncludesPK(\n  ordering: Ordering,\n  pk: PrimaryKey,\n): void {\n  const orderingFields = ordering.map(([field]) => field);\n  const missingFields = pk.filter(pkField => !orderingFields.includes(pkField));\n\n  if (missingFields.length > 0) {\n    throw new Error(\n      `Ordering must include all primary key fields. Missing: ${missingFields.join(\n        ', ',\n      )}. ZQL automatically appends primary key fields to the ordering if they are missing \n      so a common cause of this error is a casing mismatch between Postgres and ZQL.\n      E.g., \"userid\" vs \"userID\".\n      You may want to add double-quotes around your Postgres column names to prevent Postgres from lower-casing them:\n      https://www.postgresql.org/docs/current/sql-syntax-lexical.htm`,\n    );\n  }\n}\n\nfunction uniquifyCorrelatedSubqueryConditionAliases(ast: AST): AST {\n  if (!ast.where) {\n    return ast;\n  }\n  const {where} = ast;\n  if (where.type !== 'and' && where.type !== 'or') {\n    return ast;\n  }\n\n  let count = 0;\n  const uniquifyCorrelatedSubquery = (csqc: CorrelatedSubqueryCondition) => ({\n    ...csqc,\n    related: {\n      ...csqc.related,\n      subquery: {\n        ...csqc.related.subquery,\n        alias: (csqc.related.subquery.alias ?? '') + '_' + count++,\n      },\n    },\n  });\n\n  const uniquify = (cond: Condition): Condition => {\n    if (cond.type === 'simple') {\n      return cond;\n    } else if (cond.type === 'correlatedSubquery') {\n      return uniquifyCorrelatedSubquery(cond);\n    }\n    const conditions = [];\n    for (const c of cond.conditions) {\n      conditions.push(uniquify(c));\n    }\n    return {\n      type: cond.type,\n      conditions,\n    };\n  };\n\n  const result = {\n    ...ast,\n    where: uniquify(where),\n  };\n  return result;\n}\n","export class NotImplementedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NotImplementedError';\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport type {Immutable} from '../../../shared/src/immutable.ts';\nimport type {TTL} from '../query/ttl.ts';\nimport type {Listener, TypedView} from '../query/typed-view.ts';\nimport type {Change} from './change.ts';\nimport type {Input, Output} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport {applyChange} from './view-apply-change.ts';\nimport type {Entry, Format, View} from './view.ts';\n\n/**\n * Implements a materialized view of the output of an operator.\n *\n * It might seem more efficient to use an immutable b-tree for the\n * materialization, but it's not so clear. Inserts in the middle are\n * asymptotically slower in an array, but can often be done with zero\n * allocations, where changes to the b-tree will often require several allocs.\n *\n * Also the plain array view is more convenient for consumers since you can dump\n * it into console to see what it is, rather than having to iterate it.\n */\nexport class ArrayView<V extends View> implements Output, TypedView<V> {\n  readonly #input: Input;\n  readonly #listeners = new Set<Listener<V>>();\n  readonly #schema: SourceSchema;\n  readonly #format: Format;\n\n  // Synthetic \"root\" entry that has a single \"\" relationship, so that we can\n  // treat all changes, including the root change, generically.\n  readonly #root: Entry;\n\n  onDestroy: (() => void) | undefined;\n\n  #dirty = false;\n  #complete = false;\n  readonly #updateTTL: (ttl: TTL) => void;\n\n  constructor(\n    input: Input,\n    format: Format,\n    queryComplete: true | Promise<true>,\n    updateTTL: (ttl: TTL) => void,\n  ) {\n    this.#input = input;\n    this.#schema = input.getSchema();\n    this.#format = format;\n    this.#updateTTL = updateTTL;\n    this.#root = {'': format.singular ? undefined : []};\n    input.setOutput(this);\n\n    if (queryComplete === true) {\n      this.#complete = true;\n    } else {\n      void queryComplete.then(() => {\n        this.#complete = true;\n        this.#fireListeners();\n      });\n    }\n    this.#hydrate();\n  }\n\n  get data() {\n    return this.#root[''] as V;\n  }\n\n  addListener(listener: Listener<V>) {\n    assert(!this.#listeners.has(listener), 'Listener already registered');\n    this.#listeners.add(listener);\n\n    this.#fireListener(listener);\n\n    return () => {\n      this.#listeners.delete(listener);\n    };\n  }\n\n  #fireListeners() {\n    for (const listener of this.#listeners) {\n      this.#fireListener(listener);\n    }\n  }\n\n  #fireListener(listener: Listener<V>) {\n    listener(\n      this.data as Immutable<V>,\n      this.#complete ? 'complete' : 'unknown',\n    );\n  }\n\n  destroy() {\n    this.onDestroy?.();\n  }\n\n  #hydrate() {\n    this.#dirty = true;\n    for (const node of this.#input.fetch({})) {\n      applyChange(\n        this.#root,\n        {type: 'add', node},\n        this.#schema,\n        '',\n        this.#format,\n      );\n    }\n    this.flush();\n  }\n\n  push(change: Change): void {\n    this.#dirty = true;\n    applyChange(this.#root, change, this.#schema, '', this.#format);\n  }\n\n  flush() {\n    if (!this.#dirty) {\n      return;\n    }\n    this.#dirty = false;\n    this.#fireListeners();\n  }\n\n  updateTTL(ttl: TTL) {\n    this.#updateTTL(ttl);\n  }\n}\n","import {unreachable} from '../../../shared/src/asserts.ts';\nimport type {Condition} from '../../../zero-protocol/src/ast.ts';\n\n/**\n * Checks if a condition contains any NOT EXISTS operations.\n *\n * The client-side query engine cannot support NOT EXISTS operations because:\n *\n * 1. Zero only syncs a subset of data to the client, defined by the queries you use\n * 2. On the client, we can't distinguish between a row not existing at all vs.\n *    a row not being synced to the client\n * 3. For NOT EXISTS to work correctly, we would need complete knowledge of what\n *    doesn't exist, which is not reasonable with the partial sync model\n *\n * @param condition The condition to check\n * @throws Error if the condition uses NOT EXISTS operator\n */\nexport function assertNoNotExists(condition: Condition): void {\n  switch (condition.type) {\n    case 'simple':\n      // Simple conditions don't use EXISTS/NOT EXISTS\n      return;\n\n    case 'correlatedSubquery':\n      if (condition.op === 'NOT EXISTS') {\n        throw new Error(\n          'not(exists()) is not supported on the client - see https://bugs.rocicorp.dev/issue/3438',\n        );\n      }\n      // Check if the subquery has a where condition\n      if (condition.related.subquery.where) {\n        assertNoNotExists(condition.related.subquery.where);\n      }\n      return;\n\n    case 'and':\n    case 'or':\n      for (const c of condition.conditions) {\n        assertNoNotExists(c);\n      }\n      return;\n    default:\n      unreachable(condition);\n  }\n}\n"],"names":["assert","v","path","toDisplay","err","atPath","hash","hash","v","assert","assert","hash","v","path","hash","binarySearch","v","getSizeOfEntry","hash","binarySearch","array","entries","getSizeOfEntry","splice","hash","binarySearch","diff","v","hash","v","v","createChunk","value","hash","v","value","entries","hash","createChunk","chunk","diff","valueHash","assert","hash","valueHash","indexRecords","v","v","compareUTF8","compareUTF8","v","node","relationship","binarySearch","v","v","compareUTF8","defined","table","val","compareUTF8","c","array","hash","hash","z1","z2","hash","v","change","key","cmp","cmp","flattened","array","impl","not","take","filter","condition","v","cleanup"],"mappings":"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","debugId":null}},
    {"offset": {"line": 8707, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Blogger%405.4.0/node_modules/%40rocicorp/logger/out/logger.js"],"sourcesContent":["/**\n * A [[LogSink]] implementation that logs to multiple sinks.\n */\nexport class TeeLogSink {\n    #sinks;\n    constructor(sinks) {\n        this.#sinks = sinks;\n    }\n    log(level, context, ...args) {\n        for (const logger of this.#sinks) {\n            logger.log(level, context, ...args);\n        }\n    }\n    async flush() {\n        await Promise.all(this.#sinks.map(logger => logger.flush?.()));\n    }\n}\nexport class OptionalLoggerImpl {\n    debug = undefined;\n    info = undefined;\n    warn = undefined;\n    error = undefined;\n    flush;\n    constructor(logSink, level = 'info', context) {\n        const impl = (level) => (...args) => logSink.log(level, context, ...args);\n        /* eslint-disable no-fallthrough , @typescript-eslint/ban-ts-comment */\n        switch (level) {\n            // @ts-ignore\n            case 'debug':\n                this.debug = impl('debug');\n            // @ts-ignore\n            case 'info':\n                this.info = impl('info');\n            // @ts-ignore\n            case 'warn':\n                this.warn = impl('warn');\n            // @ts-ignore\n            case 'error':\n                this.error = impl('error');\n        }\n        /* eslint-enable @typescript-eslint/ban-ts-comment, no-fallthrough */\n        this.flush = () => logSink.flush?.() ?? Promise.resolve();\n    }\n}\n/**\n * Create a logger that will log to the console.\n */\nexport class ConsoleLogger extends OptionalLoggerImpl {\n    constructor(level, context) {\n        super(consoleLogSink, level, context);\n    }\n}\n/**\n * An implementation of [[LogSink]] that logs using `console.log` etc\n */\nexport const consoleLogSink = {\n    log(level, context, ...args) {\n        console[level](...stringified(context), ...args.map(normalizeArgument));\n    },\n};\n/**\n * A console logger that enables the caller to format log lines.\n */\nexport class FormatLogger {\n    #format;\n    constructor(format) {\n        this.#format = format;\n    }\n    log(level, context, ...args) {\n        console[level](...this.#format(level, ...stringified(context), ...args));\n    }\n}\n/**\n * A console logger that prefixes log lines with a log level.\n */\nexport const nodeConsoleLogSink = {\n    log(level, context, ...args) {\n        console[level](logLevelPrefix[level], ...stringified(context), ...args.map(normalizeArgument));\n    },\n};\n/**\n * Log line level prefixes, used by the node logger. They are uniform length\n * to make visual parsing of a log file easier.\n */\nexport const logLevelPrefix = {\n    error: 'ERR',\n    warn: 'WRN',\n    info: 'INF',\n    debug: 'DBG',\n};\n/**\n * A logger that logs nothing.\n */\nexport class SilentLogger {\n}\n/**\n * The LogContext facilitates constructing and adding to the\n * Context passed to the LogSink.\n *\n * Typical usage is something like:\n *\n *   const lc = new LogContext('debug');\n *   lc.debug?.('hello');\n *   const lc2 = lc.withContext('foo');\n *   f(lc2);  // logging inside f will contain 'foo' in the Context.\n */\nexport class LogContext extends OptionalLoggerImpl {\n    #logSink;\n    #level;\n    #context;\n    constructor(level = 'info', context, logSink = consoleLogSink) {\n        super(logSink, level, context);\n        this.#level = level;\n        this.#logSink = logSink;\n        this.#context = context;\n    }\n    /**\n     * Creates a new Logger that with the given key and value\n     * added to the logged Context.\n     */\n    withContext(key, value) {\n        const ctx = { ...this.#context, [key]: value };\n        return new LogContext(this.#level, ctx, this.#logSink);\n    }\n}\nfunction stringified(context) {\n    const args = [];\n    for (const [k, v] of Object.entries(context ?? {})) {\n        const arg = v === undefined ? k : `${k}=${v}`;\n        args.push(arg);\n    }\n    return args;\n}\nfunction normalizeArgument(v) {\n    switch (typeof v) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n        case 'undefined':\n        case 'symbol':\n        case 'bigint':\n            return v;\n        case 'object':\n            if (v === null) {\n                return null;\n            }\n            break;\n    }\n    return JSON.stringify(v, errorReplacer);\n}\nfunction errorReplacer(_key, v) {\n    if (v instanceof Error) {\n        return {\n            name: v.name,\n            message: v.message,\n            stack: v.stack,\n            ...('cause' in v ? { cause: v.cause } : null),\n        };\n    }\n    return v;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8863, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/call-default-fetch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/error-responses.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/http-request-info.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/patch-operation.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/get-default-puller.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/idb-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/browser-env.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/write-impl-base.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/make-idb-name.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/abort-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/sleep.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/bg-interval.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/gc.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/key.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/store-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/deleted-clients.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/navigator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/mem-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/read-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/write-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/kv/idb-store-with-mem-fallback.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/get-kv-store-provider.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/log-options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/idb-databases-store-db-name.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/idb-databases-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/collect-idb-databases.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/transaction-closed-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/custom-queries.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/error-kind-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/builder/table-builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/client-schema.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/builder/schema-builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/update-needed-reason-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/replicache-impl.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/document-visible.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/connection-loop-delegates.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/connection-loop.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/lazy-store.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/transactions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/scan-iterator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/scan-options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/db/rebase.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/get-default-pusher.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/http-status-unauthorized.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/report-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/to-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/handle-pull-response-result-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/pull-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/sync-head-name.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/pull.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/pusher.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/push.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/mutation-recovery.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/broadcast-channel.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/new-client-channel.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/on-persist-channel.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/pending-mutations.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/client-gc.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/client-group-gc.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/heartbeat.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/dag/visitor.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/gather-mem-only-visitor.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/persist.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/gather-not-cached-visitor.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/persist/refresh.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/process-scheduler.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/request-idle.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/set-interval-with-signal.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/subscriptions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/invoke-kind-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/sync/request-id.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/replicache/src/version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/subscribable.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/delete-clients.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/queries-patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/connect.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/mutation-type-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/push.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/mutations-patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/row-patch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/poke.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/pong.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/pull.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/down.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-protocol/src/protocol-version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/name-mapper.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/mutate/custom.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/metrics-delegate.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/util/socket.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/active-clients-manager.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/connection-state-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/memory-storage.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/btree-set.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/measure-push-operator.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/constraint.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/ivm/memory-source.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/ivm-branch.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/context.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/crud.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/sentinels.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/custom.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/delete-clients-manager.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/enable-analytics.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/http-string.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/log-options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/datadog/src/datadog-log-sink.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/version.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/metric-name-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/metrics.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/mutation-tracker.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/ping-result-enum.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/query-manager.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/options.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/reload-error-handler.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/server-error.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/server-option.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero-log-context.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero-poke-handler.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-client/src/client/zero-rep.ts"],"sourcesContent":["import type {HTTPRequestInfo} from './http-request-info.ts';\n\n/**\n * Helper function for {@link getDefaultPuller} and {@link getDefaultPusher}.\n */\nexport async function callDefaultFetch<Body>(\n  url: string,\n  auth: string,\n  requestID: string,\n  requestBody: Body,\n): Promise<readonly [Response | undefined, HTTPRequestInfo]> {\n  const init = {\n    headers: {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'Content-type': 'application/json',\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'Authorization': auth,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      'X-Replicache-RequestID': requestID,\n    },\n    body: JSON.stringify(requestBody),\n    method: 'POST',\n  };\n  const request = new Request(url, init);\n  const response = await fetch(request);\n  const httpStatusCode = response.status;\n  if (httpStatusCode !== 200) {\n    return [\n      undefined,\n      {\n        httpStatusCode,\n        errorMessage: await response.text(),\n      },\n    ];\n  }\n  return [\n    response,\n    {\n      httpStatusCode,\n      errorMessage: '',\n    },\n  ];\n}\n","import {assert} from '../../shared/src/asserts.ts';\n\nfunction isError(obj: unknown, type: string): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    (obj as {error: unknown}).error === type\n  );\n}\n\ntype ErrorResponse = {error: string};\n\nexport function isErrorResponse(obj: object): obj is ErrorResponse {\n  return typeof (obj as {error: unknown}).error === 'string';\n}\n\n/**\n * In certain scenarios the server can signal that it does not know about the\n * client. For example, the server might have lost all of its state (this might\n * happen during the development of the server).\n */\nexport type ClientStateNotFoundResponse = {\n  error: 'ClientStateNotFound';\n};\n\nexport function isClientStateNotFoundResponse(\n  v: unknown,\n): v is ClientStateNotFoundResponse {\n  return isError(v, 'ClientStateNotFound');\n}\n\n/**\n * The server endpoint may respond with a `VersionNotSupported` error if it does\n * not know how to handle the pull, push or schema version.\n */\nexport type VersionNotSupportedResponse = {\n  error: 'VersionNotSupported';\n  versionType?: 'pull' | 'push' | 'schema' | undefined;\n};\n\nexport function isVersionNotSupportedResponse(\n  v: unknown,\n): v is VersionNotSupportedResponse {\n  if (!isError(v, 'VersionNotSupported')) {\n    return false;\n  }\n\n  const {versionType} = v as Record<string, unknown>;\n  switch (versionType) {\n    case undefined:\n    case 'pull':\n    case 'push':\n    case 'schema':\n      return true;\n  }\n\n  return false;\n}\n\nexport function assertVersionNotSupportedResponse(\n  v: unknown,\n): asserts v is VersionNotSupportedResponse {\n  assert(isVersionNotSupportedResponse(v));\n}\n","import {\n  assertNumber,\n  assertObject,\n  assertString,\n} from '../../shared/src/asserts.ts';\n\nexport function assertHTTPRequestInfo(\n  v: unknown,\n): asserts v is HTTPRequestInfo {\n  assertObject(v);\n  assertNumber(v.httpStatusCode);\n  assertString(v.errorMessage);\n}\n\nexport type HTTPRequestInfo = {\n  httpStatusCode: number;\n  errorMessage: string;\n};\n","import {\n  assertArray,\n  assertObject,\n  assertString,\n} from '../../shared/src/asserts.ts';\nimport {\n  type ReadonlyJSONObject,\n  type ReadonlyJSONValue,\n  assertJSONObject,\n  assertJSONValue,\n} from '../../shared/src/json.ts';\n\nexport type PatchOperationInternal =\n  | {\n      readonly op: 'put';\n      readonly key: string;\n      readonly value: ReadonlyJSONValue;\n    }\n  | {\n      readonly op: 'update';\n      readonly key: string;\n      readonly merge?: ReadonlyJSONObject | undefined;\n      readonly constrain?: readonly string[] | undefined;\n    }\n  | {\n      readonly op: 'del';\n      readonly key: string;\n    }\n  | {\n      readonly op: 'clear';\n    };\n\n/**\n * This type describes the patch field in a {@link PullResponse} and it is used\n * to describe how to update the Replicache key-value store.\n */\nexport type PatchOperation =\n  | {\n      readonly op: 'put';\n      readonly key: string;\n      readonly value: ReadonlyJSONValue;\n    }\n  | {\n      readonly op: 'del';\n      readonly key: string;\n    }\n  | {\n      readonly op: 'clear';\n    };\n\nexport function assertPatchOperations(\n  p: unknown,\n): asserts p is PatchOperationInternal[] {\n  assertArray(p);\n  for (const item of p) {\n    assertPatchOperation(item);\n  }\n}\n\nfunction assertPatchOperation(p: unknown): asserts p is PatchOperationInternal {\n  assertObject(p);\n  switch (p.op) {\n    case 'put':\n      assertString(p.key);\n      assertJSONValue(p.value);\n      break;\n    case 'update':\n      assertString(p.key);\n      if (p.merge !== undefined) {\n        assertJSONObject(p.merge);\n      }\n      if (p.constrain !== undefined) {\n        assertArray(p.constrain);\n        for (const key of p.constrain) {\n          assertString(key);\n        }\n      }\n      break;\n    case 'del':\n      assertString(p.key);\n      break;\n    case 'clear':\n      break;\n    default:\n      throw new Error(\n        `unknown patch op \\`${p.op}\\`, expected one of \\`put\\`, \\`del\\`, \\`clear\\``,\n      );\n  }\n}\n","import {\n  assertNumber,\n  assertObject,\n  assertString,\n} from '../../shared/src/asserts.ts';\nimport {callDefaultFetch} from './call-default-fetch.ts';\nimport {assertCookie} from './cookies.ts';\nimport {\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n} from './error-responses.ts';\nimport {assertHTTPRequestInfo} from './http-request-info.ts';\nimport {assertPatchOperations} from './patch-operation.ts';\nimport type {\n  PullResponseV1,\n  Puller,\n  PullerResult,\n  PullerResultV1,\n} from './puller.ts';\nimport type {PullRequest} from './sync/pull.ts';\n\n/**\n * This creates a default puller which uses HTTP POST to send the pull request.\n */\nexport function getDefaultPuller(rep: {pullURL: string; auth: string}): Puller {\n  async function puller(\n    requestBody: PullRequest,\n    requestID: string,\n  ): Promise<PullerResult> {\n    const [response, httpRequestInfo] = await callDefaultFetch(\n      rep.pullURL,\n      rep.auth,\n      requestID,\n      requestBody,\n    );\n    if (!response) {\n      return {httpRequestInfo};\n    }\n\n    return {\n      response: await response.json(),\n      httpRequestInfo,\n    };\n  }\n\n  defaultPullers.add(puller);\n  return puller;\n}\n\nconst defaultPullers = new WeakSet();\n\nexport function isDefaultPuller(puller: Puller): boolean {\n  return defaultPullers.has(puller);\n}\n\nexport function assertPullResponseV1(v: unknown): asserts v is PullResponseV1 {\n  assertObject(v);\n  if (isClientStateNotFoundResponse(v) || isVersionNotSupportedResponse(v)) {\n    return;\n  }\n  const v2 = v as Record<string, unknown>;\n  if (v2.cookie !== undefined) {\n    assertCookie(v2.cookie);\n  }\n  assertLastMutationIDChanges(v2.lastMutationIDChanges);\n  assertPatchOperations(v2.patch);\n}\n\nfunction assertLastMutationIDChanges(\n  lastMutationIDChanges: unknown,\n): asserts lastMutationIDChanges is Record<string, number> {\n  assertObject(lastMutationIDChanges);\n  for (const [key, value] of Object.entries(lastMutationIDChanges)) {\n    assertString(key);\n    assertNumber(value);\n  }\n}\n\nexport function assertPullerResultV1(v: unknown): asserts v is PullerResultV1 {\n  assertObject(v);\n  assertHTTPRequestInfo(v.httpRequestInfo);\n  if (v.response !== undefined) {\n    assertPullResponseV1(v.response);\n  }\n}\n","import {resolver} from '@rocicorp/resolver';\nimport {assertNotNull} from '../../../shared/src/asserts.ts';\nimport {mustGetBrowserGlobal} from '../../../shared/src/browser-env.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport {\n  type FrozenJSONValue,\n  deepFreezeAllowUndefined,\n} from '../frozen-json.ts';\nimport type {Read, Store, Write} from './store.ts';\nimport {WriteImplBase, deleteSentinel} from './write-impl-base.ts';\n\nconst RELAXED = {durability: 'relaxed'} as const;\nconst OBJECT_STORE = 'chunks';\n\nexport class IDBStore implements Store {\n  #db: Promise<IDBDatabase>;\n  #closed = false;\n  #idbDeleted = false;\n\n  constructor(name: string) {\n    this.#db = openDatabase(name);\n  }\n\n  read(): Promise<Read> {\n    return this.#withReopen(readImpl);\n  }\n\n  write(): Promise<Write> {\n    return this.#withReopen(writeImpl);\n  }\n\n  async close(): Promise<void> {\n    if (!this.#idbDeleted) {\n      const db = await this.#db;\n      db.close();\n    }\n    this.#closed = true;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  async #withReopen<R>(fn: (db: IDBDatabase) => R): Promise<R> {\n    // Tries to reopen an IndexedDB, and rejects if the database needs\n    // upgrading (is missing for whatever reason).\n    const reopenExistingDB = async (name: string): Promise<IDBDatabase> => {\n      const {promise, resolve, reject} = resolver<IDBDatabase>();\n      const req = indexedDB.open(name);\n\n      req.onupgradeneeded = () => {\n        const tx = req.transaction;\n        assertNotNull(tx);\n        tx.abort();\n        this.#idbDeleted = true;\n        reject(\n          new IDBNotFoundError(\n            `Expected IndexedDB not found: ${name}. This likely means that the user deleted IndexedDB instances while the app was running. This is non-fatal. The app will continue running in memory until reload.`,\n          ),\n        );\n      };\n\n      req.onsuccess = () => resolve(req.result);\n      req.onerror = () => reject(req.error);\n\n      const db = await promise;\n      db.onversionchange = () => db.close();\n      return db;\n    };\n\n    // We abstract on `readImpl` to work around an issue in Safari. Safari does\n    // not allow any microtask between a transaction is created until it is\n    // first used. We used to use `await read()` here instead of `await\n    // this._db` but then there is a microtask between the creation of the\n    // transaction and the return of this function. By doing `await this._db`\n    // here we only await the db and no await is involved with the transaction.\n    // See https://github.com/jakearchibald/idb-keyval/commit/1af0a00b1a70a678d2f9cf5e74c55a22e57324c5#r55989916\n    const db = await this.#db;\n\n    try {\n      return fn(db);\n    } catch (e: unknown) {\n      if (!this.#closed && e instanceof DOMException) {\n        if (e.name === 'InvalidStateError') {\n          this.#db = reopenExistingDB(db.name);\n          const reopened = await this.#db;\n          return fn(reopened);\n        } else if (e.name === 'NotFoundError') {\n          // This edge-case can happen if the db has been deleted and the\n          // user/developer has DevTools open in certain browsers.\n          // See discussion at https://github.com/rocicorp/replicache-internal/pull/216\n          this.#idbDeleted = true;\n          mustGetBrowserGlobal('indexedDB').deleteDatabase(db.name);\n          throw new IDBNotFoundError(\n            `Expected IndexedDB ${db.name} missing object store. Deleting db. This is non-fatal, the app will continue working in memory until it is reloaded.`,\n          );\n        }\n      }\n      throw e;\n    }\n  }\n}\n\nclass ReadImpl implements Read {\n  readonly #tx: IDBTransaction;\n  #closed = false;\n\n  constructor(tx: IDBTransaction) {\n    this.#tx = tx;\n  }\n\n  has(key: string): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const req = objectStore(this.#tx).count(key);\n      req.onsuccess = () => resolve(req.result > 0);\n      req.onerror = () => reject(req.error);\n    });\n  }\n\n  get(key: string): Promise<FrozenJSONValue | undefined> {\n    return new Promise((resolve, reject) => {\n      const req = objectStore(this.#tx).get(key);\n      req.onsuccess = () => resolve(deepFreezeAllowUndefined(req.result));\n      req.onerror = () => reject(req.error);\n    });\n  }\n\n  release(): void {\n    this.#closed = true;\n    // Do nothing. We rely on IDB locking.\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n}\n\nclass WriteImpl extends WriteImplBase {\n  readonly #tx: IDBTransaction;\n  #closed = false;\n\n  constructor(tx: IDBTransaction) {\n    super(new ReadImpl(tx));\n    this.#tx = tx;\n  }\n\n  commit(): Promise<void> {\n    if (this._pending.size === 0) {\n      return promiseVoid;\n    }\n\n    return new Promise((resolve, reject) => {\n      const tx = this.#tx;\n      const store = objectStore(tx);\n      for (const [key, val] of this._pending) {\n        if (val === deleteSentinel) {\n          store.delete(key);\n        } else {\n          store.put(val, key);\n        }\n      }\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  release(): void {\n    // We rely on IDB locking so no need to do anything here.\n    this.#closed = true;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n}\n\nfunction writeImpl(db: IDBDatabase): Write {\n  const tx = db.transaction(OBJECT_STORE, 'readwrite', RELAXED);\n  return new WriteImpl(tx);\n}\n\nfunction readImpl(db: IDBDatabase): Read {\n  const tx = db.transaction(OBJECT_STORE, 'readonly');\n  return new ReadImpl(tx);\n}\n\nfunction objectStore(tx: IDBTransaction): IDBObjectStore {\n  return tx.objectStore(OBJECT_STORE);\n}\n\nfunction openDatabase(name: string): Promise<IDBDatabase> {\n  const idb = mustGetBrowserGlobal('indexedDB');\n  return new Promise((resolve, reject) => {\n    const req = idb.open(name);\n    req.onupgradeneeded = () => {\n      req.result.createObjectStore(OBJECT_STORE);\n    };\n    req.onsuccess = () => {\n      const db = req.result;\n      // Another tab/process wants to modify the db, so release it.\n      db.onversionchange = () => db.close();\n      resolve(db);\n    };\n    req.onerror = () => reject(req.error);\n  });\n}\n\n/**\n * This error is thrown when we detect that the IndexedDB has been removed. This\n * does not normally happen but can happen during development if the user has\n * DevTools open and deletes the IndexedDB from there.\n */\nexport class IDBNotFoundError extends Error {\n  name = 'IDBNotFoundError';\n}\n","// Helpers for some objects from the browser environment. These are wrapped in\n// functions because Replicache runs in environments that do not have these\n// objects (such as Web Workers, Deno etc).\n\ntype GlobalThis = typeof globalThis;\n\nconst overrides = new Map<keyof GlobalThis, GlobalThis[keyof GlobalThis]>();\n\nexport function overrideBrowserGlobal<T extends keyof GlobalThis>(\n  name: T,\n  value: GlobalThis[T],\n) {\n  overrides.set(name, value);\n}\n\nexport function clearBrowserOverrides() {\n  overrides.clear();\n}\n\nexport function getBrowserGlobal<T extends keyof GlobalThis>(\n  name: T,\n): GlobalThis[T] | undefined {\n  if (overrides.has(name)) {\n    return overrides.get(name);\n  }\n  return globalThis[name];\n}\n\n/**\n * Returns the global method with the given name, bound to the global object.\n * This is important because some methods (e.g. `requestAnimationFrame`) are not\n * bound to the global object by default.\n *\n * If you end up using {@linkcode getBrowserGlobal} instead in a case like this:\n *\n * ```js\n * this.#raf = getBrowserGlobal('requestAnimationFrame') ?? rafFallback;\n * ...\n * this.#raf(() => ...);\n * ```\n *\n * You will end up with `Uncaught TypeError: Illegal invocation` because `this`\n * is not bound to the global object\n */\nexport function getBrowserGlobalMethod<T extends keyof GlobalThis>(\n  name: T,\n): GlobalThis[T] | undefined {\n  return getBrowserGlobal(name)?.bind(globalThis);\n}\n\nexport function mustGetBrowserGlobal<T extends keyof GlobalThis>(\n  name: T,\n): GlobalThis[T] {\n  const r = getBrowserGlobal(name);\n  if (r === undefined) {\n    throw new Error(\n      `Unsupported JavaScript environment: Could not find ${name}.`,\n    );\n  }\n  return r;\n}\n","import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {\n  promiseFalse,\n  promiseTrue,\n  promiseVoid,\n} from '../../../shared/src/resolved-promises.ts';\nimport {\n  type FrozenJSONValue,\n  deepFreeze,\n  deepFreezeAllowUndefined,\n} from '../frozen-json.ts';\nimport type {Read} from './store.ts';\n\nexport const deleteSentinel = Symbol();\ntype DeleteSentinel = typeof deleteSentinel;\n\nexport class WriteImplBase {\n  protected readonly _pending: Map<string, FrozenJSONValue | DeleteSentinel> =\n    new Map();\n  readonly #read: Read;\n\n  constructor(read: Read) {\n    this.#read = read;\n  }\n\n  has(key: string): Promise<boolean> {\n    switch (this._pending.get(key)) {\n      case undefined:\n        return this.#read.has(key);\n      case deleteSentinel:\n        return promiseFalse;\n      default:\n        return promiseTrue;\n    }\n  }\n\n  async get(key: string): Promise<FrozenJSONValue | undefined> {\n    const v = this._pending.get(key);\n    switch (v) {\n      case deleteSentinel:\n        return undefined;\n      case undefined: {\n        const v = await this.#read.get(key);\n        return deepFreezeAllowUndefined(v);\n      }\n      default:\n        return v;\n    }\n  }\n\n  put(key: string, value: ReadonlyJSONValue): Promise<void> {\n    this._pending.set(key, deepFreeze(value));\n    return promiseVoid;\n  }\n\n  del(key: string): Promise<void> {\n    this._pending.set(key, deleteSentinel);\n    return promiseVoid;\n  }\n\n  release(): void {\n    this.#read.release();\n  }\n\n  get closed(): boolean {\n    return this.#read.closed;\n  }\n}\n","import * as FormatVersion from './format-version-enum.ts';\n\n/**\n * Returns the name of the IDB database that will be used for a particular Replicache instance.\n * @param name The name of the Replicache instance (i.e., the `name` field of `ReplicacheOptions`).\n * @param schemaVersion The schema version of the database (i.e., the `schemaVersion` field of `ReplicacheOptions`).\n * @returns\n */\n\nexport function makeIDBName(name: string, schemaVersion?: string): string {\n  return makeIDBNameInternal(name, schemaVersion, FormatVersion.Latest);\n}\n\nfunction makeIDBNameInternal(\n  name: string,\n  schemaVersion: string | undefined,\n  formatVersion: number,\n): string {\n  const n = `rep:${name}:${formatVersion}`;\n  return schemaVersion ? `${n}:${schemaVersion}` : n;\n}\n\nexport {makeIDBNameInternal as makeIDBNameForTesting};\n","export class AbortError extends Error {\n  name = 'AbortError';\n}\n","import {resolver} from '@rocicorp/resolver';\nimport {AbortError} from './abort-error.ts';\n\nconst promiseVoid = Promise.resolve();\nconst promiseNever = new Promise<void>(() => undefined);\n\n/**\n * Creates a promise that resolves after `ms` milliseconds. Note that if you\n * pass in `0` no `setTimeout` is used and the promise resolves immediately. In\n * other words no macro task is used in that case.\n *\n * Pass in an AbortSignal to clear the timeout.\n */\nexport function sleep(ms: number, signal?: AbortSignal): Promise<void> {\n  const newAbortError = () => new AbortError('Aborted');\n\n  if (signal?.aborted) {\n    return Promise.reject(newAbortError());\n  }\n\n  if (ms === 0) {\n    return promiseVoid;\n  }\n\n  return new Promise((resolve, reject) => {\n    let handleAbort: () => void;\n    if (signal) {\n      handleAbort = () => {\n        clearTimeout(id);\n        reject(newAbortError());\n      };\n      signal.addEventListener('abort', handleAbort, {once: true});\n    }\n\n    const id = setTimeout(() => {\n      resolve();\n      signal?.removeEventListener('abort', handleAbort);\n    }, ms);\n  });\n}\n\n/**\n * Returns a pair of promises. The first promise resolves after `ms` milliseconds\n * unless the AbortSignal is aborted. The second promise resolves when the AbortSignal\n * is aborted.\n */\nexport function sleepWithAbort(\n  ms: number,\n  signal: AbortSignal,\n): [ok: Promise<void>, aborted: Promise<void>] {\n  if (ms === 0) {\n    return [promiseVoid, promiseNever];\n  }\n\n  const {promise: abortedPromise, resolve: abortedResolve} = resolver<void>();\n\n  const sleepPromise = new Promise<void>(resolve => {\n    const handleAbort = () => {\n      clearTimeout(id);\n      abortedResolve();\n    };\n\n    const id = setTimeout(() => {\n      resolve();\n      signal.removeEventListener('abort', handleAbort);\n    }, ms);\n\n    signal.addEventListener('abort', handleAbort, {once: true});\n  });\n\n  return [sleepPromise, abortedPromise];\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {AbortError} from '../../shared/src/abort-error.ts';\nimport {sleep} from '../../shared/src/sleep.ts';\n\nexport function initBgIntervalProcess(\n  processName: string,\n  process: () => Promise<unknown>,\n  delayMs: () => number,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  void runBgIntervalProcess(processName, process, delayMs, lc, signal);\n}\n\nasync function runBgIntervalProcess(\n  processName: string,\n  process: () => Promise<unknown>,\n  delayMs: () => number,\n  lc: LogContext,\n  signal: AbortSignal,\n): Promise<void> {\n  if (signal.aborted) {\n    return;\n  }\n  lc = lc.withContext('bgIntervalProcess', processName);\n  lc.debug?.('Starting');\n  while (!signal.aborted) {\n    try {\n      await sleep(delayMs(), signal);\n    } catch (e) {\n      if (!(e instanceof AbortError)) {\n        throw e;\n      }\n    }\n    if (!signal.aborted) {\n      lc.debug?.('Running');\n      try {\n        await process();\n      } catch (e) {\n        if (signal.aborted) {\n          lc.debug?.('Error running most likely due to close.', e);\n        } else {\n          lc.error?.('Error running.', e);\n        }\n      }\n    }\n  }\n  lc.debug?.('Stopping');\n}\n","import {assert, assertNumber} from '../../../shared/src/asserts.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport {skipGCAsserts} from '../config.ts';\nimport {type Hash, emptyHash} from '../hash.ts';\n\nexport type HeadChange = {\n  new: Hash | undefined;\n  old: Hash | undefined;\n};\n\ntype LoadedRefCountPromises = Map<Hash, Promise<number>>;\n\nexport interface RefCountUpdatesDelegate {\n  getRefCount: (hash: Hash) => MaybePromise<number | undefined>;\n  getRefs: (hash: Hash) => MaybePromise<readonly Hash[] | undefined>;\n  /**\n   * Should be implemented if the store lazily loads refs, returning whether\n   * or not the chunks refs have already been counted (i.e. are reflected\n   * in `getRefCount`).\n   *\n   * If defined then:\n   *  - `getRefs` should return undefined for refs that have not been loaded,\n   *    but should never return undefined for hashes in `putChunks`.\n   *  - it is assumed that chunks in `putChunks` may have been reachable before\n   *    the write, but may not have been counted.  This method is used to\n   *    determine if they have been counted or not.  If they have not been\n   *    counted, and are reachable with the write applied, the returned\n   *    ref count updates will include updates for counting them.\n   *\n   * If undefined then:\n   *  - `getRefs` should never return undefined\n   *  - it is assumed that the refs of any chunks which were reachable before\n   *    the write are already counted\n   */\n  areRefsCounted?: (hash: Hash) => boolean;\n}\n\n/**\n * Computes how ref counts should be updated when a dag write is committed.\n * Does not modify the dag store.\n * @param headChanges Heads that were changed by the dag write.\n * @param putChunks Chunks that were put by the dag write.\n * @param delegate Delegate used for getting ref information from the dag store.\n * @returns Map from chunk Hash to changed ref counts.  Chunks with a new ref\n * count of 0 should be deleted.  All hashes in `putChunks` will have an entry\n * (which will be zero if the newly put chunk is not reachable from any head).\n */\nexport function computeRefCountUpdates(\n  headChanges: Iterable<HeadChange>,\n  putChunks: ReadonlySet<Hash>,\n  delegate: RefCountUpdatesDelegate,\n): Promise<Map<Hash, number>> {\n  return new RefCountUpdates(headChanges, putChunks, delegate).compute();\n}\n\nclass RefCountUpdates {\n  readonly #newHeads: Hash[];\n  readonly #oldHeads: Hash[];\n  readonly #putChunks: ReadonlySet<Hash>;\n  readonly #delegate: RefCountUpdatesDelegate;\n  readonly #refsCounted: Set<Hash> | null;\n  readonly #refCountUpdates: Map<Hash, number>;\n  readonly #loadedRefCountPromises: LoadedRefCountPromises;\n  readonly #isLazyDelegate: boolean;\n\n  constructor(\n    headChanges: Iterable<HeadChange>,\n    putChunks: ReadonlySet<Hash>,\n    delegate: RefCountUpdatesDelegate,\n  ) {\n    const newHeads: Hash[] = [];\n    const oldHeads: Hash[] = [];\n    for (const changedHead of headChanges) {\n      if (changedHead.old !== changedHead.new) {\n        changedHead.old && oldHeads.push(changedHead.old);\n        changedHead.new && newHeads.push(changedHead.new);\n      }\n    }\n    this.#newHeads = newHeads;\n    this.#oldHeads = oldHeads;\n    this.#putChunks = putChunks;\n    this.#delegate = delegate;\n    this.#refCountUpdates = new Map();\n    // This map is used to ensure we do not load the ref count key more than once.\n    // Once it is loaded we only operate on a cache of the ref counts.\n    this.#loadedRefCountPromises = new Map();\n    this.#isLazyDelegate = delegate.areRefsCounted !== undefined;\n    this.#refsCounted = this.#isLazyDelegate ? new Set() : null;\n  }\n\n  async compute(): Promise<Map<Hash, number>> {\n    for (const n of this.#newHeads) {\n      await this.#changeRefCount(n, 1);\n    }\n\n    // Now go through the put chunks to ensure each has an entry in\n    // refCountUpdates (zero for new chunks which are not reachable from\n    // newHeads).\n    await Promise.all(\n      Array.from(this.#putChunks.values(), hash =>\n        this.#ensureRefCountLoaded(hash),\n      ),\n    );\n\n    if (this.#isLazyDelegate) {\n      assert(this.#delegate.areRefsCounted);\n      assert(this.#refsCounted);\n      let refCountsUpdated;\n      do {\n        refCountsUpdated = false;\n        for (const hash of this.#putChunks.values()) {\n          if (\n            !this.#delegate.areRefsCounted(hash) &&\n            !this.#refsCounted.has(hash) &&\n            this.#refCountUpdates.get(hash) !== 0\n          ) {\n            await this.#updateRefsCounts(hash, 1);\n            refCountsUpdated = true;\n            break;\n          }\n        }\n      } while (refCountsUpdated);\n    }\n\n    for (const o of this.#oldHeads) {\n      await this.#changeRefCount(o, -1);\n    }\n\n    if (!skipGCAsserts) {\n      for (const [hash, update] of this.#refCountUpdates) {\n        assert(\n          update >= 0,\n          `ref count update must be non-negative. ${hash}:${update}`,\n        );\n      }\n    }\n\n    return this.#refCountUpdates;\n  }\n\n  async #changeRefCount(hash: Hash, delta: number): Promise<void> {\n    // First make sure that we have the ref count in the cache. This is async\n    // because it might need to load the ref count from the store (via the delegate).\n    //\n    // Once we have loaded the ref count all the updates to it are sync to\n    // prevent race conditions.\n    await this.#ensureRefCountLoaded(hash);\n    if (this.#updateRefCount(hash, delta)) {\n      await this.#updateRefsCounts(hash, delta);\n    }\n  }\n\n  async #updateRefsCounts(hash: Hash, delta: number) {\n    if (hash === emptyHash) {\n      return;\n    }\n    const refs = await this.#delegate.getRefs(hash);\n    if (!skipGCAsserts) {\n      assert(\n        refs || (this.#isLazyDelegate && !this.#putChunks.has(hash)),\n        'refs must be defined',\n      );\n    }\n\n    if (refs !== undefined) {\n      this.#refsCounted?.add(hash);\n      const ps = refs.map(ref => this.#changeRefCount(ref, delta));\n      await Promise.all(ps);\n    }\n  }\n\n  #ensureRefCountLoaded(hash: Hash): Promise<number> {\n    // Only get the ref count once.\n    let p = this.#loadedRefCountPromises.get(hash);\n    if (p === undefined) {\n      p = (async () => {\n        const value = (await this.#delegate.getRefCount(hash)) || 0;\n        this.#refCountUpdates.set(hash, value);\n        return value;\n      })();\n      this.#loadedRefCountPromises.set(hash, p);\n    }\n    return p;\n  }\n\n  #updateRefCount(hash: Hash, delta: number): boolean {\n    const oldCount = this.#refCountUpdates.get(hash);\n    assertNumber(oldCount);\n    this.#refCountUpdates.set(hash, oldCount + delta);\n    return (oldCount === 0 && delta === 1) || (oldCount === 1 && delta === -1);\n  }\n}\n","import {type Hash, parse as parseHash} from '../hash.ts';\nimport * as KeyType from './key-type-enum.ts';\n\nexport function chunkDataKey(hash: Hash): string {\n  return `c/${hash}/d`;\n}\n\nexport function chunkMetaKey(hash: Hash): string {\n  return `c/${hash}/m`;\n}\n\nexport function chunkRefCountKey(hash: Hash): string {\n  return `c/${hash}/r`;\n}\n\nexport function headKey(name: string): string {\n  return `h/${name}`;\n}\n\nexport type Key =\n  | {\n      type: KeyType.ChunkData;\n      hash: Hash;\n    }\n  | {\n      type: KeyType.ChunkMeta;\n      hash: Hash;\n    }\n  | {\n      type: KeyType.ChunkRefCount;\n      hash: Hash;\n    }\n  | {\n      type: KeyType.Head;\n      name: string;\n    };\n\nexport function parse(key: string): Key {\n  const invalidKey = () => new Error(`Invalid key. Got \"${key}\"`);\n  const hash = () => parseHash(key.substring(2, key.length - 2));\n\n  // '/'\n  if (key.charCodeAt(1) === 47) {\n    switch (key.charCodeAt(0)) {\n      // c\n      case 99: {\n        if (key.length < 4 || key.charCodeAt(key.length - 2) !== 47) {\n          throw invalidKey();\n        }\n        switch (key.charCodeAt(key.length - 1)) {\n          case 100: // d\n            return {\n              type: KeyType.ChunkData,\n              hash: hash(),\n            };\n          case 109: // m\n            return {\n              type: KeyType.ChunkMeta,\n              hash: hash(),\n            };\n          case 114: // r\n            return {\n              type: KeyType.ChunkRefCount,\n              hash: hash(),\n            };\n        }\n        break;\n      }\n      case 104: // h\n        return {\n          type: KeyType.Head,\n          name: key.substring(2),\n        };\n    }\n  }\n  throw invalidKey();\n}\n","import {assertNumber} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {type Hash, assertHash} from '../hash.ts';\nimport type {\n  Read as KVRead,\n  Store as KVStore,\n  Write as KVWrite,\n} from '../kv/store.ts';\nimport {\n  Chunk,\n  type ChunkHasher,\n  type Refs,\n  assertRefs,\n  createChunk,\n} from './chunk.ts';\nimport {type RefCountUpdatesDelegate, computeRefCountUpdates} from './gc.ts';\nimport {chunkDataKey, chunkMetaKey, chunkRefCountKey, headKey} from './key.ts';\nimport {type Read, type Store, type Write, mustGetChunk} from './store.ts';\n\nexport class StoreImpl implements Store {\n  readonly #kv: KVStore;\n  readonly #chunkHasher: ChunkHasher;\n  readonly #assertValidHash: (hash: Hash) => void;\n\n  constructor(\n    kv: KVStore,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n  ) {\n    this.#kv = kv;\n    this.#chunkHasher = chunkHasher;\n    this.#assertValidHash = assertValidHash;\n  }\n\n  async read(): Promise<Read> {\n    return new ReadImpl(await this.#kv.read(), this.#assertValidHash);\n  }\n\n  async write(): Promise<Write> {\n    return new WriteImpl(\n      await this.#kv.write(),\n      this.#chunkHasher,\n      this.#assertValidHash,\n    );\n  }\n\n  close(): Promise<void> {\n    return this.#kv.close();\n  }\n}\n\nexport class ReadImpl implements Read {\n  protected readonly _tx: KVRead;\n  readonly assertValidHash: (hash: Hash) => void;\n\n  constructor(kv: KVRead, assertValidHash: (hash: Hash) => void) {\n    this._tx = kv;\n    this.assertValidHash = assertValidHash;\n  }\n\n  hasChunk(hash: Hash): Promise<boolean> {\n    return this._tx.has(chunkDataKey(hash));\n  }\n\n  async getChunk(hash: Hash): Promise<Chunk | undefined> {\n    const data = await this._tx.get(chunkDataKey(hash));\n    if (data === undefined) {\n      return undefined;\n    }\n\n    const refsVal = await this._tx.get(chunkMetaKey(hash));\n    let refs: Refs;\n    if (refsVal !== undefined) {\n      assertRefs(refsVal);\n      refs = refsVal;\n    } else {\n      refs = [];\n    }\n    return new Chunk(hash, data, refs);\n  }\n\n  mustGetChunk(hash: Hash): Promise<Chunk> {\n    return mustGetChunk(this, hash);\n  }\n\n  async getHead(name: string): Promise<Hash | undefined> {\n    const data = await this._tx.get(headKey(name));\n    if (data === undefined) {\n      return undefined;\n    }\n    assertHash(data);\n    return data;\n  }\n\n  release(): void {\n    this._tx.release();\n  }\n\n  get closed(): boolean {\n    return this._tx.closed;\n  }\n}\n\ntype HeadChange = {\n  new: Hash | undefined;\n  old: Hash | undefined;\n};\n\nexport class WriteImpl\n  extends ReadImpl\n  implements Write, RefCountUpdatesDelegate\n{\n  declare protected readonly _tx: KVWrite;\n  readonly #chunkHasher: ChunkHasher;\n\n  readonly #putChunks = new Set<Hash>();\n  readonly #changedHeads = new Map<string, HeadChange>();\n\n  constructor(\n    kvw: KVWrite,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n  ) {\n    super(kvw, assertValidHash);\n    this.#chunkHasher = chunkHasher;\n  }\n\n  createChunk = <V>(data: V, refs: Refs): Chunk<V> =>\n    createChunk(data, refs, this.#chunkHasher);\n\n  get kvWrite(): KVWrite {\n    return this._tx;\n  }\n\n  async putChunk(c: Chunk): Promise<void> {\n    const {hash, data, meta} = c;\n    // We never want to write temp hashes to the underlying store.\n    this.assertValidHash(hash);\n    const key = chunkDataKey(hash);\n    // Commit contains InternalValue and Hash which are opaque types.\n    const p1 = this._tx.put(key, data as ReadonlyJSONValue);\n    let p2;\n    if (meta.length > 0) {\n      for (const h of meta) {\n        this.assertValidHash(h);\n      }\n      p2 = this._tx.put(chunkMetaKey(hash), meta);\n    }\n    this.#putChunks.add(hash);\n    await p1;\n    await p2;\n  }\n\n  setHead(name: string, hash: Hash): Promise<void> {\n    return this.#setHead(name, hash);\n  }\n\n  removeHead(name: string): Promise<void> {\n    return this.#setHead(name, undefined);\n  }\n\n  async #setHead(name: string, hash: Hash | undefined): Promise<void> {\n    const oldHash = await this.getHead(name);\n    const hk = headKey(name);\n\n    let p1: Promise<void>;\n    if (hash === undefined) {\n      p1 = this._tx.del(hk);\n    } else {\n      p1 = this._tx.put(hk, hash);\n    }\n\n    const v = this.#changedHeads.get(name);\n    if (v === undefined) {\n      this.#changedHeads.set(name, {new: hash, old: oldHash});\n    } else {\n      // Keep old if existing\n      v.new = hash;\n    }\n\n    await p1;\n  }\n\n  async commit(): Promise<void> {\n    const refCountUpdates = await computeRefCountUpdates(\n      this.#changedHeads.values(),\n      this.#putChunks,\n      this,\n    );\n    await this.#applyRefCountUpdates(refCountUpdates);\n    await this._tx.commit();\n  }\n\n  async getRefCount(hash: Hash): Promise<number | undefined> {\n    const value = await this._tx.get(chunkRefCountKey(hash));\n    if (value === undefined) {\n      return undefined;\n    }\n    assertNumber(value);\n    if (value < 0 || value > 0xffff || value !== (value | 0)) {\n      throw new Error(\n        `Invalid ref count ${value}. We expect the value to be a Uint16`,\n      );\n    }\n    return value;\n  }\n\n  async getRefs(hash: Hash): Promise<readonly Hash[]> {\n    const meta = await this._tx.get(chunkMetaKey(hash));\n    if (meta === undefined) {\n      return [];\n    }\n    assertRefs(meta);\n    return meta;\n  }\n\n  async #applyRefCountUpdates(refCountCache: Map<Hash, number>): Promise<void> {\n    const ps: Promise<void>[] = [];\n    for (const [hash, count] of refCountCache) {\n      if (count === 0) {\n        ps.push(this.#removeAllRelatedKeys(hash));\n      } else {\n        const refCountKey = chunkRefCountKey(hash);\n        ps.push(this._tx.put(refCountKey, count));\n      }\n    }\n    await Promise.all(ps);\n  }\n\n  async #removeAllRelatedKeys(hash: Hash): Promise<void> {\n    await Promise.all([\n      this._tx.del(chunkDataKey(hash)),\n      this._tx.del(chunkMetaKey(hash)),\n      this._tx.del(chunkRefCountKey(hash)),\n    ]);\n\n    this.#putChunks.delete(hash);\n  }\n\n  release(): void {\n    this._tx.release();\n  }\n}\n","import * as v from '../../shared/src/valita.ts';\nimport type {Read, Write} from './dag/store.ts';\nimport {deepFreeze} from './frozen-json.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\n\n/**\n * We keep track of deleted clients in the {@linkcode DELETED_CLIENTS_HEAD_NAME}\n * head.\n */\nexport const DELETED_CLIENTS_HEAD_NAME = 'deleted-clients';\n\nexport const deletedClientsSchema = v.readonlyObject({\n  clientIDs: v.readonlyArray(v.string()),\n  clientGroupIDs: v.readonlyArray(v.string()),\n});\n\n// Before 11facd03a88b95667d1f171610548de5984dd928 this was an array of strings.\n// We need to allow reading that format.\nconst legacyDeletedClientsSchema = v.readonlyArray(v.string());\n\nexport type DeletedClients = v.Infer<typeof deletedClientsSchema>;\n\nexport async function setDeletedClients(\n  dagWrite: Write,\n  clientIDs: readonly ClientID[],\n  clientGroupIDs: readonly ClientGroupID[],\n): Promise<DeletedClients> {\n  // sort and dedupe\n\n  const data = {\n    clientIDs: normalize(clientIDs),\n    clientGroupIDs: normalize(clientGroupIDs),\n  };\n  const chunkData = deepFreeze(data);\n  const chunk = dagWrite.createChunk(chunkData, []);\n  await dagWrite.putChunk(chunk);\n  await dagWrite.setHead(DELETED_CLIENTS_HEAD_NAME, chunk.hash);\n  return data;\n}\n\nexport async function getDeletedClients(\n  dagRead: Read,\n): Promise<DeletedClients> {\n  const hash = await dagRead.getHead(DELETED_CLIENTS_HEAD_NAME);\n  if (hash === undefined) {\n    return {clientIDs: [], clientGroupIDs: []};\n  }\n  const chunk = await dagRead.mustGetChunk(hash);\n\n  // Try legacy schema\n  const res = v.test(chunk.data, legacyDeletedClientsSchema);\n  if (res.ok) {\n    return {clientIDs: res.value, clientGroupIDs: []};\n  }\n\n  return v.parse(chunk.data, deletedClientsSchema);\n}\n\n/**\n * Adds deleted clients to the {@linkcode DELETED_CLIENTS_HEAD_NAME} head.\n * @returns the new list of deleted clients (sorted and deduped).\n */\nexport async function addDeletedClients(\n  dagWrite: Write,\n  clientIDs: ClientID[],\n  clientGroupIDs: ClientGroupID[],\n): Promise<DeletedClients> {\n  const {clientIDs: oldClientIDs, clientGroupIDs: oldClientGroupIDs} =\n    await getDeletedClients(dagWrite);\n\n  return setDeletedClients(\n    dagWrite,\n    [...oldClientIDs, ...clientIDs],\n    [...oldClientGroupIDs, ...clientGroupIDs],\n  );\n}\n\nexport async function removeDeletedClients(\n  dagWrite: Write,\n  clientIDs: readonly ClientID[],\n  clientGroupIDs: readonly ClientGroupID[],\n): Promise<DeletedClients> {\n  const {clientIDs: oldClientIDs, clientGroupIDs: oldClientGroupIDs} =\n    await getDeletedClients(dagWrite);\n  const newDeletedClients = oldClientIDs.filter(\n    clientID => !clientIDs.includes(clientID),\n  );\n  const newDeletedClientGroups = oldClientGroupIDs.filter(\n    clientGroupID => !clientGroupIDs.includes(clientGroupID),\n  );\n  return setDeletedClients(dagWrite, newDeletedClients, newDeletedClientGroups);\n}\n\n/**\n * Sorts and dedupes the given array.\n */\nexport function normalize<T>(arr: readonly T[]): T[] {\n  return [...new Set(arr)].sort();\n}\n","type Navigator = {\n  onLine: boolean;\n  userAgent: string;\n  // add more as needed\n};\n\nconst localNavigator: Navigator | undefined =\n  typeof navigator !== 'undefined' ? navigator : undefined;\n\nexport {localNavigator as navigator};\n","import {RWLock} from '@rocicorp/lock';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {ReadImpl} from './read-impl.ts';\nimport type {Read, Store, Write} from './store.ts';\nimport {WriteImpl} from './write-impl.ts';\n\ntype StorageMap = Map<string, FrozenJSONValue>;\n\ntype Value = {readonly lock: RWLock; readonly map: StorageMap};\n\nconst stores = new Map<string, Value>();\n\nexport function clearAllNamedMemStoresForTesting(): void {\n  stores.clear();\n}\n\nexport function dropMemStore(name: string): Promise<void> {\n  stores.delete(name);\n  return promiseVoid;\n}\n\nexport function hasMemStore(name: string): boolean {\n  return stores.has(name);\n}\n\n/**\n * A named in-memory Store implementation.\n *\n * Two (or more) named memory stores with the same name will share the same\n * underlying storage. They will also share the same read/write locks, so that\n * only one write transaction can be running at the same time.\n *\n * @experimental This class is experimental and might be removed or changed\n * in the future without following semver versioning. Please be cautious.\n */\nexport class MemStore implements Store {\n  readonly #map: StorageMap;\n  readonly #rwLock: RWLock;\n  #closed = false;\n\n  constructor(name: string) {\n    const entry = stores.get(name);\n    let lock: RWLock;\n    let map: StorageMap;\n    if (entry) {\n      ({lock, map} = entry);\n    } else {\n      lock = new RWLock();\n      map = new Map();\n      stores.set(name, {lock, map});\n    }\n    this.#rwLock = lock;\n    this.#map = map;\n  }\n\n  async read(): Promise<Read> {\n    const release = await this.#rwLock.read();\n    return new ReadImpl(this.#map, release);\n  }\n\n  async write(): Promise<Write> {\n    const release = await this.#rwLock.write();\n    return new WriteImpl(this.#map, release);\n  }\n\n  close(): Promise<void> {\n    this.#closed = true;\n    return promiseVoid;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n}\n","import type {FrozenJSONValue} from '../frozen-json.ts';\nimport type {Read} from './store.ts';\n\nexport class ReadImpl implements Read {\n  readonly #map: Map<string, FrozenJSONValue>;\n  readonly #release: () => void;\n  #closed = false;\n\n  constructor(map: Map<string, FrozenJSONValue>, release: () => void) {\n    this.#map = map;\n    this.#release = release;\n  }\n\n  release() {\n    this.#release();\n    this.#closed = true;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  has(key: string): Promise<boolean> {\n    return Promise.resolve(this.#map.has(key));\n  }\n\n  get(key: string): Promise<FrozenJSONValue | undefined> {\n    return Promise.resolve(this.#map.get(key));\n  }\n}\n","import {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {ReadImpl} from './read-impl.ts';\nimport type {Write} from './store.ts';\nimport {deleteSentinel, WriteImplBase} from './write-impl-base.ts';\n\nexport class WriteImpl extends WriteImplBase implements Write {\n  readonly #map: Map<string, FrozenJSONValue>;\n\n  constructor(map: Map<string, FrozenJSONValue>, release: () => void) {\n    super(new ReadImpl(map, release));\n    this.#map = map;\n  }\n\n  commit(): Promise<void> {\n    // HOT. Do not allocate entry tuple and destructure.\n    this._pending.forEach((value, key) => {\n      if (value === deleteSentinel) {\n        this.#map.delete(key);\n      } else {\n        this.#map.set(key, value);\n      }\n    });\n    this._pending.clear();\n    this.release();\n    return promiseVoid;\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {navigator} from '../../../shared/src/navigator.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport {IDBStore} from './idb-store.ts';\nimport {MemStore, dropMemStore} from './mem-store.ts';\nimport type {Read, Store, Write} from './store.ts';\n\n/**\n * This store uses an {@link IDBStore} by default. If the {@link IDBStore} fails\n * to open the DB with an exception that matches\n * {@link isFirefoxPrivateBrowsingError} we switch out the implementation to use\n * a {@link MemStore} instead.\n *\n * The reason this is relatively complicated is that when {@link IDBStore} is\n * created, it calls `openDatabase` synchronously, but that returns a `Promise`\n * that will reject in the case of Firefox private browsing. We don't await this\n * promise until we call `read` or `write` so we cannot do the switch until\n * then.\n */\n\nexport class IDBStoreWithMemFallback implements Store {\n  readonly #lc: LogContext;\n  readonly #name: string;\n  #store: Store;\n  constructor(lc: LogContext, name: string) {\n    this.#lc = lc;\n    this.#name = name;\n    this.#store = new IDBStore(name);\n  }\n\n  read(): Promise<Read> {\n    return this.#withBrainTransplant(s => s.read());\n  }\n\n  write(): Promise<Write> {\n    return this.#withBrainTransplant(s => s.write());\n  }\n\n  async #withBrainTransplant<T extends Read>(\n    f: (store: Store) => Promise<T>,\n  ): Promise<T> {\n    try {\n      return await f(this.#store);\n    } catch (e) {\n      if (isFirefoxPrivateBrowsingError(e)) {\n        // It is possible that we end up with multiple pending read/write and\n        // they all reject. Make sure we only replace the implementation once.\n        if (this.#store instanceof IDBStore) {\n          this.#lc.info?.(\n            'Switching to MemStore because of Firefox private browsing error',\n          );\n          this.#store = new MemStore(this.#name);\n        }\n        return f(this.#store);\n      }\n      throw e;\n    }\n  }\n\n  close(): Promise<void> {\n    return this.#store.close();\n  }\n\n  get closed(): boolean {\n    return this.#store.closed;\n  }\n}\n\nfunction isFirefoxPrivateBrowsingError(e: unknown): e is DOMException {\n  return (\n    isFirefox() &&\n    e instanceof DOMException &&\n    e.name === 'InvalidStateError' &&\n    e.message ===\n      'A mutation operation was attempted on a database that did not allow mutations.'\n  );\n}\n\nfunction isFirefox(): boolean {\n  return navigator?.userAgent?.includes('Firefox') ?? false;\n}\n\nexport function newIDBStoreWithMemFallback(\n  lc: LogContext,\n  name: string,\n): Store {\n  if (isFirefox()) {\n    return new IDBStoreWithMemFallback(lc, name);\n  }\n  return new IDBStore(name);\n}\n\nexport function dropIDBStoreWithMemFallback(name: string): Promise<void> {\n  if (!isFirefox()) {\n    return dropIDBStore(name);\n  }\n  try {\n    return dropIDBStore(name);\n  } catch (e) {\n    if (isFirefoxPrivateBrowsingError(e)) {\n      return dropMemStore(name);\n    }\n  }\n  return promiseVoid;\n}\n\nfunction dropIDBStore(name: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.deleteDatabase(name);\n    req.onsuccess = () => resolve();\n    req.onerror = () => reject(req.error);\n  });\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {\n  dropIDBStoreWithMemFallback,\n  newIDBStoreWithMemFallback,\n} from './kv/idb-store-with-mem-fallback.ts';\nimport {dropMemStore, MemStore} from './kv/mem-store.ts';\nimport type {StoreProvider} from './kv/store.ts';\n\nexport function getKVStoreProvider(\n  lc: LogContext,\n  kvStore: 'mem' | 'idb' | StoreProvider | undefined,\n): StoreProvider {\n  switch (kvStore) {\n    case 'idb':\n    case undefined:\n      return {\n        create: name => newIDBStoreWithMemFallback(lc, name),\n        drop: dropIDBStoreWithMemFallback,\n      };\n    case 'mem':\n      return {\n        create: name => new MemStore(name),\n        drop: name => dropMemStore(name),\n      };\n    default:\n      return kvStore;\n  }\n}\n","import {\n  consoleLogSink,\n  LogContext,\n  TeeLogSink,\n  type Context,\n  type LogLevel,\n  type LogSink,\n} from '@rocicorp/logger';\n\n/**\n * Creates a LogContext\n * @param logLevel The log level to use. Default is `'info'`.\n * @param logSinks Destination for logs. Default is `[consoleLogSink]`.\n * @param context Optional: Additional information that can be associated with logs.\n * @returns A LogContext instance configured with the provided options.\n */\nexport function createLogContext(\n  logLevel: LogLevel = 'info',\n  logSinks: LogSink[] = [consoleLogSink],\n  context?: Context | undefined,\n): LogContext {\n  const logSink =\n    logSinks.length === 1 ? logSinks[0] : new TeeLogSink(logSinks);\n  return new LogContext(logLevel, context, logSink);\n}\n","import {randomUint64} from '../../../shared/src/random-uint64.ts';\nimport {dropIDBStoreWithMemFallback} from '../kv/idb-store-with-mem-fallback.ts';\n\nconst IDB_DATABASES_VERSION = 0;\nconst IDB_DATABASES_DB_NAME = 'replicache-dbs-v' + IDB_DATABASES_VERSION;\n\nlet testNamespace = '';\n\n/** Namespace db name in test to isolate tests' indexeddb state. */\nexport function setupForTest(): void {\n  testNamespace = randomUint64().toString(36);\n}\n\nexport function teardownForTest(): Promise<void> {\n  const idbDatabasesDBName = getIDBDatabasesDBName();\n  testNamespace = '';\n  return dropIDBStoreWithMemFallback(idbDatabasesDBName);\n}\n\nexport function getIDBDatabasesDBName(): string {\n  return testNamespace + IDB_DATABASES_DB_NAME;\n}\n","import {\n  assert,\n  assertNumber,\n  assertObject,\n  assertString,\n} from '../../../shared/src/asserts.ts';\nimport {deepFreeze} from '../frozen-json.ts';\nimport type {CreateStore, Read, Store} from '../kv/store.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {getIDBDatabasesDBName} from './idb-databases-store-db-name.ts';\nimport {makeClientID} from './make-client-id.ts';\n\nconst DBS_KEY = 'dbs';\nconst PROFILE_ID_KEY = 'profileId';\n\n// TODO: make an opaque type\nexport type IndexedDBName = string;\n\nexport type IndexedDBDatabase = {\n  readonly name: IndexedDBName;\n  readonly replicacheName: string;\n  readonly replicacheFormatVersion: number;\n  readonly schemaVersion: string;\n  readonly lastOpenedTimestampMS?: number;\n};\n\nexport type IndexedDBDatabaseRecord = {\n  readonly [name: IndexedDBName]: IndexedDBDatabase;\n};\n\nfunction assertIndexedDBDatabaseRecord(\n  value: unknown,\n): asserts value is IndexedDBDatabaseRecord {\n  assertObject(value);\n  for (const [name, db] of Object.entries(value)) {\n    assertString(name);\n    assertIndexedDBDatabase(db);\n    assert(name === db.name);\n  }\n}\n\nfunction assertIndexedDBDatabase(\n  value: unknown,\n): asserts value is IndexedDBDatabase {\n  assertObject(value);\n  assertString(value.name);\n  assertString(value.replicacheName);\n  assertNumber(value.replicacheFormatVersion);\n  assertString(value.schemaVersion);\n  if (value.lastOpenedTimestampMS !== undefined) {\n    assertNumber(value.lastOpenedTimestampMS);\n  }\n}\n\nexport class IDBDatabasesStore {\n  readonly #kvStore: Store;\n\n  constructor(createKVStore: CreateStore) {\n    this.#kvStore = createKVStore(getIDBDatabasesDBName());\n  }\n\n  putDatabase(db: IndexedDBDatabase): Promise<IndexedDBDatabaseRecord> {\n    return this.#putDatabase({...db, lastOpenedTimestampMS: Date.now()});\n  }\n\n  putDatabaseForTesting(\n    db: IndexedDBDatabase,\n  ): Promise<IndexedDBDatabaseRecord> {\n    return this.#putDatabase(db);\n  }\n\n  #putDatabase(db: IndexedDBDatabase): Promise<IndexedDBDatabaseRecord> {\n    return withWrite(this.#kvStore, async write => {\n      const oldDbRecord = await getDatabases(write);\n      const dbRecord = {\n        ...oldDbRecord,\n        [db.name]: db,\n      };\n      await write.put(DBS_KEY, dbRecord);\n      return dbRecord;\n    });\n  }\n\n  clearDatabases(): Promise<void> {\n    return withWrite(this.#kvStore, write => write.del(DBS_KEY));\n  }\n\n  deleteDatabases(names: Iterable<IndexedDBName>): Promise<void> {\n    return withWrite(this.#kvStore, async write => {\n      const oldDbRecord = await getDatabases(write);\n      const dbRecord = {\n        ...oldDbRecord,\n      };\n      for (const name of names) {\n        delete dbRecord[name];\n      }\n      await write.put(DBS_KEY, dbRecord);\n    });\n  }\n\n  getDatabases(): Promise<IndexedDBDatabaseRecord> {\n    return withRead(this.#kvStore, getDatabases);\n  }\n\n  close(): Promise<void> {\n    return this.#kvStore.close();\n  }\n\n  getProfileID(): Promise<string> {\n    return withWrite(this.#kvStore, async write => {\n      let profileId = await write.get(PROFILE_ID_KEY);\n      if (profileId === undefined) {\n        // Profile id is 'p' followed by a random number.\n        profileId = `p${makeClientID()}`;\n        await write.put(PROFILE_ID_KEY, profileId);\n      }\n      assertString(profileId);\n      return profileId;\n    });\n  }\n}\n\nasync function getDatabases(read: Read): Promise<IndexedDBDatabaseRecord> {\n  let dbRecord = await read.get(DBS_KEY);\n  if (!dbRecord) {\n    dbRecord = deepFreeze({});\n  }\n  assertIndexedDBDatabaseRecord(dbRecord);\n  return dbRecord;\n}\n","import type {LogContext, LogLevel, LogSink} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport {StoreImpl} from '../dag/store-impl.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  addDeletedClients,\n  getDeletedClients,\n  normalize,\n} from '../deleted-clients.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport {getKVStoreProvider} from '../get-kv-store-provider.ts';\nimport {assertHash, newRandomHash} from '../hash.ts';\nimport {IDBStore} from '../kv/idb-store.ts';\nimport type {DropStore, StoreProvider} from '../kv/store.ts';\nimport {createLogContext} from '../log-options.ts';\nimport type {ClientGroupID, ClientID} from '../sync/ids.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {\n  clientGroupHasPendingMutations,\n  getClientGroups,\n} from './client-groups.ts';\nimport type {OnClientsDeleted} from './clients.ts';\nimport {getClients} from './clients.ts';\nimport type {IndexedDBDatabase} from './idb-databases-store.ts';\nimport {IDBDatabasesStore} from './idb-databases-store.ts';\n\n/**\n * How frequently to try to collect\n */\nexport const COLLECT_IDB_INTERVAL = 12 * 60 * 60 * 1000; // 12 hours\n\n/**\n * We delay the initial collection to prevent doing it at startup.\n */\nexport const INITIAL_COLLECT_IDB_DELAY = 5 * 60 * 1000; // 5 minutes\n\nexport function initCollectIDBDatabases(\n  idbDatabasesStore: IDBDatabasesStore,\n  kvDropStore: DropStore,\n  collectInterval: number,\n  initialCollectDelay: number,\n  maxAge: number,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  let initial = true;\n  initBgIntervalProcess(\n    'CollectIDBDatabases',\n    async () => {\n      await collectIDBDatabases(\n        idbDatabasesStore,\n        Date.now(),\n        maxAge,\n        kvDropStore,\n        enableMutationRecovery,\n        onClientsDeleted,\n      );\n    },\n    () => {\n      if (initial) {\n        initial = false;\n        return initialCollectDelay;\n      }\n      return collectInterval;\n    },\n    lc,\n    signal,\n  );\n}\n\n/**\n * Collects IDB databases that are no longer needed.\n */\nexport async function collectIDBDatabases(\n  idbDatabasesStore: IDBDatabasesStore,\n  now: number,\n  maxAge: number,\n  kvDropStore: DropStore,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n  newDagStore = defaultNewDagStore,\n): Promise<void> {\n  const databases = await idbDatabasesStore.getDatabases();\n\n  const dbs = Object.values(databases) as IndexedDBDatabase[];\n  const collectResults = await Promise.all(\n    dbs.map(\n      async db =>\n        [\n          db.name,\n          await gatherDatabaseInfoForCollect(\n            db,\n            now,\n            maxAge,\n            enableMutationRecovery,\n            newDagStore,\n          ),\n        ] as const,\n    ),\n  );\n\n  const dbNamesToRemove: string[] = [];\n  const dbNamesToKeep: string[] = [];\n  const clientIDsToRemove: ClientID[] = [];\n  const clientGroupIDsToRemove: ClientGroupID[] = [];\n  for (const [\n    dbName,\n    [canCollect, clientIDs, clientGroupIDs],\n  ] of collectResults) {\n    if (canCollect) {\n      dbNamesToRemove.push(dbName);\n      clientIDsToRemove.push(...clientIDs);\n      clientGroupIDsToRemove.push(...clientGroupIDs);\n    } else {\n      dbNamesToKeep.push(dbName);\n    }\n  }\n\n  const {errors} = await dropDatabases(\n    idbDatabasesStore,\n    dbNamesToRemove,\n    kvDropStore,\n  );\n  if (errors.length) {\n    throw errors[0];\n  }\n\n  if (clientIDsToRemove.length || clientGroupIDsToRemove.length) {\n    // Add the deleted clients to all the dbs that survived the collection.\n    const newClientIDsToRemove: ClientID[] = clientIDsToRemove;\n    const newClientGroupIDsToRemove: ClientGroupID[] = clientGroupIDsToRemove;\n    for (const name of dbNamesToKeep) {\n      await withWrite(newDagStore(name), async dagWrite => {\n        const {clientIDs, clientGroupIDs} = await addDeletedClients(\n          dagWrite,\n          clientIDsToRemove,\n          clientGroupIDsToRemove,\n        );\n\n        newClientIDsToRemove.push(...clientIDs);\n        newClientGroupIDsToRemove.push(...clientGroupIDs);\n      });\n    }\n    // normalize and dedupe\n    onClientsDeleted(\n      normalize(newClientIDsToRemove),\n      normalize(newClientGroupIDsToRemove),\n    );\n  }\n}\n\nasync function dropDatabaseInternal(\n  name: string,\n  idbDatabasesStore: IDBDatabasesStore,\n  kvDropStore: DropStore,\n) {\n  await kvDropStore(name);\n  await idbDatabasesStore.deleteDatabases([name]);\n}\n\nasync function dropDatabases(\n  idbDatabasesStore: IDBDatabasesStore,\n  namesToRemove: string[],\n  kvDropStore: DropStore,\n): Promise<{dropped: string[]; errors: unknown[]}> {\n  // Try to remove the databases in parallel. Don't let a single reject fail the\n  // other ones. We will check for failures afterwards.\n  const dropStoreResults = await Promise.allSettled(\n    namesToRemove.map(async name => {\n      await dropDatabaseInternal(name, idbDatabasesStore, kvDropStore);\n      return name;\n    }),\n  );\n\n  const dropped: string[] = [];\n  const errors: unknown[] = [];\n  for (const result of dropStoreResults) {\n    if (result.status === 'fulfilled') {\n      dropped.push(result.value);\n    } else {\n      errors.push(result.reason);\n    }\n  }\n\n  return {dropped, errors};\n}\n\nfunction defaultNewDagStore(name: string): Store {\n  const perKvStore = new IDBStore(name);\n  return new StoreImpl(perKvStore, newRandomHash, assertHash);\n}\n\n/**\n * If the database is older than maxAge and there are no pending mutations we\n * return `true` and an array of the clientIDs in that db. If the database is\n * too new or there are pending mutations we return `[false]`.\n */\nfunction gatherDatabaseInfoForCollect(\n  db: IndexedDBDatabase,\n  now: number,\n  maxAge: number,\n  enableMutationRecovery: boolean,\n  newDagStore: typeof defaultNewDagStore,\n): MaybePromise<\n  | [canCollect: false]\n  | [\n      canCollect: true,\n      deletedClientIDs: ClientID[],\n      deletedClientGroupIDs: ClientGroupID[],\n    ]\n> {\n  if (db.replicacheFormatVersion > FormatVersion.Latest) {\n    return [false];\n  }\n\n  // 0 is used in testing\n  assert(db.lastOpenedTimestampMS !== undefined);\n\n  // - For DD31 we can delete the database if it is older than maxAge and\n  //   there are no pending mutations.\n  if (now - db.lastOpenedTimestampMS < maxAge) {\n    return [false];\n  }\n  // If increase the format version we need to decide how to deal with this\n  // logic.\n  assert(\n    db.replicacheFormatVersion === FormatVersion.DD31 ||\n      db.replicacheFormatVersion === FormatVersion.V6 ||\n      db.replicacheFormatVersion === FormatVersion.V7,\n  );\n  return canDatabaseBeCollectedAndGetDeletedClientIDs(\n    enableMutationRecovery,\n    newDagStore(db.name),\n  );\n}\n\n/**\n * Options for `dropDatabase` and `dropAllDatabases`.\n */\nexport type DropDatabaseOptions = {\n  /**\n   * Allows providing a custom implementation of the underlying storage layer.\n   * Default is `'idb'`.\n   */\n  kvStore?: 'idb' | 'mem' | StoreProvider | undefined;\n  /**\n   * Determines how much logging to do. When this is set to `'debug'`,\n   * Replicache will also log `'info'` and `'error'` messages. When set to\n   * `'info'` we log `'info'` and `'error'` but not `'debug'`. When set to\n   * `'error'` we only log `'error'` messages.\n   * Default is `'info'`.\n   */\n  logLevel?: LogLevel | undefined;\n  /**\n   * Enables custom handling of logs.\n   *\n   * By default logs are logged to the console.  If you would like logs to be\n   * sent elsewhere (e.g. to a cloud logging service like DataDog) you can\n   * provide an array of {@link LogSink}s.  Logs at or above\n   * {@link DropDatabaseOptions.logLevel} are sent to each of these {@link LogSink}s.\n   * If you would still like logs to go to the console, include\n   * `consoleLogSink` in the array.\n   *\n   * ```ts\n   * logSinks: [consoleLogSink, myCloudLogSink],\n   * ```\n   * Default is `[consoleLogSink]`.\n   */\n  logSinks?: LogSink[] | undefined;\n};\n\n/**\n * Drops the specified database.\n * @param dbName The name of the database to drop.\n * @param opts Options for dropping the database.\n */\nexport async function dropDatabase(\n  dbName: string,\n  opts?: DropDatabaseOptions | undefined,\n) {\n  const logContext = createLogContext(opts?.logLevel, opts?.logSinks, {\n    dropDatabase: undefined,\n  });\n  const kvStoreProvider = getKVStoreProvider(logContext, opts?.kvStore);\n  await dropDatabaseInternal(\n    dbName,\n    new IDBDatabasesStore(kvStoreProvider.create),\n    kvStoreProvider.drop,\n  );\n}\n\n/**\n * Deletes all IndexedDB data associated with Replicache.\n *\n * Returns an object with the names of the successfully dropped databases\n * and any errors encountered while dropping.\n */\nexport async function dropAllDatabases(\n  opts?: DropDatabaseOptions | undefined,\n): Promise<{\n  dropped: string[];\n  errors: unknown[];\n}> {\n  const logContext = createLogContext(opts?.logLevel, opts?.logSinks, {\n    dropAllDatabases: undefined,\n  });\n  const kvStoreProvider = getKVStoreProvider(logContext, opts?.kvStore);\n  const store = new IDBDatabasesStore(kvStoreProvider.create);\n  const databases = await store.getDatabases();\n  const dbNames = Object.values(databases).map(db => db.name);\n  const result = await dropDatabases(store, dbNames, kvStoreProvider.drop);\n  return result;\n}\n\n/**\n * Deletes all IndexedDB data associated with Replicache.\n *\n * Returns an object with the names of the successfully dropped databases\n * and any errors encountered while dropping.\n *\n * @deprecated Use `dropAllDatabases` instead.\n */\nexport function deleteAllReplicacheData(\n  opts?: DropDatabaseOptions | undefined,\n) {\n  return dropAllDatabases(opts);\n}\n\n/**\n * If the there are pending mutations in any of the clients in this db we return\n * `[false]`. Otherwise we return `true` and an array of the clientIDs to\n * remove.\n */\nfunction canDatabaseBeCollectedAndGetDeletedClientIDs(\n  enableMutationRecovery: boolean,\n  perdag: Store,\n): Promise<\n  | [canCollect: false]\n  | [\n      canCollect: true,\n      deletedClientIDs: ClientID[],\n      deletedClientGroupIDs: ClientGroupID[],\n    ]\n> {\n  return withRead(perdag, async read => {\n    // If mutation recovery is disabled we do not care if there are pending\n    // mutations when we decide if we can collect the database.\n    if (enableMutationRecovery) {\n      const clientGroups = await getClientGroups(read);\n      for (const clientGroup of clientGroups.values()) {\n        if (clientGroupHasPendingMutations(clientGroup)) {\n          return [false];\n        }\n      }\n    }\n\n    const clients = await getClients(read);\n    const {clientIDs, clientGroupIDs} = await getDeletedClients(read);\n    const newClientIDs: ClientID[] = [...clientIDs];\n    const newClientGroupIDs: ClientGroupID[] = [...clientGroupIDs];\n    for (const [clientID, client] of clients) {\n      newClientIDs.push(clientID);\n      newClientGroupIDs.push(client.clientGroupID);\n    }\n    // Deduping and sorting is done when storing\n    return [true, newClientIDs, newClientGroupIDs];\n  });\n}\n","/**\n * This error is thrown when you try to call methods on a closed transaction.\n */\nexport class TransactionClosedError extends Error {\n  constructor() {\n    super('Transaction is closed');\n  }\n}\n\nexport type Closed = {closed: boolean};\n\nexport function throwIfClosed(tx: Closed): void {\n  if (tx.closed) {\n    throw new TransactionClosedError();\n  }\n}\n\nexport function rejectIfClosed(tx: Closed): undefined | Promise<never> {\n  return tx.closed ? Promise.reject(new TransactionClosedError()) : undefined;\n}\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {astSchema} from './ast.ts';\n\nexport const transformRequestBodySchema = v.array(\n  v.object({\n    id: v.string(),\n    name: v.string(),\n    args: v.readonly(v.array(jsonSchema)),\n  }),\n);\nexport type TransformRequestBody = v.Infer<typeof transformRequestBodySchema>;\n\nexport const transformedQuerySchema = v.object({\n  id: v.string(),\n  name: v.string(),\n  ast: astSchema,\n});\n\nexport const appQueryErrorSchema = v.object({\n  error: v.literal('app'),\n  id: v.string(),\n  name: v.string(),\n  details: jsonSchema,\n});\n\nexport const zeroErrorSchema = v.object({\n  error: v.literal('zero'),\n  id: v.string(),\n  name: v.string(),\n  details: jsonSchema,\n});\n\nexport const httpQueryErrorSchema = v.object({\n  error: v.literal('http'),\n  id: v.string(),\n  name: v.string(),\n  status: v.number(),\n  details: jsonSchema,\n});\n\nexport const erroredQuerySchema = v.union(\n  appQueryErrorSchema,\n  httpQueryErrorSchema,\n  zeroErrorSchema,\n);\nexport type ErroredQuery = v.Infer<typeof erroredQuerySchema>;\nexport type AppQueryError = v.Infer<typeof appQueryErrorSchema>;\nexport type HttpQueryError = v.Infer<typeof httpQueryErrorSchema>;\n\nexport const transformResponseBodySchema = v.array(\n  v.union(transformedQuerySchema, erroredQuerySchema),\n);\nexport type TransformResponseBody = v.Infer<typeof transformResponseBodySchema>;\n\nexport const transformRequestMessageSchema = v.tuple([\n  v.literal('transform'),\n  transformRequestBodySchema,\n]);\nexport type TransformRequestMessage = v.Infer<\n  typeof transformRequestMessageSchema\n>;\nexport const transformErrorMessageSchema = v.tuple([\n  v.literal('transformError'),\n  v.array(erroredQuerySchema),\n]);\nexport type TransformErrorMessage = v.Infer<typeof transformErrorMessageSchema>;\n\nexport const transformResponseMessageSchema = v.tuple([\n  v.literal('transformed'),\n  transformResponseBodySchema,\n]);\nexport type TransformResponseMessage = v.Infer<\n  typeof transformResponseMessageSchema\n>;\n","/* eslint-disable @typescript-eslint/naming-convention */\n\n// Note: Metric names depend on these values,\n// so if you add or change on here a corresponding dashboard\n// change will likely be needed.\n\nexport const AuthInvalidated = 'AuthInvalidated';\nexport const ClientNotFound = 'ClientNotFound';\nexport const InvalidConnectionRequest = 'InvalidConnectionRequest';\nexport const InvalidConnectionRequestBaseCookie =\n  'InvalidConnectionRequestBaseCookie';\nexport const InvalidConnectionRequestLastMutationID =\n  'InvalidConnectionRequestLastMutationID';\nexport const InvalidConnectionRequestClientDeleted =\n  'InvalidConnectionRequestClientDeleted';\nexport const InvalidMessage = 'InvalidMessage';\nexport const InvalidPush = 'InvalidPush';\nexport const MutationFailed = 'MutationFailed';\nexport const MutationRateLimited = 'MutationRateLimited';\nexport const Rebalance = 'Rebalance';\nexport const Rehome = 'Rehome';\nexport const Unauthorized = 'Unauthorized';\nexport const VersionNotSupported = 'VersionNotSupported';\nexport const SchemaVersionNotSupported = 'SchemaVersionNotSupported';\nexport const ServerOverloaded = 'ServerOverloaded';\nexport const Internal = 'Internal';\n\nexport type AuthInvalidated = typeof AuthInvalidated;\nexport type ClientNotFound = typeof ClientNotFound;\nexport type InvalidConnectionRequest = typeof InvalidConnectionRequest;\nexport type InvalidConnectionRequestBaseCookie =\n  typeof InvalidConnectionRequestBaseCookie;\nexport type InvalidConnectionRequestLastMutationID =\n  typeof InvalidConnectionRequestLastMutationID;\nexport type InvalidConnectionRequestClientDeleted =\n  typeof InvalidConnectionRequestClientDeleted;\nexport type InvalidMessage = typeof InvalidMessage;\nexport type InvalidPush = typeof InvalidPush;\nexport type MutationFailed = typeof MutationFailed;\nexport type MutationRateLimited = typeof MutationRateLimited;\nexport type Rebalance = typeof Rebalance;\nexport type Rehome = typeof Rehome;\nexport type Unauthorized = typeof Unauthorized;\nexport type VersionNotSupported = typeof VersionNotSupported;\nexport type SchemaVersionNotSupported = typeof SchemaVersionNotSupported;\nexport type ServerOverloaded = typeof ServerOverloaded;\nexport type Internal = typeof Internal;\n","import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport type {SchemaValue, TableSchema} from '../table-schema.ts';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function table<TName extends string>(name: TName) {\n  return new TableBuilder({\n    name,\n    columns: {},\n    primaryKey: [] as any as PrimaryKey,\n  });\n}\n\nexport function string<T extends string = string>() {\n  return new ColumnBuilder({\n    type: 'string',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function number<T extends number = number>() {\n  return new ColumnBuilder({\n    type: 'number',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function boolean<T extends boolean = boolean>() {\n  return new ColumnBuilder({\n    type: 'boolean',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function json<T extends ReadonlyJSONValue = ReadonlyJSONValue>() {\n  return new ColumnBuilder({\n    type: 'json',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport function enumeration<T extends string>() {\n  return new ColumnBuilder({\n    type: 'string',\n    optional: false,\n    customType: null as unknown as T,\n  });\n}\n\nexport const column = {\n  string,\n  number,\n  boolean,\n  json,\n  enumeration,\n};\n\nexport class TableBuilder<TShape extends TableSchema> {\n  readonly #schema: TShape;\n  constructor(schema: TShape) {\n    this.#schema = schema;\n  }\n\n  from<ServerName extends string>(serverName: ServerName) {\n    return new TableBuilder<TShape>({\n      ...this.#schema,\n      // Strip the \"public.\" schema if specified, as tables in the upstream\n      // \"public\" schema are created without the schema prefix on the replica.\n      // See liteTableName() in zero-cache/src/types/names.ts\n      serverName: serverName.startsWith('public.')\n        ? serverName.substring('public.'.length)\n        : serverName,\n    });\n  }\n\n  columns<const TColumns extends Record<string, ColumnBuilder<SchemaValue>>>(\n    columns: TColumns,\n  ): TableBuilderWithColumns<{\n    name: TShape['name'];\n    columns: {[K in keyof TColumns]: TColumns[K]['schema']};\n    primaryKey: TShape['primaryKey'];\n  }> {\n    const columnSchemas = Object.fromEntries(\n      Object.entries(columns).map(([k, v]) => [k, v.schema]),\n    ) as {[K in keyof TColumns]: TColumns[K]['schema']};\n    return new TableBuilderWithColumns({\n      ...this.#schema,\n      columns: columnSchemas,\n    }) as any;\n  }\n}\n\nexport class TableBuilderWithColumns<TShape extends TableSchema> {\n  readonly #schema: TShape;\n\n  constructor(schema: TShape) {\n    this.#schema = schema;\n  }\n\n  primaryKey<TPKColNames extends (keyof TShape['columns'])[]>(\n    ...pkColumnNames: TPKColNames\n  ) {\n    return new TableBuilderWithColumns({\n      ...this.#schema,\n      primaryKey: pkColumnNames,\n    });\n  }\n\n  get schema() {\n    return this.#schema;\n  }\n\n  build() {\n    // We can probably get the type system to throw an error if primaryKey is not called\n    // before passing the schema to createSchema\n    // Till then --\n    if (this.#schema.primaryKey.length === 0) {\n      throw new Error(`Table \"${this.#schema.name}\" is missing a primary key`);\n    }\n    const names = new Set<string>();\n    for (const [col, {serverName}] of Object.entries(this.#schema.columns)) {\n      const name = serverName ?? col;\n      if (names.has(name)) {\n        throw new Error(\n          `Table \"${\n            this.#schema.name\n          }\" has multiple columns referencing \"${name}\"`,\n        );\n      }\n      names.add(name);\n    }\n    return this.#schema;\n  }\n}\n\nclass ColumnBuilder<TShape extends SchemaValue<any>> {\n  readonly #schema: TShape;\n  constructor(schema: TShape) {\n    this.#schema = schema;\n  }\n\n  from<ServerName extends string>(serverName: ServerName) {\n    return new ColumnBuilder<TShape & {serverName: string}>({\n      ...this.#schema,\n      serverName,\n    });\n  }\n\n  optional(): ColumnBuilder<Omit<TShape, 'optional'> & {optional: true}> {\n    return new ColumnBuilder({\n      ...this.#schema,\n      optional: true,\n    });\n  }\n\n  get schema() {\n    return this.#schema;\n  }\n}\n\nexport type {ColumnBuilder};\n","import {mapAllEntries} from '../../shared/src/objects.ts';\nimport * as v from '../../shared/src/valita.ts';\n\nexport type ValueType = 'string' | 'number' | 'boolean' | 'null' | 'json';\n\nexport const valueTypeSchema: v.Type<ValueType> = v.literalUnion(\n  'string',\n  'number',\n  'boolean',\n  'null',\n  'json',\n);\n\nexport const columnSchemaSchema = v.object({\n  type: valueTypeSchema,\n});\n\nexport type ColumnSchema = v.Infer<typeof columnSchemaSchema>;\n\nexport const tableSchemaSchema = v.object({\n  columns: v.record(columnSchemaSchema),\n});\n\nexport type TableSchema = v.Infer<typeof tableSchemaSchema>;\n\nexport const clientSchemaSchema = v.object({\n  tables: v.record(tableSchemaSchema),\n});\n\nexport type ClientSchema = v.Infer<typeof clientSchemaSchema>;\n\nconst keyCmp = ([a]: [a: string, _: unknown], [b]: [b: string, _: unknown]) =>\n  a < b ? -1 : a > b ? 1 : 0;\n\n/**\n * Returns a normalized schema (with the tables and columns sorted)\n * suitable for hashing.\n */\nexport function normalizeClientSchema(schema: ClientSchema): ClientSchema {\n  return {\n    tables: mapAllEntries(schema.tables, tables =>\n      tables\n        .sort(keyCmp)\n        .map(([name, table]) => [\n          name,\n          {columns: mapAllEntries(table.columns, e => e.sort(keyCmp))},\n        ]),\n    ),\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {h64} from '../../../shared/src/hash.ts';\nimport {mapEntries} from '../../../shared/src/objects.ts';\nimport {\n  normalizeClientSchema,\n  type ClientSchema,\n} from '../../../zero-protocol/src/client-schema.ts';\nimport type {\n  Relationship,\n  RelationshipsSchema,\n  TableSchema,\n} from '../table-schema.ts';\nimport type {Relationships} from './relationship-builder.ts';\nimport {type TableBuilderWithColumns} from './table-builder.ts';\n\nexport type Schema = {\n  readonly tables: {readonly [table: string]: TableSchema};\n  readonly relationships: {readonly [table: string]: RelationshipsSchema};\n  /**\n   * Enables legacy query support.\n   * When this is true, old-style queries that do not require server side implementations will be enabled.\n   * This will flip to false in the future and what we currently call \"custom queries\" will become \"queries\" and\n   * the only option for reading data.\n   * The default is true, but will flip to false in the future.\n   */\n  readonly enableLegacyQueries?: boolean | undefined;\n  /**\n   * Enables legacy mutator support.\n   * When this is true, old-style mutations that do not require server side implementations will be enabled.\n   * This will flip to false in the future and what we currently call \"custom mutations\" will become \"mutations\" and\n   * the only option for writing data.\n   * The default is true, but will flip to false in the future.\n   */\n  readonly enableLegacyMutators?: boolean | undefined;\n};\n\n/**\n * Note: the keys of the `tables` and `relationships` parameters do not matter.\n * You can assign them to any value you like. E.g.,\n *\n * ```ts\n * createSchema({rsdfgafg: table('users')...}, {sdfd: relationships(users, ...)})\n * ```\n */\nexport function createSchema<\n  const TTables extends readonly TableBuilderWithColumns<TableSchema>[],\n  const TRelationships extends readonly Relationships[],\n  const TEnableLegacyQueries extends boolean | undefined,\n  const TEnableLegacyMutators extends boolean | undefined,\n>(options: {\n  readonly tables: TTables;\n  readonly relationships?: TRelationships | undefined;\n  /** @see Schema.enableLegacyQueries */\n  readonly enableLegacyQueries?: TEnableLegacyQueries | undefined;\n  /** @see Schema.enableLegacyMutators */\n  readonly enableLegacyMutators?: TEnableLegacyMutators | undefined;\n}): {\n  tables: {\n    readonly [K in TTables[number]['schema']['name']]: Extract<\n      TTables[number]['schema'],\n      {name: K}\n    >;\n  };\n  relationships: {\n    readonly [K in TRelationships[number]['name']]: Extract<\n      TRelationships[number],\n      {name: K}\n    >['relationships'];\n  };\n  enableLegacyQueries: TEnableLegacyQueries;\n  enableLegacyMutators: TEnableLegacyMutators;\n} {\n  const retTables: Record<string, TableSchema> = {};\n  const retRelationships: Record<string, Record<string, Relationship>> = {};\n  const serverNames = new Set<string>();\n\n  options.tables.forEach(table => {\n    const {serverName = table.schema.name} = table.schema;\n    if (serverNames.has(serverName)) {\n      throw new Error(`Multiple tables reference the name \"${serverName}\"`);\n    }\n    serverNames.add(serverName);\n    if (retTables[table.schema.name]) {\n      throw new Error(\n        `Table \"${table.schema.name}\" is defined more than once in the schema`,\n      );\n    }\n    retTables[table.schema.name] = table.build();\n  });\n  options.relationships?.forEach(relationships => {\n    if (retRelationships[relationships.name]) {\n      throw new Error(\n        `Relationships for table \"${relationships.name}\" are defined more than once in the schema`,\n      );\n    }\n    retRelationships[relationships.name] = relationships.relationships;\n    checkRelationship(\n      relationships.relationships,\n      relationships.name,\n      retTables,\n    );\n  });\n\n  return {\n    tables: retTables,\n    relationships: retRelationships,\n    enableLegacyQueries: options.enableLegacyQueries,\n    enableLegacyMutators: options.enableLegacyMutators,\n  } as any;\n}\n\nfunction checkRelationship(\n  relationships: Record<string, Relationship>,\n  tableName: string,\n  tables: Record<string, TableSchema>,\n) {\n  // TS should be able to check this for us but something is preventing it from happening.\n  Object.entries(relationships).forEach(([name, rel]) => {\n    let source = tables[tableName];\n    if (source.columns[name] !== undefined) {\n      throw new Error(\n        `Relationship \"${tableName}\".\"${name}\" cannot have the same name as the column \"${name}\" on the the table \"${source.name}\"`,\n      );\n    }\n    rel.forEach(connection => {\n      if (!tables[connection.destSchema]) {\n        throw new Error(\n          `For relationship \"${tableName}\".\"${name}\", destination table \"${connection.destSchema}\" is missing in the schema`,\n        );\n      }\n      if (!source.columns[connection.sourceField[0]]) {\n        throw new Error(\n          `For relationship \"${tableName}\".\"${name}\", the source field \"${connection.sourceField[0]}\" is missing in the table schema \"${source.name}\"`,\n        );\n      }\n      source = tables[connection.destSchema];\n    });\n  });\n}\n\nexport function clientSchemaFrom(schema: Schema): {\n  clientSchema: ClientSchema;\n  hash: string;\n} {\n  const client = {\n    tables: mapEntries(schema.tables, (name, {serverName, columns}) => [\n      serverName ?? name,\n      {\n        columns: mapEntries(columns, (name, {serverName, type}) => [\n          serverName ?? name,\n          {type},\n        ]),\n      },\n    ]),\n  };\n  const clientSchema = normalizeClientSchema(client);\n  const hash = h64(JSON.stringify(clientSchema)).toString(36);\n  return {clientSchema, hash};\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * There is a new client group due to a another tab loading new code which\n * cannot sync locally with this tab until it updates to the new code. This tab\n * can still sync with the zero-cache.\n */\nexport const NewClientGroup = 'NewClientGroup';\nexport type NewClientGroup = typeof NewClientGroup;\n\n/**\n * This client was unable to connect to the zero-cache because it is using a\n * protocol version that the zero-cache does not support.\n */\nexport const VersionNotSupported = 'VersionNotSupported';\nexport type VersionNotSupported = typeof VersionNotSupported;\n\n/**\n * This client was unable to connect to the zero-cache because it is using a\n * schema version (see {@codelink Schema}) that the zero-cache does not support.\n */\nexport const SchemaVersionNotSupported = 'SchemaVersionNotSupported';\nexport type SchemaVersionNotSupported = typeof SchemaVersionNotSupported;\n","import {type LogLevel, type LogSink} from '@rocicorp/logger';\nimport {type Resolver, resolver} from '@rocicorp/resolver';\nimport {\n  ReplicacheImpl,\n  type ReplicacheImplOptions,\n} from '../../../replicache/src/impl.ts';\nimport {dropDatabase} from '../../../replicache/src/persist/collect-idb-databases.ts';\nimport type {Puller, PullerResult} from '../../../replicache/src/puller.ts';\nimport type {Pusher, PusherResult} from '../../../replicache/src/pusher.ts';\nimport type {ReplicacheOptions} from '../../../replicache/src/replicache-options.ts';\nimport type {\n  ClientGroupID,\n  ClientID,\n} from '../../../replicache/src/sync/ids.ts';\nimport type {PullRequest} from '../../../replicache/src/sync/pull.ts';\nimport type {PushRequest} from '../../../replicache/src/sync/push.ts';\nimport type {\n  MutatorDefs,\n  MutatorReturn,\n  UpdateNeededReason as ReplicacheUpdateNeededReason,\n} from '../../../replicache/src/types.ts';\nimport {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport {\n  getBrowserGlobal,\n  mustGetBrowserGlobal,\n} from '../../../shared/src/browser-env.ts';\nimport type {DeepMerge} from '../../../shared/src/deep-merge.ts';\nimport {getDocumentVisibilityWatcher} from '../../../shared/src/document-visible.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {navigator} from '../../../shared/src/navigator.ts';\nimport {sleep, sleepWithAbort} from '../../../shared/src/sleep.ts';\nimport {Subscribable} from '../../../shared/src/subscribable.ts';\nimport * as valita from '../../../shared/src/valita.ts';\nimport type {Writable} from '../../../shared/src/writable.ts';\nimport {type ClientSchema} from '../../../zero-protocol/src/client-schema.ts';\nimport type {\n  ConnectedMessage,\n  UserMutateParams,\n  UserQueryParams,\n} from '../../../zero-protocol/src/connect.ts';\nimport {encodeSecProtocols} from '../../../zero-protocol/src/connect.ts';\nimport type {DeleteClientsBody} from '../../../zero-protocol/src/delete-clients.ts';\nimport type {Downstream} from '../../../zero-protocol/src/down.ts';\nimport {downstreamSchema} from '../../../zero-protocol/src/down.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport type {ErrorMessage} from '../../../zero-protocol/src/error.ts';\nimport * as MutationType from '../../../zero-protocol/src/mutation-type-enum.ts';\nimport type {PingMessage} from '../../../zero-protocol/src/ping.ts';\nimport type {\n  PokeEndMessage,\n  PokePartMessage,\n  PokeStartMessage,\n} from '../../../zero-protocol/src/poke.ts';\nimport {PROTOCOL_VERSION} from '../../../zero-protocol/src/protocol-version.ts';\nimport type {\n  PullRequestMessage,\n  PullResponseBody,\n  PullResponseMessage,\n} from '../../../zero-protocol/src/pull.ts';\nimport type {\n  CRUDMutation,\n  CRUDMutationArg,\n  CustomMutation,\n  MutationID,\n  PushMessage,\n} from '../../../zero-protocol/src/push.ts';\nimport {CRUD_MUTATION_NAME, mapCRUD} from '../../../zero-protocol/src/push.ts';\nimport type {UpQueriesPatchOp} from '../../../zero-protocol/src/queries-patch.ts';\nimport type {Upstream} from '../../../zero-protocol/src/up.ts';\nimport type {NullableVersion} from '../../../zero-protocol/src/version.ts';\nimport {nullableVersionSchema} from '../../../zero-protocol/src/version.ts';\nimport {\n  type Schema,\n  clientSchemaFrom,\n} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {\n  type NameMapper,\n  clientToServer,\n} from '../../../zero-schema/src/name-mapper.ts';\nimport {customMutatorKey} from '../../../zql/src/mutate/custom.ts';\nimport {\n  type ClientMetricMap,\n  type MetricMap,\n  isClientMetric,\n} from '../../../zql/src/query/metrics-delegate.ts';\nimport type {QueryDelegate} from '../../../zql/src/query/query-delegate.ts';\nimport {\n  materialize,\n  newQuery,\n  type AnyQuery,\n} from '../../../zql/src/query/query-impl.ts';\nimport {\n  delegateSymbol,\n  type HumanReadable,\n  type MaterializeOptions,\n  type PreloadOptions,\n  type Query,\n  type QueryReturn,\n  type QueryTable,\n  type RunOptions,\n} from '../../../zql/src/query/query.ts';\nimport {nanoid} from '../util/nanoid.ts';\nimport {send} from '../util/socket.ts';\nimport {ActiveClientsManager} from './active-clients-manager.ts';\nimport * as ConnectionState from './connection-state-enum.ts';\nimport {ZeroContext} from './context.ts';\nimport {\n  type BatchMutator,\n  type CRUDMutator,\n  type DBMutator,\n  type WithCRUD,\n  makeCRUDMutate,\n  makeCRUDMutator,\n} from './crud.ts';\nimport type {\n  CustomMutatorDefs,\n  CustomMutatorImpl,\n  MakeCustomMutatorInterfaces,\n} from './custom.ts';\nimport {makeReplicacheMutator} from './custom.ts';\nimport {DeleteClientsManager} from './delete-clients-manager.ts';\nimport {shouldEnableAnalytics} from './enable-analytics.ts';\nimport {\n  type HTTPString,\n  type WSString,\n  appendPath,\n  toWSString,\n} from './http-string.ts';\nimport type {Inspector} from './inspector/types.ts';\nimport {IVMSourceBranch} from './ivm-branch.ts';\nimport {type LogOptions, createLogOptions} from './log-options.ts';\nimport {\n  DID_NOT_CONNECT_VALUE,\n  type DisconnectReason,\n  MetricManager,\n  REPORT_INTERVAL_MS,\n  type Series,\n  getLastConnectErrorValue,\n} from './metrics.ts';\nimport {MutationTracker} from './mutation-tracker.ts';\nimport type {OnErrorParameters} from './on-error.ts';\nimport type {UpdateNeededReason, ZeroOptions} from './options.ts';\nimport * as PingResult from './ping-result-enum.ts';\nimport {QueryManager} from './query-manager.ts';\nimport {\n  reloadScheduled,\n  reloadWithReason,\n  reportReloadReason,\n  resetBackoff,\n} from './reload-error-handler.ts';\nimport {\n  ServerError,\n  isAuthError,\n  isBackoffError,\n  isServerError,\n} from './server-error.ts';\nimport {getServer} from './server-option.ts';\nimport {version} from './version.ts';\nimport {ZeroLogContext} from './zero-log-context.ts';\nimport {PokeHandler} from './zero-poke-handler.ts';\nimport {ZeroRep} from './zero-rep.ts';\nimport type {ViewFactory} from '../../../zql/src/ivm/view.ts';\nimport type {TypedView} from '../../../zql/src/query/typed-view.ts';\nimport {emptyFunction} from '../../../shared/src/sentinels.ts';\n\ntype ConnectionState = Enum<typeof ConnectionState>;\ntype PingResult = Enum<typeof PingResult>;\n\nexport type NoRelations = Record<string, never>;\n\nexport type MakeEntityQueriesFromSchema<S extends Schema> = {\n  readonly [K in keyof S['tables'] & string]: Query<S, K>;\n};\n\ndeclare const TESTING: boolean;\n\nexport type TestingContext = {\n  puller: Puller;\n  pusher: Pusher;\n  setReload: (r: () => void) => void;\n  logOptions: LogOptions;\n  connectStart: () => number | undefined;\n  socketResolver: () => Resolver<WebSocket>;\n  connectionState: () => ConnectionState;\n};\n\nexport const onSetConnectionStateSymbol = Symbol();\nexport const exposedToTestingSymbol = Symbol();\nexport const createLogOptionsSymbol = Symbol();\n\ninterface TestZero {\n  [exposedToTestingSymbol]?: TestingContext;\n  [onSetConnectionStateSymbol]?: (state: ConnectionState) => void;\n  [createLogOptionsSymbol]?: (options: {\n    consoleLogLevel: LogLevel;\n    server: string | null;\n  }) => LogOptions;\n}\n\nfunction asTestZero<S extends Schema, MD extends CustomMutatorDefs | undefined>(\n  z: Zero<S, MD>,\n): TestZero {\n  return z as TestZero;\n}\n\nexport const RUN_LOOP_INTERVAL_MS = 5_000;\n\n/**\n * How frequently we should ping the server to keep the connection alive.\n */\nexport const PING_INTERVAL_MS = 5_000;\n\n/**\n * The amount of time we wait for a pong before we consider the ping timed out.\n */\nexport const PING_TIMEOUT_MS = 5_000;\n\n/**\n * The amount of time we wait for a pull response before we consider a pull\n * request timed out.\n */\nexport const PULL_TIMEOUT_MS = 5_000;\n\nexport const DEFAULT_DISCONNECT_HIDDEN_DELAY_MS = 5_000;\n\n/**\n * The amount of time we wait for a connection to be established before we\n * consider it timed out.\n */\nexport const CONNECT_TIMEOUT_MS = 10_000;\n\nconst CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY = 6;\n\nconst NULL_LAST_MUTATION_ID_SENT = {clientID: '', id: -1} as const;\n\nconst DEFAULT_QUERY_CHANGE_THROTTLE_MS = 10;\n\nfunction convertOnUpdateNeededReason(\n  reason: ReplicacheUpdateNeededReason,\n): UpdateNeededReason {\n  return {type: reason.type};\n}\n\nfunction updateNeededReloadReasonMessage(\n  reason: UpdateNeededReason,\n  serverErrMsg?: string | undefined,\n) {\n  const {type} = reason;\n  let reasonMsg = '';\n  switch (type) {\n    case 'NewClientGroup':\n      reasonMsg =\n        \"This client could not sync with a newer client. This is probably due to another tab loading a newer incompatible version of the app's code.\";\n      break;\n    case 'VersionNotSupported':\n      reasonMsg =\n        \"The server no longer supports this client's protocol version.\";\n      break;\n    case 'SchemaVersionNotSupported':\n      reasonMsg = 'Client and server schemas incompatible.';\n      break;\n    default:\n      unreachable(type);\n  }\n  if (serverErrMsg) {\n    reasonMsg += ' ' + serverErrMsg;\n  }\n  return reasonMsg;\n}\n\nconst serverAheadReloadReason = `Server reported that client is ahead of server. This probably happened because the server is in development mode and restarted. Currently when this happens, the dev server loses its state and on reconnect sees the client as ahead. If you see this in other cases, it may be a bug in Zero.`;\n\nfunction onClientStateNotFoundServerReason(serverErrMsg: string) {\n  return `Server could not find state needed to synchronize this client. ${serverErrMsg}`;\n}\nconst ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT =\n  'The local persistent state needed to synchronize this client has been garbage collected.';\n\n// Keep in sync with packages/replicache/src/replicache-options.ts\nexport interface ReplicacheInternalAPI {\n  lastMutationID(): number;\n}\n\nconst internalReplicacheImplMap = new WeakMap<object, ReplicacheImpl>();\n\nexport function getInternalReplicacheImplForTesting(\n  z: object,\n): ReplicacheImpl<MutatorDefs> {\n  assert(TESTING);\n  return must(internalReplicacheImplMap.get(z));\n}\n\nconst CLOSE_CODE_NORMAL = 1000;\nconst CLOSE_CODE_GOING_AWAY = 1001;\ntype CloseCode = typeof CLOSE_CODE_NORMAL | typeof CLOSE_CODE_GOING_AWAY;\n\nexport class Zero<\n  const S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> {\n  readonly version = version;\n\n  readonly #rep: ReplicacheImpl<WithCRUD<MutatorDefs>>;\n  readonly #server: HTTPString | null;\n  readonly userID: string;\n  readonly storageKey: string;\n\n  readonly #lc: ZeroLogContext;\n  readonly #logOptions: LogOptions;\n  readonly #enableAnalytics: boolean;\n  readonly #schema: S;\n  readonly #clientSchema: ClientSchema;\n\n  readonly #pokeHandler: PokeHandler;\n  readonly #queryManager: QueryManager;\n  readonly #ivmMain: IVMSourceBranch;\n  readonly #clientToServer: NameMapper;\n  readonly #deleteClientsManager: DeleteClientsManager;\n  readonly #mutationTracker: MutationTracker;\n\n  /**\n   * The queries we sent when inside the sec-protocol header when establishing a connection.\n   * More queries could be registered while we're waiting for the 'connected' message\n   * to come back from the server. To understand what queries we need to send\n   * to the server, we diff the `initConnectionQueries` with the current set of desired queries.\n   *\n   * If this is set to `undefined` that means no queries were sent inside the `sec-protocol` header\n   * and an `initConnection` message must be sent to the server after receiving the `connected` message.\n   */\n  #initConnectionQueries: Map<string, UpQueriesPatchOp> | undefined;\n\n  /**\n   * We try to send the deleted clients and (client groups) as part of the\n   * sec-protocol header. If we can't because the header would get too large we\n   * keep track of the deleted clients and send them after the connection is\n   * established.\n   */\n  #deletedClients: DeleteClientsBody | undefined;\n\n  #lastMutationIDSent: {clientID: string; id: number} =\n    NULL_LAST_MUTATION_ID_SENT;\n\n  #onPong: () => void = () => undefined;\n\n  readonly #onlineManager: OnlineManager;\n\n  readonly #onUpdateNeeded: (\n    reason: UpdateNeededReason,\n    serverErrorMsg?: string,\n  ) => void;\n  readonly #onClientStateNotFound: (reason?: string) => void;\n  // Last cookie used to initiate a connection\n  #connectCookie: NullableVersion = null;\n  // Total number of sockets successfully connected by this client\n  #connectedCount = 0;\n  // Number of messages received over currently connected socket.  Reset\n  // on disconnect.\n  #messageCount = 0;\n  #connectedAt = 0;\n  // Reset on successful connection.\n  #connectErrorCount = 0;\n\n  #abortPingTimeout = () => {\n    // intentionally empty\n  };\n\n  readonly #zeroContext: ZeroContext;\n  readonly queryDelegate: QueryDelegate;\n\n  #connectResolver = resolver<void>();\n  #pendingPullsByRequestID: Map<string, Resolver<PullResponseBody>> = new Map();\n  #lastMutationIDReceived = 0;\n\n  #socket: WebSocket | undefined = undefined;\n  #socketResolver = resolver<WebSocket>();\n\n  #connectionStateChangeResolver = resolver<ConnectionState>();\n\n  /**\n   * This resolver is only used for rejections. It is awaited in the connected\n   * state (including when waiting for a pong). It is rejected when we get an\n   * invalid message or an 'error' message.\n   */\n  #rejectMessageError: Resolver<never> | undefined = undefined;\n\n  #closeAbortController = new AbortController();\n\n  readonly #visibilityWatcher;\n\n  // We use an accessor pair to allow the subclass to override the setter.\n  #connectionState: ConnectionState = ConnectionState.Disconnected;\n  readonly #activeClientsManager: Promise<ActiveClientsManager>;\n\n  #setConnectionState(state: ConnectionState) {\n    if (state === this.#connectionState) {\n      return;\n    }\n\n    this.#connectionState = state;\n    this.#connectionStateChangeResolver.resolve(state);\n    this.#connectionStateChangeResolver = resolver<ConnectionState>();\n\n    if (TESTING) {\n      asTestZero(this)[onSetConnectionStateSymbol]?.(state);\n    }\n  }\n\n  #connectStart: number | undefined = undefined;\n  // Set on connect attempt if currently undefined.\n  // Reset to undefined when\n  // 1. client stops trying to connect because it is hidden\n  // 2. client encounters a connect error and canary request indicates\n  //    the client is offline\n  // 2. client successfully connects\n  #totalToConnectStart: number | undefined = undefined;\n\n  readonly #options: ZeroOptions<S, MD>;\n\n  readonly query: MakeEntityQueriesFromSchema<S>;\n\n  // TODO: Metrics needs to be rethought entirely as we're not going to\n  // send metrics to customer server.\n  #metrics: MetricManager;\n\n  // Store as field to allow test subclass to override. Web API doesn't allow\n  // overwriting location fields for security reasons.\n  #reload = () => getBrowserGlobal('location')?.reload();\n\n  /**\n   * Constructs a new Zero client.\n   */\n  constructor(options: ZeroOptions<S, MD>) {\n    const {\n      userID,\n      storageKey,\n      onOnlineChange,\n      onUpdateNeeded,\n      onClientStateNotFound,\n      hiddenTabDisconnectDelay = DEFAULT_DISCONNECT_HIDDEN_DELAY_MS,\n      schema,\n      batchViewUpdates = applyViewUpdates => applyViewUpdates(),\n      maxRecentQueries = 0,\n      slowMaterializeThreshold = 5_000,\n    } = options as ZeroOptions<S, MD>;\n    if (!userID) {\n      throw new Error('ZeroOptions.userID must not be empty.');\n    }\n    const server = getServer(options.server);\n    this.#enableAnalytics = shouldEnableAnalytics(\n      server,\n      false /*options.enableAnalytics,*/, // Reenable analytics\n    );\n\n    let {kvStore = 'idb'} = options as ZeroOptions<S, MD>;\n    if (kvStore === 'idb') {\n      if (!getBrowserGlobal('indexedDB')) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          'IndexedDB is not supported in this environment. Falling back to memory storage.',\n        );\n        kvStore = 'mem';\n      }\n    }\n\n    if (hiddenTabDisconnectDelay < 0) {\n      throw new Error(\n        'ZeroOptions.hiddenTabDisconnectDelay must not be negative.',\n      );\n    }\n\n    this.#onlineManager = new OnlineManager();\n\n    if (onOnlineChange) {\n      this.#onlineManager.subscribe(onOnlineChange);\n    }\n\n    this.#options = options;\n\n    this.#logOptions = this.#createLogOptions({\n      consoleLogLevel: options.logLevel ?? 'warn',\n      server: null, //server, // Reenable remote logging\n      enableAnalytics: this.#enableAnalytics,\n    });\n    const logOptions = this.#logOptions;\n\n    const {enableLegacyMutators = true, enableLegacyQueries = true} = schema;\n\n    const replicacheMutators: MutatorDefs & {\n      [CRUD_MUTATION_NAME]: CRUDMutator;\n    } = {\n      [CRUD_MUTATION_NAME]: enableLegacyMutators\n        ? makeCRUDMutator(schema)\n        : () =>\n            Promise.reject(new Error('Zero CRUD mutators are not enabled.')),\n    };\n    this.#ivmMain = new IVMSourceBranch(schema.tables);\n\n    function assertUnique(key: string) {\n      assert(\n        replicacheMutators[key] === undefined,\n        `A mutator, or mutator namespace, has already been defined for ${key}`,\n      );\n    }\n\n    // We create a special log sink that calls onError if defined instead of\n    // logging error messages.\n    const {onError} = options;\n    const sink = logOptions.logSink;\n    const logSink: LogSink<OnErrorParameters> = {\n      log(level, context, ...args) {\n        if (level === 'error' && onError) {\n          onError(...(args as OnErrorParameters));\n        } else {\n          sink.log(level, context, ...args);\n        }\n      },\n      async flush() {\n        await sink.flush?.();\n      },\n    };\n\n    const lc = new ZeroLogContext(logOptions.logLevel, {}, logSink);\n\n    this.#mutationTracker = new MutationTracker(lc, (upTo: MutationID) =>\n      this.#send(['ackMutationResponses', upTo]),\n    );\n    if (options.mutators) {\n      for (const [namespaceOrKey, mutatorOrMutators] of Object.entries(\n        options.mutators,\n      )) {\n        if (typeof mutatorOrMutators === 'function') {\n          const key = namespaceOrKey as string;\n          assertUnique(key);\n          replicacheMutators[key] = makeReplicacheMutator(\n            lc,\n            mutatorOrMutators,\n            schema,\n            // Replicache expects mutators to only be able to return JSON\n            // but Zero wraps the return with: `{server?: Promise<MutationResult>, client?: T}`\n          ) as () => MutatorReturn;\n          continue;\n        }\n        if (typeof mutatorOrMutators === 'object') {\n          for (const [name, mutator] of Object.entries(mutatorOrMutators)) {\n            const key = customMutatorKey(\n              namespaceOrKey as string,\n              name as string,\n            );\n            assertUnique(key);\n            replicacheMutators[key] = makeReplicacheMutator(\n              lc,\n              mutator as CustomMutatorImpl<S>,\n              schema,\n            ) as () => MutatorReturn;\n          }\n          continue;\n        }\n        unreachable(mutatorOrMutators);\n      }\n    }\n\n    this.storageKey = storageKey ?? '';\n\n    this.#schema = schema;\n    const {clientSchema, hash} = clientSchemaFrom(schema);\n    this.#clientSchema = clientSchema;\n\n    const replicacheOptions: ReplicacheOptions<WithCRUD<MutatorDefs>> = {\n      // The schema stored in IDB is dependent upon both the ClientSchema\n      // and the AST schema (i.e. PROTOCOL_VERSION).\n      schemaVersion: `${PROTOCOL_VERSION}.${hash}`,\n      logLevel: logOptions.logLevel,\n      logSinks: [logOptions.logSink],\n      mutators: replicacheMutators,\n      name: `zero-${userID}-${this.storageKey}`,\n      pusher: (req, reqID) => this.#pusher(req, reqID),\n      puller: (req, reqID) => this.#puller(req, reqID),\n      pushDelay: 0,\n      requestOptions: {\n        maxDelayMs: 0,\n        minDelayMs: 0,\n      },\n      licenseKey: 'zero-client-static-key',\n      kvStore,\n    };\n\n    this.#zeroContext = new ZeroContext(\n      lc,\n      this.#ivmMain,\n      (ast, ttl, gotCallback) => {\n        if (enableLegacyQueries) {\n          return this.#queryManager.addLegacy(ast, ttl, gotCallback);\n        }\n        // legacy queries are client side only. Do not track with the server\n        return emptyFunction;\n      },\n      (ast, customQueryID, ttl, gotCallback) =>\n        this.#queryManager.addCustom(ast, customQueryID, ttl, gotCallback),\n      (ast, ttl) => {\n        if (enableLegacyQueries) {\n          this.#queryManager.updateLegacy(ast, ttl);\n          return;\n        }\n        this.#queryManager.updateLegacy(ast, ttl);\n      },\n      (customQueryID, ttl) =>\n        this.#queryManager.updateCustom(customQueryID, ttl),\n      () => this.#queryManager.flushBatch(),\n      batchViewUpdates,\n      this.#addMetric,\n      assertValidRunOptions,\n    );\n    this.queryDelegate = this.#zeroContext;\n\n    const replicacheImplOptions: ReplicacheImplOptions = {\n      enableClientGroupForking: false,\n      enableMutationRecovery: false,\n      enablePullAndPushInOpen: false, // Zero calls push in its connection management code\n      onClientsDeleted: (clientIDs, clientGroupIDs) =>\n        this.#deleteClientsManager.onClientsDeleted(clientIDs, clientGroupIDs),\n      zero: new ZeroRep(\n        this.#zeroContext,\n        this.#ivmMain,\n        options.mutators !== undefined,\n        this.#mutationTracker,\n      ),\n    };\n\n    const rep = new ReplicacheImpl(replicacheOptions, replicacheImplOptions);\n    this.#rep = rep;\n\n    if (TESTING) {\n      internalReplicacheImplMap.set(this, rep);\n    }\n    this.#server = server;\n    this.userID = userID;\n    this.#lc = lc.withContext('clientID', rep.clientID);\n    this.#mutationTracker.setClientIDAndWatch(\n      rep.clientID,\n      rep.experimentalWatch.bind(rep),\n    );\n\n    this.#activeClientsManager = makeActiveClientsManager(\n      rep.clientGroupID,\n      this.clientID,\n      this.#closeAbortController.signal,\n      (clientID: string) =>\n        this.#deleteClientsManager.onClientsDeleted([clientID], []),\n    );\n\n    const onUpdateNeededCallback = (\n      reason: UpdateNeededReason,\n      serverErrorMsg?: string | undefined,\n    ) => {\n      if (onUpdateNeeded) {\n        onUpdateNeeded(reason);\n      } else {\n        reloadWithReason(\n          this.#lc,\n          this.#reload,\n          reason.type,\n          updateNeededReloadReasonMessage(reason, serverErrorMsg),\n        );\n      }\n    };\n    this.#onUpdateNeeded = onUpdateNeededCallback;\n    this.#rep.onUpdateNeeded = reason => {\n      onUpdateNeededCallback(convertOnUpdateNeededReason(reason));\n    };\n\n    const onClientStateNotFoundCallback =\n      onClientStateNotFound ??\n      ((reason?: string) => {\n        reloadWithReason(\n          this.#lc,\n          this.#reload,\n          ErrorKind.ClientNotFound,\n          reason ?? ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT,\n        );\n      });\n    this.#onClientStateNotFound = onClientStateNotFoundCallback;\n    this.#rep.onClientStateNotFound = onClientStateNotFoundCallback;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const {mutate, mutateBatch} = makeCRUDMutate<S>(schema, rep.mutate) as any;\n\n    if (options.mutators) {\n      for (const [namespaceOrKey, mutatorsOrMutator] of Object.entries(\n        options.mutators,\n      )) {\n        if (typeof mutatorsOrMutator === 'function') {\n          mutate[namespaceOrKey] = must(rep.mutate[namespaceOrKey as string]);\n          continue;\n        }\n\n        let existing = mutate[namespaceOrKey];\n        if (existing === undefined) {\n          existing = {};\n          mutate[namespaceOrKey] = existing;\n        }\n\n        for (const name of Object.keys(mutatorsOrMutator)) {\n          existing[name] = must(\n            rep.mutate[customMutatorKey(namespaceOrKey as string, name)],\n          );\n        }\n      }\n    }\n\n    this.mutate = mutate;\n    this.mutateBatch = mutateBatch;\n\n    this.#queryManager = new QueryManager(\n      this.#lc,\n      this.#mutationTracker,\n      rep.clientID,\n      schema.tables,\n      msg => this.#send(msg),\n      rep.experimentalWatch.bind(rep),\n      maxRecentQueries,\n      options.queryChangeThrottleMs ?? DEFAULT_QUERY_CHANGE_THROTTLE_MS,\n      slowMaterializeThreshold,\n    );\n    this.#clientToServer = clientToServer(schema.tables);\n\n    this.#deleteClientsManager = new DeleteClientsManager(\n      msg => this.#send(msg),\n      rep.perdag,\n      this.#lc,\n    );\n\n    this.query = this.#registerQueries(schema);\n\n    reportReloadReason(this.#lc);\n\n    this.#metrics = new MetricManager({\n      reportIntervalMs: REPORT_INTERVAL_MS,\n      host: getBrowserGlobal('location')?.host ?? '',\n      source: 'client',\n      reporter: this.#enableAnalytics\n        ? allSeries => this.#reportMetrics(allSeries)\n        : () => Promise.resolve(),\n      lc: this.#lc,\n    });\n    this.#metrics.tags.push(`version:${this.version}`);\n\n    this.#pokeHandler = new PokeHandler(\n      poke => this.#rep.poke(poke),\n      () => this.#onPokeError(),\n      rep.clientID,\n      schema,\n      this.#lc,\n      this.#mutationTracker,\n    );\n\n    this.#visibilityWatcher = getDocumentVisibilityWatcher(\n      getBrowserGlobal('document'),\n      hiddenTabDisconnectDelay,\n      this.#closeAbortController.signal,\n    );\n\n    void this.#runLoop();\n\n    this.#expose();\n\n    if (TESTING) {\n      asTestZero(this)[exposedToTestingSymbol] = {\n        puller: this.#puller,\n        pusher: this.#pusher,\n        setReload: (r: () => void) => {\n          this.#reload = r;\n        },\n        logOptions: this.#logOptions,\n        connectStart: () => this.#connectStart,\n        socketResolver: () => this.#socketResolver,\n        connectionState: () => this.#connectionState,\n      };\n    }\n  }\n\n  #expose() {\n    // Expose the Zero instance to the global scope.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const g = globalThis as any;\n    if (g.__zero === undefined) {\n      g.__zero = this;\n    } else if (g.__zero instanceof Zero) {\n      const prev = g.__zero;\n      g.__zero = {\n        [prev.clientID]: prev,\n        [this.clientID]: this,\n      };\n    } else {\n      g.__zero[this.clientID] = this;\n    }\n  }\n\n  #unexpose() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const g = globalThis as any;\n    assert(g.__zero !== undefined);\n    if (g.__zero instanceof Zero) {\n      assert(g.__zero === this);\n      delete g.__zero;\n    } else {\n      delete g.__zero[this.clientID];\n      if (Object.entries(g.__zero).length === 1) {\n        g.__zero = Object.values(g.__zero)[0];\n      }\n    }\n  }\n\n  #send(msg: Upstream): void {\n    if (this.#socket && this.#connectionState === ConnectionState.Connected) {\n      send(this.#socket, msg);\n    }\n  }\n\n  #createLogOptions(options: {\n    consoleLogLevel: LogLevel;\n    server: HTTPString | null;\n    enableAnalytics: boolean;\n  }): LogOptions {\n    if (TESTING) {\n      const testZero = asTestZero(this);\n      if (testZero[createLogOptionsSymbol]) {\n        return testZero[createLogOptionsSymbol](options);\n      }\n    }\n    return createLogOptions(options);\n  }\n\n  preload(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    query: Query<S, keyof S['tables'] & string, any>,\n    options?: PreloadOptions | undefined,\n  ) {\n    return query[delegateSymbol](this.#zeroContext).preload(options);\n  }\n\n  run<Q>(\n    query: Q,\n    runOptions?: RunOptions | undefined,\n  ): Promise<HumanReadable<QueryReturn<Q>>> {\n    return (\n      (query as AnyQuery)\n        // eslint-disable-next-line no-unexpected-multiline\n        [delegateSymbol](this.#zeroContext)\n        .run(runOptions) as Promise<HumanReadable<QueryReturn<Q>>>\n    );\n  }\n\n  materialize<Q>(\n    query: Q,\n    options?: MaterializeOptions | undefined,\n  ): TypedView<HumanReadable<QueryReturn<Q>>>;\n  materialize<T, Q>(\n    query: Q,\n    factory: ViewFactory<S, QueryTable<Q>, QueryReturn<Q>, T>,\n    options?: MaterializeOptions | undefined,\n  ): T;\n  materialize<T, Q>(\n    query: Q,\n    factoryOrOptions?:\n      | ViewFactory<S, QueryTable<Q>, QueryReturn<Q>, T>\n      | MaterializeOptions\n      | undefined,\n    maybeOptions?: MaterializeOptions | undefined,\n  ) {\n    return materialize(\n      query,\n      this.#zeroContext,\n      factoryOrOptions,\n      maybeOptions,\n    );\n  }\n\n  /**\n   * The server URL that this Zero instance is configured with.\n   */\n  get server(): HTTPString | null {\n    return this.#server;\n  }\n\n  /**\n   * The name of the IndexedDB database in which the data of this\n   * instance of Zero is stored.\n   */\n  get idbName(): string {\n    return this.#rep.idbName;\n  }\n\n  /**\n   * The schema version of the data understood by this application.\n   * See [[ZeroOptions.schemaVersion]].\n   */\n  get schemaVersion(): string {\n    return this.#rep.schemaVersion;\n  }\n\n  /**\n   * The client ID for this instance of Zero. Each instance\n   * gets a unique client ID.\n   */\n  get clientID(): ClientID {\n    return this.#rep.clientID;\n  }\n\n  get clientGroupID(): Promise<ClientGroupID> {\n    return this.#rep.clientGroupID;\n  }\n\n  /**\n   * Provides simple \"CRUD\" mutations for the tables in the schema.\n   *\n   * Each table has `create`, `set`, `update`, and `delete` methods.\n   *\n   * ```ts\n   * await zero.mutate.issue.create({id: '1', title: 'First issue', priority: 'high'});\n   * await zero.mutate.comment.create({id: '1', text: 'First comment', issueID: '1'});\n   * ```\n   *\n   * The `update` methods support partials. Unspecified or `undefined` fields\n   * are left unchanged:\n   *\n   * ```ts\n   * // Priority left unchanged.\n   * await zero.mutate.issue.update({id: '1', title: 'Updated title'});\n   * ```\n   */\n  readonly mutate: MD extends CustomMutatorDefs\n    ? S['enableLegacyMutators'] extends false\n      ? MakeCustomMutatorInterfaces<S, MD>\n      : DeepMerge<DBMutator<S>, MakeCustomMutatorInterfaces<S, MD>>\n    : DBMutator<S>;\n\n  /**\n   * Provides a way to batch multiple CRUD mutations together:\n   *\n   * ```ts\n   * await zero.mutateBatch(m => {\n   *   await m.issue.create({id: '1', title: 'First issue'});\n   *   await m.comment.create({id: '1', text: 'First comment', issueID: '1'});\n   * });\n   * ```\n   *\n   * Batch sends all mutations in a single transaction. If one fails, all are\n   * rolled back together. Batch can also be more efficient than making many\n   * individual mutations.\n   *\n   * `mutateBatch` is not allowed inside another `mutateBatch` call. Doing so\n   * will throw an error.\n   */\n  readonly mutateBatch: BatchMutator<S>;\n\n  /**\n   * Whether this Zero instance has been closed.\n   *\n   * Once a Zero instance has been closed it no longer syncs, you can no\n   * longer query or mutate data with it, and its query views stop updating.\n   */\n  get closed(): boolean {\n    return this.#rep.closed;\n  }\n\n  /**\n   * Closes this Zero instance.\n   *\n   * Once a Zero instance has been closed it no longer syncs, you can no\n   * longer query or mutate data with it, and its query views stop updating.\n   */\n  async close(): Promise<void> {\n    const lc = this.#lc.withContext('close');\n\n    lc.debug?.('Closing Zero instance. Stack:', new Error().stack);\n\n    this.#onlineManager.cleanup();\n\n    if (this.#connectionState !== ConnectionState.Disconnected) {\n      this.#disconnect(\n        lc,\n        {\n          client: 'ClientClosed',\n        },\n        CLOSE_CODE_NORMAL,\n      );\n    }\n    lc.debug?.('Aborting closeAbortController due to close()');\n    this.#closeAbortController.abort();\n    this.#metrics.stop();\n    const ret = await this.#rep.close();\n    this.#unexpose();\n    return ret;\n  }\n\n  #onMessage = (e: MessageEvent<string>) => {\n    const lc = this.#lc;\n    lc.debug?.('received message', e.data);\n    if (this.closed) {\n      lc.debug?.('ignoring message because already closed');\n      return;\n    }\n\n    const rejectInvalidMessage = (e?: unknown) =>\n      this.#rejectMessageError?.reject(\n        new Error(\n          `Invalid message received from server: ${\n            e instanceof Error ? e.message + '. ' : ''\n          }${data}`,\n        ),\n      );\n\n    let downMessage: Downstream;\n    const {data} = e;\n    try {\n      downMessage = valita.parse(\n        JSON.parse(data),\n        downstreamSchema,\n        'passthrough',\n      );\n    } catch (e) {\n      rejectInvalidMessage(e);\n      return;\n    }\n    this.#messageCount++;\n    const msgType = downMessage[0];\n    switch (msgType) {\n      case 'connected':\n        return this.#handleConnectedMessage(lc, downMessage);\n\n      case 'error':\n        return this.#handleErrorMessage(lc, downMessage);\n\n      case 'pong':\n        // Receiving a pong means that the connection is healthy, as the\n        // initial schema / versioning negotiations would produce an error\n        // before a ping-pong timeout.\n        resetBackoff();\n        return this.#onPong();\n\n      case 'pokeStart':\n        return this.#handlePokeStart(lc, downMessage);\n\n      case 'pokePart':\n        if (downMessage[1].rowsPatch) {\n          // Receiving row data indicates that the client is in a good state\n          // and can reset the reload backoff state.\n          resetBackoff();\n        }\n        return this.#handlePokePart(lc, downMessage);\n\n      case 'pokeEnd':\n        return this.#handlePokeEnd(lc, downMessage);\n\n      case 'pull':\n        return this.#handlePullResponse(lc, downMessage);\n\n      case 'deleteClients':\n        return this.#deleteClientsManager.clientsDeletedOnServer(\n          downMessage[1],\n        );\n\n      case 'pushResponse':\n        return this.#mutationTracker.processPushResponse(downMessage[1]);\n\n      case 'transformError':\n        // this.#queryManager.handleTransformError();\n        break;\n\n      case 'inspect':\n        // ignore at this layer.\n        break;\n\n      default:\n        msgType satisfies never;\n        rejectInvalidMessage();\n    }\n  };\n\n  #onOpen = () => {\n    const l = addWebSocketIDFromSocketToLogContext(this.#socket!, this.#lc);\n    if (this.#connectStart === undefined) {\n      l.error?.('Got open event but connect start time is undefined.');\n    } else {\n      const now = Date.now();\n      const timeToOpenMs = now - this.#connectStart;\n      l.info?.('Got socket open event', {\n        navigatorOnline: navigator?.onLine,\n        timeToOpenMs,\n      });\n    }\n  };\n\n  #onClose = (e: CloseEvent) => {\n    const lc = addWebSocketIDFromSocketToLogContext(this.#socket!, this.#lc);\n    const {code, reason, wasClean} = e;\n    if (code <= 1001) {\n      lc.info?.('Got socket close event', {code, reason, wasClean});\n    } else {\n      lc.error?.('Got unexpected socket close event', {\n        code,\n        reason,\n        wasClean,\n      });\n    }\n\n    const closeKind = wasClean ? 'CleanClose' : 'AbruptClose';\n    this.#connectResolver.reject(new CloseError(closeKind));\n    this.#disconnect(lc, {client: closeKind});\n  };\n\n  // An error on the connection is fatal for the connection.\n  async #handleErrorMessage(\n    lc: ZeroLogContext,\n    downMessage: ErrorMessage,\n  ): Promise<void> {\n    const [, {kind, message}] = downMessage;\n\n    // Rate limit errors are not fatal to the connection.\n    // We really don't want to disconnect and reconnect a rate limited user as\n    // it'll use more resources on the server\n    if (kind === ErrorKind.MutationRateLimited) {\n      this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;\n      lc.error?.(kind, 'Mutation rate limited', {message});\n      return;\n    }\n\n    lc.info?.(`${kind}: ${message}}`);\n    const error = new ServerError(downMessage[1]);\n\n    this.#rejectMessageError?.reject(error);\n    lc.debug?.('Rejecting connect resolver due to error', error);\n    this.#connectResolver.reject(error);\n    this.#disconnect(lc, {server: kind});\n\n    if (kind === ErrorKind.VersionNotSupported) {\n      this.#onUpdateNeeded?.({type: kind}, message);\n    } else if (kind === ErrorKind.SchemaVersionNotSupported) {\n      await this.#rep.disableClientGroup();\n      this.#onUpdateNeeded?.({type: 'SchemaVersionNotSupported'}, message);\n    } else if (kind === ErrorKind.ClientNotFound) {\n      await this.#rep.disableClientGroup();\n      this.#onClientStateNotFound?.(onClientStateNotFoundServerReason(message));\n    } else if (\n      kind === ErrorKind.InvalidConnectionRequestLastMutationID ||\n      kind === ErrorKind.InvalidConnectionRequestBaseCookie\n    ) {\n      await dropDatabase(this.#rep.idbName);\n      reloadWithReason(lc, this.#reload, kind, serverAheadReloadReason);\n    }\n  }\n\n  async #handleConnectedMessage(\n    lc: ZeroLogContext,\n    connectedMessage: ConnectedMessage,\n  ): Promise<void> {\n    const now = Date.now();\n    const [, connectBody] = connectedMessage;\n    lc = addWebSocketIDToLogContext(connectBody.wsid, lc);\n\n    if (this.#connectedCount === 0) {\n      this.#checkConnectivity('firstConnect');\n    } else if (this.#connectErrorCount > 0) {\n      this.#checkConnectivity('connectAfterError');\n    }\n    this.#connectedCount++;\n    this.#connectedAt = now;\n    this.#metrics.lastConnectError.clear();\n    const proceedingConnectErrorCount = this.#connectErrorCount;\n    this.#connectErrorCount = 0;\n\n    let timeToConnectMs: number | undefined;\n    let connectMsgLatencyMs: number | undefined;\n    if (this.#connectStart === undefined) {\n      lc.error?.('Got connected message but connect start time is undefined.');\n    } else {\n      timeToConnectMs = now - this.#connectStart;\n      this.#metrics.timeToConnectMs.set(timeToConnectMs);\n      connectMsgLatencyMs =\n        connectBody.timestamp !== undefined\n          ? now - connectBody.timestamp\n          : undefined;\n      this.#connectStart = undefined;\n    }\n    let totalTimeToConnectMs: number | undefined;\n    if (this.#totalToConnectStart === undefined) {\n      lc.error?.(\n        'Got connected message but total to connect start time is undefined.',\n      );\n    } else {\n      totalTimeToConnectMs = now - this.#totalToConnectStart;\n      this.#totalToConnectStart = undefined;\n    }\n\n    this.#metrics.setConnected(timeToConnectMs ?? 0, totalTimeToConnectMs ?? 0);\n\n    lc.info?.('Connected', {\n      navigatorOnline: navigator?.onLine,\n      timeToConnectMs,\n      totalTimeToConnectMs,\n      connectMsgLatencyMs,\n      connectedCount: this.#connectedCount,\n      proceedingConnectErrorCount,\n    });\n    this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;\n\n    lc.debug?.('Resolving connect resolver');\n    const socket = must(this.#socket);\n    const queriesPatch = await this.#rep.query(tx =>\n      this.#queryManager.getQueriesPatch(tx, this.#initConnectionQueries),\n    );\n\n    const hasDeletedClients = () =>\n      skipEmptyArray(this.#deletedClients?.clientIDs) ||\n      skipEmptyArray(this.#deletedClients?.clientGroupIDs);\n\n    const maybeSendDeletedClients = () => {\n      if (hasDeletedClients()) {\n        send(socket, ['deleteClients', this.#deletedClients!]);\n        this.#deletedClients = undefined;\n      }\n    };\n\n    if (queriesPatch.size > 0 && this.#initConnectionQueries !== undefined) {\n      maybeSendDeletedClients();\n      send(socket, [\n        'changeDesiredQueries',\n        {\n          desiredQueriesPatch: [...queriesPatch.values()],\n        },\n      ]);\n    } else if (this.#initConnectionQueries === undefined) {\n      // if #initConnectionQueries was undefined that means we never\n      // sent `initConnection` to the server inside the sec-protocol header.\n      const clientSchema = this.#clientSchema;\n      send(socket, [\n        'initConnection',\n        {\n          desiredQueriesPatch: [...queriesPatch.values()],\n          deleted: skipEmptyDeletedClients(this.#deletedClients),\n          // The clientSchema only needs to be sent for the very first request.\n          // Henceforth it is stored with the CVR and verified automatically.\n          ...(this.#connectCookie === null ? {clientSchema} : {}),\n          userPushParams: this.#options.mutate ?? this.#options.push,\n          userQueryParams: this.#options.query,\n        },\n      ]);\n      this.#deletedClients = undefined;\n    }\n    this.#initConnectionQueries = undefined;\n\n    maybeSendDeletedClients();\n\n    this.#setConnectionState(ConnectionState.Connected);\n    this.#connectResolver.resolve();\n  }\n\n  /**\n   * Starts a new connection. This will create the WebSocket that does the HTTP\n   * request to the server.\n   *\n   * {@link #connect} will throw an assertion error if the\n   * {@link #connectionState} is not {@link ConnectionState.Disconnected}.\n   * Callers MUST check the connection state before calling this method and log\n   * an error as needed.\n   *\n   * The function will resolve once the socket is connected. If you need to know\n   * when a connection has been established, as in we have received the\n   * {@link ConnectedMessage}, you should await the {@link #connectResolver}\n   * promise. The {@link #connectResolver} promise rejects if an error message\n   * is received before the connected message is received or if the connection\n   * attempt times out.\n   */\n  async #connect(\n    lc: ZeroLogContext,\n    additionalConnectParams: Record<string, string> | undefined,\n  ): Promise<void> {\n    assert(this.#server);\n\n    // All the callers check this state already.\n    assert(this.#connectionState === ConnectionState.Disconnected);\n\n    const wsid = nanoid();\n    lc = addWebSocketIDToLogContext(wsid, lc);\n    lc.info?.('Connecting...', {navigatorOnline: navigator?.onLine});\n\n    this.#setConnectionState(ConnectionState.Connecting);\n\n    // connect() called but connect start time is defined. This should not\n    // happen.\n    assert(this.#connectStart === undefined);\n\n    const now = Date.now();\n    this.#connectStart = now;\n    if (this.#totalToConnectStart === undefined) {\n      this.#totalToConnectStart = now;\n    }\n\n    if (this.closed) {\n      return;\n    }\n    this.#connectCookie = valita.parse(\n      await this.#rep.cookie,\n      nullableVersionSchema,\n      'passthrough',\n    );\n    if (this.closed) {\n      return;\n    }\n\n    // Reject connect after a timeout.\n    const timeoutID = setTimeout(() => {\n      lc.debug?.('Rejecting connect resolver due to timeout');\n      this.#connectResolver.reject(new TimedOutError('Connect'));\n      this.#disconnect(lc, {\n        client: 'ConnectTimeout',\n      });\n    }, CONNECT_TIMEOUT_MS);\n    const abortHandler = () => {\n      clearTimeout(timeoutID);\n    };\n    // signal.aborted cannot be true here because we checked for `this.closed` above.\n    this.#closeAbortController.signal.addEventListener('abort', abortHandler);\n\n    const [ws, initConnectionQueries, deletedClients] = await createSocket(\n      this.#rep,\n      this.#queryManager,\n      this.#deleteClientsManager,\n      toWSString(this.#server),\n      this.#connectCookie,\n      this.clientID,\n      await this.clientGroupID,\n      this.#clientSchema,\n      this.userID,\n      this.#rep.auth,\n      this.#lastMutationIDReceived,\n      wsid,\n      this.#options.logLevel === 'debug',\n      lc,\n      this.#options.mutate ?? this.#options.push,\n      this.#options.query,\n      this.#options.maxHeaderLength,\n      additionalConnectParams,\n      await this.#activeClientsManager,\n    );\n\n    if (this.closed) {\n      return;\n    }\n\n    this.#initConnectionQueries = initConnectionQueries;\n    this.#deletedClients = deletedClients;\n    ws.addEventListener('message', this.#onMessage);\n    ws.addEventListener('open', this.#onOpen);\n    ws.addEventListener('close', this.#onClose);\n    this.#socket = ws;\n    this.#socketResolver.resolve(ws);\n\n    try {\n      lc.debug?.('Waiting for connection to be acknowledged');\n      await this.#connectResolver.promise;\n      this.#mutationTracker.onConnected(this.#lastMutationIDReceived);\n      // push any outstanding mutations on reconnect.\n      this.#rep.push().catch(() => {});\n    } finally {\n      clearTimeout(timeoutID);\n      this.#closeAbortController.signal.removeEventListener(\n        'abort',\n        abortHandler,\n      );\n    }\n  }\n\n  #disconnect(\n    lc: ZeroLogContext,\n    reason: DisconnectReason,\n    closeCode?: CloseCode,\n  ): void {\n    if (this.#connectionState === ConnectionState.Connecting) {\n      this.#connectErrorCount++;\n    }\n    lc.info?.('disconnecting', {\n      navigatorOnline: navigator?.onLine,\n      reason,\n      connectStart: this.#connectStart,\n      totalToConnectStart: this.#totalToConnectStart,\n      connectedAt: this.#connectedAt,\n      connectionDuration: this.#connectedAt\n        ? Date.now() - this.#connectedAt\n        : 0,\n      messageCount: this.#messageCount,\n      connectionState: this.#connectionState,\n      connectErrorCount: this.#connectErrorCount,\n    });\n\n    switch (this.#connectionState) {\n      case ConnectionState.Connected: {\n        if (this.#connectStart !== undefined) {\n          lc.error?.(\n            'disconnect() called while connected but connect start time is defined.',\n          );\n          // this._connectStart reset below.\n        }\n\n        break;\n      }\n      case ConnectionState.Connecting: {\n        this.#metrics.lastConnectError.set(getLastConnectErrorValue(reason));\n        this.#metrics.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n        this.#metrics.setConnectError(reason);\n        if (\n          this.#connectErrorCount % CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY ===\n          1\n        ) {\n          this.#checkConnectivity(\n            `connectErrorCount=${this.#connectErrorCount}`,\n          );\n        }\n        // this._connectStart reset below.\n        if (this.#connectStart === undefined) {\n          lc.error?.(\n            'disconnect() called while connecting but connect start time is undefined.',\n          );\n        }\n\n        break;\n      }\n      case ConnectionState.Disconnected:\n        lc.error?.('disconnect() called while disconnected');\n        break;\n    }\n\n    this.#socketResolver = resolver();\n    lc.debug?.('Creating new connect resolver');\n    this.#connectResolver = resolver();\n    this.#setConnectionState(ConnectionState.Disconnected);\n    this.#messageCount = 0;\n    this.#connectStart = undefined; // don't reset this._totalToConnectStart\n    this.#connectedAt = 0;\n    this.#socket?.removeEventListener('message', this.#onMessage);\n    this.#socket?.removeEventListener('open', this.#onOpen);\n    this.#socket?.removeEventListener('close', this.#onClose);\n    this.#socket?.close(closeCode);\n    this.#socket = undefined;\n    this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;\n    this.#pokeHandler.handleDisconnect();\n  }\n\n  #handlePokeStart(_lc: ZeroLogContext, pokeMessage: PokeStartMessage): void {\n    this.#abortPingTimeout();\n    this.#pokeHandler.handlePokeStart(pokeMessage[1]);\n  }\n\n  #handlePokePart(_lc: ZeroLogContext, pokeMessage: PokePartMessage): void {\n    this.#abortPingTimeout();\n    const lastMutationIDChangeForSelf = this.#pokeHandler.handlePokePart(\n      pokeMessage[1],\n    );\n    if (lastMutationIDChangeForSelf !== undefined) {\n      this.#lastMutationIDReceived = lastMutationIDChangeForSelf;\n    }\n  }\n\n  #handlePokeEnd(_lc: ZeroLogContext, pokeMessage: PokeEndMessage): void {\n    this.#abortPingTimeout();\n    this.#pokeHandler.handlePokeEnd(pokeMessage[1]);\n  }\n\n  #onPokeError(): void {\n    const lc = this.#lc;\n    lc.info?.(\n      'poke error, disconnecting?',\n      this.#connectionState !== ConnectionState.Disconnected,\n    );\n\n    // It is theoretically possible that we get disconnected during the\n    // async poke above. Only disconnect if we are not already\n    // disconnected.\n    if (this.#connectionState !== ConnectionState.Disconnected) {\n      this.#disconnect(lc, {\n        client: 'UnexpectedBaseCookie',\n      });\n    }\n  }\n\n  #handlePullResponse(\n    lc: ZeroLogContext,\n    pullResponseMessage: PullResponseMessage,\n  ): void {\n    this.#abortPingTimeout();\n    const body = pullResponseMessage[1];\n    lc = lc.withContext('requestID', body.requestID);\n    lc.debug?.('Handling pull response', body);\n    const resolver = this.#pendingPullsByRequestID.get(body.requestID);\n    if (!resolver) {\n      // This can happen because resolvers are deleted\n      // from this._pendingPullsByRequestID when pulls timeout.\n      lc.debug?.('No resolver found');\n      return;\n    }\n    resolver.resolve(pullResponseMessage[1]);\n  }\n\n  async #pusher(req: PushRequest, requestID: string): Promise<PusherResult> {\n    // The deprecation of pushVersion 0 predates zero-client\n    assert(req.pushVersion === 1);\n    // If we are connecting we wait until we are connected.\n    await this.#connectResolver.promise;\n    const lc = this.#lc.withContext('requestID', requestID);\n    lc.debug?.(`pushing ${req.mutations.length} mutations`);\n    const socket = this.#socket;\n    assert(socket);\n\n    const isMutationRecoveryPush =\n      req.clientGroupID !== (await this.clientGroupID);\n    const start = isMutationRecoveryPush\n      ? 0\n      : req.mutations.findIndex(\n          m =>\n            m.clientID === this.#lastMutationIDSent.clientID &&\n            m.id === this.#lastMutationIDSent.id,\n        ) + 1;\n    lc.debug?.(\n      isMutationRecoveryPush ? 'pushing for recovery' : 'pushing',\n      req.mutations.length - start,\n      'mutations of',\n      req.mutations.length,\n      'mutations.',\n    );\n    const now = Date.now();\n    for (let i = start; i < req.mutations.length; i++) {\n      const m = req.mutations[i];\n      const timestamp = now - Math.round(performance.now() - m.timestamp);\n      const zeroM =\n        m.name === CRUD_MUTATION_NAME\n          ? ({\n              type: MutationType.CRUD,\n              timestamp,\n              id: m.id,\n              clientID: m.clientID,\n              name: m.name,\n              args: [mapCRUD(m.args as CRUDMutationArg, this.#clientToServer)],\n            } satisfies CRUDMutation)\n          : ({\n              type: MutationType.Custom,\n              timestamp,\n              id: m.id,\n              clientID: m.clientID,\n              name: m.name,\n              args: [m.args],\n            } satisfies CustomMutation);\n      const msg: PushMessage = [\n        'push',\n        {\n          timestamp: now,\n          clientGroupID: req.clientGroupID,\n          mutations: [zeroM],\n          pushVersion: req.pushVersion,\n          requestID,\n        },\n      ];\n      send(socket, msg);\n      if (!isMutationRecoveryPush) {\n        this.#lastMutationIDSent = {clientID: m.clientID, id: m.id};\n      }\n    }\n    return {\n      httpRequestInfo: {\n        errorMessage: '',\n        httpStatusCode: 200,\n      },\n    };\n  }\n\n  async #updateAuthToken(\n    lc: ZeroLogContext,\n    error?: 'invalid-token',\n  ): Promise<void> {\n    const {auth: authOption} = this.#options;\n    const auth = await (typeof authOption === 'function'\n      ? authOption(error)\n      : authOption);\n    if (auth) {\n      lc.debug?.('Got auth token');\n      this.#rep.auth = auth;\n    }\n  }\n\n  async #runLoop() {\n    this.#lc.info?.(`Starting Zero version: ${this.version}`);\n\n    if (this.#server === null) {\n      this.#lc.info?.('No socket origin provided, not starting connect loop.');\n      return;\n    }\n\n    let runLoopCounter = 0;\n    const bareLogContext = this.#lc;\n    const getLogContext = () => {\n      let lc = bareLogContext;\n      if (this.#socket) {\n        lc = addWebSocketIDFromSocketToLogContext(this.#socket, lc);\n      }\n      return lc.withContext('runLoopCounter', runLoopCounter);\n    };\n\n    await this.#updateAuthToken(bareLogContext);\n\n    let needsReauth = false;\n    let gotError = false;\n    let backoffMs = RUN_LOOP_INTERVAL_MS;\n    let additionalConnectParams: Record<string, string> | undefined;\n\n    while (!this.closed) {\n      runLoopCounter++;\n      let lc = getLogContext();\n      backoffMs = RUN_LOOP_INTERVAL_MS;\n\n      try {\n        switch (this.#connectionState) {\n          case ConnectionState.Disconnected: {\n            if (this.#visibilityWatcher.visibilityState === 'hidden') {\n              this.#metrics.setDisconnectedWaitingForVisible();\n              // reset this._totalToConnectStart since this client\n              // is no longer trying to connect due to being hidden.\n              this.#totalToConnectStart = undefined;\n            }\n            // If hidden, we wait for the tab to become visible before trying again.\n            await this.#visibilityWatcher.waitForVisible();\n\n            // If we got an auth error we try to get a new auth token before reconnecting.\n            if (needsReauth) {\n              await this.#updateAuthToken(lc, 'invalid-token');\n            }\n\n            // If a reload is pending, do not try to reconnect.\n            if (reloadScheduled()) {\n              break;\n            }\n\n            await this.#connect(lc, additionalConnectParams);\n            additionalConnectParams = undefined;\n            if (this.closed) {\n              break;\n            }\n\n            // Now we have a new socket, update lc with the new wsid.\n            assert(this.#socket);\n            lc = getLogContext();\n\n            lc.debug?.('Connected successfully');\n            gotError = false;\n            needsReauth = false;\n            this.#setOnline(true);\n            break;\n          }\n\n          case ConnectionState.Connecting:\n            // Can't get here because Disconnected waits for Connected or\n            // rejection.\n            lc.error?.('unreachable');\n            gotError = true;\n            break;\n\n          case ConnectionState.Connected: {\n            // When connected we wait for whatever happens first out of:\n            // - After PING_INTERVAL_MS we send a ping\n            // - We get disconnected\n            // - We get a message\n            // - We get an error (rejectMessageError rejects)\n            // - The tab becomes hidden (with a delay)\n\n            const controller = new AbortController();\n            this.#abortPingTimeout = () => controller.abort();\n            const [pingTimeoutPromise, pingTimeoutAborted] = sleepWithAbort(\n              PING_INTERVAL_MS,\n              controller.signal,\n            );\n\n            this.#rejectMessageError = resolver();\n\n            const PING = 0;\n            const HIDDEN = 2;\n\n            const raceResult = await promiseRace([\n              pingTimeoutPromise,\n              pingTimeoutAborted,\n              this.#visibilityWatcher.waitForHidden(),\n              this.#connectionStateChangeResolver.promise,\n              this.#rejectMessageError.promise,\n            ]);\n\n            if (this.closed) {\n              this.#rejectMessageError = undefined;\n              break;\n            }\n\n            switch (raceResult) {\n              case PING: {\n                const pingResult = await this.#ping(\n                  lc,\n                  this.#rejectMessageError.promise,\n                );\n                if (pingResult === PingResult.TimedOut) {\n                  gotError = true;\n                }\n                break;\n              }\n              case HIDDEN:\n                this.#disconnect(lc, {\n                  client: 'Hidden',\n                });\n                this.#setOnline(false);\n                break;\n            }\n\n            this.#rejectMessageError = undefined;\n          }\n        }\n      } catch (ex) {\n        if (this.#connectionState !== ConnectionState.Connected) {\n          const level = isAuthError(ex) ? 'warn' : 'error';\n          const kind = isServerError(ex) ? ex.kind : 'Unknown Error';\n          lc[level]?.('Failed to connect', ex, kind, {\n            lmid: this.#lastMutationIDReceived,\n            baseCookie: this.#connectCookie,\n          });\n        }\n\n        lc.debug?.(\n          'Got an exception in the run loop',\n          'state:',\n          this.#connectionState,\n          'exception:',\n          ex,\n        );\n\n        if (isAuthError(ex)) {\n          if (!needsReauth) {\n            needsReauth = true;\n            // First auth error, try right away without waiting.\n            continue;\n          }\n          needsReauth = true;\n        }\n\n        if (\n          isServerError(ex) ||\n          ex instanceof TimedOutError ||\n          ex instanceof CloseError\n        ) {\n          gotError = true;\n        }\n\n        const backoffError = isBackoffError(ex);\n        if (backoffError) {\n          if (backoffError.minBackoffMs !== undefined) {\n            backoffMs = Math.max(backoffMs, backoffError.minBackoffMs);\n          }\n          if (backoffError.maxBackoffMs !== undefined) {\n            backoffMs = Math.min(backoffMs, backoffError.maxBackoffMs);\n          }\n          additionalConnectParams = backoffError.reconnectParams;\n        }\n      }\n\n      // Only authentication errors are retried immediately the first time they\n      // occur. All other errors wait a few seconds before retrying the first\n      // time. We specifically do not use a backoff for consecutive errors\n      // because it's a bad experience to wait many seconds for reconnection.\n\n      if (gotError) {\n        this.#setOnline(false);\n        //\n        // let cfGetCheckSucceeded = false;\n        // const cfGetCheckURL = new URL(this.#server);\n        // cfGetCheckURL.pathname = '/api/canary/v0/get';\n        // cfGetCheckURL.searchParams.set('id', nanoid());\n        // const cfGetCheckController = new AbortController();\n        // fetch(cfGetCheckURL, {signal: cfGetCheckController.signal})\n        //   .then(_ => {\n        //     cfGetCheckSucceeded = true;\n        //   })\n        //   .catch(_ => {\n        //     cfGetCheckSucceeded = false;\n        //   });\n        lc.debug?.(\n          'Sleeping',\n          backoffMs,\n          'ms before reconnecting due to error, state:',\n          this.#connectionState,\n        );\n        await sleep(backoffMs);\n        // cfGetCheckController.abort();\n        // if (!cfGetCheckSucceeded) {\n        //   lc.info?.(\n        //     'Canary request failed, resetting total time to connect start time.',\n        //   );\n        //   this.#totalToConnectStart = undefined;\n        // }\n      }\n    }\n  }\n\n  async #puller(req: PullRequest, requestID: string): Promise<PullerResult> {\n    // The deprecation of pushVersion 0 predates zero-client\n    assert(req.pullVersion === 1);\n    const lc = this.#lc.withContext('requestID', requestID);\n    lc.debug?.('Pull', req);\n    // Pull request for this instance's client group.  A no-op response is\n    // returned as pulls for this client group are handled via poke over the\n    // socket.\n    if (req.clientGroupID === (await this.clientGroupID)) {\n      return {\n        httpRequestInfo: {\n          errorMessage: '',\n          httpStatusCode: 200,\n        },\n      };\n    }\n\n    // If we are connecting we wait until we are connected.\n    await this.#connectResolver.promise;\n    const socket = this.#socket;\n    assert(socket);\n    // Mutation recovery pull.\n    lc.debug?.('Pull is for mutation recovery');\n    const cookie = valita.parse(\n      req.cookie,\n      nullableVersionSchema,\n      'passthrough',\n    );\n    const pullRequestMessage: PullRequestMessage = [\n      'pull',\n      {\n        clientGroupID: req.clientGroupID,\n        cookie,\n        requestID,\n      },\n    ];\n    send(socket, pullRequestMessage);\n    const pullResponseResolver: Resolver<PullResponseBody> = resolver();\n    this.#pendingPullsByRequestID.set(requestID, pullResponseResolver);\n    try {\n      const TIMEOUT = 0;\n      const RESPONSE = 1;\n\n      const raceResult = await promiseRace([\n        sleep(PULL_TIMEOUT_MS),\n        pullResponseResolver.promise,\n      ]);\n      switch (raceResult) {\n        case TIMEOUT:\n          lc.debug?.('Mutation recovery pull timed out');\n          throw new Error('Pull timed out');\n        case RESPONSE: {\n          lc.debug?.('Returning mutation recovery pull response');\n          const response = await pullResponseResolver.promise;\n          return {\n            response: {\n              cookie: response.cookie,\n              lastMutationIDChanges: response.lastMutationIDChanges,\n              patch: [],\n            },\n            httpRequestInfo: {\n              errorMessage: '',\n              httpStatusCode: 200,\n            },\n          };\n        }\n        default:\n          unreachable();\n      }\n    } finally {\n      pullResponseResolver.reject('timed out');\n      this.#pendingPullsByRequestID.delete(requestID);\n    }\n  }\n\n  #setOnline(online: boolean): void {\n    this.#onlineManager.setOnline(online);\n  }\n\n  /**\n   * A rough heuristic for whether the client is currently online and\n   * authenticated.\n   */\n  get online(): boolean {\n    return this.#onlineManager.online;\n  }\n\n  /**\n   * Subscribe to online status changes.\n   *\n   * This is useful when you want to update state based on the online status.\n   *\n   * @param listener - The listener to subscribe to.\n   * @returns A function to unsubscribe the listener.\n   */\n  onOnline = (listener: (online: boolean) => void): (() => void) =>\n    this.#onlineManager.subscribe(listener);\n\n  /**\n   * Starts a ping and waits for a pong.\n   *\n   * If it takes too long to get a pong we disconnect and this returns\n   * {@linkcode PingResult.TimedOut}.\n   */\n  async #ping(\n    lc: ZeroLogContext,\n    messageErrorRejectionPromise: Promise<never>,\n  ): Promise<PingResult> {\n    lc.debug?.('pinging');\n    const {promise, resolve} = resolver();\n    this.#onPong = resolve;\n    const pingMessage: PingMessage = ['ping', {}];\n    const t0 = performance.now();\n    assert(this.#socket);\n    send(this.#socket, pingMessage);\n\n    const connected =\n      (await promiseRace([\n        promise,\n        sleep(PING_TIMEOUT_MS),\n        messageErrorRejectionPromise,\n      ])) === 0;\n\n    const delta = performance.now() - t0;\n    if (!connected) {\n      lc.info?.('ping failed in', delta, 'ms - disconnecting');\n      this.#disconnect(lc, {\n        client: 'PingTimeout',\n      });\n      return PingResult.TimedOut;\n    }\n\n    lc.debug?.('ping succeeded in', delta, 'ms');\n    return PingResult.Success;\n  }\n\n  // Sends a set of metrics to the server. Throws unless the server\n  // returns 200.\n  // TODO: Reenable metrics reporting\n  async #reportMetrics(_allSeries: Series[]) {\n    // if (this.#server === null) {\n    //   this.#lc.info?.('Skipping metrics report, socketOrigin is null');\n    //   return;\n    // }\n    // const body = JSON.stringify({series: allSeries});\n    // const url = new URL('/api/metrics/v0/report', this.#server);\n    // url.searchParams.set('clientID', this.clientID);\n    // url.searchParams.set('clientGroupID', await this.clientGroupID);\n    // url.searchParams.set('userID', this.userID);\n    // url.searchParams.set('requestID', nanoid());\n    // const res = await fetch(url.toString(), {\n    //   method: 'POST',\n    //   body,\n    //   keepalive: true,\n    // });\n    // if (!res.ok) {\n    //   const maybeBody = await res.text();\n    //   throw new Error(\n    //     `unexpected response: ${res.status} ${res.statusText} body: ${maybeBody}`,\n    //   );\n    // }\n  }\n\n  #checkConnectivity(reason: string) {\n    void this.#checkConnectivityAsync(reason);\n  }\n\n  #checkConnectivityAsync(_reason: string) {\n    // skipping connectivity checks for now - the server doesn't respond to\n    // them so it just creates noise.\n    // assert(this.#server);\n    // if (this.closed) {\n    //   return;\n    // }\n    // try {\n    //   await checkConnectivity(\n    //     reason,\n    //     this.#server,\n    //     this.#lc,\n    //     this.#closeAbortController.signal,\n    //     this.#enableAnalytics,\n    //   );\n    // } catch (e) {\n    //   this.#lc.info?.('Error checking connectivity for', reason, e);\n    // }\n  }\n\n  #registerQueries(schema: Schema): MakeEntityQueriesFromSchema<S> {\n    const rv = {} as Record<string, Query<Schema, string>>;\n    const context = this.#zeroContext;\n    // Not using parse yet\n    for (const name of Object.keys(schema.tables)) {\n      rv[name] = newQuery(context, schema, name);\n    }\n\n    return rv as MakeEntityQueriesFromSchema<S>;\n  }\n\n  /**\n   * `inspect` returns an object that can be used to inspect the state of the\n   * queries a Zero instance uses. It is intended for debugging purposes.\n   */\n  async inspect(): Promise<Inspector> {\n    // We use esbuild dropLabels to strip this code when we build the code for the bundle size dashboard.\n    // https://esbuild.github.io/api/#ignore-annotations\n    // /packages/zero/tool/build.ts\n\n    // eslint-disable-next-line no-unused-labels\n    BUNDLE_SIZE: {\n      const m = await import('./inspector/inspector.ts');\n      // Wait for the web socket to be available\n      return m.newInspector(\n        this.#rep,\n        this.#queryManager,\n        this.#schema,\n        async () => {\n          await this.#connectResolver.promise;\n          return this.#socket!;\n        },\n      );\n    }\n  }\n\n  #addMetric: <K extends keyof MetricMap>(\n    metric: K,\n    value: number,\n    ...args: MetricMap[K]\n  ) => void = (metric, value, ...args) => {\n    assert(isClientMetric(metric), `Invalid metric: ${metric}`);\n    this.#queryManager.addMetric(\n      metric as keyof ClientMetricMap,\n      value,\n      ...(args as ClientMetricMap[keyof ClientMetricMap]),\n    );\n  };\n}\n\nexport class OnlineManager extends Subscribable<boolean> {\n  #online = false;\n\n  setOnline(online: boolean): void {\n    if (this.#online === online) {\n      return;\n    }\n    this.#online = online;\n    this.notify(online);\n  }\n\n  get online(): boolean {\n    return this.#online;\n  }\n}\n\nexport async function createSocket(\n  rep: ReplicacheImpl,\n  queryManager: QueryManager,\n  deleteClientsManager: DeleteClientsManager,\n  socketOrigin: WSString,\n  baseCookie: NullableVersion,\n  clientID: string,\n  clientGroupID: string,\n  clientSchema: ClientSchema,\n  userID: string,\n  auth: string | undefined,\n  lmid: number,\n  wsid: string,\n  debugPerf: boolean,\n  lc: ZeroLogContext,\n  userPushParams: UserMutateParams | undefined,\n  userQueryParams: UserQueryParams | undefined,\n  maxHeaderLength = 1024 * 8,\n  additionalConnectParams: Record<string, string> | undefined,\n  activeClientsManager: Pick<ActiveClientsManager, 'activeClients'>,\n): Promise<\n  [\n    WebSocket,\n    Map<string, UpQueriesPatchOp> | undefined,\n    DeleteClientsBody | undefined,\n  ]\n> {\n  const url = new URL(\n    appendPath(socketOrigin, `/sync/v${PROTOCOL_VERSION}/connect`),\n  );\n  const {searchParams} = url;\n  searchParams.set('clientID', clientID);\n  searchParams.set('clientGroupID', clientGroupID);\n  searchParams.set('userID', userID);\n  searchParams.set('baseCookie', baseCookie === null ? '' : String(baseCookie));\n  searchParams.set('ts', String(performance.now()));\n  searchParams.set('lmid', String(lmid));\n  searchParams.set('wsid', wsid);\n  if (debugPerf) {\n    searchParams.set('debugPerf', true.toString());\n  }\n  if (additionalConnectParams) {\n    for (const k in additionalConnectParams) {\n      if (searchParams.has(k)) {\n        lc.warn?.(`skipping conflicting parameter ${k}`);\n      } else {\n        searchParams.set(k, additionalConnectParams[k]);\n      }\n    }\n  }\n\n  lc.info?.('Connecting to', url.toString());\n\n  // Pass auth to the server via the `Sec-WebSocket-Protocol` header by passing\n  // it as a `protocol` to the `WebSocket` constructor.  The empty string is an\n  // invalid `protocol`, and will result in an exception, so pass undefined\n  // instead.  encodeURIComponent to ensure it only contains chars allowed\n  // for a `protocol`.\n  const WS = mustGetBrowserGlobal('WebSocket');\n  const queriesPatchP = rep.query(tx => queryManager.getQueriesPatch(tx));\n  let deletedClients: DeleteClientsBody | undefined =\n    await deleteClientsManager.getDeletedClients();\n  let queriesPatch: Map<string, UpQueriesPatchOp> | undefined =\n    await queriesPatchP;\n  const {activeClients} = activeClientsManager;\n\n  let secProtocol = encodeSecProtocols(\n    [\n      'initConnection',\n      {\n        desiredQueriesPatch: [...queriesPatch.values()],\n        deleted: skipEmptyDeletedClients(deletedClients),\n        // The clientSchema only needs to be sent for the very first request.\n        // Henceforth it is stored with the CVR and verified automatically.\n        ...(baseCookie === null ? {clientSchema} : {}),\n        userPushParams,\n        userQueryParams,\n        activeClients: [...activeClients],\n      },\n    ],\n    auth,\n  );\n  if (secProtocol.length > maxHeaderLength) {\n    secProtocol = encodeSecProtocols(undefined, auth);\n    if (secProtocol.length > maxHeaderLength) {\n      lc.warn?.(\n        `Encoded auth token length (${secProtocol.length}) exceeds ` +\n          `ZeroOptions.maxHeaderLength (${maxHeaderLength}). This may ` +\n          `cause connection failures.`,\n      );\n    }\n    queriesPatch = undefined;\n  } else {\n    deletedClients = undefined;\n  }\n  return [\n    new WS(\n      // toString() required for RN URL polyfill.\n      url.toString(),\n      secProtocol,\n    ),\n    queriesPatch,\n    skipEmptyDeletedClients(deletedClients),\n  ];\n}\n\nfunction skipEmptyArray<T>(\n  arr: readonly T[] | undefined,\n): readonly T[] | undefined {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n\nfunction skipEmptyDeletedClients(\n  deletedClients: DeleteClientsBody | undefined,\n): DeleteClientsBody | undefined {\n  if (!deletedClients) {\n    return undefined;\n  }\n  const {clientIDs, clientGroupIDs} = deletedClients;\n  if (\n    (!clientIDs || clientIDs.length === 0) &&\n    (!clientGroupIDs || clientGroupIDs.length === 0)\n  ) {\n    return undefined;\n  }\n  const data: Writable<DeleteClientsBody> = {};\n  data.clientIDs = skipEmptyArray(clientIDs);\n  data.clientGroupIDs = skipEmptyArray(clientGroupIDs);\n  return data;\n}\n\n/**\n * Adds the wsid query parameter to the log context. If the URL does not\n * have a wsid we use a randomID instead.\n */\nfunction addWebSocketIDFromSocketToLogContext(\n  {url}: {url: string},\n  lc: ZeroLogContext,\n): ZeroLogContext {\n  const wsid = new URL(url).searchParams.get('wsid') ?? nanoid();\n  return addWebSocketIDToLogContext(wsid, lc);\n}\n\nfunction addWebSocketIDToLogContext(\n  wsid: string,\n  lc: ZeroLogContext,\n): ZeroLogContext {\n  return lc.withContext('wsid', wsid);\n}\n\n/**\n * Like Promise.race but returns the index of the first promise that resolved.\n */\nfunction promiseRace(ps: Promise<unknown>[]): Promise<number> {\n  return Promise.race(ps.map((p, i) => p.then(() => i)));\n}\n\nclass TimedOutError extends Error {\n  constructor(m: string) {\n    super(`${m} timed out`);\n  }\n}\n\nclass CloseError extends Error {}\n\nfunction assertValidRunOptions(_options?: RunOptions | undefined): void {}\n\nasync function makeActiveClientsManager(\n  clientGroupID: Promise<string>,\n  clientID: string,\n  signal: AbortSignal,\n  onDelete: ActiveClientsManager['onDelete'],\n): Promise<ActiveClientsManager> {\n  const manager = await ActiveClientsManager.create(\n    await clientGroupID,\n    clientID,\n    signal,\n  );\n  manager.onDelete = onDelete;\n  return manager;\n}\n","import {Lock} from '@rocicorp/lock';\nimport {consoleLogSink, LogContext} from '@rocicorp/logger';\nimport {resolver} from '@rocicorp/resolver';\nimport {AbortError} from '../../shared/src/abort-error.ts';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {getBrowserGlobal} from '../../shared/src/browser-env.ts';\nimport {getDocumentVisibilityWatcher} from '../../shared/src/document-visible.ts';\nimport type {JSONValue, ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport type {MaybePromise} from '../../shared/src/types.ts';\nimport {PullDelegate, PushDelegate} from './connection-loop-delegates.ts';\nimport {ConnectionLoop, MAX_DELAY_MS, MIN_DELAY_MS} from './connection-loop.ts';\nimport {assertCookie, type Cookie} from './cookies.ts';\nimport {LazyStore} from './dag/lazy-store.ts';\nimport {StoreImpl} from './dag/store-impl.ts';\nimport {ChunkNotFoundError, mustGetHeadHash, type Store} from './dag/store.ts';\nimport {\n  baseSnapshotFromHash,\n  DEFAULT_HEAD_NAME,\n  isLocalMetaDD31,\n  type LocalMeta,\n} from './db/commit.ts';\nimport {readFromDefaultHead} from './db/read.ts';\nimport {rebaseMutationAndCommit} from './db/rebase.ts';\nimport {newWriteLocal} from './db/write.ts';\nimport {\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n  type VersionNotSupportedResponse,\n} from './error-responses.ts';\nimport * as FormatVersion from './format-version-enum.ts';\nimport {deepFreeze} from './frozen-json.ts';\nimport {getDefaultPuller, isDefaultPuller} from './get-default-puller.ts';\nimport {getDefaultPusher, isDefaultPusher} from './get-default-pusher.ts';\nimport {getKVStoreProvider} from './get-kv-store-provider.ts';\nimport {assertHash, emptyHash, type Hash, newRandomHash} from './hash.ts';\nimport type {HTTPRequestInfo} from './http-request-info.ts';\nimport {httpStatusUnauthorized} from './http-status-unauthorized.ts';\nimport type {IndexDefinitions} from './index-defs.ts';\nimport type {StoreProvider} from './kv/store.ts';\nimport {createLogContext} from './log-options.ts';\nimport {makeIDBName} from './make-idb-name.ts';\nimport {MutationRecovery} from './mutation-recovery.ts';\nimport {initNewClientChannel} from './new-client-channel.ts';\nimport {\n  initOnPersistChannel,\n  type OnPersist,\n  type PersistInfo,\n} from './on-persist-channel.ts';\nimport {\n  type PendingMutation,\n  pendingMutationsForAPI,\n} from './pending-mutations.ts';\nimport {\n  CLIENT_MAX_INACTIVE_TIME,\n  GC_INTERVAL,\n  initClientGC,\n} from './persist/client-gc.ts';\nimport {initClientGroupGC} from './persist/client-group-gc.ts';\nimport {disableClientGroup} from './persist/client-groups.ts';\nimport {\n  ClientStateNotFoundError,\n  initClientV6,\n  type OnClientsDeleted,\n  hasClientState as persistHasClientState,\n} from './persist/clients.ts';\nimport {\n  COLLECT_IDB_INTERVAL,\n  initCollectIDBDatabases,\n  INITIAL_COLLECT_IDB_DELAY,\n} from './persist/collect-idb-databases.ts';\nimport {HEARTBEAT_INTERVAL, startHeartbeats} from './persist/heartbeat.ts';\nimport {\n  IDBDatabasesStore,\n  type IndexedDBDatabase,\n} from './persist/idb-databases-store.ts';\nimport {makeClientID} from './persist/make-client-id.ts';\nimport {persistDD31} from './persist/persist.ts';\nimport {refresh} from './persist/refresh.ts';\nimport {ProcessScheduler} from './process-scheduler.ts';\nimport type {Puller} from './puller.ts';\nimport {type Pusher, PushError} from './pusher.ts';\nimport type {\n  MutationTrackingData,\n  ReplicacheOptions,\n  ZeroOption,\n} from './replicache-options.ts';\nimport {ReportError} from './report-error.ts';\nimport {setIntervalWithSignal} from './set-interval-with-signal.ts';\nimport {\n  type SubscribeOptions,\n  SubscriptionImpl,\n  type SubscriptionsManager,\n  SubscriptionsManagerImpl,\n  type WatchCallback,\n  type WatchCallbackForOptions,\n  type WatchNoIndexCallback,\n  type WatchOptions,\n  WatchSubscription,\n} from './subscriptions.ts';\nimport type {DiffsMap} from './sync/diff.ts';\nimport * as HandlePullResponseResultEnum from './sync/handle-pull-response-result-type-enum.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\nimport {PullError} from './sync/pull-error.ts';\nimport {beginPullV1, handlePullResponseV1, maybeEndPull} from './sync/pull.ts';\nimport {push, PUSH_VERSION_DD31} from './sync/push.ts';\nimport {newRequestID} from './sync/request-id.ts';\nimport {SYNC_HEAD_NAME} from './sync/sync-head-name.ts';\nimport {throwIfClosed} from './transaction-closed-error.ts';\nimport type {ReadTransaction, WriteTransaction} from './transactions.ts';\nimport {ReadTransactionImpl, WriteTransactionImpl} from './transactions.ts';\nimport type {\n  BeginPullResult,\n  MakeMutator,\n  MakeMutators,\n  MutatorDefs,\n  MutatorReturn,\n  PokeInternal,\n  QueryInternal,\n  RequestOptions,\n  UpdateNeededReason,\n} from './types.ts';\nimport {version} from './version.ts';\nimport {\n  withRead,\n  withWrite,\n  withWriteNoImplicitCommit,\n} from './with-transactions.ts';\n\ndeclare const TESTING: boolean;\n\ndeclare const process: {\n  env: {\n    ['DISABLE_MUTATION_RECOVERY']?: string | undefined;\n  };\n};\n\n/**\n * The maximum number of time to call out to getAuth before giving up\n * and throwing an error.\n */\nconst MAX_REAUTH_TRIES = 8;\n\nconst PERSIST_IDLE_TIMEOUT_MS = 1000;\nconst REFRESH_IDLE_TIMEOUT_MS = 1000;\n\nconst PERSIST_THROTTLE_MS = 500;\nconst REFRESH_THROTTLE_MS = 500;\n\nconst LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT = 100 * 2 ** 20; // 100 MB\n\nconst RECOVER_MUTATIONS_INTERVAL_MS = 5 * 60 * 1000; // 5 mins\n\nconst noop = () => {\n  // noop\n};\n\nconst updateNeededReasonNewClientGroup: UpdateNeededReason = {\n  type: 'NewClientGroup',\n} as const;\n\n/** @deprecated Not used any more */\nexport interface MakeSubscriptionsManager {\n  (queryInternal: QueryInternal, lc: LogContext): SubscriptionsManager;\n}\n\nexport interface ReplicacheImplOptions {\n  /**\n   * Defaults to true.\n   */\n  enableMutationRecovery?: boolean | undefined;\n\n  /**\n   * Defaults to true.\n   */\n  enableScheduledPersist?: boolean | undefined;\n\n  /**\n   * Defaults to true.\n   */\n  enableScheduledRefresh?: boolean | undefined;\n\n  /**\n   * Defaults to true.\n   */\n  enablePullAndPushInOpen?: boolean | undefined;\n\n  /**\n   * @deprecated Not used anymore.\n   */\n  makeSubscriptionsManager?: unknown;\n\n  /**\n   * Default is `true`.  If `false` if an exact match client group\n   * is not found, a new client group is always made instead of forking\n   * from an existing client group.\n   */\n  enableClientGroupForking?: boolean | undefined;\n\n  /**\n   * Callback for when Replicache has deleted clients.\n   */\n  onClientsDeleted?: OnClientsDeleted | undefined;\n\n  /**\n   * Internal option used by Zero.\n   * Replicache will call this to and, if zero is enabled, will\n   * invoke various hooks to allow Zero the keep IVM in sync with Replicache's b-trees.\n   */\n  zero?: ZeroOption | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class ReplicacheImpl<MD extends MutatorDefs = {}> {\n  /** The URL to use when doing a pull request. */\n  pullURL: string;\n\n  /** The URL to use when doing a push request. */\n  pushURL: string;\n\n  /** The authorization token used when doing a push request. */\n  #auth: string;\n\n  /** The name of the Replicache database. Populated by {@link ReplicacheOptions#name}. */\n  readonly name: string;\n\n  readonly #subscriptions: SubscriptionsManager;\n  readonly #mutationRecovery: MutationRecovery | undefined;\n\n  /**\n   * Client groups gets disabled when the server does not know about it.\n   * A disabled client group prevents the client from pushing and pulling.\n   */\n  isClientGroupDisabled = false;\n\n  readonly #kvStoreProvider: StoreProvider;\n\n  lastMutationID: number = 0;\n\n  /**\n   * This is the name Replicache uses for the IndexedDB database where data is\n   * stored.\n   */\n  get idbName(): string {\n    return makeIDBName(this.name, this.schemaVersion);\n  }\n\n  set auth(auth: string) {\n    if (this.#zero) {\n      this.#zero.auth = auth;\n    }\n\n    this.#auth = auth;\n  }\n\n  get auth() {\n    return this.#auth;\n  }\n\n  /** The schema version of the data understood by this application. */\n  readonly schemaVersion: string;\n\n  get #idbDatabase(): IndexedDBDatabase {\n    return {\n      name: this.idbName,\n      replicacheName: this.name,\n      replicacheFormatVersion: FormatVersion.Latest,\n      schemaVersion: this.schemaVersion,\n    };\n  }\n  #closed = false;\n  #online = true;\n  readonly #clientID = makeClientID();\n  readonly #ready: Promise<void>;\n  readonly #profileIDPromise: Promise<string>;\n  readonly #clientGroupIDPromise: Promise<string>;\n  readonly #mutatorRegistry: MutatorDefs = {};\n\n  /**\n   * The mutators that was registered in the constructor.\n   */\n  readonly mutate: MakeMutators<MD>;\n\n  // Number of pushes/pulls at the moment.\n  #pushCounter = 0;\n  #pullCounter = 0;\n\n  #pullConnectionLoop: ConnectionLoop;\n  #pushConnectionLoop: ConnectionLoop;\n\n  /**\n   * The duration between each periodic {@link pull}. Setting this to `null`\n   * disables periodic pull completely. Pull will still happen if you call\n   * {@link pull} manually.\n   */\n  pullInterval: number | null;\n\n  /**\n   * The delay between when a change is made to Replicache and when Replicache\n   * attempts to push that change.\n   */\n  pushDelay: number;\n\n  readonly #requestOptions: Required<RequestOptions>;\n\n  /**\n   * The function to use to pull data from the server.\n   */\n  puller: Puller;\n\n  /**\n   * The function to use to push data to the server.\n   */\n  pusher: Pusher;\n\n  readonly memdag: LazyStore;\n  readonly perdag: Store;\n  readonly #idbDatabases: IDBDatabasesStore;\n  readonly #lc: LogContext;\n  readonly #zero: ZeroOption | undefined;\n\n  readonly #closeAbortController = new AbortController();\n\n  readonly #persistLock = new Lock();\n  readonly #enableScheduledPersist: boolean;\n  readonly #enableScheduledRefresh: boolean;\n  readonly #enablePullAndPushInOpen: boolean;\n  #persistScheduler = new ProcessScheduler(\n    () => this.persist(),\n    PERSIST_IDLE_TIMEOUT_MS,\n    PERSIST_THROTTLE_MS,\n    this.#closeAbortController.signal,\n  );\n  readonly #onPersist: OnPersist;\n  #refreshScheduler = new ProcessScheduler(\n    () => this.refresh(),\n    REFRESH_IDLE_TIMEOUT_MS,\n    REFRESH_THROTTLE_MS,\n    this.#closeAbortController.signal,\n  );\n\n  /**\n   * The options used to control the {@link pull} and push request behavior. This\n   * object is live so changes to it will affect the next pull or push call.\n   */\n  get requestOptions(): Required<RequestOptions> {\n    return this.#requestOptions;\n  }\n\n  /**\n   * `onSync(true)` is called when Replicache transitions from no push or pull\n   * happening to at least one happening. `onSync(false)` is called in the\n   * opposite case: when Replicache transitions from at least one push or pull\n   * happening to none happening.\n   *\n   * This can be used in a React like app by doing something like the following:\n   *\n   * ```js\n   * const [syncing, setSyncing] = useState(false);\n   * useEffect(() => {\n   *   rep.onSync = setSyncing;\n   * }, [rep]);\n   * ```\n   */\n  onSync: ((syncing: boolean) => void) | null = null;\n\n  /**\n   * `onClientStateNotFound` is called when the persistent client has been\n   * garbage collected. This can happen if the client has no pending mutations\n   * and has not been used for a while.\n   *\n   * The default behavior is to reload the page (using `location.reload()`). Set\n   * this to `null` or provide your own function to prevent the page from\n   * reloading automatically.\n   */\n  onClientStateNotFound: (() => void) | null = reload;\n\n  /**\n   * `onUpdateNeeded` is called when a code update is needed.\n   *\n   * A code update can be needed because:\n   * - the server no longer supports the {@link pushVersion},\n   *   {@link pullVersion} or {@link schemaVersion} of the current code.\n   * - a new Replicache client has created a new client group, because its code\n   *   has different mutators, indexes, schema version and/or format version\n   *   from this Replicache client. This is likely due to the new client having\n   *   newer code. A code update is needed to be able to locally sync with this\n   *   new Replicache client (i.e. to sync while offline, the clients can still\n   *   sync with each other via the server).\n   *\n   * The default behavior is to reload the page (using `location.reload()`). Set\n   * this to `null` or provide your own function to prevent the page from\n   * reloading automatically. You may want to provide your own function to\n   * display a toast to inform the end user there is a new version of your app\n   * available and prompting them to refresh.\n   */\n  onUpdateNeeded: ((reason: UpdateNeededReason) => void) | null = reload;\n\n  /**\n   * This gets called when we get an HTTP unauthorized (401) response from the\n   * push or pull endpoint. Set this to a function that will ask your user to\n   * reauthenticate.\n   */\n  getAuth: (() => MaybePromise<string | null | undefined>) | null | undefined =\n    null;\n\n  // These three are used for testing\n  onPushInvoked = () => undefined;\n  onBeginPull = () => undefined;\n  onRecoverMutations = (r: Promise<boolean>) => r;\n\n  constructor(\n    options: ReplicacheOptions<MD>,\n    implOptions: ReplicacheImplOptions = {},\n  ) {\n    validateOptions(options);\n    const {\n      name,\n      logLevel = 'info',\n      logSinks = [consoleLogSink],\n      pullURL = '',\n      auth,\n      pushDelay = 10,\n      pushURL = '',\n      schemaVersion = '',\n      pullInterval = 60000,\n      mutators = {} as MD,\n      requestOptions = {},\n      puller,\n      pusher,\n      indexes = {},\n      clientMaxAgeMs = CLIENT_MAX_INACTIVE_TIME,\n    } = options;\n    const {\n      enableMutationRecovery = true,\n      enableScheduledPersist = true,\n      enableScheduledRefresh = true,\n      enablePullAndPushInOpen = true,\n      enableClientGroupForking = true,\n      onClientsDeleted = () => {},\n    } = implOptions;\n    this.#zero = implOptions.zero;\n    this.#auth = auth ?? '';\n    this.pullURL = pullURL;\n    this.pushURL = pushURL;\n    this.name = name;\n    this.schemaVersion = schemaVersion;\n    this.pullInterval = pullInterval;\n    this.pushDelay = pushDelay;\n    this.puller = puller ?? getDefaultPuller(this);\n    this.pusher = pusher ?? getDefaultPusher(this);\n\n    this.#enableScheduledPersist = enableScheduledPersist;\n    this.#enableScheduledRefresh = enableScheduledRefresh;\n    this.#enablePullAndPushInOpen = enablePullAndPushInOpen;\n\n    this.#lc = createLogContext(logLevel, logSinks, {name});\n    this.#lc.debug?.('Constructing Replicache', {\n      name,\n      'replicache version': version,\n    });\n\n    this.#subscriptions = new SubscriptionsManagerImpl(\n      this.#queryInternal,\n      this.#lc,\n      this.#closeAbortController.signal,\n    );\n\n    const kvStoreProvider = getKVStoreProvider(this.#lc, options.kvStore);\n    this.#kvStoreProvider = kvStoreProvider;\n\n    const perKVStore = kvStoreProvider.create(this.idbName);\n\n    this.#idbDatabases = new IDBDatabasesStore(kvStoreProvider.create);\n    this.perdag = new StoreImpl(perKVStore, newRandomHash, assertHash);\n    this.memdag = new LazyStore(\n      this.perdag,\n      LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT,\n      newRandomHash,\n      assertHash,\n    );\n\n    // Use a promise-resolve pair so that we have a promise to use even before\n    // we call the Open RPC.\n    const readyResolver = resolver<void>();\n    this.#ready = readyResolver.promise;\n\n    const {minDelayMs = MIN_DELAY_MS, maxDelayMs = MAX_DELAY_MS} =\n      requestOptions;\n    this.#requestOptions = {maxDelayMs, minDelayMs};\n\n    const visibilityWatcher = getDocumentVisibilityWatcher(\n      getBrowserGlobal('document'),\n      0,\n      this.#closeAbortController.signal,\n    );\n\n    this.#pullConnectionLoop = new ConnectionLoop(\n      this.#lc.withContext('PULL'),\n      new PullDelegate(this, () => this.#invokePull()),\n      visibilityWatcher,\n    );\n\n    this.#pushConnectionLoop = new ConnectionLoop(\n      this.#lc.withContext('PUSH'),\n      new PushDelegate(this, () => this.#invokePush()),\n    );\n\n    this.mutate = this.#registerMutators(mutators);\n\n    const profileIDResolver = resolver<string>();\n    this.#profileIDPromise = profileIDResolver.promise;\n    const clientGroupIDResolver = resolver<string>();\n    this.#clientGroupIDPromise = clientGroupIDResolver.promise;\n\n    if (!process.env.DISABLE_MUTATION_RECOVERY) {\n      this.#mutationRecovery = new MutationRecovery({\n        delegate: this,\n        lc: this.#lc,\n        enableMutationRecovery,\n        wrapInOnlineCheck: this.#wrapInOnlineCheck.bind(this),\n        wrapInReauthRetries: this.#wrapInReauthRetries.bind(this),\n        isPullDisabled: this.#isPullDisabled.bind(this),\n        isPushDisabled: this.#isPushDisabled.bind(this),\n        clientGroupIDPromise: this.#clientGroupIDPromise,\n      });\n    }\n\n    this.#onPersist = initOnPersistChannel(\n      this.name,\n      this.#closeAbortController.signal,\n      persistInfo => {\n        void this.#handlePersist(persistInfo);\n      },\n    );\n\n    void this.#open(\n      indexes,\n      enableClientGroupForking,\n      enableMutationRecovery,\n      clientMaxAgeMs,\n      profileIDResolver.resolve,\n      clientGroupIDResolver.resolve,\n      readyResolver.resolve,\n      onClientsDeleted,\n    );\n  }\n\n  async #open(\n    indexes: IndexDefinitions,\n    enableClientGroupForking: boolean,\n    enableMutationRecovery: boolean,\n    clientMaxAgeMs: number,\n    profileIDResolver: (profileID: string) => void,\n    resolveClientGroupID: (clientGroupID: ClientGroupID) => void,\n    resolveReady: () => void,\n    onClientsDeleted: OnClientsDeleted,\n  ): Promise<void> {\n    const {clientID} = this;\n    // If we are currently closing a Replicache instance with the same name,\n    // wait for it to finish closing.\n    await closingInstances.get(this.name);\n    await this.#idbDatabases.getProfileID().then(profileIDResolver);\n    await this.#idbDatabases.putDatabase(this.#idbDatabase);\n    const [client, headHash, , isNewClientGroup] = await initClientV6(\n      clientID,\n      this.#lc,\n      this.perdag,\n      Object.keys(this.#mutatorRegistry),\n      indexes,\n      FormatVersion.Latest,\n      enableClientGroupForking,\n    );\n\n    resolveClientGroupID(client.clientGroupID);\n    await withWrite(this.memdag, write =>\n      write.setHead(DEFAULT_HEAD_NAME, headHash),\n    );\n\n    // Now we have a profileID, a clientID, a clientGroupID and DB!\n    await this.#zero?.init(headHash, this.memdag);\n    resolveReady();\n\n    if (this.#enablePullAndPushInOpen) {\n      this.pull().catch(noop);\n      this.push().catch(noop);\n    }\n\n    const {signal} = this.#closeAbortController;\n\n    startHeartbeats(\n      clientID,\n      this.perdag,\n      () => {\n        this.#clientStateNotFoundOnClient(clientID);\n      },\n      HEARTBEAT_INTERVAL,\n      this.#lc,\n      signal,\n    );\n    initClientGC(\n      clientID,\n      this.perdag,\n      clientMaxAgeMs,\n      GC_INTERVAL,\n      onClientsDeleted,\n      this.#lc,\n      signal,\n    );\n    initCollectIDBDatabases(\n      this.#idbDatabases,\n      this.#kvStoreProvider.drop,\n      COLLECT_IDB_INTERVAL,\n      INITIAL_COLLECT_IDB_DELAY,\n      2 * clientMaxAgeMs,\n      enableMutationRecovery,\n      onClientsDeleted,\n      this.#lc,\n      signal,\n    );\n    initClientGroupGC(\n      this.perdag,\n      enableMutationRecovery,\n      onClientsDeleted,\n      this.#lc,\n      signal,\n    );\n    initNewClientChannel(\n      this.name,\n      this.idbName,\n      signal,\n      client.clientGroupID,\n      isNewClientGroup,\n      () => {\n        this.#fireOnUpdateNeeded(updateNeededReasonNewClientGroup);\n      },\n      this.perdag,\n    );\n\n    setIntervalWithSignal(\n      () => this.recoverMutations(),\n      RECOVER_MUTATIONS_INTERVAL_MS,\n      signal,\n    );\n    void this.recoverMutations();\n\n    getBrowserGlobal('document')?.addEventListener(\n      'visibilitychange',\n      this.#onVisibilityChange,\n    );\n  }\n\n  #onVisibilityChange = async () => {\n    if (this.#closed) {\n      return;\n    }\n\n    // In case of running in a worker, we don't have a document.\n    if (getBrowserGlobal('document')?.visibilityState !== 'visible') {\n      return;\n    }\n\n    await this.#checkForClientStateNotFoundAndCallHandler();\n  };\n\n  async #checkForClientStateNotFoundAndCallHandler(): Promise<boolean> {\n    const {clientID} = this;\n    const hasClientState = await withRead(this.perdag, read =>\n      persistHasClientState(clientID, read),\n    );\n    if (!hasClientState) {\n      this.#clientStateNotFoundOnClient(clientID);\n    }\n    return !hasClientState;\n  }\n\n  /**\n   * The browser profile ID for this browser profile. Every instance of Replicache\n   * browser-profile-wide shares the same profile ID.\n   */\n  get profileID(): Promise<string> {\n    return this.#profileIDPromise;\n  }\n\n  /**\n   * The client ID for this instance of Replicache. Each instance of Replicache\n   * gets a unique client ID.\n   */\n  get clientID(): string {\n    return this.#clientID;\n  }\n\n  /**\n   * The client group ID for this instance of Replicache. Instances of\n   * Replicache will have the same client group ID if and only if they have\n   * the same name, mutators, indexes, schema version, format version, and\n   * browser profile.\n   */\n  get clientGroupID(): Promise<string> {\n    return this.#clientGroupIDPromise;\n  }\n\n  /**\n   * `onOnlineChange` is called when the {@link online} property changes. See\n   * {@link online} for more details.\n   */\n  onOnlineChange: ((online: boolean) => void) | null = null;\n\n  /**\n   * A rough heuristic for whether the client is currently online. Note that\n   * there is no way to know for certain whether a client is online - the next\n   * request can always fail. This property returns true if the last sync attempt succeeded,\n   * and false otherwise.\n   */\n  get online(): boolean {\n    return this.#online;\n  }\n\n  /**\n   * Whether the Replicache database has been closed. Once Replicache has been\n   * closed it no longer syncs and you can no longer read or write data out of\n   * it. After it has been closed it is pretty much useless and should not be\n   * used any more.\n   */\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  /**\n   * Closes this Replicache instance.\n   *\n   * When closed all subscriptions end and no more read or writes are allowed.\n   */\n  async close(): Promise<void> {\n    this.#closed = true;\n    const {promise, resolve} = resolver();\n    closingInstances.set(this.name, promise);\n\n    this.#closeAbortController.abort();\n\n    getBrowserGlobal('document')?.removeEventListener(\n      'visibilitychange',\n      this.#onVisibilityChange,\n    );\n\n    await this.#ready;\n    const closingPromises = [\n      this.memdag.close(),\n      this.perdag.close(),\n      this.#idbDatabases.close(),\n    ];\n\n    this.#pullConnectionLoop.close();\n    this.#pushConnectionLoop.close();\n\n    this.#subscriptions.clear();\n\n    await Promise.all(closingPromises);\n    closingInstances.delete(this.name);\n    resolve();\n  }\n\n  async maybeEndPull(syncHead: Hash, requestID: string): Promise<void> {\n    for (;;) {\n      if (this.#closed) {\n        return;\n      }\n\n      await this.#ready;\n      const {clientID} = this;\n      const lc = this.#lc\n        .withContext('maybeEndPull')\n        .withContext('requestID', requestID);\n      const {replayMutations, diffs, oldMainHead, mainHead} =\n        await maybeEndPull<LocalMeta>(\n          this.memdag,\n          lc,\n          syncHead,\n          clientID,\n          this.#subscriptions,\n          FormatVersion.Latest,\n        );\n\n      if (!replayMutations || replayMutations.length === 0) {\n        // All done.\n        this.#zero?.advance(oldMainHead, mainHead, diffs.get('') ?? []);\n        await this.#subscriptions.fire(diffs);\n        void this.#schedulePersist();\n        return;\n      }\n\n      // Replay.\n      const zeroData = await this.#zero?.getTxData?.(syncHead);\n      for (const mutation of replayMutations) {\n        // TODO(greg): I'm not sure why this was in Replicache#_mutate...\n        // Ensure that we run initial pending subscribe functions before starting a\n        // write transaction.\n        if (this.#subscriptions.hasPendingSubscriptionRuns) {\n          await Promise.resolve();\n        }\n        const {meta} = mutation;\n        syncHead = await withWriteNoImplicitCommit(this.memdag, dagWrite =>\n          rebaseMutationAndCommit(\n            mutation,\n            dagWrite,\n            syncHead,\n            SYNC_HEAD_NAME,\n            this.#mutatorRegistry,\n            lc,\n            isLocalMetaDD31(meta) ? meta.clientID : clientID,\n            FormatVersion.Latest,\n            zeroData,\n          ),\n        );\n      }\n    }\n  }\n\n  #invokePull(): Promise<boolean> {\n    if (this.#isPullDisabled()) {\n      return Promise.resolve(true);\n    }\n\n    return this.#wrapInOnlineCheck(async () => {\n      try {\n        this.#changeSyncCounters(0, 1);\n        const {syncHead, requestID, ok} = await this.beginPull();\n        if (!ok) {\n          return false;\n        }\n        if (syncHead !== emptyHash) {\n          await this.maybeEndPull(syncHead, requestID);\n        }\n      } catch (e) {\n        throw await this.#convertToClientStateNotFoundError(e);\n      } finally {\n        this.#changeSyncCounters(0, -1);\n      }\n      return true;\n    }, 'Pull');\n  }\n\n  #isPullDisabled() {\n    return (\n      this.isClientGroupDisabled ||\n      (this.pullURL === '' && isDefaultPuller(this.puller))\n    );\n  }\n\n  async #wrapInOnlineCheck(\n    f: () => Promise<boolean>,\n    name: string,\n  ): Promise<boolean> {\n    let online = true;\n\n    try {\n      return await f();\n    } catch (e) {\n      // The error paths of beginPull and maybeEndPull need to be reworked.\n      //\n      // We want to distinguish between:\n      // a) network requests failed -- we're offline basically\n      // b) sync was aborted because one's already in progress\n      // c) oh noes - something unexpected happened\n      //\n      // Right now, all of these come out as errors. We distinguish (b) with a\n      // hacky string search. (a) and (c) are not distinguishable currently\n      // because repc doesn't provide sufficient information, so we treat all\n      // errors that aren't (b) as (a).\n      if (e instanceof PushError || e instanceof PullError) {\n        online = false;\n        this.#lc.debug?.(`${name} threw:\\n`, e, '\\nwith cause:\\n', e.causedBy);\n      } else if (e instanceof ReportError) {\n        this.#lc.error?.(e);\n      } else {\n        this.#lc.info?.(`${name} threw:\\n`, e);\n      }\n      return false;\n    } finally {\n      if (this.#online !== online) {\n        this.#online = online;\n        this.onOnlineChange?.(online);\n        if (online) {\n          void this.recoverMutations();\n        }\n      }\n    }\n  }\n\n  async #wrapInReauthRetries<R>(\n    f: (\n      requestID: string,\n      requestLc: LogContext,\n    ) => Promise<{\n      httpRequestInfo: HTTPRequestInfo | undefined;\n      result: R;\n    }>,\n    verb: string,\n    lc: LogContext,\n    preAuth: () => MaybePromise<void> = noop,\n    postAuth: () => MaybePromise<void> = noop,\n  ): Promise<{\n    result: R;\n    authFailure: boolean;\n  }> {\n    const {clientID} = this;\n    let reauthAttempts = 0;\n    let lastResult;\n    lc = lc.withContext(verb);\n    do {\n      const requestID = newRequestID(clientID);\n      const requestLc = lc.withContext('requestID', requestID);\n      const {httpRequestInfo, result} = await f(requestID, requestLc);\n      lastResult = result;\n      if (!httpRequestInfo) {\n        return {\n          result,\n          authFailure: false,\n        };\n      }\n      const {errorMessage, httpStatusCode} = httpRequestInfo;\n\n      if (errorMessage || httpStatusCode !== 200) {\n        // TODO(arv): Maybe we should not log the server URL when the error comes\n        // from a Pusher/Puller?\n        requestLc.error?.(\n          `Got a non 200 response doing ${verb}: ${httpStatusCode}` +\n            (errorMessage ? `: ${errorMessage}` : ''),\n        );\n      }\n      if (httpStatusCode !== httpStatusUnauthorized) {\n        return {\n          result,\n          authFailure: false,\n        };\n      }\n      if (!this.getAuth) {\n        return {\n          result,\n          authFailure: true,\n        };\n      }\n      let auth;\n      try {\n        await preAuth();\n        auth = await this.getAuth();\n      } finally {\n        await postAuth();\n      }\n      if (auth === null || auth === undefined) {\n        return {\n          result,\n          authFailure: true,\n        };\n      }\n      this.auth = auth;\n      reauthAttempts++;\n    } while (reauthAttempts < MAX_REAUTH_TRIES);\n    lc.info?.('Tried to reauthenticate too many times');\n    return {\n      result: lastResult,\n      authFailure: true,\n    };\n  }\n\n  #isPushDisabled() {\n    return (\n      this.isClientGroupDisabled ||\n      (this.pushURL === '' && isDefaultPusher(this.pusher))\n    );\n  }\n\n  async #invokePush(): Promise<boolean> {\n    if (TESTING) {\n      this.onPushInvoked();\n    }\n    if (this.#isPushDisabled()) {\n      return true;\n    }\n\n    await this.#ready;\n    const profileID = await this.#profileIDPromise;\n    const {clientID} = this;\n    const clientGroupID = await this.#clientGroupIDPromise;\n    return this.#wrapInOnlineCheck(async () => {\n      const {result: pusherResult} = await this.#wrapInReauthRetries(\n        async (requestID: string, requestLc: LogContext) => {\n          try {\n            this.#changeSyncCounters(1, 0);\n            const pusherResult = await push(\n              requestID,\n              this.memdag,\n              requestLc,\n              profileID,\n              clientGroupID,\n              clientID,\n              this.pusher,\n              this.schemaVersion,\n              PUSH_VERSION_DD31,\n            );\n            return {\n              result: pusherResult,\n              httpRequestInfo: pusherResult?.httpRequestInfo,\n            };\n          } finally {\n            this.#changeSyncCounters(-1, 0);\n          }\n        },\n        'push',\n        this.#lc,\n      );\n\n      if (pusherResult === undefined) {\n        // No pending mutations.\n        return true;\n      }\n\n      const {response, httpRequestInfo} = pusherResult;\n\n      if (isVersionNotSupportedResponse(response)) {\n        this.#handleVersionNotSupportedResponse(response);\n      } else if (isClientStateNotFoundResponse(response)) {\n        await this.#clientStateNotFoundOnServer();\n      }\n\n      // No pushResponse means we didn't do a push because there were no\n      // pending mutations.\n      return httpRequestInfo.httpStatusCode === 200;\n    }, 'Push');\n  }\n\n  #handleVersionNotSupportedResponse(response: VersionNotSupportedResponse) {\n    const reason: UpdateNeededReason = {\n      type: response.error,\n    };\n    if (response.versionType) {\n      reason.versionType = response.versionType;\n    }\n    this.#fireOnUpdateNeeded(reason);\n  }\n\n  /**\n   * Push pushes pending changes to the {@link pushURL}.\n   *\n   * You do not usually need to manually call push. If {@link pushDelay} is\n   * non-zero (which it is by default) pushes happen automatically shortly after\n   * mutations.\n   *\n   * If the server endpoint fails push will be continuously retried with an\n   * exponential backoff.\n   *\n   * @param [now=false] If true, push will happen immediately and ignore\n   *   {@link pushDelay}, {@link RequestOptions.minDelayMs} as well as the\n   *   exponential backoff in case of errors.\n   * @returns A promise that resolves when the next push completes. In case of\n   * errors the first error will reject the returned promise. Subsequent errors\n   * will not be reflected in the promise.\n   */\n  push({now = false} = {}): Promise<void> {\n    return throwIfError(this.#pushConnectionLoop.send(now));\n  }\n\n  /**\n   * Pull pulls changes from the {@link pullURL}. If there are any changes local\n   * changes will get replayed on top of the new server state.\n   *\n   * If the server endpoint fails pull will be continuously retried with an\n   * exponential backoff.\n   *\n   * @param [now=false] If true, pull will happen immediately and ignore\n   *   {@link RequestOptions.minDelayMs} as well as the exponential backoff in\n   *   case of errors.\n   * @returns A promise that resolves when the next pull completes. In case of\n   * errors the first error will reject the returned promise. Subsequent errors\n   * will not be reflected in the promise.\n   */\n  pull({now = false} = {}): Promise<void> {\n    return throwIfError(this.#pullConnectionLoop.send(now));\n  }\n\n  /**\n   * Applies an update from the server to Replicache.\n   * Throws an error if cookie does not match. In that case the server thinks\n   * this client has a different cookie than it does; the caller should disconnect\n   * from the server and re-register, which transmits the cookie the client actually\n   * has.\n   *\n   * @experimental This method is under development and its semantics will change.\n   */\n  async poke(poke: PokeInternal): Promise<void> {\n    await this.#ready;\n    // TODO(MP) Previously we created a request ID here and included it with the\n    // PullRequest to the server so we could tie events across client and server\n    // together. Since the direction is now reversed, creating and adding a request ID\n    // here is kind of silly. We should consider creating the request ID\n    // on the *server* and passing it down in the poke for inclusion here in the log\n    // context\n    const {clientID} = this;\n    const requestID = newRequestID(clientID);\n    const lc = this.#lc\n      .withContext('handlePullResponse')\n      .withContext('requestID', requestID);\n\n    const {pullResponse} = poke;\n\n    if (isVersionNotSupportedResponse(pullResponse)) {\n      this.#handleVersionNotSupportedResponse(pullResponse);\n      return;\n    }\n\n    if (isClientStateNotFoundResponse(pullResponse)) {\n      await this.#clientStateNotFoundOnServer();\n      return;\n    }\n\n    const result = await handlePullResponseV1(\n      lc,\n      this.memdag,\n      deepFreeze(poke.baseCookie),\n      pullResponse,\n      clientID,\n      FormatVersion.Latest,\n    );\n\n    switch (result.type) {\n      case HandlePullResponseResultEnum.Applied:\n        await this.maybeEndPull(result.syncHead, requestID);\n        break;\n      case HandlePullResponseResultEnum.CookieMismatch:\n        throw new Error(\n          'unexpected base cookie for poke: ' + JSON.stringify(poke),\n        );\n      case HandlePullResponseResultEnum.NoOp:\n        break;\n    }\n  }\n\n  async beginPull(): Promise<BeginPullResult> {\n    if (TESTING) {\n      this.onBeginPull();\n    }\n    await this.#ready;\n    const profileID = await this.profileID;\n    const {clientID} = this;\n    const clientGroupID = await this.#clientGroupIDPromise;\n    const {\n      result: {beginPullResponse, requestID},\n    } = await this.#wrapInReauthRetries(\n      async (requestID: string, requestLc: LogContext) => {\n        const beginPullResponse = await beginPullV1(\n          profileID,\n          clientID,\n          clientGroupID,\n          this.schemaVersion,\n          this.puller,\n          requestID,\n          this.memdag,\n          FormatVersion.Latest,\n          requestLc,\n        );\n        return {\n          result: {beginPullResponse, requestID},\n          httpRequestInfo: beginPullResponse.httpRequestInfo,\n        };\n      },\n      'pull',\n      this.#lc,\n      () => this.#changeSyncCounters(0, -1),\n      () => this.#changeSyncCounters(0, 1),\n    );\n\n    const {pullResponse} = beginPullResponse;\n    if (isVersionNotSupportedResponse(pullResponse)) {\n      this.#handleVersionNotSupportedResponse(pullResponse);\n    } else if (isClientStateNotFoundResponse(beginPullResponse.pullResponse)) {\n      await this.#clientStateNotFoundOnServer();\n    }\n\n    const {syncHead, httpRequestInfo} = beginPullResponse;\n    return {requestID, syncHead, ok: httpRequestInfo.httpStatusCode === 200};\n  }\n\n  persist(): Promise<void> {\n    // Prevent multiple persist calls from running at the same time.\n    return this.#persistLock.withLock(async () => {\n      const {clientID} = this;\n      await this.#ready;\n      if (this.#closed) {\n        return;\n      }\n      try {\n        await persistDD31(\n          this.#lc,\n          clientID,\n          this.memdag,\n          this.perdag,\n          this.#mutatorRegistry,\n          () => this.#closed,\n          FormatVersion.Latest,\n          this.#zero?.getTxData,\n        );\n      } catch (e) {\n        if (e instanceof ClientStateNotFoundError) {\n          this.#clientStateNotFoundOnClient(clientID);\n        } else if (this.#closed) {\n          this.#lc.debug?.('Exception persisting during close', e);\n        } else {\n          throw e;\n        }\n      }\n\n      const clientGroupID = await this.#clientGroupIDPromise;\n      assert(clientGroupID);\n      this.#onPersist({clientID, clientGroupID});\n    });\n  }\n\n  async refresh(): Promise<void> {\n    await this.#ready;\n    const {clientID} = this;\n    if (this.#closed) {\n      return;\n    }\n    let refreshResult: Awaited<ReturnType<typeof refresh>>;\n    try {\n      refreshResult = await refresh(\n        this.#lc,\n        this.memdag,\n        this.perdag,\n        clientID,\n        this.#mutatorRegistry,\n        this.#subscriptions,\n        () => this.closed,\n        FormatVersion.Latest,\n        this.#zero,\n      );\n    } catch (e) {\n      if (e instanceof ClientStateNotFoundError) {\n        this.#clientStateNotFoundOnClient(clientID);\n      } else if (this.#closed) {\n        this.#lc.debug?.('Exception refreshing during close', e);\n      } else {\n        throw e;\n      }\n    }\n    if (refreshResult !== undefined) {\n      await this.#subscriptions.fire(refreshResult.diffs);\n    }\n  }\n\n  #fireOnClientStateNotFound() {\n    this.onClientStateNotFound?.();\n  }\n\n  #clientStateNotFoundOnClient(clientID: ClientID) {\n    this.#lc.error?.(`Client state not found on client, clientID: ${clientID}`);\n    this.#fireOnClientStateNotFound();\n  }\n\n  async #clientStateNotFoundOnServer() {\n    const clientGroupID = await this.#clientGroupIDPromise;\n    this.#lc.error?.(\n      `Client state not found on server, clientGroupID: ${clientGroupID}`,\n    );\n    await this.disableClientGroup();\n    this.#fireOnClientStateNotFound();\n  }\n\n  async disableClientGroup(): Promise<void> {\n    const clientGroupID = await this.#clientGroupIDPromise;\n    assert(clientGroupID);\n    this.isClientGroupDisabled = true;\n    await withWrite(this.perdag, dagWrite =>\n      disableClientGroup(clientGroupID, dagWrite),\n    );\n  }\n\n  #fireOnUpdateNeeded(reason: UpdateNeededReason) {\n    this.#lc.debug?.(`Update needed, reason: ${reason}`);\n    this.onUpdateNeeded?.(reason);\n  }\n\n  async #schedulePersist(): Promise<void> {\n    if (!this.#enableScheduledPersist) {\n      return;\n    }\n    await this.#schedule('persist', this.#persistScheduler);\n  }\n\n  async #handlePersist(persistInfo: PersistInfo): Promise<void> {\n    this.#lc.debug?.('Handling persist', persistInfo);\n    const clientGroupID = await this.#clientGroupIDPromise;\n    if (persistInfo.clientGroupID === clientGroupID) {\n      void this.#scheduleRefresh();\n    }\n  }\n\n  async #scheduleRefresh(): Promise<void> {\n    if (!this.#enableScheduledRefresh) {\n      return;\n    }\n    await this.#schedule('refresh from storage', this.#refreshScheduler);\n  }\n\n  async #schedule(name: string, scheduler: ProcessScheduler): Promise<void> {\n    try {\n      await scheduler.schedule();\n    } catch (e) {\n      if (e instanceof AbortError) {\n        this.#lc.debug?.(`Scheduled ${name} did not complete before close.`);\n      } else {\n        this.#lc.error?.(`Error during ${name}`, e);\n      }\n    }\n  }\n\n  #changeSyncCounters(pushDelta: 0, pullDelta: 1 | -1): void;\n  #changeSyncCounters(pushDelta: 1 | -1, pullDelta: 0): void;\n  #changeSyncCounters(pushDelta: number, pullDelta: number): void {\n    this.#pushCounter += pushDelta;\n    this.#pullCounter += pullDelta;\n    const delta = pushDelta + pullDelta;\n    const counter = this.#pushCounter + this.#pullCounter;\n    if ((delta === 1 && counter === 1) || counter === 0) {\n      const syncing = counter > 0;\n      // Run in a new microtask.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      Promise.resolve().then(() => this.onSync?.(syncing));\n    }\n  }\n\n  /**\n   * Subscribe to the result of a {@link query}. The `body` function is\n   * evaluated once and its results are returned via `onData`.\n   *\n   * Thereafter, each time the the result of `body` changes, `onData` is fired\n   * again with the new result.\n   *\n   * `subscribe()` goes to significant effort to avoid extraneous work\n   * re-evaluating subscriptions:\n   *\n   * 1. subscribe tracks the keys that `body` accesses each time it runs. `body`\n   *    is only re-evaluated when those keys change.\n   * 2. subscribe only re-fires `onData` in the case that a result changes by\n   *    way of the `isEqual` option which defaults to doing a deep JSON value\n   *    equality check.\n   *\n   * Because of (1), `body` must be a pure function of the data in Replicache.\n   * `body` must not access anything other than the `tx` parameter passed to it.\n   *\n   * Although subscribe is as efficient as it can be, it is somewhat constrained\n   * by the goal of returning an arbitrary computation of the cache. For even\n   * better performance (but worse dx), see {@link experimentalWatch}.\n   *\n   * If an error occurs in the `body` the `onError` function is called if\n   * present. Otherwise, the error is logged at log level 'error'.\n   *\n   * To cancel the subscription, call the returned function.\n   *\n   * @param body The function to evaluate to get the value to pass into\n   *    `onData`.\n   * @param options Options is either a function or an object. If it is a\n   *    function it is equivalent to passing it as the `onData` property of an\n   *    object.\n   */\n  subscribe<R>(\n    body: (tx: ReadTransaction) => Promise<R>,\n    options: SubscribeOptions<R> | ((result: R) => void),\n  ): () => void {\n    if (typeof options === 'function') {\n      options = {onData: options};\n    }\n\n    const {onData, onError, onDone, isEqual} = options;\n    return this.#subscriptions.add(\n      new SubscriptionImpl(body, onData, onError, onDone, isEqual),\n    );\n  }\n\n  /**\n   * Watches Replicache for changes.\n   *\n   * The `callback` gets called whenever the underlying data changes and the\n   * `key` changes matches the `prefix` of {@link ExperimentalWatchIndexOptions} or\n   * {@link ExperimentalWatchNoIndexOptions} if present. If a change\n   * occurs to the data but the change does not impact the key space the\n   * callback is not called. In other words, the callback is never called with\n   * an empty diff.\n   *\n   * This gets called after commit (a mutation or a rebase).\n   *\n   * @experimental This method is under development and its semantics will\n   * change.\n   */\n  experimentalWatch(callback: WatchNoIndexCallback): () => void;\n  experimentalWatch<Options extends WatchOptions>(\n    callback: WatchCallbackForOptions<Options>,\n    options?: Options,\n  ): () => void;\n  experimentalWatch<Options extends WatchOptions>(\n    callback: WatchCallbackForOptions<Options>,\n    options?: Options,\n  ): () => void {\n    return this.#subscriptions.add(\n      new WatchSubscription(callback as WatchCallback, options),\n    );\n  }\n\n  /**\n   * Query is used for read transactions. It is recommended to use transactions\n   * to ensure you get a consistent view across multiple calls to `get`, `has`\n   * and `scan`.\n   */\n  query<R>(body: (tx: ReadTransaction) => Promise<R> | R): Promise<R> {\n    return this.#queryInternal(body);\n  }\n\n  get cookie(): Promise<Cookie> {\n    return this.#ready.then(() =>\n      withRead(this.memdag, async dagRead => {\n        const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n        if (!mainHeadHash) {\n          throw new Error('Internal no main head found');\n        }\n        const baseSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);\n        const baseSnapshotMeta = baseSnapshot.meta;\n        const cookie = baseSnapshotMeta.cookieJSON;\n        assertCookie(cookie);\n        return cookie;\n      }),\n    );\n  }\n\n  #queryInternal: QueryInternal = async body => {\n    await this.#ready;\n    const {clientID} = this;\n    return withRead(this.memdag, async dagRead => {\n      try {\n        const dbRead = await readFromDefaultHead(dagRead, FormatVersion.Latest);\n        const tx = new ReadTransactionImpl(clientID, dbRead, this.#lc);\n        return await body(tx);\n      } catch (ex) {\n        throw await this.#convertToClientStateNotFoundError(ex);\n      }\n    });\n  };\n\n  #register<Return extends ReadonlyJSONValue | void, Args extends JSONValue>(\n    name: string,\n    mutatorImpl: (tx: WriteTransaction, args?: Args) => MaybePromise<Return>,\n  ): (\n    args?: Args,\n  ) => Promise<Return> | {client: Promise<Return>; server: Promise<unknown>} {\n    this.#mutatorRegistry[name] = mutatorImpl as (\n      tx: WriteTransaction,\n      args: JSONValue | undefined,\n    ) => Promise<void | JSONValue>;\n\n    return (\n      args?: Args,\n    ):\n      | Promise<Return>\n      | {client: Promise<Return>; server: Promise<unknown>} => {\n      // DO NOT track CRUD mutations as they do not receive responses from\n      // the server.\n      const trackingData =\n        name === '_zero_crud' ? undefined : this.#zero?.trackMutation();\n\n      const result = this.#mutate(\n        trackingData,\n        name,\n        mutatorImpl,\n        args,\n        performance.now(),\n      );\n\n      if (trackingData) {\n        return {\n          client: result,\n          server: trackingData.serverPromise,\n          then: (onFulfilled, onRejected) => {\n            this.#lc.warn?.(\n              'Awaiting the mutator result directly is being deprecated.' +\n                ' Please use `await z.mutate[mutatorName].client` or `await result.mutate[mutatorName].server`',\n            );\n            return result.then(onFulfilled, onRejected);\n          },\n        };\n      }\n\n      return result;\n    };\n  }\n\n  #registerMutators<\n    M extends {\n      [key: string]: (\n        tx: WriteTransaction,\n        args?: ReadonlyJSONValue,\n      ) => MutatorReturn;\n    },\n  >(regs: M): MakeMutators<M> {\n    type Mut = MakeMutators<M>;\n    const rv: Partial<Mut> = Object.create(null);\n    for (const k in regs) {\n      rv[k] = this.#register(k, regs[k]) as MakeMutator<M[typeof k]>;\n    }\n    return rv as Mut;\n  }\n\n  async #mutate<\n    R extends ReadonlyJSONValue | void,\n    A extends ReadonlyJSONValue,\n  >(\n    trackingData: MutationTrackingData | undefined,\n    name: string,\n    mutatorImpl: (tx: WriteTransaction, args?: A) => MaybePromise<R>,\n    args: A | undefined,\n    timestamp: number,\n  ): Promise<R> {\n    const frozenArgs = deepFreeze(args ?? null);\n\n    // Ensure that we run initial pending subscribe functions before starting a\n    // write transaction.\n    if (this.#subscriptions.hasPendingSubscriptionRuns) {\n      await Promise.resolve();\n    }\n\n    await this.#ready;\n    const {clientID} = this;\n    return withWriteNoImplicitCommit(this.memdag, async dagWrite => {\n      try {\n        let result: R;\n        let newHead: Hash;\n        let diffs: DiffsMap;\n        let headHash: Hash;\n        try {\n          headHash = await mustGetHeadHash(DEFAULT_HEAD_NAME, dagWrite);\n          const originalHash = null;\n\n          const dbWrite = await newWriteLocal(\n            headHash,\n            name,\n            frozenArgs,\n            originalHash,\n            dagWrite,\n            timestamp,\n            clientID,\n            FormatVersion.Latest,\n          );\n\n          const mutationID = await dbWrite.getMutationID();\n          const tx = new WriteTransactionImpl(\n            clientID,\n            mutationID,\n            'initial',\n            await this.#zero?.getTxData(headHash, {\n              openLazyRead: dagWrite,\n            }),\n            dbWrite,\n            this.#lc,\n          );\n\n          if (trackingData) {\n            this.#zero?.mutationIDAssigned(\n              trackingData.ephemeralID,\n              mutationID,\n            );\n          }\n\n          result = await mutatorImpl(tx, args);\n\n          throwIfClosed(dbWrite);\n          const lastMutationID = await dbWrite.getMutationID();\n          [newHead, diffs] = await dbWrite.commitWithDiffs(\n            DEFAULT_HEAD_NAME,\n            this.#subscriptions,\n          );\n\n          // Update this after the commit in case the commit fails.\n          this.lastMutationID = lastMutationID;\n        } catch (e) {\n          // If we threw before we could persist the mutation\n          // then we need to reject the mutation.\n          if (trackingData) {\n            this.#zero?.rejectMutation(trackingData.ephemeralID, e);\n          }\n          throw e;\n        }\n\n        this.#zero?.advance(headHash, newHead, diffs.get('') ?? []);\n\n        // Send is not supposed to reject\n        this.#pushConnectionLoop.send(false).catch(() => void 0);\n        await this.#subscriptions.fire(diffs);\n        void this.#schedulePersist();\n        return result;\n      } catch (ex) {\n        throw await this.#convertToClientStateNotFoundError(ex);\n      }\n    });\n  }\n\n  /**\n   * In the case we get a ChunkNotFoundError we check if the client got garbage\n   * collected and if so change the error to a ClientStateNotFoundError instead\n   */\n  async #convertToClientStateNotFoundError(ex: unknown): Promise<unknown> {\n    if (\n      ex instanceof ChunkNotFoundError &&\n      (await this.#checkForClientStateNotFoundAndCallHandler())\n    ) {\n      return new ClientStateNotFoundError(this.clientID);\n    }\n\n    return ex;\n  }\n\n  recoverMutations(): Promise<boolean> | void {\n    if (!process.env.DISABLE_MUTATION_RECOVERY) {\n      const result = this.#mutationRecovery!.recoverMutations(\n        this.#ready,\n        this.perdag,\n        this.#idbDatabase,\n        this.#idbDatabases,\n        this.#kvStoreProvider.create,\n      );\n      if (TESTING) {\n        void this.onRecoverMutations(result);\n      }\n      return result;\n    }\n  }\n\n  /**\n   * List of pending mutations. The order of this is from oldest to newest.\n   *\n   * Gives a list of local mutations that have `mutationID` >\n   * `syncHead.mutationID` that exists on the main client group.\n   *\n   * @experimental This method is experimental and may change in the future.\n   */\n  experimentalPendingMutations(): Promise<readonly PendingMutation[]> {\n    return withRead(this.memdag, pendingMutationsForAPI);\n  }\n}\n\n// This map is used to keep track of closing instances of Replicache. When an\n// instance is opening we wait for any currently closing instances.\nconst closingInstances: Map<string, Promise<unknown>> = new Map();\n\nasync function throwIfError(p: Promise<undefined | {error: unknown}>) {\n  const res = await p;\n  if (res) {\n    throw res.error;\n  }\n}\n\nfunction reload(): void {\n  if (typeof location !== 'undefined') {\n    location.reload();\n  }\n}\n\nfunction validateOptions<MD extends MutatorDefs>(\n  options: ReplicacheOptions<MD>,\n): void {\n  const {name, clientMaxAgeMs} = options;\n  if (typeof name !== 'string' || !name) {\n    throw new TypeError('name is required and must be non-empty');\n  }\n\n  if (clientMaxAgeMs !== undefined) {\n    const min = Math.max(GC_INTERVAL, HEARTBEAT_INTERVAL);\n    if (typeof clientMaxAgeMs !== 'number' || clientMaxAgeMs <= min) {\n      throw new TypeError(\n        `clientAgeMaxMs must be a number larger than ${min}ms`,\n      );\n    }\n  }\n}\n","import {resolver} from '@rocicorp/resolver';\n\ntype PartialDocument = Pick<\n  Document,\n  'visibilityState' | 'addEventListener' | 'removeEventListener'\n>;\n\nexport function getDocumentVisibilityWatcher(\n  doc: PartialDocument | undefined,\n  hiddenIntervalMS: number,\n  signal: AbortSignal,\n): DocumentVisibilityWatcher {\n  return doc\n    ? new DocumentVisibilityWatcherImpl(doc, hiddenIntervalMS, signal)\n    : new DocumentVisibilityWatcherNoDoc();\n}\n\nexport interface DocumentVisibilityWatcher {\n  readonly visibilityState: DocumentVisibilityState;\n  waitForVisible(): Promise<unknown>;\n  waitForHidden(): Promise<unknown>;\n}\n\nclass DocumentVisibilityWatcherImpl implements DocumentVisibilityWatcher {\n  readonly #doc: PartialDocument;\n  readonly #hiddenIntervalMS: number;\n  #timeoutID: ReturnType<typeof setTimeout> | 0 = 0;\n\n  // This trails doc.visibilityState by hiddenIntervalMS when being hidden. This\n  // is because we want to wait for the tab to be hidden for a while before\n  // considering as hidden.\n  visibilityState: DocumentVisibilityState;\n\n  readonly #promises = new Set<{\n    resolve: () => void;\n    state: DocumentVisibilityState;\n  }>();\n\n  constructor(\n    doc: PartialDocument,\n    hiddenIntervalMS: number,\n    signal: AbortSignal,\n  ) {\n    this.#doc = doc;\n    this.#hiddenIntervalMS = hiddenIntervalMS;\n    this.visibilityState = doc.visibilityState;\n    // Safari got support for abort signal in addEventListener in version\n    // 15 (Released 2021-09-20)\n    this.#doc.addEventListener('visibilitychange', this.#onVisibilityChange, {\n      signal,\n    });\n  }\n\n  #onVisibilityChange = () => {\n    if (this.#doc.visibilityState === 'visible') {\n      clearTimeout(this.#timeoutID);\n      this.#setVisibilityState('visible');\n    } else {\n      this.#timeoutID = setTimeout(() => {\n        this.#setVisibilityState('hidden');\n      }, this.#hiddenIntervalMS);\n    }\n  };\n\n  #setVisibilityState(visibilityState: DocumentVisibilityState) {\n    if (visibilityState === this.visibilityState) {\n      return;\n    }\n    this.visibilityState = visibilityState;\n    for (const entry of this.#promises) {\n      const {resolve, state} = entry;\n      if (state === visibilityState) {\n        resolve();\n        this.#promises.delete(entry);\n      }\n    }\n  }\n\n  waitForVisible(): Promise<unknown> {\n    return this.#waitFor('visible');\n  }\n\n  waitForHidden(): Promise<unknown> {\n    return this.#waitFor('hidden');\n  }\n\n  #waitFor(state: DocumentVisibilityState): Promise<unknown> {\n    if (this.visibilityState === state) {\n      return Promise.resolve();\n    }\n\n    const {promise, resolve} = resolver();\n    this.#promises.add({resolve, state});\n    return promise;\n  }\n}\n\nconst resolvedPromise = Promise.resolve();\nconst promiseThatNeverResolves = new Promise(() => undefined);\n\nclass DocumentVisibilityWatcherNoDoc implements DocumentVisibilityWatcher {\n  readonly visibilityState: DocumentVisibilityState = 'visible';\n  waitForVisible(): Promise<unknown> {\n    return resolvedPromise;\n  }\n\n  waitForHidden(): Promise<unknown> {\n    return promiseThatNeverResolves;\n  }\n}\n","import type {ConnectionLoopDelegate} from './connection-loop.ts';\nimport type {ReplicacheImpl} from './replicache-impl.ts';\n\nclass ConnectionLoopDelegateImpl {\n  readonly rep: ReplicacheImpl;\n  readonly invokeSend: () => Promise<boolean>;\n\n  // TODO: Remove the ability to have more than one concurrent connection and update tests.\n  // Bug: https://github.com/rocicorp/replicache-internal/issues/303\n  readonly maxConnections = 1;\n\n  constructor(rep: ReplicacheImpl, invokeSend: () => Promise<boolean>) {\n    this.rep = rep;\n    this.invokeSend = invokeSend;\n  }\n\n  get maxDelayMs(): number {\n    return this.rep.requestOptions.maxDelayMs;\n  }\n\n  get minDelayMs(): number {\n    return this.rep.requestOptions.minDelayMs;\n  }\n}\n\nexport class PullDelegate\n  extends ConnectionLoopDelegateImpl\n  implements ConnectionLoopDelegate\n{\n  readonly debounceDelay = 0;\n\n  get watchdogTimer(): number | null {\n    return this.rep.pullInterval;\n  }\n}\n\nexport class PushDelegate\n  extends ConnectionLoopDelegateImpl\n  implements ConnectionLoopDelegate\n{\n  get debounceDelay(): number {\n    return this.rep.pushDelay;\n  }\n\n  watchdogTimer = null;\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {resolver} from '@rocicorp/resolver';\nimport type {DocumentVisibilityWatcher} from '../../shared/src/document-visible.ts';\nimport {sleep} from '../../shared/src/sleep.ts';\n\nexport const DEBOUNCE_DELAY_MS = 10;\n\nexport const MIN_DELAY_MS = 30;\nexport const MAX_DELAY_MS = 60_000;\n\ntype SendRecord = {duration: number; ok: boolean};\n\nexport interface ConnectionLoopDelegate {\n  invokeSend(): Promise<boolean>;\n  debounceDelay: number;\n  // If null, no watchdog timer is used.\n  watchdogTimer: number | null;\n  maxConnections: number;\n  maxDelayMs: number;\n  minDelayMs: number;\n}\n\nexport class ConnectionLoop {\n  // ConnectionLoop runs a loop sending network requests (either pushes or\n  // pulls) to the server. Our goal, generally, is to send requests as fast as\n  // we can, but to adjust in case of slowness, network errors, etc. We will\n  // send requests in parallel if the server supports it. We also debounce\n  // pushes since they frequently happen in series very near to one another\n  // (e.g., during drag'n drops).\n  //\n  // The loop flows through the following states forever, until it is closed:\n  //\n  // Pending: Wait for event or watchdog\n  //          |\n  //          v\n  // Debounce: Wait for more events (we debounce pushes)\n  //          |\n  //          v\n  // Wait for available connection (we limit number of parallel requests\n  // allowed)\n  //          |\n  //          v\n  // Wait to send (if requests are taking too long, we will slow down)\n  //          |\n  //          v\n  // Send (asynchronously, wrt the loop)\n  //          |\n  //          v\n  // Back to the pending!\n\n  // Controls whether the next iteration of the loop will wait at the pending\n  // state.\n  #pendingResolver = resolver<void>();\n\n  /**\n   * This resolver is used to allow us to skip sleeps when we do send(true)\n   */\n  #skipSleepsResolver = resolver<void>();\n\n  /**\n   * Resolver for the next send. Never rejects. Returns an error instead since\n   * this resolver is used in cases where they might not be someone waiting,\n   * and we don't want an unhandled promise rejection in that case.\n   */\n  #sendResolver = resolver<undefined | {error: unknown}>();\n\n  readonly #delegate: ConnectionLoopDelegate;\n  #closed = false;\n\n  /**\n   * Number of pending send calls.\n   *\n   * We keep track of this because if close happens while we are waiting for the\n   * send to resolve we should reject the send promise.\n   */\n  #sendCounter = 0;\n  readonly #lc: LogContext;\n  readonly #visibilityWatcher: DocumentVisibilityWatcher | undefined;\n\n  constructor(\n    lc: LogContext,\n    delegate: ConnectionLoopDelegate,\n    visibilityWatcher?: DocumentVisibilityWatcher,\n  ) {\n    this.#lc = lc;\n    this.#delegate = delegate;\n    this.#visibilityWatcher = visibilityWatcher;\n    void this.run();\n  }\n\n  close(): void {\n    this.#closed = true;\n    if (this.#sendCounter > 0) {\n      this.#sendResolver.resolve({error: closeError()});\n    }\n  }\n\n  /**\n   *\n   * @returns Returns undefined if ok, otherwise it return the error that caused\n   * the send to fail.\n   */\n  async send(now: boolean): Promise<undefined | {error: unknown}> {\n    if (this.#closed) {\n      return {error: closeError()};\n    }\n    this.#sendCounter++;\n    this.#lc.debug?.('send', now);\n    if (now) {\n      this.#skipSleepsResolver.resolve();\n    } else {\n      await this.#visibilityWatcher?.waitForVisible();\n    }\n\n    this.#pendingResolver.resolve();\n\n    const result = await this.#sendResolver.promise;\n    this.#sendCounter--;\n    return result;\n  }\n\n  async run(): Promise<void> {\n    const sendRecords: SendRecord[] = [];\n\n    let recoverResolver = resolver();\n    let lastSendTime;\n\n    // The number of active connections.\n    let counter = 0;\n    const delegate = this.#delegate;\n    const {debug} = this.#lc;\n    let delay = 0;\n\n    debug?.('Starting connection loop');\n\n    const sleepMaybeSkip: typeof sleep = ms =>\n      Promise.race([this.#skipSleepsResolver.promise, sleep(ms)]);\n\n    while (!this.#closed) {\n      debug?.(\n        didLastSendRequestFail(sendRecords)\n          ? 'Last request failed. Trying again'\n          : 'Waiting for a send',\n      );\n\n      // Wait until send is called or until the watchdog timer fires.\n      const races = [this.#pendingResolver.promise];\n      const t = delegate.watchdogTimer;\n      if (t !== null) {\n        races.push(sleep(t));\n      }\n      await Promise.race(races);\n      if (this.#closed) break;\n\n      debug?.('Waiting for debounce');\n      await sleepMaybeSkip(delegate.debounceDelay);\n      if (this.#closed) break;\n      debug?.('debounced');\n\n      // This resolver is used to wait for incoming push calls.\n      this.#pendingResolver = resolver();\n\n      if (counter >= delegate.maxConnections) {\n        debug?.('Too many request in flight. Waiting until one finishes...');\n        await this.#waitUntilAvailableConnection();\n        if (this.#closed) break;\n        debug?.('...finished');\n      }\n\n      // We need to delay the next request even if there are no active requests\n      // in case of error.\n      if (counter > 0 || didLastSendRequestFail(sendRecords)) {\n        delay = computeDelayAndUpdateDurations(delay, delegate, sendRecords);\n        debug?.(\n          didLastSendRequestFail(sendRecords)\n            ? 'Last connection errored. Sleeping for'\n            : 'More than one outstanding connection (' +\n                counter +\n                '). Sleeping for',\n          delay,\n          'ms',\n        );\n      } else {\n        // We set this to 0 here in case minDelayMs is mutated to a lower value\n        // than the old delay so that we still get minDelayMs. This can happen\n        // if we get an error during a run where minDelayMs is larger than the\n        // current value of minDelayMs.\n        delay = 0;\n      }\n\n      const clampedDelay = Math.min(\n        delegate.maxDelayMs,\n        Math.max(delegate.minDelayMs, delay),\n      );\n      if (lastSendTime !== undefined) {\n        const timeSinceLastSend = Date.now() - lastSendTime;\n        if (clampedDelay > timeSinceLastSend) {\n          await Promise.race([\n            sleepMaybeSkip(clampedDelay - timeSinceLastSend),\n            recoverResolver.promise,\n          ]);\n          if (this.#closed) break;\n        }\n      }\n\n      counter++;\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (async () => {\n        const start = Date.now();\n        let ok: boolean;\n        let error: unknown;\n        try {\n          lastSendTime = start;\n          debug?.('Sending request');\n          this.#skipSleepsResolver = resolver();\n          ok = await delegate.invokeSend();\n          debug?.('Send returned', ok);\n        } catch (e) {\n          debug?.('Send failed', e);\n          error = e;\n          ok = false;\n        }\n        if (this.#closed) {\n          debug?.('Closed after invokeSend');\n          return;\n        }\n        debug?.('Request done', {duration: Date.now() - start, ok});\n        sendRecords.push({duration: Date.now() - start, ok});\n        if (recovered(sendRecords)) {\n          recoverResolver.resolve();\n          recoverResolver = resolver();\n        }\n        counter--;\n        this.#connectionAvailable();\n        const sendResolver = this.#sendResolver;\n        this.#sendResolver = resolver();\n        if (error) {\n          sendResolver.resolve({error});\n        } else {\n          sendResolver.resolve(undefined);\n        }\n        if (!ok) {\n          // Keep trying\n          this.#pendingResolver.resolve();\n        }\n      })();\n    }\n  }\n\n  #waitingConnectionResolve: (() => void) | undefined = undefined;\n\n  #connectionAvailable() {\n    if (this.#waitingConnectionResolve) {\n      const resolve = this.#waitingConnectionResolve;\n      this.#waitingConnectionResolve = undefined;\n      resolve();\n    }\n  }\n\n  #waitUntilAvailableConnection() {\n    const {promise, resolve} = resolver();\n    this.#waitingConnectionResolve = resolve;\n    return promise;\n  }\n}\n\n// Number of connections to remember when computing the new delay.\nconst CONNECTION_MEMORY_COUNT = 9;\n\nfunction closeError() {\n  return new Error('Closed');\n}\n\n// Computes a new delay based on the previous requests. We use the median of the\n// previous successful request divided by `maxConnections`. When we get errors\n// we do exponential backoff. As soon as we recover from an error we reset back\n// to delegate.minDelayMs.\nfunction computeDelayAndUpdateDurations(\n  delay: number,\n  delegate: ConnectionLoopDelegate,\n  sendRecords: SendRecord[],\n): number {\n  const {length} = sendRecords;\n  if (length === 0) {\n    return delay;\n  }\n\n  const {ok} = sendRecords[sendRecords.length - 1];\n  const {maxConnections, minDelayMs} = delegate;\n\n  if (!ok) {\n    return delay === 0 ? minDelayMs : delay * 2;\n  }\n\n  if (length > 1) {\n    // length > 1\n    const previous: SendRecord = sendRecords[sendRecords.length - 2];\n\n    // Prune\n    while (sendRecords.length > CONNECTION_MEMORY_COUNT) {\n      sendRecords.shift();\n    }\n\n    if (ok && !previous.ok) {\n      // Recovered\n      return minDelayMs;\n    }\n  }\n\n  const med = median(\n    sendRecords.filter(({ok}) => ok).map(({duration}) => duration),\n  );\n\n  return (med / maxConnections) | 0;\n}\n\nfunction median(values: number[]) {\n  values.sort();\n  const {length} = values;\n  const half = length >> 1;\n  if (length % 2 === 1) {\n    return values[half];\n  }\n  return (values[half - 1] + values[half]) / 2;\n}\n\nfunction didLastSendRequestFail(sendRecords: SendRecord[]) {\n  return sendRecords.length > 0 && !sendRecords[sendRecords.length - 1].ok;\n}\n\nfunction recovered(sendRecords: SendRecord[]) {\n  return (\n    sendRecords.length > 1 &&\n    !sendRecords[sendRecords.length - 2].ok &&\n    sendRecords[sendRecords.length - 1].ok\n  );\n}\n","import {RWLock} from '@rocicorp/lock';\nimport {joinIterables} from '../../../shared/src/iterables.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport type {Hash} from '../hash.ts';\nimport {getSizeOfValue} from '../size-of-value.ts';\nimport {Chunk, type ChunkHasher, type Refs, createChunk} from './chunk.ts';\nimport {\n  type HeadChange,\n  type RefCountUpdatesDelegate,\n  computeRefCountUpdates,\n} from './gc.ts';\nimport {type Read, type Store, type Write, mustGetChunk} from './store.ts';\n\n/**\n * Dag Store which lazily loads values from a source store and then caches\n * them in an LRU cache.  The memory cache for chunks from the source store\n * size is limited to `sourceCacheSizeLimit` bytes, and values are evicted in an\n * LRU fashion.  The purpose of this store is to avoid holding the entire client\n * view (i.e. the source store's content) in each tab's JavaScript heap.\n *\n * This store's heads are independent from the heads of source store, and are\n * only stored in memory.\n *\n * Chunks which are created via this store's {@link Write} transaction's\n * {@link createChunk} method are assumed to not be persisted to the source\n * store and thus are cached separately from the source store chunks.  These\n * memory-only chunks will not be evicted, and their sizes are not counted\n * towards the source chunk cache size.  A memory-only chunk will be deleted if\n * it is no longer reachable from one of this store's heads.\n *\n * Writes only manipulate the in memory state of this store and do not alter the\n * source store.  Thus values must be written to the source store through a\n * separate process (see {@link persist}).\n *\n * Intended use:\n * 1. source store is the 'perdag', a slower persistent store (i.e.\n *    dag.StoreImpl using a kv.IDBStore)\n * 2. this store's 'main' head is initialized to the hash of a chunk containing\n *    a commit in the source store\n * 3. reads lazily read chunks from the source store and cache them\n * 3. writes are initially made to this store with memory-only chunks\n * 4. writes are asynchronously persisted to the source store through a separate\n *    process (see {@link persist}}. This process gathers memory-only chunks\n *    from this store and then writes them to the source store.  It then informs\n *    this store that these chunks are no longer memory-only by calling\n *    {@link chunksPersisted}, which move these chunks\n *    to this store's LRU cache of source chunks (making them eligible for\n *    eviction).\n *\n * @param sourceStore Store to lazy load and cache values from.\n * @param sourceCacheSizeLimit Size limit in bytes for cache of chunks loaded\n * from `sourceStore`.  This size of a value is determined using\n * `getSizeOfValue`.  Keys do not count towards cache size.  Memory-only chunks\n * do not count towards cache size.\n * @param getSizeOfValue Function for measuring the size in bytes of a value.\n */\nexport class LazyStore implements Store {\n  /**\n   * This lock is used to ensure correct isolation of Reads and Writes.\n   * Multiple Reads are allowed in parallel but only a single Write.  Reads and\n   * Writes see an isolated view of the store (corresponding to the Serializable\n   * level of transaction isolation defined in the SQL standard).\n   *\n   * To ensure these semantics the read lock must be acquired when a Read is\n   * created and held til it is closed, and a Write lock must be acquired when a\n   * Write is created and held til it is committed or closed.\n   *\n   * Code must have a read or write lock to\n   * - read `_heads`\n   * - read `_memOnlyChunks`\n   * - read `_sourceStore`\n   * - read and write `_sourceChunksCache`\n   * - read and write `_refCounts`\n   * - read and write `_refs`\n   * and must have a write lock to\n   * - write `_heads`\n   * - write `_memOnlyChunks`\n   */\n  readonly #rwLock = new RWLock();\n  readonly #heads = new Map<string, Hash>();\n  readonly #sourceStore: Store;\n  readonly #chunkHasher: ChunkHasher;\n  readonly #assertValidHash: (hash: Hash) => void;\n\n  /** The following are protected so testing subclass can access. */\n  protected readonly _memOnlyChunks = new Map<Hash, Chunk>();\n  protected readonly _sourceChunksCache: ChunksCache;\n  /**\n   * Ref counts are maintained so that chunks which are unreachable\n   * from this stores heads can be eagerly and deterministically deleted from\n   * `this._memOnlyChunks` and `this._sourceChunksCache`.\n   *\n   * These ref counts are independent from `this._sourceStore`'s ref counts.\n   * These ref counts are based on reachability from `this._heads`.\n   * A chunk is deleted from `this._memOnlyChunks` or\n   * `this._sourceChunksCache` (which ever it is in) when its ref count becomes\n   * zero.\n   * These ref counts count the refs in `this._heads` and `this._refs`.\n   *\n   * Not all reachable chunk's refs are included in `this._refs`, because this\n   * would require loading all chunks reachable in the source store in a\n   * non-lazy manner. `this._refs` contains the refs of all currently reachable\n   * chunks that were ever in `this._memOnlyChunks` or\n   * `this._sourceChunksCache` (even if they have been evicted).  A\n   * chunk's ref information is lazily discovered and stored in `this._refs` and\n   * counted in `this._refCounts`. A chunk's entries in `this._refs` and\n   * `this._refCounts` are only deleted when a chunk is deleted due to it\n   * becoming unreachable (it is not deleted if the chunk is evicted from the\n   * source-store cache).\n   *\n   * The major implication of this lazy discovery of source store refs, is that\n   * a reachable source store chunk may not be cached when loaded, because it is\n   * not known to be reachable because some of the pertinent refs have not been\n   * discovered.  However, in practice chunks are read by traversing the graph\n   * starting from a head, and all pertinent refs are discovered as part of the\n   * traversal.\n   *\n   * These ref counts can be changed in two ways:\n   * 1. A LazyRead has a cache miss and loads a chunk from the source store that\n   * is reachable from this._heads.  If this chunk's refs are not currently\n   * counted, it will not have an entry in `this._refs`.  In this case, the\n   * chunks refs will be put in `this._refs` and `this._refCounts` will be\n   * updated to count them.\n   * 2. A LazyWrite commit updates a head (which can result in increasing or\n   * decreasing ref count) or puts a reachable chunk (either a `memory-only` or\n   * `source` chunk) that references this hash (increasing ref count).  The\n   * computation of these ref count changes is delegated to the\n   * `computeRefCountUpdates` shared with dag.StoreImpl.  In order to\n   * delegate determining reachability to `computeRefCountUpdates` and defer\n   * this determination until commit time, LazyWrite treats cache misses\n   * as a 'put' of the lazily-loaded chunk.\n   *\n   * A chunk's hash may have an entry in `this._refCounts` without that\n   * chunk have ever been in `this._memOnlyChunks` or `this._sourceChunksCache`.\n   * This is the case when a head or a reachable chunk that was ever in\n   * `this._memOnlyChunks` or `this._sourceChunksCache` references a chunk\n   * which is not currently cached (either because it has not been read, or\n   * because it has been evicted).\n   */\n  protected readonly _refCounts = new Map<Hash, number>();\n  protected readonly _refs = new Map<Hash, readonly Hash[]>();\n\n  constructor(\n    sourceStore: Store,\n    sourceCacheSizeLimit: number,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n    getSizeOfChunk: (chunk: Chunk) => number = getSizeOfValue,\n  ) {\n    this._sourceChunksCache = new ChunksCache(\n      sourceCacheSizeLimit,\n      getSizeOfChunk,\n      this._refCounts,\n      this._refs,\n    );\n    this.#sourceStore = sourceStore;\n    this.#chunkHasher = chunkHasher;\n    this.#assertValidHash = assertValidHash;\n  }\n\n  async read(sourceRead?: Read): Promise<LazyRead> {\n    const release = await this.#rwLock.read();\n    return new LazyRead(\n      this.#heads,\n      this._memOnlyChunks,\n      this._sourceChunksCache,\n      this.#sourceStore,\n      release,\n      this.#assertValidHash,\n      sourceRead,\n    );\n  }\n\n  async write(): Promise<LazyWrite> {\n    const release = await this.#rwLock.write();\n    return new LazyWrite(\n      this.#heads,\n      this._memOnlyChunks,\n      this._sourceChunksCache,\n      this.#sourceStore,\n      this._refCounts,\n      this._refs,\n      release,\n      this.#chunkHasher,\n      this.#assertValidHash,\n    );\n  }\n\n  close(): Promise<void> {\n    return promiseVoid;\n  }\n\n  /**\n   * Does not acquire any lock on the store.\n   */\n  isCached(chunkHash: Hash): boolean {\n    return (\n      this._sourceChunksCache.getWithoutUpdatingLRU(chunkHash) !== undefined\n    );\n  }\n\n  withSuspendedSourceCacheEvictsAndDeletes<T>(\n    fn: () => MaybePromise<T>,\n  ): Promise<T> {\n    return this._sourceChunksCache.withSuspendedEvictsAndDeletes(fn);\n  }\n}\n\nexport class LazyRead implements Read {\n  protected readonly _heads: Map<string, Hash>;\n  protected readonly _memOnlyChunks: Map<Hash, Chunk>;\n  protected readonly _sourceChunksCache: ChunksCache;\n  protected readonly _sourceStore: Store;\n  #sourceRead: Promise<Read> | undefined = undefined;\n  readonly #release: () => void;\n  #closed = false;\n  readonly assertValidHash: (hash: Hash) => void;\n  readonly #sourceReadOwnedByCaller: boolean;\n\n  constructor(\n    heads: Map<string, Hash>,\n    memOnlyChunks: Map<Hash, Chunk>,\n    sourceChunksCache: ChunksCache,\n    sourceStore: Store,\n    release: () => void,\n    assertValidHash: (hash: Hash) => void,\n    // If the lazyRead is being run in the context of an existing\n    // read, or write, from the perdag then we must use _that_\n    // transaction's read. Trying to open our own `sourceRead` will\n    // cause the outer transaction to auto-commit.\n    sourceRead?: Read | undefined,\n  ) {\n    this._heads = heads;\n    this._memOnlyChunks = memOnlyChunks;\n    this._sourceChunksCache = sourceChunksCache;\n    this._sourceStore = sourceStore;\n    this.#release = release;\n    this.assertValidHash = assertValidHash;\n    this.#sourceRead =\n      sourceRead !== undefined ? Promise.resolve(sourceRead) : undefined;\n    this.#sourceReadOwnedByCaller = sourceRead !== undefined;\n  }\n\n  isMemOnlyChunkHash(hash: Hash): boolean {\n    return this._memOnlyChunks.has(hash);\n  }\n\n  async hasChunk(hash: Hash): Promise<boolean> {\n    return (await this.getChunk(hash)) !== undefined;\n  }\n\n  async getChunk(hash: Hash): Promise<Chunk | undefined> {\n    const memOnlyChunk = this._memOnlyChunks.get(hash);\n    if (memOnlyChunk !== undefined) {\n      return memOnlyChunk;\n    }\n    let chunk = this._sourceChunksCache.get(hash);\n    if (chunk === undefined) {\n      chunk = await (await this._getSourceRead()).getChunk(hash);\n      if (chunk !== undefined) {\n        this._sourceChunksCache.put(chunk);\n      }\n    }\n    return chunk;\n  }\n\n  mustGetChunk(hash: Hash): Promise<Chunk> {\n    return mustGetChunk(this, hash);\n  }\n\n  getHead(name: string): Promise<Hash | undefined> {\n    return Promise.resolve(this._heads.get(name));\n  }\n\n  release(): void {\n    if (!this.#closed) {\n      this.#release();\n      if (!this.#sourceReadOwnedByCaller) {\n        this.#sourceRead\n          ?.then(read => read.release())\n          // If creation of the read failed there is nothing to release.\n          // Catch to avoid `Uncaught (in promise)` errors being reported.\n          // eslint-disable-next-line @typescript-eslint/no-empty-function\n          .catch(_ => {});\n      }\n      this.#closed = true;\n    }\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  protected _getSourceRead(): Promise<Read> {\n    if (!this.#sourceRead) {\n      this.#sourceRead = this._sourceStore.read();\n    }\n    return this.#sourceRead;\n  }\n}\n\nexport class LazyWrite\n  extends LazyRead\n  implements Write, RefCountUpdatesDelegate\n{\n  readonly #refCounts: Map<Hash, number>;\n  readonly #refs: Map<Hash, readonly Hash[]>;\n  readonly #chunkHasher: ChunkHasher;\n  protected readonly _pendingHeadChanges = new Map<string, HeadChange>();\n  protected readonly _pendingMemOnlyChunks = new Map<Hash, Chunk>();\n  protected readonly _pendingCachedChunks = new Map<\n    Hash,\n    {chunk: Chunk; size: number}\n  >();\n  readonly #createdChunks = new Set<Hash>();\n\n  constructor(\n    heads: Map<string, Hash>,\n    memOnlyChunks: Map<Hash, Chunk>,\n    sourceChunksCache: ChunksCache,\n    sourceStore: Store,\n    refCounts: Map<Hash, number>,\n    refs: Map<Hash, readonly Hash[]>,\n    release: () => void,\n    chunkHasher: ChunkHasher,\n    assertValidHash: (hash: Hash) => void,\n  ) {\n    super(\n      heads,\n      memOnlyChunks,\n      sourceChunksCache,\n      sourceStore,\n      release,\n      assertValidHash,\n    );\n    this.#refCounts = refCounts;\n    this.#refs = refs;\n    this.#chunkHasher = chunkHasher;\n  }\n\n  createChunk = <V>(data: V, refs: Refs): Chunk<V> => {\n    const chunk = createChunk(data, refs, this.#chunkHasher);\n    this.#createdChunks.add(chunk.hash);\n    return chunk;\n  };\n\n  putChunk<V>(c: Chunk<V>, size?: number): Promise<void> {\n    const {hash, meta} = c;\n    this.assertValidHash(hash);\n    if (meta.length > 0) {\n      for (const h of meta) {\n        this.assertValidHash(h);\n      }\n    }\n    if (this.#createdChunks.has(hash) || this.isMemOnlyChunkHash(hash)) {\n      this._pendingMemOnlyChunks.set(hash, c);\n    } else {\n      this._pendingCachedChunks.set(hash, {chunk: c, size: size ?? -1});\n    }\n    return promiseVoid;\n  }\n\n  async setHead(name: string, hash: Hash): Promise<void> {\n    await this.#setHead(name, hash);\n  }\n\n  async removeHead(name: string): Promise<void> {\n    await this.#setHead(name, undefined);\n  }\n\n  async #setHead(name: string, hash: Hash | undefined): Promise<void> {\n    const oldHash = await this.getHead(name);\n    const v = this._pendingHeadChanges.get(name);\n    if (v === undefined) {\n      this._pendingHeadChanges.set(name, {new: hash, old: oldHash});\n    } else {\n      // Keep old if existing\n      v.new = hash;\n    }\n  }\n\n  override isMemOnlyChunkHash(hash: Hash): boolean {\n    return (\n      this._pendingMemOnlyChunks.has(hash) || super.isMemOnlyChunkHash(hash)\n    );\n  }\n\n  override async getChunk(hash: Hash): Promise<Chunk | undefined> {\n    const pendingMemOnlyChunk = this._pendingMemOnlyChunks.get(hash);\n    if (pendingMemOnlyChunk !== undefined) {\n      return pendingMemOnlyChunk;\n    }\n    const memOnlyChunk = this._memOnlyChunks.get(hash);\n    if (memOnlyChunk !== undefined) {\n      return memOnlyChunk;\n    }\n    // In order to delegate determining reachability to `computeRefCountUpdates`\n    // and defer this determination until commit time, treat cache misses\n    // as a 'put' of the lazily-loaded chunk.\n    const pendingCachedChunk = this._pendingCachedChunks.get(hash);\n    if (pendingCachedChunk !== undefined) {\n      return pendingCachedChunk.chunk;\n    }\n    let chunk = this._sourceChunksCache.get(hash);\n    if (chunk === undefined) {\n      chunk = await (await this._getSourceRead()).getChunk(hash);\n      if (chunk !== undefined) {\n        this._pendingCachedChunks.set(chunk.hash, {chunk, size: -1});\n      }\n    }\n    return chunk;\n  }\n\n  override getHead(name: string): Promise<Hash | undefined> {\n    const headChange = this._pendingHeadChanges.get(name);\n    if (headChange) {\n      return Promise.resolve(headChange.new);\n    }\n    return super.getHead(name);\n  }\n\n  async commit(): Promise<void> {\n    const pendingChunks = new Set(\n      joinIterables(\n        this._pendingMemOnlyChunks.keys(),\n        this._pendingCachedChunks.keys(),\n      ),\n    );\n    const refCountUpdates = await computeRefCountUpdates(\n      this._pendingHeadChanges.values(),\n      pendingChunks,\n      this,\n    );\n\n    for (const [hash, count] of refCountUpdates) {\n      if (this.isMemOnlyChunkHash(hash)) {\n        if (count === 0) {\n          this.#refCounts.delete(hash);\n          this._memOnlyChunks.delete(hash);\n          this.#refs.delete(hash);\n        } else {\n          this.#refCounts.set(hash, count);\n          const chunk = this._pendingMemOnlyChunks.get(hash);\n          if (chunk) {\n            this.#refs.set(hash, chunk.meta);\n            this._memOnlyChunks.set(hash, chunk);\n          }\n        }\n        refCountUpdates.delete(hash);\n      }\n    }\n\n    this._sourceChunksCache.updateForCommit(\n      this._pendingCachedChunks,\n      refCountUpdates,\n    );\n\n    for (const [name, headChange] of this._pendingHeadChanges) {\n      if (headChange.new) {\n        this._heads.set(name, headChange.new);\n      } else {\n        this._heads.delete(name);\n      }\n    }\n\n    this._pendingMemOnlyChunks.clear();\n    this._pendingCachedChunks.clear();\n    this._pendingHeadChanges.clear();\n    this.release();\n  }\n\n  getRefCount(hash: Hash): number | undefined {\n    return this.#refCounts.get(hash);\n  }\n\n  getRefs(hash: Hash): readonly Hash[] | undefined {\n    const pendingMemOnlyChunk = this._pendingMemOnlyChunks.get(hash);\n    if (pendingMemOnlyChunk) {\n      return pendingMemOnlyChunk.meta;\n    }\n    const memOnlyChunk = this._memOnlyChunks.get(hash);\n    if (memOnlyChunk) {\n      return memOnlyChunk.meta;\n    }\n    const pendingCachedChunk = this._pendingCachedChunks.get(hash);\n    if (pendingCachedChunk !== undefined) {\n      return pendingCachedChunk.chunk.meta;\n    }\n    return this.#refs.get(hash);\n  }\n\n  areRefsCounted(hash: Hash): boolean {\n    return this.#refs.has(hash);\n  }\n\n  chunksPersisted(chunkHashes: readonly Hash[]): void {\n    const chunksToCache = [];\n    for (const chunkHash of chunkHashes) {\n      const chunk = this._memOnlyChunks.get(chunkHash);\n      if (chunk) {\n        this._memOnlyChunks.delete(chunkHash);\n        chunksToCache.push(chunk);\n      }\n    }\n    this._sourceChunksCache.persisted(chunksToCache);\n  }\n}\n\ntype CacheEntry = {\n  chunk: Chunk;\n  size: number;\n};\n\nclass ChunksCache {\n  readonly #cacheSizeLimit: number;\n  readonly #getSizeOfChunk: (chunk: Chunk) => number;\n  readonly #refCounts: Map<Hash, number>;\n  readonly #refs: Map<Hash, readonly Hash[]>;\n  #size = 0;\n  #evictsAndDeletesSuspended = false;\n  readonly #suspendedDeletes: Hash[] = [];\n\n  /**\n   * Iteration order is from least to most recently used.\n   *\n   * Public so that testing subclass can access.\n   */\n  readonly cacheEntries = new Map<Hash, CacheEntry>();\n\n  constructor(\n    cacheSizeLimit: number,\n    getSizeOfChunk: (v: Chunk) => number,\n    refCounts: Map<Hash, number>,\n    refs: Map<Hash, readonly Hash[]>,\n  ) {\n    this.#cacheSizeLimit = cacheSizeLimit;\n    this.#getSizeOfChunk = getSizeOfChunk;\n    this.#refCounts = refCounts;\n    this.#refs = refs;\n  }\n\n  get(hash: Hash): Chunk | undefined {\n    const cacheEntry = this.cacheEntries.get(hash);\n    if (cacheEntry) {\n      // Update order in map for LRU tracking.\n      this.cacheEntries.delete(hash);\n      this.cacheEntries.set(hash, cacheEntry);\n    }\n    return cacheEntry?.chunk;\n  }\n\n  getWithoutUpdatingLRU(hash: Hash): Chunk | undefined {\n    return this.cacheEntries.get(hash)?.chunk;\n  }\n\n  put(chunk: Chunk): void {\n    const {hash} = chunk;\n    // If there is an existing cache entry then the cached value must be\n    // equivalent.  Update order in map for LRU tracking and early return.\n    const oldCacheEntry = this.cacheEntries.get(hash);\n    if (oldCacheEntry) {\n      this.cacheEntries.delete(hash);\n      this.cacheEntries.set(hash, oldCacheEntry);\n      return;\n    }\n\n    // Only cache if there is a ref from a head to this chunk\n    const refCount = this.#refCounts.get(hash);\n    if (refCount === undefined || refCount < 1) {\n      return;\n    }\n    if (!this.#cacheChunk(chunk)) {\n      return;\n    }\n    if (!this.#refs.has(hash)) {\n      for (const refHash of chunk.meta) {\n        this.#refCounts.set(refHash, (this.#refCounts.get(refHash) || 0) + 1);\n      }\n      this.#refs.set(hash, chunk.meta);\n    }\n\n    this.#ensureCacheSizeLimit();\n  }\n\n  #ensureCacheSizeLimit() {\n    if (this.#evictsAndDeletesSuspended) {\n      return;\n    }\n    for (const entry of this.cacheEntries.values()) {\n      if (this.#size <= this.#cacheSizeLimit) {\n        break;\n      }\n      this.#evict(entry);\n    }\n  }\n\n  #cacheChunk(chunk: Chunk, size?: number): boolean {\n    const chunkSize = size ?? this.#getSizeOfChunk(chunk);\n    if (chunkSize > this.#cacheSizeLimit) {\n      // This value cannot be cached due to its size exceeding the\n      // cache size limit, don't evict other entries to try to make\n      // room for it.\n      return false;\n    }\n    this.#size += chunkSize;\n    this.cacheEntries.set(chunk.hash, {chunk, size: chunkSize});\n    return true;\n  }\n\n  #evict(cacheEntry: CacheEntry): void {\n    const {hash} = cacheEntry.chunk;\n    this.#size -= cacheEntry.size;\n    this.cacheEntries.delete(hash);\n  }\n\n  #deleteEntryByHash(hash: Hash): void {\n    this.#refCounts.delete(hash);\n    this.#refs.delete(hash);\n    const cacheEntry = this.cacheEntries.get(hash);\n    if (cacheEntry) {\n      this.#size -= cacheEntry.size;\n      this.cacheEntries.delete(hash);\n    }\n  }\n\n  updateForCommit(\n    chunksToPut: Map<Hash, {chunk: Chunk; size: number}>,\n    refCountUpdates: Map<Hash, number>,\n  ): void {\n    for (const [hash, count] of refCountUpdates) {\n      if (count === 0) {\n        if (!this.#evictsAndDeletesSuspended) {\n          this.#deleteEntryByHash(hash);\n        } else {\n          this.#refCounts.set(hash, 0);\n          this.#suspendedDeletes.push(hash);\n        }\n      } else {\n        this.#refCounts.set(hash, count);\n        const chunkAndSize = chunksToPut.get(hash);\n        if (chunkAndSize) {\n          const {chunk, size} = chunkAndSize;\n          const oldCacheEntry = this.cacheEntries.get(hash);\n          if (oldCacheEntry) {\n            // If there is an existing cache entry then the cached value must be\n            // equivalent.  Update order in map for LRU tracking but avoid\n            // recomputing size and creating a new cache entry.\n            this.cacheEntries.delete(hash);\n            this.cacheEntries.set(hash, oldCacheEntry);\n          } else {\n            this.#cacheChunk(chunk, size !== -1 ? size : undefined);\n            this.#refs.set(hash, chunk.meta);\n          }\n        }\n      }\n    }\n    this.#ensureCacheSizeLimit();\n  }\n\n  persisted(chunks: Iterable<Chunk>) {\n    for (const chunk of chunks) {\n      this.#cacheChunk(chunk);\n    }\n    this.#ensureCacheSizeLimit();\n  }\n\n  async withSuspendedEvictsAndDeletes<T>(\n    fn: () => MaybePromise<T>,\n  ): Promise<T> {\n    this.#evictsAndDeletesSuspended = true;\n    try {\n      return await fn();\n    } finally {\n      this.#evictsAndDeletesSuspended = false;\n      for (const hash of this.#suspendedDeletes) {\n        if (this.#refCounts.get(hash) === 0) {\n          this.#deleteEntryByHash(hash);\n        }\n      }\n      this.#ensureCacheSizeLimit();\n    }\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {greaterThan} from 'compare-utf8';\nimport type {JSONValue, ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {type IndexKey, decodeIndexKey} from './db/index.ts';\nimport type {Read} from './db/read.ts';\nimport type {Write} from './db/write.ts';\nimport {deepFreeze} from './frozen-json.ts';\nimport type {IndexDefinition} from './index-defs.ts';\nimport type {ScanResult} from './scan-iterator.ts';\nimport {ScanResultImpl, fromKeyForIndexScanInternal} from './scan-iterator.ts';\nimport {\n  type KeyTypeForScanOptions,\n  type ScanIndexOptions,\n  type ScanNoIndexOptions,\n  type ScanOptions,\n  isScanIndexOptions,\n  toDbScanOptions,\n} from './scan-options.ts';\nimport type {ScanSubscriptionInfo} from './subscriptions.ts';\nimport type {ClientID} from './sync/ids.ts';\nimport {rejectIfClosed, throwIfClosed} from './transaction-closed-error.ts';\nimport type {ZeroTxData} from './replicache-options.ts';\n\nexport type TransactionEnvironment = 'client' | 'server';\nexport type TransactionLocation = TransactionEnvironment;\nexport type TransactionReason = 'initial' | 'rebase' | 'authoritative';\n\n/**\n * Basic deep readonly type. It works for {@link JSONValue}.\n */\nexport type DeepReadonly<T> = T extends\n  | null\n  | boolean\n  | string\n  | number\n  | undefined\n  ? T\n  : DeepReadonlyObject<T>;\n\nexport type DeepReadonlyObject<T> = {\n  readonly [K in keyof T]: DeepReadonly<T[K]>;\n};\n\n/**\n * ReadTransactions are used with {@link Replicache.query} and\n * {@link Replicache.subscribe} and allows read operations on the\n * database.\n */\nexport interface ReadTransaction {\n  readonly clientID: ClientID;\n  /** @deprecated Use {@link ReadTransaction.location} instead. */\n  readonly environment: TransactionLocation;\n  readonly location: TransactionLocation;\n\n  /**\n   * Get a single value from the database. If the `key` is not present this\n   * returns `undefined`.\n   *\n   * Important: The returned JSON is readonly and should not be modified. This\n   * is only enforced statically by TypeScript and there are no runtime checks\n   * for performance reasons. If you mutate the return value you will get\n   * undefined behavior.\n   */\n\n  get(key: string): Promise<ReadonlyJSONValue | undefined>;\n  get<T extends JSONValue>(key: string): Promise<DeepReadonly<T> | undefined>;\n\n  /** Determines if a single `key` is present in the database. */\n  has(key: string): Promise<boolean>;\n\n  /** Whether the database is empty. */\n  isEmpty(): Promise<boolean>;\n\n  /**\n   * Gets many values from the database. This returns a {@link ScanResult} which\n   * implements `AsyncIterable`. It also has methods to iterate over the\n   * {@link ScanResult.keys | keys} and {@link ScanResult.entries | entries}.\n   *\n   * If `options` has an `indexName`, then this does a scan over an index with\n   * that name. A scan over an index uses a tuple for the key consisting of\n   * `[secondary: string, primary: string]`.\n   *\n   * If the {@link ScanResult} is used after the `ReadTransaction` has been closed\n   * it will throw a {@link TransactionClosedError}.\n   *\n   * Important: The returned JSON is readonly and should not be modified. This\n   * is only enforced statically by TypeScript and there are no runtime checks\n   * for performance reasons. If you mutate the return value you will get\n   * undefined behavior.\n   */\n  scan(options: ScanIndexOptions): ScanResult<IndexKey, ReadonlyJSONValue>;\n  scan(options?: ScanNoIndexOptions): ScanResult<string, ReadonlyJSONValue>;\n  scan(options?: ScanOptions): ScanResult<IndexKey | string, ReadonlyJSONValue>;\n\n  scan<V extends ReadonlyJSONValue>(\n    options: ScanIndexOptions,\n  ): ScanResult<IndexKey, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanNoIndexOptions,\n  ): ScanResult<string, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, DeepReadonly<V>>;\n}\n\nlet transactionIDCounter = 0;\n\nexport class ReadTransactionImpl implements ReadTransaction {\n  readonly clientID: ClientID;\n  readonly dbtx: Read;\n  protected readonly _lc: LogContext;\n\n  /**\n   * The location in which this transaction is being used. This is either `client` or `server`.\n   */\n  readonly location: TransactionLocation;\n  /** @deprecated Use {@link ReadTransaction.location} instead. */\n  readonly environment: TransactionLocation;\n\n  constructor(\n    clientID: ClientID,\n    dbRead: Read,\n    lc: LogContext,\n    rpcName = 'openReadTransaction',\n  ) {\n    this.clientID = clientID;\n    this.dbtx = dbRead;\n    this._lc = lc\n      .withContext(rpcName)\n      .withContext('txid', transactionIDCounter++);\n    this.environment = 'client';\n    this.location = 'client';\n  }\n\n  get(key: string): Promise<ReadonlyJSONValue | undefined>;\n  get<V extends JSONValue>(key: string): Promise<DeepReadonly<V> | undefined> {\n    return (\n      rejectIfClosed(this.dbtx) ||\n      (this.dbtx.get(key) as Promise<DeepReadonly<V> | undefined>)\n    );\n  }\n\n  // eslint-disable-next-line require-await\n  async has(key: string): Promise<boolean> {\n    throwIfClosed(this.dbtx);\n    return this.dbtx.has(key);\n  }\n\n  // eslint-disable-next-line require-await\n  async isEmpty(): Promise<boolean> {\n    throwIfClosed(this.dbtx);\n    return this.dbtx.isEmpty();\n  }\n\n  scan(options: ScanIndexOptions): ScanResult<IndexKey, ReadonlyJSONValue>;\n  scan(options?: ScanNoIndexOptions): ScanResult<string, ReadonlyJSONValue>;\n  scan(options?: ScanOptions): ScanResult<IndexKey | string, ReadonlyJSONValue>;\n\n  scan<V extends ReadonlyJSONValue>(\n    options: ScanIndexOptions,\n  ): ScanResult<IndexKey, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanNoIndexOptions,\n  ): ScanResult<string, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, DeepReadonly<V>>;\n\n  scan(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, ReadonlyJSONValue> {\n    return scan(options, this.dbtx, noop);\n  }\n}\n\nfunction noop(_: unknown): void {\n  // empty\n}\n\nfunction scan<Options extends ScanOptions, V extends JSONValue>(\n  options: Options | undefined,\n  dbRead: Read,\n  onLimitKey: (inclusiveLimitKey: string) => void,\n): ScanResult<KeyTypeForScanOptions<Options>, V> {\n  const iter = getScanIterator<Options, V>(dbRead, options);\n  return makeScanResultFromScanIteratorInternal(\n    iter,\n    options ?? ({} as Options),\n    dbRead,\n    onLimitKey,\n  );\n}\n\n// An implementation of ReadTransaction that keeps track of `keys` and `scans`\n// for use with Subscriptions.\nexport class SubscriptionTransactionWrapper implements ReadTransaction {\n  readonly #keys: Set<string> = new Set();\n  readonly #scans: ScanSubscriptionInfo[] = [];\n  readonly #tx: ReadTransactionImpl;\n\n  constructor(tx: ReadTransactionImpl) {\n    this.#tx = tx;\n  }\n\n  get environment(): TransactionLocation {\n    return this.#tx.location;\n  }\n\n  get location(): TransactionLocation {\n    return this.#tx.location;\n  }\n\n  get clientID(): string {\n    return this.#tx.clientID;\n  }\n\n  isEmpty(): Promise<boolean> {\n    // Any change to the subscription requires rerunning it.\n    this.#scans.push({options: {}});\n    return this.#tx.isEmpty();\n  }\n\n  get(key: string): Promise<ReadonlyJSONValue | undefined>;\n  get<T extends JSONValue>(key: string): Promise<DeepReadonly<T> | undefined> {\n    this.#keys.add(key);\n    return this.#tx.get(key) as Promise<DeepReadonly<T> | undefined>;\n  }\n\n  has(key: string): Promise<boolean> {\n    this.#keys.add(key);\n    return this.#tx.has(key);\n  }\n\n  scan(options: ScanIndexOptions): ScanResult<IndexKey, ReadonlyJSONValue>;\n  scan(options?: ScanNoIndexOptions): ScanResult<string, ReadonlyJSONValue>;\n  scan(options?: ScanOptions): ScanResult<IndexKey | string, ReadonlyJSONValue>;\n\n  scan<V extends ReadonlyJSONValue>(\n    options: ScanIndexOptions,\n  ): ScanResult<IndexKey, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanNoIndexOptions,\n  ): ScanResult<string, DeepReadonly<V>>;\n  scan<V extends ReadonlyJSONValue>(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, DeepReadonly<V>>;\n\n  scan(\n    options?: ScanOptions,\n  ): ScanResult<IndexKey | string, ReadonlyJSONValue> {\n    const scanInfo: ScanSubscriptionInfo = {\n      options: toDbScanOptions(options),\n      inclusiveLimitKey: undefined,\n    };\n    this.#scans.push(scanInfo);\n    return scan(options, this.#tx.dbtx, inclusiveLimitKey => {\n      scanInfo.inclusiveLimitKey = inclusiveLimitKey;\n    });\n  }\n\n  get keys(): ReadonlySet<string> {\n    return this.#keys;\n  }\n\n  get scans(): ScanSubscriptionInfo[] {\n    return this.#scans;\n  }\n}\n\n/**\n * WriteTransactions are used with *mutators* which are registered using\n * {@link ReplicacheOptions.mutators} and allows read and write operations on the\n * database.\n */\nexport interface WriteTransaction extends ReadTransaction {\n  /**\n   * The ID of the mutation that is being applied.\n   */\n  readonly mutationID: number;\n\n  /**\n   * The reason for the transaction. This can be `initial`, `rebase` or `authoriative`.\n   */\n  readonly reason: TransactionReason;\n\n  /**\n   * Sets a single `value` in the database. The value will be frozen (using\n   * `Object.freeze`) in debug mode.\n   */\n  set(key: string, value: ReadonlyJSONValue): Promise<void>;\n\n  /**\n   * @deprecated Use {@link WriteTransaction.set} instead.\n   */\n  put(key: string, value: ReadonlyJSONValue): Promise<void>;\n\n  /**\n   * Removes a `key` and its value from the database. Returns `true` if there was a\n   * `key` to remove.\n   */\n  del(key: string): Promise<boolean>;\n}\n\n// Internal symbol, not exported by Replicache\n// but accessible to Zero.\nexport const zeroData = Symbol();\n\nexport class WriteTransactionImpl\n  extends ReadTransactionImpl\n  implements WriteTransaction\n{\n  // use `declare` to specialize the type.\n  declare readonly dbtx: Write;\n  readonly reason: TransactionReason;\n  readonly mutationID: number;\n  readonly [zeroData]: ZeroTxData | undefined;\n\n  constructor(\n    clientID: ClientID,\n    mutationID: number,\n    reason: TransactionReason,\n    zData: ZeroTxData | undefined,\n    dbWrite: Write,\n    lc: LogContext,\n    rpcName = 'openWriteTransaction',\n  ) {\n    super(clientID, dbWrite, lc, rpcName);\n    this.mutationID = mutationID;\n    this.reason = reason;\n    this[zeroData] = zData;\n  }\n\n  put(key: string, value: ReadonlyJSONValue): Promise<void> {\n    return this.set(key, value);\n  }\n\n  async set(key: string, value: ReadonlyJSONValue): Promise<void> {\n    throwIfClosed(this.dbtx);\n    await this.dbtx.put(this._lc, key, deepFreeze(value));\n  }\n\n  del(key: string): Promise<boolean> {\n    return rejectIfClosed(this.dbtx) ?? this.dbtx.del(this._lc, key);\n  }\n}\n\nexport type CreateIndexDefinition = IndexDefinition & {name: string};\n\ntype Entry<Key, Value> = readonly [key: Key, value: Value];\n\ntype IndexKeyEntry<Value> = Entry<IndexKey, Value>;\n\ntype StringKeyEntry<Value> = Entry<string, Value>;\n\nexport type EntryForOptions<\n  Options extends ScanOptions,\n  V,\n> = Options extends ScanIndexOptions ? IndexKeyEntry<V> : StringKeyEntry<V>;\n\nfunction getScanIterator<Options extends ScanOptions, V>(\n  dbRead: Read,\n  options: Options | undefined,\n): AsyncIterable<EntryForOptions<Options, V>> {\n  if (options && isScanIndexOptions(options)) {\n    return getScanIteratorForIndexMap(dbRead, options) as AsyncIterable<\n      EntryForOptions<Options, V>\n    >;\n  }\n\n  return dbRead.map.scan(fromKeyForNonIndexScan(options)) as AsyncIterable<\n    EntryForOptions<Options, V>\n  >;\n}\n\nexport function fromKeyForNonIndexScan(\n  options: ScanNoIndexOptions | undefined,\n): string {\n  if (!options) {\n    return '';\n  }\n\n  const {prefix = '', start} = options;\n  if (start && greaterThan(start.key, prefix)) {\n    return start.key;\n  }\n  return prefix;\n}\n\nfunction makeScanResultFromScanIteratorInternal<\n  Options extends ScanOptions,\n  V extends JSONValue,\n>(\n  iter: AsyncIterable<EntryForOptions<Options, V>>,\n  options: Options,\n  dbRead: Read,\n  onLimitKey: (inclusiveLimitKey: string) => void,\n): ScanResult<KeyTypeForScanOptions<Options>, V> {\n  return new ScanResultImpl(iter, options, dbRead, onLimitKey);\n}\n\nasync function* getScanIteratorForIndexMap(\n  dbRead: Read,\n  options: ScanIndexOptions,\n): AsyncIterable<IndexKeyEntry<ReadonlyJSONValue>> {\n  const map = dbRead.getMapForIndex(options.indexName);\n  for await (const entry of map.scan(fromKeyForIndexScanInternal(options))) {\n    yield [decodeIndexKey(entry[0]), entry[1]];\n  }\n}\n","import {greaterThan} from 'compare-utf8';\nimport type {ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {asyncIterableToArray} from './async-iterable-to-array.ts';\nimport {type IndexKey, encodeIndexScanKey} from './db/index.ts';\nimport type {IterableUnion} from './iterable-union.ts';\nimport {\n  type KeyTypeForScanOptions,\n  type ScanIndexOptions,\n  type ScanOptionIndexedStartKey,\n  type ScanOptions,\n  isScanIndexOptions,\n  normalizeScanOptionIndexedStartKey,\n} from './scan-options.ts';\nimport {type Closed, throwIfClosed} from './transaction-closed-error.ts';\nimport {type EntryForOptions, fromKeyForNonIndexScan} from './transactions.ts';\n\ntype ScanKey = string | IndexKey;\n\ntype ToValue<Options extends ScanOptions, Value> = (\n  entry: EntryForOptions<Options, ReadonlyJSONValue>,\n) => Value;\n\n/**\n * This class is used for the results of {@link ReadTransaction.scan | scan}. It\n * implements `AsyncIterable<JSONValue>` which allows you to use it in a `for\n * await` loop. There are also methods to iterate over the {@link keys},\n * {@link entries} or {@link values}.\n */\nexport class ScanResultImpl<Options extends ScanOptions, V>\n  implements ScanResult<KeyTypeForScanOptions<Options>, V>\n{\n  readonly #iter: AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>;\n  readonly #options: Options;\n  readonly #dbDelegateOptions: Closed;\n  readonly #onLimitKey: (inclusiveLimitKey: string) => void;\n\n  constructor(\n    iter: AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>,\n    options: Options,\n    dbDelegateOptions: Closed,\n    onLimitKey: (inclusiveLimitKey: string) => void,\n  ) {\n    this.#iter = iter;\n    this.#options = options;\n    this.#dbDelegateOptions = dbDelegateOptions;\n    this.#onLimitKey = onLimitKey;\n  }\n\n  /** The default AsyncIterable. This is the same as {@link values}. */\n  [Symbol.asyncIterator](): AsyncIterableIteratorToArray<V> {\n    return this.values();\n  }\n\n  /** Async iterator over the values of the {@link ReadTransaction.scan | scan} call. */\n  values(): AsyncIterableIteratorToArray<V> {\n    return new AsyncIterableIteratorToArrayWrapperImpl(\n      this.#newIterator(e => e[1] as V),\n    );\n  }\n\n  /**\n   * Async iterator over the keys of the {@link ReadTransaction.scan | scan}\n   * call. If the {@link ReadTransaction.scan | scan} is over an index the key\n   * is a tuple of `[secondaryKey: string, primaryKey]`\n   */\n  keys(): AsyncIterableIteratorToArray<KeyTypeForScanOptions<Options>> {\n    type K = KeyTypeForScanOptions<Options>;\n    return new AsyncIterableIteratorToArrayWrapperImpl<K>(\n      this.#newIterator<K>(e => e[0] as K),\n    );\n  }\n\n  /**\n   * Async iterator over the entries of the {@link ReadTransaction.scan | scan}\n   * call. An entry is a tuple of key values. If the\n   * {@link ReadTransaction.scan | scan} is over an index the key is a tuple of\n   * `[secondaryKey: string, primaryKey]`\n   */\n  entries(): AsyncIterableIteratorToArray<\n    readonly [KeyTypeForScanOptions<Options>, V]\n  > {\n    type Key = KeyTypeForScanOptions<Options>;\n    type Entry = readonly [Key, V];\n    return new AsyncIterableIteratorToArrayWrapperImpl(\n      this.#newIterator<Entry>(e => [e[0] as Key, e[1] as V]),\n    );\n  }\n\n  /** Returns all the values as an array. Same as `values().toArray()` */\n  toArray(): Promise<V[]> {\n    return this.values().toArray();\n  }\n\n  #newIterator<T>(toValue: ToValue<Options, T>): AsyncIterableIterator<T> {\n    return scanIterator(\n      toValue,\n      this.#iter,\n      this.#options,\n      this.#dbDelegateOptions,\n      this.#onLimitKey,\n    );\n  }\n}\n\nexport interface ScanResult<K extends ScanKey, V> extends AsyncIterable<V> {\n  /** The default AsyncIterable. This is the same as {@link values}. */\n  [Symbol.asyncIterator](): AsyncIterableIteratorToArray<V>;\n\n  /** Async iterator over the values of the {@link ReadTransaction.scan | scan} call. */\n  values(): AsyncIterableIteratorToArray<V>;\n\n  /**\n   * Async iterator over the keys of the {@link ReadTransaction.scan | scan}\n   * call. If the {@link ReadTransaction.scan | scan} is over an index the key\n   * is a tuple of `[secondaryKey: string, primaryKey]`\n   */\n  keys(): AsyncIterableIteratorToArray<K>;\n\n  /**\n   * Async iterator over the entries of the {@link ReadTransaction.scan | scan}\n   * call. An entry is a tuple of key values. If the\n   * {@link ReadTransaction.scan | scan} is over an index the key is a tuple of\n   * `[secondaryKey: string, primaryKey]`\n   */\n  entries(): AsyncIterableIteratorToArray<readonly [K, V]>;\n\n  /** Returns all the values as an array. Same as `values().toArray()` */\n  toArray(): Promise<V[]>;\n}\n\n/**\n * An interface that adds a {@link toArray} method to `AsyncIterableIterator`.\n *\n * Usage:\n *\n * ```ts\n * const keys: string[] = await rep.scan().keys().toArray();\n * ```\n */\nexport interface AsyncIterableIteratorToArray<V>\n  extends AsyncIterableIterator<V> {\n  toArray(): Promise<V[]>;\n}\n\nclass AsyncIterableIteratorToArrayWrapperImpl<V>\n  implements AsyncIterableIterator<V>\n{\n  readonly #it: AsyncIterableIterator<V>;\n\n  constructor(it: AsyncIterableIterator<V>) {\n    this.#it = it;\n  }\n\n  next() {\n    return this.#it.next();\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<V> {\n    return this.#it[Symbol.asyncIterator]();\n  }\n\n  toArray(): Promise<V[]> {\n    return asyncIterableToArray(this.#it);\n  }\n}\n\nasync function* scanIterator<Options extends ScanOptions, Value>(\n  toValue: ToValue<Options, Value>,\n  iter: AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>,\n  options: Options,\n  closed: Closed,\n  onLimitKey: (inclusiveLimitKey: string) => void,\n): AsyncIterableIterator<Value> {\n  throwIfClosed(closed);\n\n  let {limit = Infinity} = options;\n  const {prefix = ''} = options;\n  let exclusive = options.start?.exclusive;\n\n  const isIndexScan = isScanIndexOptions(options);\n\n  // iter has already been moved to the first entry\n  for await (const entry of iter) {\n    const key = entry[0];\n    const keyToMatch: string = isIndexScan ? key[0] : (key as string);\n    if (!keyToMatch.startsWith(prefix)) {\n      return;\n    }\n\n    if (exclusive) {\n      exclusive = true;\n      if (isIndexScan) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (shouldSkipIndexScan(key as IndexKey, options.start!.key)) {\n          continue;\n        }\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (shouldSkipNonIndexScan(key as string, options.start!.key)) {\n          continue;\n        }\n      }\n    }\n\n    yield toValue(entry);\n\n    if (--limit === 0) {\n      // We do not do the limit optimization for index scans in subscriptions.\n      if (!isIndexScan) {\n        onLimitKey(key as string);\n      }\n      return;\n    }\n  }\n}\n\nfunction shouldSkipIndexScan(\n  key: IndexKey,\n  startKey: ScanOptionIndexedStartKey,\n): boolean {\n  const [secondaryStartKey, primaryStartKey] =\n    normalizeScanOptionIndexedStartKey(startKey);\n  const [secondaryKey, primaryKey] = normalizeScanOptionIndexedStartKey(key);\n  if (secondaryKey !== secondaryStartKey) {\n    return false;\n  }\n  if (primaryStartKey === undefined) {\n    return true;\n  }\n  return primaryKey === primaryStartKey;\n}\n\nfunction shouldSkipNonIndexScan(key: string, startKey: string): boolean {\n  return key === startKey;\n}\n\nexport type Entry<V> = readonly [key: string, value: V];\n\n/**\n * This is called when doing a {@link ReadTransaction.scan | scan} without an\n * `indexName`.\n *\n * @param fromKey The `fromKey` is computed by `scan` and is the key of the\n * first entry to return in the iterator. It is based on `prefix` and\n * `start.key` of the {@link ScanNoIndexOptions}.\n */\nexport type GetScanIterator = (\n  fromKey: string,\n) => IterableUnion<Entry<ReadonlyJSONValue>>;\n\n/**\n * When using {@link makeScanResult} this is the type used for the function called when doing a {@link ReadTransaction.scan | scan} with an\n * `indexName`.\n *\n * @param indexName The name of the index we are scanning over.\n * @param fromSecondaryKey The `fromSecondaryKey` is computed by `scan` and is\n * the secondary key of the first entry to return in the iterator. It is based\n * on `prefix` and `start.key` of the {@link ScanIndexOptions}.\n * @param fromPrimaryKey The `fromPrimaryKey` is computed by `scan` and is the\n * primary key of the first entry to return in the iterator. It is based on\n * `prefix` and `start.key` of the {@link ScanIndexOptions}.\n */\nexport type GetIndexScanIterator = (\n  indexName: string,\n  fromSecondaryKey: string,\n  fromPrimaryKey: string | undefined,\n) => IterableUnion<readonly [key: IndexKey, value: ReadonlyJSONValue]>;\n\n/**\n * A helper function that makes it easier to implement {@link ReadTransaction.scan}\n * with a custom backend.\n *\n * If you are implementing a custom backend and have an in memory pending async\n * iterable we provide two helper functions to make it easier to merge these\n * together. {@link mergeAsyncIterables} and {@link filterAsyncIterable}.\n *\n * For example:\n *\n * ```ts\n * const scanResult = makeScanResult(\n *   options,\n *   options.indexName\n *     ? () => {\n *         throw Error('not implemented');\n *       }\n *     : fromKey => {\n *         const persisted: AsyncIterable<Entry<ReadonlyJSONValue>> = ...;\n *         const pending: AsyncIterable<Entry<ReadonlyJSONValue | undefined>> = ...;\n *         const iter = await mergeAsyncIterables(persisted, pending);\n *         const filteredIter = await filterAsyncIterable(\n *           iter,\n *           entry => entry[1] !== undefined,\n *         );\n *         return filteredIter;\n *       },\n * );\n * ```\n */\nexport function makeScanResult<Options extends ScanOptions>(\n  options: Options,\n  getScanIterator: Options extends ScanIndexOptions\n    ? GetIndexScanIterator\n    : GetScanIterator,\n): ScanResult<KeyTypeForScanOptions<Options>, ReadonlyJSONValue> {\n  type AsyncIter = AsyncIterable<EntryForOptions<Options, ReadonlyJSONValue>>;\n\n  if (isScanIndexOptions(options)) {\n    const [fromSecondaryKey, fromPrimaryKey] = fromKeyForIndexScan(options);\n    return new ScanResultImpl(\n      (getScanIterator as GetIndexScanIterator)(\n        options.indexName,\n        fromSecondaryKey,\n        fromPrimaryKey,\n      ) as AsyncIter,\n      options,\n      {closed: false},\n      _ => {\n        // noop\n      },\n    );\n  }\n  const fromKey = fromKeyForNonIndexScan(options);\n  return new ScanResultImpl(\n    (getScanIterator as GetScanIterator)(fromKey) as AsyncIter,\n    options,\n    {closed: false},\n    _ => {\n      // noop\n    },\n  );\n}\n\nexport function fromKeyForIndexScan(\n  options: ScanIndexOptions,\n): readonly [secondary: string, primary?: string | undefined] {\n  const {prefix, start} = options;\n  const prefixNormalized: [secondary: string, primary?: string | undefined] = [\n    prefix ?? '',\n    undefined,\n  ];\n\n  if (!start) {\n    return prefixNormalized;\n  }\n\n  const startKeyNormalized = normalizeScanOptionIndexedStartKey(start.key);\n  if (greaterThan(startKeyNormalized[0], prefixNormalized[0])) {\n    return startKeyNormalized;\n  }\n  if (\n    startKeyNormalized[0] === prefixNormalized[0] &&\n    startKeyNormalized[1] !== undefined\n  ) {\n    return startKeyNormalized;\n  }\n\n  return prefixNormalized;\n}\n\nexport function fromKeyForIndexScanInternal(options: ScanIndexOptions): string {\n  const {prefix, start} = options;\n  let prefix2 = '';\n  if (prefix !== undefined) {\n    prefix2 = encodeIndexScanKey(prefix, undefined);\n  }\n  if (!start) {\n    return prefix2;\n  }\n\n  const {key} = start;\n  const [secondary, primary] = normalizeScanOptionIndexedStartKey(key);\n  const startKey = encodeIndexScanKey(secondary, primary);\n\n  if (greaterThan(startKey, prefix2)) {\n    return startKey;\n  }\n\n  return prefix2;\n}\n","import type {IndexKey} from './db/index.ts';\nimport type {ScanOptions as DbScanOptions} from './db/scan.ts';\n\n/**\n * Options for {@link ReadTransaction.scan | scan}\n */\nexport type ScanOptions = ScanIndexOptions | ScanNoIndexOptions;\n\n/**\n * Options for {@link ReadTransaction.scan | scan} when scanning over the entire key\n * space.\n */\nexport type ScanNoIndexOptions = {\n  /** Only include keys starting with `prefix`. */\n  prefix?: string | undefined;\n\n  /** Only include up to `limit` results. */\n  limit?: number | undefined;\n\n  /** When provided the scan starts at this key. */\n  start?:\n    | {\n        key: string;\n\n        /** Whether the `key` is exclusive or inclusive. */\n        exclusive?: boolean | undefined;\n      }\n    | undefined;\n};\n\n/**\n * Options for {@link ReadTransaction.scan | scan} when scanning over an index. When\n * scanning over and index you need to provide the `indexName` and the `start`\n * `key` is now a tuple consisting of secondary and primary key\n */\nexport type ScanIndexOptions = {\n  /** Only include results starting with the *secondary* keys starting with `prefix`. */\n  prefix?: string | undefined;\n\n  /** Only include up to `limit` results. */\n  limit?: number | undefined;\n\n  /** Do a {@link ReadTransaction.scan | scan} over a named index. The `indexName` is\n   * the name of an index defined when creating the {@link Replicache} instance using\n   * {@link ReplicacheOptions.indexes}. */\n  indexName: string;\n\n  /** When provided the scan starts at this key. */\n  start?:\n    | {\n        key: ScanOptionIndexedStartKey;\n\n        /** Whether the `key` is exclusive or inclusive. */\n        exclusive?: boolean | undefined;\n      }\n    | undefined;\n};\n\n/**\n * Type narrowing of {@link ScanOptions}.\n */\nexport function isScanIndexOptions(\n  options: ScanOptions,\n): options is ScanIndexOptions {\n  return (options as ScanIndexOptions).indexName !== undefined;\n}\n\n/**\n * If the options contains an `indexName` then the key type is a tuple of\n * secondary and primary.\n */\nexport type KeyTypeForScanOptions<O extends ScanOptions> =\n  O extends ScanIndexOptions ? IndexKey : string;\n\n/**\n * The key to start scanning at.\n *\n * If you are scanning the primary index (i.e., you did not specify\n * `indexName`), then pass a single string for this field, which is the key in\n * the primary index to scan at.\n *\n * If you are scanning a secondary index (i.e., you specified `indexName`), then\n * use the tuple form. In that case, `secondary` is the secondary key to start\n * scanning at, and `primary` (if any) is the primary key to start scanning at.\n */\nexport type ScanOptionIndexedStartKey =\n  | readonly [secondary: string, primary?: string | undefined]\n  | string;\n\nexport function normalizeScanOptionIndexedStartKey(\n  startKey: string | readonly [secondary: string, primary?: string | undefined],\n): readonly [secondary: string, primary?: string | undefined] {\n  if (typeof startKey === 'string') {\n    return [startKey];\n  }\n  return startKey;\n}\n\nexport function toDbScanOptions(options?: ScanOptions): DbScanOptions {\n  if (!options) {\n    return {};\n  }\n  let key: string | ScanOptionIndexedStartKey | undefined;\n  let exclusive: boolean | undefined;\n  let primary: string | undefined;\n  let secondary: string | undefined;\n  type MaybeIndexName = {indexName?: string};\n  if (options.start) {\n    ({key, exclusive} = options.start);\n    if ((options as MaybeIndexName).indexName) {\n      if (typeof key === 'string') {\n        secondary = key;\n      } else {\n        secondary = key[0];\n        primary = key[1];\n      }\n    } else {\n      primary = key as string;\n    }\n  }\n\n  return {\n    prefix: options.prefix,\n    startSecondaryKey: secondary,\n    startKey: primary,\n    startExclusive: exclusive,\n    limit: options.limit,\n    indexName: (options as MaybeIndexName).indexName,\n  };\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport type {Write as DagWrite} from '../dag/store.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {WriteTransactionImpl} from '../transactions.ts';\nimport type {MutatorDefs} from '../types.ts';\nimport {\n  Commit,\n  type LocalMeta,\n  type LocalMetaDD31,\n  type Meta,\n  assertLocalMetaDD31,\n  commitFromHash,\n  isLocalMetaDD31,\n} from './commit.ts';\nimport {Write, newWriteLocal} from './write.ts';\nimport type {ZeroTxData} from '../replicache-options.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nasync function rebaseMutation(\n  mutation: Commit<LocalMetaDD31>,\n  dagWrite: DagWrite,\n  basisHash: Hash,\n  mutators: MutatorDefs,\n  lc: LogContext,\n  mutationClientID: ClientID,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Write> {\n  const localMeta = mutation.meta;\n  const name = localMeta.mutatorName;\n  if (isLocalMetaDD31(localMeta)) {\n    assert(\n      localMeta.clientID === mutationClientID,\n      'mutationClientID must match clientID of LocalMeta',\n    );\n  }\n  const maybeMutatorImpl = mutators[name];\n  if (!maybeMutatorImpl) {\n    // Developers must not remove mutator names from code deployed with the\n    // same schemaVersion because Replicache needs to be able to replay\n    // mutations during pull.\n    //\n    // If we detect that this has happened, stub in a no-op mutator so that at\n    // least sync can move forward. Note that the server-side mutation will\n    // still get sent. This doesn't remove the queued local mutation, it just\n    // removes its visible effects.\n    lc.error?.(`Cannot rebase unknown mutator ${name}`);\n  }\n  const mutatorImpl =\n    maybeMutatorImpl ||\n    (async () => {\n      // no op\n    });\n\n  const args = localMeta.mutatorArgsJSON;\n\n  const basisCommit = await commitFromHash(basisHash, dagWrite);\n  const nextMutationID = await basisCommit.getNextMutationID(\n    mutationClientID,\n    dagWrite,\n  );\n  if (nextMutationID !== localMeta.mutationID) {\n    throw new Error(\n      `Inconsistent mutation ID: original: ${localMeta.mutationID}, next: ${nextMutationID} - mutationClientID: ${mutationClientID} mutatorName: ${name}`,\n    );\n  }\n\n  if (formatVersion >= FormatVersion.DD31) {\n    assertLocalMetaDD31(localMeta);\n  }\n\n  const dbWrite = await newWriteLocal(\n    basisHash,\n    name,\n    args,\n    mutation.chunk.hash,\n    dagWrite,\n    localMeta.timestamp,\n    mutationClientID,\n    formatVersion,\n  );\n\n  const tx = new WriteTransactionImpl(\n    mutationClientID,\n    await dbWrite.getMutationID(),\n    'rebase',\n    zeroData,\n    dbWrite,\n    lc,\n  );\n  await mutatorImpl(tx, args);\n  return dbWrite;\n}\n\nexport async function rebaseMutationAndPutCommit(\n  mutation: Commit<LocalMeta>,\n  dagWrite: DagWrite,\n  basis: Hash,\n  mutators: MutatorDefs,\n  lc: LogContext,\n  // TODO(greg): mutationClientID can be retrieved from mutation if LocalMeta\n  // is a LocalMetaDD31.  As part of DD31 cleanup we can remove this arg.\n  mutationClientID: ClientID,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Commit<Meta>> {\n  const tx = await rebaseMutation(\n    mutation,\n    dagWrite,\n    basis,\n    mutators,\n    lc,\n    mutationClientID,\n    formatVersion,\n    zeroData,\n  );\n  return tx.putCommit();\n}\n\nexport async function rebaseMutationAndCommit(\n  mutation: Commit<LocalMeta>,\n  dagWrite: DagWrite,\n  basis: Hash,\n  headName: string,\n  mutators: MutatorDefs,\n  lc: LogContext,\n  // TODO(greg): mutationClientID can be retrieved from mutation if LocalMeta\n  // is a LocalMetaDD31.  As part of DD31 cleanup we can remove this arg.\n  mutationClientID: ClientID,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Hash> {\n  const dbWrite = await rebaseMutation(\n    mutation,\n    dagWrite,\n    basis,\n    mutators,\n    lc,\n    mutationClientID,\n    formatVersion,\n    zeroData,\n  );\n  return dbWrite.commit(headName);\n}\n","import {callDefaultFetch} from './call-default-fetch.ts';\nimport {\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n} from './error-responses.ts';\nimport type {Pusher, PusherResult} from './pusher.ts';\nimport type {PushRequest} from './sync/push.ts';\n\n/**\n * This creates a default pusher which uses HTTP POST to send the push request.\n */\nexport function getDefaultPusher(rep: {pushURL: string; auth: string}): Pusher {\n  async function pusher(\n    requestBody: PushRequest,\n    requestID: string,\n  ): Promise<PusherResult> {\n    const [response, httpRequestInfo] = await callDefaultFetch(\n      rep.pushURL,\n      rep.auth,\n      requestID,\n      requestBody,\n    );\n    if (!response) {\n      return {httpRequestInfo};\n    }\n\n    const rv: PusherResult = {\n      httpRequestInfo,\n    };\n\n    let result;\n    try {\n      result = await response.json();\n    } catch {\n      // Ignore JSON parse errors. It is valid to return a non-JSON response.\n      return rv;\n    }\n\n    if (\n      isClientStateNotFoundResponse(result) ||\n      isVersionNotSupportedResponse(result)\n    ) {\n      rv.response = result;\n    }\n\n    return rv;\n  }\n\n  defaultPushers.add(pusher);\n  return pusher;\n}\n\nconst defaultPushers = new WeakSet();\n\nexport function isDefaultPusher(pusher: Pusher): boolean {\n  return defaultPushers.has(pusher);\n}\n","export const httpStatusUnauthorized = 401;\n","/**\n * Wrapper error class that should be reported as error (logger.error)\n */\nexport class ReportError extends Error {}\n","export function toError(e: unknown): Error {\n  if (e instanceof Error) {\n    return e;\n  }\n  return new Error(String(e));\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const Applied = 0;\nexport const NoOp = 1;\nexport const CookieMismatch = 2;\n\nexport type Applied = typeof Applied;\nexport type NoOp = typeof NoOp;\nexport type CookieMismatch = typeof CookieMismatch;\n","import type {LogContext} from '@rocicorp/logger';\nimport {assertObject} from '../../../shared/src/asserts.ts';\nimport type {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from '../../../shared/src/json.ts';\nimport type {Write} from '../db/write.ts';\nimport {\n  type FrozenJSONObject,\n  type FrozenJSONValue,\n  deepFreeze,\n} from '../frozen-json.ts';\nimport type {PatchOperationInternal} from '../patch-operation.ts';\nimport type {DiffOperation} from '../btree/node.ts';\n\nexport type Diff =\n  | DiffOperation<string>\n  | {\n      op: 'clear';\n    };\n\nexport async function apply(\n  lc: LogContext,\n  dbWrite: Write,\n  patch: readonly PatchOperationInternal[],\n): Promise<void> {\n  for (const p of patch) {\n    switch (p.op) {\n      case 'put': {\n        const frozen = deepFreeze(p.value);\n        await dbWrite.put(lc, p.key, frozen);\n        break;\n      }\n      case 'update': {\n        const existing = await dbWrite.get(p.key);\n        const entries: [\n          string,\n          FrozenJSONValue | ReadonlyJSONValue | undefined,\n        ][] = [];\n        const addToEntries = (toAdd: FrozenJSONObject | ReadonlyJSONObject) => {\n          for (const [key, value] of Object.entries(toAdd)) {\n            if (\n              !p.constrain ||\n              p.constrain.length === 0 ||\n              p.constrain.indexOf(key) > -1\n            ) {\n              entries.push([key, value]);\n            }\n          }\n        };\n        if (existing !== undefined) {\n          assertObject(existing);\n          addToEntries(existing);\n        }\n        if (p.merge) {\n          addToEntries(p.merge);\n        }\n        const frozen = deepFreeze(Object.fromEntries(entries));\n        await dbWrite.put(lc, p.key, frozen);\n\n        break;\n      }\n      case 'del': {\n        const existing = await dbWrite.get(p.key);\n        if (existing === undefined) {\n          continue;\n        }\n        await dbWrite.del(lc, p.key);\n        break;\n      }\n      case 'clear':\n        await dbWrite.clear();\n        break;\n    }\n  }\n}\n","/**\n * This error is thrown when the puller fails for any reason.\n */\n\nexport class PullError extends Error {\n  name = 'PullError';\n  // causedBy is used instead of cause, because while cause has been proposed as a\n  // JavaScript language standard for this purpose (see\n  // https://github.com/tc39/proposal-error-cause) current browser behavior is\n  // inconsistent.\n  causedBy?: Error | undefined;\n  constructor(causedBy?: Error) {\n    super('Failed to pull');\n    this.causedBy = causedBy;\n  }\n}\n","export const SYNC_HEAD_NAME = 'sync';\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport {deepEqual} from '../../../shared/src/json.ts';\nimport {diff} from '../btree/diff.ts';\nimport {BTreeRead} from '../btree/read.ts';\nimport {compareCookies, type Cookie} from '../cookies.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  assertSnapshotMetaDD31,\n  baseSnapshotFromHash,\n  Commit,\n  commitFromHash,\n  commitIsLocalDD31,\n  DEFAULT_HEAD_NAME,\n  type LocalMeta,\n  localMutations as localMutations_1,\n  snapshotMetaParts,\n} from '../db/commit.ts';\nimport {newWriteSnapshotDD31} from '../db/write.ts';\nimport {isErrorResponse} from '../error-responses.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport {deepFreeze, type FrozenJSONValue} from '../frozen-json.ts';\nimport {assertPullerResultV1} from '../get-default-puller.ts';\nimport {emptyHash, type Hash} from '../hash.ts';\nimport type {HTTPRequestInfo} from '../http-request-info.ts';\nimport type {\n  Puller,\n  PullerResult,\n  PullerResultV1,\n  PullResponseOKV1Internal,\n  PullResponseV1,\n} from '../puller.ts';\nimport {ReportError} from '../report-error.ts';\nimport {toError} from '../to-error.ts';\nimport {withRead, withWriteNoImplicitCommit} from '../with-transactions.ts';\nimport {\n  addDiffsForIndexes,\n  type DiffComputationConfig,\n  DiffsMap,\n} from './diff.ts';\nimport * as HandlePullResponseResultType from './handle-pull-response-result-type-enum.ts';\nimport type {ClientGroupID, ClientID} from './ids.ts';\nimport * as patch from './patch.ts';\nimport {PullError} from './pull-error.ts';\nimport {SYNC_HEAD_NAME} from './sync-head-name.ts';\n\ntype FormatVersion = (typeof FormatVersion)[keyof typeof FormatVersion];\n\nexport const PULL_VERSION_SDD = 0;\nexport const PULL_VERSION_DD31 = 1;\n\n/**\n * The JSON value used as the body when doing a POST to the [pull\n * endpoint](/reference/server-pull).\n */\nexport type PullRequest = PullRequestV1;\n\n/**\n * The JSON value used as the body when doing a POST to the [pull\n * endpoint](/reference/server-pull).\n */\nexport type PullRequestV1 = {\n  pullVersion: 1;\n  // schemaVersion can optionally be used by the customer's app\n  // to indicate to the data layer what format of Client View the\n  // app understands.\n  schemaVersion: string;\n  profileID: string;\n  cookie: Cookie;\n\n  clientGroupID: ClientGroupID;\n};\n\nexport function isPullRequestV1(pr: PullRequest): pr is PullRequestV1 {\n  return pr.pullVersion === PULL_VERSION_DD31;\n}\n\nexport type BeginPullResponseV1 = {\n  httpRequestInfo: HTTPRequestInfo;\n  pullResponse?: PullResponseV1;\n  syncHead: Hash;\n};\n\nexport async function beginPullV1(\n  profileID: string,\n  clientID: ClientID,\n  clientGroupID: ClientGroupID,\n  schemaVersion: string,\n  puller: Puller,\n  requestID: string,\n  store: Store,\n  formatVersion: FormatVersion,\n  lc: LogContext,\n  createSyncBranch = true,\n): Promise<BeginPullResponseV1> {\n  const baseCookie = await withRead(store, async dagRead => {\n    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (!mainHeadHash) {\n      throw new Error('Internal no main head found');\n    }\n    const baseSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);\n    const baseSnapshotMeta = baseSnapshot.meta;\n    assertSnapshotMetaDD31(baseSnapshotMeta);\n    return baseSnapshotMeta.cookieJSON;\n  });\n\n  const pullReq: PullRequestV1 = {\n    profileID,\n    clientGroupID,\n    cookie: baseCookie,\n    pullVersion: PULL_VERSION_DD31,\n    schemaVersion,\n  };\n\n  const {response, httpRequestInfo} = (await callPuller(\n    lc,\n    puller,\n    pullReq,\n    requestID,\n  )) as PullerResultV1;\n\n  // If Puller did not get a pull response we still want to return the HTTP\n  // request info.\n  if (!response) {\n    return {\n      httpRequestInfo,\n      syncHead: emptyHash,\n    };\n  }\n\n  if (!createSyncBranch || isErrorResponse(response)) {\n    return {\n      httpRequestInfo,\n      pullResponse: response,\n      syncHead: emptyHash,\n    };\n  }\n\n  const result = await handlePullResponseV1(\n    lc,\n    store,\n    baseCookie,\n    response,\n    clientID,\n    formatVersion,\n  );\n\n  return {\n    httpRequestInfo,\n    pullResponse: response,\n    syncHead:\n      result.type === HandlePullResponseResultType.Applied\n        ? result.syncHead\n        : emptyHash,\n  };\n}\n\nasync function callPuller(\n  lc: LogContext,\n  puller: Puller,\n  pullReq: PullRequest,\n  requestID: string,\n): Promise<PullerResult> {\n  lc.debug?.('Starting pull...');\n  const pullStart = Date.now();\n  let pullerResult: PullerResult;\n  try {\n    pullerResult = await puller(pullReq, requestID);\n    lc.debug?.(\n      `...Pull ${pullerResult.response ? 'complete' : 'failed'} in `,\n      Date.now() - pullStart,\n      'ms',\n    );\n  } catch (e) {\n    throw new PullError(toError(e));\n  }\n  try {\n    assertPullerResultV1(pullerResult);\n    return pullerResult;\n  } catch (e) {\n    throw new ReportError('Invalid puller result', toError(e));\n  }\n}\n\ntype HandlePullResponseResult =\n  | {\n      type: HandlePullResponseResultType.Applied;\n      syncHead: Hash;\n    }\n  | {\n      type:\n        | HandlePullResponseResultType.NoOp\n        | HandlePullResponseResultType.CookieMismatch;\n    };\n\nfunction badOrderMessage(\n  name: string,\n  receivedValue: string,\n  lastSnapshotValue: string,\n) {\n  return `Received ${name} ${receivedValue} is < than last snapshot ${name} ${lastSnapshotValue}; ignoring client view`;\n}\n\nexport function handlePullResponseV1(\n  lc: LogContext,\n  store: Store,\n  expectedBaseCookie: FrozenJSONValue,\n  response: PullResponseOKV1Internal,\n  clientID: ClientID,\n  formatVersion: FormatVersion,\n): Promise<HandlePullResponseResult> {\n  // It is possible that another sync completed while we were pulling. Ensure\n  // that is not the case by re-checking the base snapshot.\n  return withWriteNoImplicitCommit(store, async dagWrite => {\n    const dagRead = dagWrite;\n    const mainHead = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (mainHead === undefined) {\n      throw new Error('Main head disappeared');\n    }\n    const baseSnapshot = await baseSnapshotFromHash(mainHead, dagRead);\n    const baseSnapshotMeta = baseSnapshot.meta;\n    assertSnapshotMetaDD31(baseSnapshotMeta);\n    const baseCookie = baseSnapshotMeta.cookieJSON;\n\n    // TODO(MP) Here we are using whether the cookie has changed as a proxy for whether\n    // the base snapshot changed, which is the check we used to do. I don't think this\n    // is quite right. We need to firm up under what conditions we will/not accept an\n    // update from the server: https://github.com/rocicorp/replicache/issues/713.\n    // In DD31 this is expected to happen if a refresh occurs during a pull.\n    if (!deepEqual(expectedBaseCookie, baseCookie)) {\n      lc.debug?.(\n        'handlePullResponse: cookie mismatch, response is not applicable',\n      );\n      return {\n        type: HandlePullResponseResultType.CookieMismatch,\n      };\n    }\n\n    // Check that the lastMutationIDs are not going backwards.\n    for (const [clientID, lmidChange] of Object.entries(\n      response.lastMutationIDChanges,\n    )) {\n      const lastMutationID = baseSnapshotMeta.lastMutationIDs[clientID];\n      if (lastMutationID !== undefined && lmidChange < lastMutationID) {\n        throw new Error(\n          badOrderMessage(\n            `${clientID} lastMutationID`,\n            String(lmidChange),\n            String(lastMutationID),\n          ),\n        );\n      }\n    }\n\n    const frozenResponseCookie = deepFreeze(response.cookie);\n    if (compareCookies(frozenResponseCookie, baseCookie) < 0) {\n      throw new Error(\n        badOrderMessage(\n          'cookie',\n          JSON.stringify(frozenResponseCookie),\n          JSON.stringify(baseCookie),\n        ),\n      );\n    }\n\n    if (deepEqual(frozenResponseCookie, baseCookie)) {\n      if (response.patch.length > 0) {\n        lc.error?.(\n          `handlePullResponse: cookie ${JSON.stringify(\n            baseCookie,\n          )} did not change, but patch is not empty`,\n        );\n      }\n      if (Object.keys(response.lastMutationIDChanges).length > 0) {\n        lc.error?.(\n          `handlePullResponse: cookie ${JSON.stringify(\n            baseCookie,\n          )} did not change, but lastMutationIDChanges is not empty`,\n        );\n      }\n      // If the cookie doesn't change, it's a nop.\n      return {\n        type: HandlePullResponseResultType.NoOp,\n      };\n    }\n\n    const dbWrite = await newWriteSnapshotDD31(\n      baseSnapshot.chunk.hash,\n      {...baseSnapshotMeta.lastMutationIDs, ...response.lastMutationIDChanges},\n      frozenResponseCookie,\n      dagWrite,\n      clientID,\n      formatVersion,\n    );\n\n    await patch.apply(lc, dbWrite, response.patch);\n\n    return {\n      type: HandlePullResponseResultType.Applied,\n      syncHead: await dbWrite.commit(SYNC_HEAD_NAME),\n    };\n  });\n}\n\nexport function maybeEndPull<M extends LocalMeta>(\n  store: Store,\n  lc: LogContext,\n  expectedSyncHead: Hash,\n  clientID: ClientID,\n  diffConfig: DiffComputationConfig,\n  formatVersion: FormatVersion,\n): Promise<{\n  syncHead: Hash;\n  mainHead: Hash;\n  oldMainHead: Hash;\n  replayMutations: Commit<M>[];\n  diffs: DiffsMap;\n}> {\n  return withWriteNoImplicitCommit(store, async dagWrite => {\n    const dagRead = dagWrite;\n    // Ensure sync head is what the caller thinks it is.\n    const syncHeadHash = await dagRead.getHead(SYNC_HEAD_NAME);\n    if (syncHeadHash === undefined) {\n      throw new Error('Missing sync head');\n    }\n    if (syncHeadHash !== expectedSyncHead) {\n      lc.error?.(\n        'maybeEndPull, Wrong sync head. Expecting:',\n        expectedSyncHead,\n        'got:',\n        syncHeadHash,\n      );\n      throw new Error('Wrong sync head');\n    }\n\n    // Ensure another sync has not landed a new snapshot on the main chain.\n    // TODO: In DD31, it is expected that a newer snapshot might have appeared\n    // on the main chain. In that case, we just abort this pull.\n    const syncSnapshot = await baseSnapshotFromHash(syncHeadHash, dagRead);\n    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (mainHeadHash === undefined) {\n      throw new Error('Missing main head');\n    }\n    const mainSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);\n\n    const {meta} = syncSnapshot;\n    const syncSnapshotBasis = meta.basisHash;\n    if (syncSnapshot === null) {\n      throw new Error('Sync snapshot with no basis');\n    }\n    if (syncSnapshotBasis !== mainSnapshot.chunk.hash) {\n      throw new Error('Overlapping syncs');\n    }\n\n    // Collect pending commits from the main chain and determine which\n    // of them if any need to be replayed.\n    const syncHead = await commitFromHash(syncHeadHash, dagRead);\n    const pending: Commit<M>[] = [];\n    const localMutations = await localMutations_1(mainHeadHash, dagRead);\n    for (const commit of localMutations) {\n      let cid = clientID;\n      assert(commitIsLocalDD31(commit));\n      cid = commit.meta.clientID;\n\n      if (\n        (await commit.getMutationID(cid, dagRead)) >\n        (await syncHead.getMutationID(cid, dagRead))\n      ) {\n        // We know that the dag can only contain either LocalMetaSDD or LocalMetaDD31\n        pending.push(commit as Commit<M>);\n      }\n    }\n    // pending() gave us the pending mutations in sync-head-first order whereas\n    // caller wants them in the order to replay (lower mutation ids first).\n    pending.reverse();\n\n    // We return the keys that changed due to this pull. This is used by\n    // subscriptions in the JS API when there are no more pending mutations.\n    const diffsMap = new DiffsMap();\n\n    // Return replay commits if any.\n    if (pending.length > 0) {\n      return {\n        syncHead: syncHeadHash,\n        oldMainHead: mainHeadHash,\n        mainHead: mainHeadHash,\n        replayMutations: pending,\n        // The changed keys are not reported when further replays are\n        // needed. The diffs will be reported at the end when there\n        // are no more mutations to be replay and then it will be reported\n        // relative to DEFAULT_HEAD_NAME.\n        diffs: diffsMap,\n      };\n    }\n\n    // TODO check invariants\n\n    // Compute diffs (changed keys) for value map and index maps.\n    const mainHead = await commitFromHash(mainHeadHash, dagRead);\n    if (diffConfig.shouldComputeDiffs()) {\n      const mainHeadMap = new BTreeRead(\n        dagRead,\n        formatVersion,\n        mainHead.valueHash,\n      );\n      const syncHeadMap = new BTreeRead(\n        dagRead,\n        formatVersion,\n        syncHead.valueHash,\n      );\n      const valueDiff = await diff(mainHeadMap, syncHeadMap);\n      diffsMap.set('', valueDiff);\n      await addDiffsForIndexes(\n        mainHead,\n        syncHead,\n        dagRead,\n        diffsMap,\n        diffConfig,\n        formatVersion,\n      );\n    }\n\n    // No mutations to replay so set the main head to the sync head and sync complete!\n    await Promise.all([\n      dagWrite.setHead(DEFAULT_HEAD_NAME, syncHeadHash),\n      dagWrite.removeHead(SYNC_HEAD_NAME),\n    ]);\n    await dagWrite.commit();\n    // main head was set to sync head\n    const newMainHeadHash = syncHeadHash;\n\n    if (lc.debug) {\n      const [oldLastMutationID, oldCookie] = snapshotMetaParts(\n        mainSnapshot,\n        clientID,\n      );\n      const [newLastMutationID, newCookie] = snapshotMetaParts(\n        syncSnapshot,\n        clientID,\n      );\n      lc.debug(\n        `Successfully pulled new snapshot with lastMutationID:`,\n        newLastMutationID,\n        `(prev:`,\n        oldLastMutationID,\n        `), cookie: `,\n        newCookie,\n        `(prev:`,\n        oldCookie,\n        `), sync head hash:`,\n        syncHeadHash,\n        ', main head hash:',\n        mainHeadHash,\n        `, valueHash:`,\n        syncHead.valueHash,\n        `(prev:`,\n        mainSnapshot.valueHash,\n      );\n    }\n\n    return {\n      syncHead: syncHeadHash,\n      oldMainHead: mainHeadHash,\n      mainHead: newMainHeadHash,\n      replayMutations: [],\n      diffs: diffsMap,\n    };\n  });\n}\n","import {assertObject} from '../../shared/src/asserts.ts';\nimport {\n  assertVersionNotSupportedResponse,\n  type ClientStateNotFoundResponse,\n  isClientStateNotFoundResponse,\n  type VersionNotSupportedResponse,\n} from './error-responses.ts';\nimport {\n  assertHTTPRequestInfo,\n  type HTTPRequestInfo,\n} from './http-request-info.ts';\nimport type {PushRequest} from './sync/push.ts';\n\nexport type PusherResult = {\n  response?: PushResponse | undefined;\n  httpRequestInfo: HTTPRequestInfo;\n};\n\n/**\n * The response from a push can contain information about error conditions.\n */\nexport type PushResponse =\n  | ClientStateNotFoundResponse\n  | VersionNotSupportedResponse;\n\nexport function assertPusherResult(v: unknown): asserts v is PusherResult {\n  assertObject(v);\n  assertHTTPRequestInfo(v.httpRequestInfo);\n  if (v.response !== undefined) {\n    assertPushResponse(v.response);\n  }\n}\n\nfunction assertPushResponse(v: unknown): asserts v is PushResponse {\n  if (isClientStateNotFoundResponse(v)) {\n    return;\n  }\n  assertVersionNotSupportedResponse(v);\n}\n\n/**\n * Pusher is the function type used to do the fetch part of a push. The request\n * is a POST request where the body is JSON with the type {@link PushRequest}.\n *\n * The return value should either be a {@link HTTPRequestInfo} or a\n * {@link PusherResult}. The reason for the two different return types is that\n * we didn't use to care about the response body of the push request. The\n * default pusher implementation checks if the response body is JSON and if it\n * matches the type {@link PusherResponse}. If it does, it is included in the\n * return value.\n */\nexport type Pusher = (\n  requestBody: PushRequest,\n  requestID: string,\n) => Promise<PusherResult>;\n\n/**\n * This error is thrown when the pusher fails for any reason.\n */\nexport class PushError extends Error {\n  name = 'PushError';\n  // causedBy is used instead of cause, because while cause has been proposed as a\n  // JavaScript language standard for this purpose (see\n  // https://github.com/tc39/proposal-error-cause) current browser behavior is\n  // inconsistent.\n  causedBy?: Error | undefined;\n  constructor(causedBy?: Error) {\n    super('Failed to push');\n    this.causedBy = causedBy;\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport {jsonSchema} from '../../../shared/src/json-schema.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport * as valita from '../../../shared/src/valita.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  DEFAULT_HEAD_NAME,\n  type LocalMetaDD31,\n  commitIsLocalDD31,\n  localMutations,\n} from '../db/commit.ts';\nimport type {FrozenJSONValue} from '../frozen-json.ts';\nimport {\n  PushError,\n  type Pusher,\n  type PusherResult,\n  assertPusherResult,\n} from '../pusher.ts';\nimport {ReportError} from '../report-error.ts';\nimport {toError} from '../to-error.ts';\nimport {withRead} from '../with-transactions.ts';\nimport {\n  type ClientGroupID,\n  type ClientID,\n  clientGroupIDSchema,\n  clientIDSchema,\n} from './ids.ts';\n\nexport const PUSH_VERSION_SDD = 0;\nexport const PUSH_VERSION_DD31 = 1;\n\n/**\n * Mutation describes a single mutation done on the client.\n */\nexport type MutationV1 = {\n  readonly id: number;\n  readonly name: string;\n  readonly args: ReadonlyJSONValue;\n  readonly timestamp: number;\n  readonly clientID: ClientID;\n};\n\nexport type Mutation = MutationV1;\n\nconst mutationV1Schema: valita.Type<MutationV1> = valita.readonlyObject({\n  id: valita.number(),\n  name: valita.string(),\n  args: jsonSchema,\n  timestamp: valita.number(),\n  clientID: clientIDSchema,\n});\n\n/**\n * The JSON value used as the body when doing a POST to the [push\n * endpoint](/reference/server-push).\n */\nexport type PushRequestV1 = {\n  pushVersion: 1;\n  /**\n   * `schemaVersion` can optionally be used to specify to the push endpoint\n   * version information about the mutators the app is using (e.g., format of\n   * mutator args).\n   */\n  schemaVersion: string;\n  profileID: string;\n\n  clientGroupID: ClientGroupID;\n  mutations: MutationV1[];\n};\n\nconst pushRequestV1Schema = valita.object({\n  pushVersion: valita.literal(1),\n  schemaVersion: valita.string(),\n  profileID: valita.string(),\n  clientGroupID: clientGroupIDSchema,\n  mutations: valita.array(mutationV1Schema),\n});\n\nexport type PushRequest = PushRequestV1;\n\nexport function assertPushRequestV1(\n  value: unknown,\n): asserts value is PushRequestV1 {\n  valita.assert(value, pushRequestV1Schema);\n}\n\n/**\n * Mutation describes a single mutation done on the client.\n */\ntype FrozenMutationV1 = {\n  readonly id: number;\n  readonly name: string;\n  readonly args: FrozenJSONValue;\n  readonly timestamp: number;\n  readonly clientID: ClientID;\n};\n\nfunction convertDD31(lm: LocalMetaDD31): FrozenMutationV1 {\n  return {\n    id: lm.mutationID,\n    name: lm.mutatorName,\n    args: lm.mutatorArgsJSON,\n    timestamp: lm.timestamp,\n    clientID: lm.clientID,\n  };\n}\n\nexport async function push(\n  requestID: string,\n  store: Store,\n  lc: LogContext,\n  profileID: string,\n  clientGroupID: ClientGroupID | undefined,\n  _clientID: ClientID,\n  pusher: Pusher,\n  schemaVersion: string,\n  pushVersion: typeof PUSH_VERSION_SDD | typeof PUSH_VERSION_DD31,\n): Promise<PusherResult | undefined> {\n  // Find pending commits between the base snapshot and the main head and push\n  // them to the data layer.\n  const pending = await withRead(store, async dagRead => {\n    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);\n    if (!mainHeadHash) {\n      throw new Error('Internal no main head');\n    }\n    return localMutations(mainHeadHash, dagRead);\n    // Important! Don't hold the lock through an HTTP request!\n  });\n\n  if (pending.length === 0) {\n    return undefined;\n  }\n\n  // Commit.pending gave us commits in head-first order; the bindings\n  // want tail first (in mutation id order).\n  pending.reverse();\n\n  assert(pushVersion === PUSH_VERSION_DD31);\n\n  const pushMutations: FrozenMutationV1[] = [];\n  for (const commit of pending) {\n    if (commitIsLocalDD31(commit)) {\n      pushMutations.push(convertDD31(commit.meta));\n    } else {\n      throw new Error('Internal non local pending commit');\n    }\n  }\n  assert(clientGroupID);\n  const pushReq: PushRequestV1 = {\n    profileID,\n    clientGroupID,\n    mutations: pushMutations,\n    pushVersion: PUSH_VERSION_DD31,\n    schemaVersion,\n  };\n\n  lc.debug?.('Starting push...');\n  const pushStart = Date.now();\n  const pusherResult = await callPusher(pusher, pushReq, requestID);\n  lc.debug?.('...Push complete in ', Date.now() - pushStart, 'ms');\n  return pusherResult;\n}\n\nasync function callPusher(\n  pusher: Pusher,\n  body: PushRequestV1,\n  requestID: string,\n): Promise<PusherResult> {\n  let pusherResult: PusherResult;\n  try {\n    pusherResult = await pusher(body, requestID);\n  } catch (e) {\n    throw new PushError(toError(e));\n  }\n  try {\n    assertPusherResult(pusherResult);\n    return pusherResult;\n  } catch (e) {\n    throw new ReportError('Invalid pusher result', toError(e));\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert, assertNotUndefined} from '../../shared/src/asserts.ts';\nimport type {Enum} from '../../shared/src/enum.ts';\nimport type {MaybePromise} from '../../shared/src/types.ts';\nimport {throwChunkHasher} from './dag/chunk.ts';\nimport {LazyStore} from './dag/lazy-store.ts';\nimport {StoreImpl} from './dag/store-impl.ts';\nimport type {Store} from './dag/store.ts';\nimport {DEFAULT_HEAD_NAME} from './db/commit.ts';\nimport {\n  type ClientStateNotFoundResponse,\n  type VersionNotSupportedResponse,\n  isClientStateNotFoundResponse,\n  isVersionNotSupportedResponse,\n} from './error-responses.ts';\nimport * as FormatVersion from './format-version-enum.ts';\nimport {parseReplicacheFormatVersion as parseFormatVersion} from './format-version.ts';\nimport {assertHash, newRandomHash} from './hash.ts';\nimport type {HTTPRequestInfo} from './http-request-info.ts';\nimport type {CreateStore} from './kv/store.ts';\nimport {\n  type ClientGroup,\n  type ClientGroupMap,\n  getClientGroups,\n  disableClientGroup as persistDisableClientGroup,\n  setClientGroups,\n} from './persist/client-groups.ts';\nimport type {\n  IDBDatabasesStore,\n  IndexedDBDatabase,\n} from './persist/idb-databases-store.ts';\nimport type {PullResponseOKV1, PullResponseV1, Puller} from './puller.ts';\nimport type {PushResponse, Pusher} from './pusher.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\nimport {beginPullV1} from './sync/pull.ts';\nimport {PUSH_VERSION_DD31, push} from './sync/push.ts';\nimport {withRead, withWrite} from './with-transactions.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nconst MUTATION_RECOVERY_LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT = 10 * 2 ** 20; // 10 MB\n\ninterface ReplicacheDelegate {\n  clientID: ClientID;\n  closed: boolean;\n  idbName: string;\n  name: string;\n  online: boolean;\n  profileID: Promise<string>;\n  puller: Puller;\n  pusher: Pusher;\n}\n\ninterface MutationRecoveryOptions {\n  delegate: ReplicacheDelegate;\n  readonly wrapInOnlineCheck: (\n    f: () => Promise<boolean>,\n    name: string,\n  ) => Promise<boolean>;\n  readonly wrapInReauthRetries: <R>(\n    f: (\n      requestID: string,\n      requestLc: LogContext,\n    ) => Promise<{\n      httpRequestInfo: HTTPRequestInfo | undefined;\n      result: R;\n    }>,\n    verb: string,\n    lc: LogContext,\n    preAuth?: () => MaybePromise<void>,\n    postAuth?: () => MaybePromise<void>,\n  ) => Promise<{\n    result: R;\n    authFailure: boolean;\n  }>;\n  readonly isPushDisabled: () => boolean;\n  readonly isPullDisabled: () => boolean;\n  readonly lc: LogContext;\n  readonly enableMutationRecovery: boolean;\n  readonly clientGroupIDPromise: Promise<ClientGroupID | undefined>;\n}\n\nexport class MutationRecovery {\n  #recoveringMutations = false;\n  readonly #options: MutationRecoveryOptions;\n\n  constructor(options: MutationRecoveryOptions) {\n    this.#options = options;\n  }\n\n  async recoverMutations(\n    ready: Promise<unknown>,\n    perdag: Store,\n    idbDatabase: IndexedDBDatabase,\n    idbDatabases: IDBDatabasesStore,\n    createStore: CreateStore,\n  ): Promise<boolean> {\n    const {lc, enableMutationRecovery, isPushDisabled, delegate} =\n      this.#options;\n\n    if (\n      !enableMutationRecovery ||\n      this.#recoveringMutations ||\n      !delegate.online ||\n      delegate.closed ||\n      isPushDisabled()\n    ) {\n      return false;\n    }\n    const stepDescription = 'Recovering mutations.';\n    lc.debug?.('Start:', stepDescription);\n    try {\n      this.#recoveringMutations = true;\n      await ready;\n      await recoverMutationsFromPerdag(idbDatabase, this.#options, perdag);\n      for (const database of Object.values(await idbDatabases.getDatabases())) {\n        if (delegate.closed) {\n          lc.debug?.('Exiting early due to close:', stepDescription);\n          return true;\n        }\n        if (\n          database.replicacheName === delegate.name &&\n          database.name !== delegate.idbName\n        ) {\n          switch (database.replicacheFormatVersion) {\n            case FormatVersion.SDD:\n            case FormatVersion.DD31:\n            case FormatVersion.V6:\n            case FormatVersion.V7:\n              await recoverMutationsWithNewPerdag(\n                database,\n                this.#options,\n                createStore,\n              );\n          }\n        }\n      }\n    } catch (e) {\n      logMutationRecoveryError(e, lc, stepDescription, delegate);\n    } finally {\n      lc.debug?.('End:', stepDescription);\n      this.#recoveringMutations = false;\n    }\n    return true;\n  }\n}\n\nfunction logMutationRecoveryError(\n  e: unknown,\n  lc: LogContext,\n  stepDescription: string,\n  closedDelegate: {closed: boolean},\n) {\n  if (closedDelegate.closed) {\n    lc.debug?.(\n      `Mutation recovery error likely due to close during:\\n${stepDescription}\\nError:\\n`,\n      e,\n    );\n  } else {\n    lc.error?.(\n      `Mutation recovery error during:\\n${stepDescription}\\nError:\\n`,\n      e,\n    );\n  }\n}\n\nasync function recoverMutationsWithNewPerdag(\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  createStore: CreateStore,\n) {\n  const perKvStore = createStore(database.name);\n  const perdag = new StoreImpl(perKvStore, newRandomHash, assertHash);\n  try {\n    await recoverMutationsFromPerdag(database, options, perdag);\n  } finally {\n    await perdag.close();\n  }\n}\n\nfunction recoverMutationsFromPerdag(\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  perdag: Store,\n): Promise<void> {\n  assert(database.replicacheFormatVersion >= FormatVersion.DD31);\n  return recoverMutationsFromPerdagDD31(database, options, perdag);\n}\n\nasync function recoverMutationsFromPerdagDD31(\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  perdag: Store,\n): Promise<void> {\n  const {delegate, lc} = options;\n  const stepDescription = `Recovering mutations from db ${database.name}.`;\n  lc.debug?.('Start:', stepDescription);\n  try {\n    const formatVersion = parseFormatVersion(database.replicacheFormatVersion);\n    let clientGroups: ClientGroupMap | undefined = await withRead(\n      perdag,\n      read => getClientGroups(read),\n    );\n    const clientGroupIDsVisited = new Set<ClientGroupID>();\n    while (clientGroups) {\n      let newClientGroups: ClientGroupMap | undefined;\n      for (const [clientGroupID, clientGroup] of clientGroups) {\n        if (delegate.closed) {\n          lc.debug?.('Exiting early due to close:', stepDescription);\n          return;\n        }\n        if (!clientGroupIDsVisited.has(clientGroupID)) {\n          clientGroupIDsVisited.add(clientGroupID);\n          newClientGroups = await recoverMutationsOfClientGroupDD31(\n            clientGroup,\n            clientGroupID,\n            perdag,\n            database,\n            options,\n            formatVersion,\n          );\n          if (newClientGroups) {\n            break;\n          }\n        }\n      }\n      clientGroups = newClientGroups;\n    }\n  } catch (e) {\n    logMutationRecoveryError(e, lc, stepDescription, delegate);\n  }\n  lc.debug?.('End:', stepDescription);\n}\n\nfunction isResponseThatShouldDisableClientGroup(\n  response: PushResponse | PullResponseV1 | undefined,\n): response is ClientStateNotFoundResponse | VersionNotSupportedResponse {\n  return (\n    isClientStateNotFoundResponse(response) ||\n    isVersionNotSupportedResponse(response)\n  );\n}\n\nasync function disableClientGroup(\n  lc: LogContext,\n  selfClientGroupID: string,\n  clientGroupID: string,\n  response: ClientStateNotFoundResponse | VersionNotSupportedResponse,\n  perdag: Store,\n) {\n  if (isClientStateNotFoundResponse(response)) {\n    lc.debug?.(\n      `Client group ${selfClientGroupID} cannot recover mutations for client group ${clientGroupID}. The client group is unknown on the server. Marking it as disabled.`,\n    );\n  } else if (isVersionNotSupportedResponse(response)) {\n    lc.debug?.(\n      `Client group ${selfClientGroupID} cannot recover mutations for client group ${clientGroupID}. The client group's version is not supported on the server. versionType: ${response.versionType}. Marking it as disabled.`,\n    );\n  }\n  // The client group is not the main client group so we do not need the\n  // Replicache instance to update its internal _isClientGroupDisabled\n  // property.\n  await withWrite(perdag, perdagWrite =>\n    persistDisableClientGroup(clientGroupID, perdagWrite),\n  );\n}\n\n/**\n * @returns When mutations are recovered the resulting updated client group map.\n *   Otherwise undefined, which can be because there were no mutations to\n *   recover, or because an error occurred when trying to recover the mutations.\n */\nasync function recoverMutationsOfClientGroupDD31(\n  clientGroup: ClientGroup,\n  clientGroupID: ClientGroupID,\n  perdag: Store,\n  database: IndexedDBDatabase,\n  options: MutationRecoveryOptions,\n  formatVersion: FormatVersion,\n): Promise<ClientGroupMap | undefined> {\n  assert(database.replicacheFormatVersion >= FormatVersion.DD31);\n\n  const {\n    delegate,\n    lc,\n    wrapInOnlineCheck,\n    wrapInReauthRetries,\n    isPushDisabled,\n    isPullDisabled,\n    clientGroupIDPromise,\n  } = options;\n\n  const selfClientGroupID = await clientGroupIDPromise;\n  assertNotUndefined(selfClientGroupID);\n  if (selfClientGroupID === clientGroupID) {\n    return;\n  }\n\n  let clientID: ClientID | undefined;\n\n  // If all local mutations have been applied then exit.\n  let allAckd = true;\n  for (const [cid, mutationID] of Object.entries(clientGroup.mutationIDs)) {\n    // if not present then the server has not acknowledged this client's mutations.\n    if (\n      !clientGroup.lastServerAckdMutationIDs[cid] ||\n      clientGroup.lastServerAckdMutationIDs[cid] < mutationID\n    ) {\n      clientID = cid;\n      allAckd = false;\n      break;\n    }\n  }\n  if (allAckd) {\n    return;\n  }\n\n  if (clientGroup.disabled) {\n    lc.debug?.(\n      `Not recovering mutations for client group ${clientGroupID} because group is disabled.`,\n    );\n    return;\n  }\n\n  const stepDescription = `Recovering mutations for client group ${clientGroupID}.`;\n  lc.debug?.('Start:', stepDescription);\n  const lazyDagForOtherClientGroup = new LazyStore(\n    perdag,\n    MUTATION_RECOVERY_LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT,\n    throwChunkHasher,\n    assertHash,\n  );\n  try {\n    await withWrite(lazyDagForOtherClientGroup, write =>\n      write.setHead(DEFAULT_HEAD_NAME, clientGroup.headHash),\n    );\n\n    if (isPushDisabled()) {\n      lc.debug?.(\n        `Cannot recover mutations for client group ${clientGroupID} because push is disabled.`,\n      );\n      return;\n    }\n\n    const {pusher} = delegate;\n\n    const pushDescription = 'recoveringMutationsPush';\n    const pushSucceeded = await wrapInOnlineCheck(async () => {\n      const {result: pusherResult} = await wrapInReauthRetries(\n        async (requestID: string, requestLc: LogContext) => {\n          assert(clientID);\n          assert(lazyDagForOtherClientGroup);\n          const pusherResult = await push(\n            requestID,\n            lazyDagForOtherClientGroup,\n            requestLc,\n            await delegate.profileID,\n            clientGroupID,\n            // TODO(DD31): clientID is not needed in DD31. It is currently kept for debugging purpose.\n            clientID,\n            pusher,\n            database.schemaVersion,\n            PUSH_VERSION_DD31,\n          );\n          return {\n            result: pusherResult,\n            httpRequestInfo: pusherResult?.httpRequestInfo,\n          };\n        },\n        pushDescription,\n        lc,\n      );\n      if (!pusherResult) {\n        return false;\n      }\n      const pusherResponse = pusherResult.response;\n      if (isResponseThatShouldDisableClientGroup(pusherResponse)) {\n        await disableClientGroup(\n          lc,\n          selfClientGroupID,\n          clientGroupID,\n          pusherResponse,\n          perdag,\n        );\n        return false;\n      }\n      return pusherResult.httpRequestInfo.httpStatusCode === 200;\n    }, pushDescription);\n    if (!pushSucceeded) {\n      lc.debug?.(\n        `Failed to recover mutations for client ${clientGroupID} due to a push error.`,\n      );\n      return;\n    }\n\n    if (isPullDisabled()) {\n      lc.debug?.(\n        `Cannot confirm mutations were recovered for client ${clientGroupID} ` +\n          `because pull is disabled.`,\n      );\n      return;\n    }\n    const {puller} = delegate;\n\n    const pullDescription = 'recoveringMutationsPull';\n    let okPullResponse: PullResponseOKV1 | undefined;\n    const pullSucceeded = await wrapInOnlineCheck(async () => {\n      const {result: beginPullResponse} = await wrapInReauthRetries(\n        async (requestID: string, requestLc: LogContext) => {\n          assert(clientID);\n          const beginPullResponse = await beginPullV1(\n            await delegate.profileID,\n            clientID,\n            clientGroupID,\n            database.schemaVersion,\n            puller,\n            requestID,\n            lazyDagForOtherClientGroup,\n            formatVersion,\n            requestLc,\n            false,\n          );\n          return {\n            result: beginPullResponse,\n            httpRequestInfo: beginPullResponse.httpRequestInfo,\n          };\n        },\n        pullDescription,\n        lc,\n      );\n      const {pullResponse} = beginPullResponse;\n      if (isResponseThatShouldDisableClientGroup(pullResponse)) {\n        await disableClientGroup(\n          lc,\n          selfClientGroupID,\n          clientGroupID,\n          pullResponse,\n          perdag,\n        );\n        return false;\n      }\n      if (\n        !pullResponse ||\n        beginPullResponse.httpRequestInfo.httpStatusCode !== 200\n      ) {\n        return false;\n      }\n      okPullResponse = pullResponse;\n      return true;\n    }, pullDescription);\n    if (!pullSucceeded) {\n      lc.debug?.(\n        `Failed to recover mutations for client ${clientGroupID} due to a pull error.`,\n      );\n      return;\n    }\n\n    // TODO(arv): Refactor to make pullResponse a const.\n    // pullResponse must be non undefined because pullSucceeded is true.\n    assert(okPullResponse);\n    lc.debug?.(\n      `Client group ${selfClientGroupID} recovered mutations for client group ${clientGroupID}.  Details`,\n      {\n        mutationIDs: clientGroup.mutationIDs,\n        lastServerAckdMutationIDs: clientGroup.lastServerAckdMutationIDs,\n        lastMutationIDChanges: okPullResponse.lastMutationIDChanges,\n      },\n    );\n\n    return await withWrite(perdag, async dagWrite => {\n      const clientGroups = await getClientGroups(dagWrite);\n      const clientGroupToUpdate = clientGroups.get(clientGroupID);\n      if (!clientGroupToUpdate) {\n        return clientGroups;\n      }\n\n      assert(okPullResponse);\n      const lastServerAckdMutationIDsUpdates: Record<ClientID, number> = {};\n      let anyMutationIDsUpdated = false;\n      for (const [clientID, lastMutationIDChange] of Object.entries(\n        okPullResponse.lastMutationIDChanges,\n      )) {\n        if (\n          (clientGroupToUpdate.lastServerAckdMutationIDs[clientID] ?? 0) <\n          lastMutationIDChange\n        ) {\n          lastServerAckdMutationIDsUpdates[clientID] = lastMutationIDChange;\n          anyMutationIDsUpdated = true;\n        }\n      }\n      if (!anyMutationIDsUpdated) {\n        return clientGroups;\n      }\n\n      const newClientGroups = new Map(clientGroups).set(clientGroupID, {\n        ...clientGroupToUpdate,\n        lastServerAckdMutationIDs: {\n          ...clientGroupToUpdate.lastServerAckdMutationIDs,\n          ...lastServerAckdMutationIDsUpdates,\n        },\n      });\n      await setClientGroups(newClientGroups, dagWrite);\n      return newClientGroups;\n    });\n  } catch (e) {\n    logMutationRecoveryError(e, lc, stepDescription, delegate);\n  } finally {\n    await lazyDagForOtherClientGroup.close();\n    lc.debug?.('End:', stepDescription);\n  }\n  return;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nclass NoopBroadcastChannel implements BroadcastChannel {\n  readonly name: string;\n\n  onmessage: ((this: BroadcastChannel, ev: MessageEvent<any>) => any) | null =\n    null;\n\n  onmessageerror:\n    | ((this: BroadcastChannel, ev: MessageEvent<any>) => any)\n    | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  addEventListener(): void {\n    // noop\n  }\n  removeEventListener(): void {\n    // noop\n  }\n  dispatchEvent(): boolean {\n    return false;\n  }\n\n  close(): void {\n    // noop\n  }\n\n  postMessage(): void {\n    // noop\n  }\n}\n\nconst bc: typeof BroadcastChannel =\n  typeof BroadcastChannel === 'undefined'\n    ? NoopBroadcastChannel\n    : BroadcastChannel;\n\nexport {bc as BroadcastChannel};\n","import {BroadcastChannel} from '../../shared/src/broadcast-channel.ts';\nimport type {Read, Store} from './dag/store.ts';\nimport {getClientGroup} from './persist/client-groups.ts';\nimport {withRead} from './with-transactions.ts';\n\n// Older clients (<= replicache@13.0.1), listened on this channel name\n// and *asserted* that the messages received were an array containing exactly\n// one string.\nfunction makeChannelNameV0(replicacheName: string): string {\n  return `replicache-new-client-group:${replicacheName}`;\n}\n\n// This channel name was introduced when we first needed to change the message\n// format.  The design of the messages sent on this channel allows for\n// the message content to be extended in the future in a way that is\n// forward and backwards compatible.  The message format can be extended\n// by adding new *optional* fields.\nfunction makeChannelNameV1(replicacheName: string): string {\n  return `replicache-new-client-group-v1:${replicacheName}`;\n}\n\nexport {\n  makeChannelNameV0 as makeChannelNameV0ForTesting,\n  makeChannelNameV1 as makeChannelNameV1ForTesting,\n};\n\n// This message type can be extended with optional properties.\ntype NewClientChannelMessageV1 = {clientGroupID: string; idbName: string};\n\nfunction isNewClientChannelMessageV1(\n  message: unknown,\n): message is NewClientChannelMessageV1 {\n  return (\n    typeof message === 'object' &&\n    typeof (message as {clientGroupID: unknown}).clientGroupID === 'string' &&\n    typeof (message as {idbName: unknown}).idbName === 'string'\n  );\n}\n\nexport function initNewClientChannel(\n  replicacheName: string,\n  idbName: string,\n  signal: AbortSignal,\n  clientGroupID: string,\n  isNewClientGroup: boolean,\n  onUpdateNeeded: () => void,\n  perdag: Store,\n) {\n  if (signal.aborted) {\n    return;\n  }\n\n  const channelV1 = new BroadcastChannel(makeChannelNameV1(replicacheName));\n  if (isNewClientGroup) {\n    channelV1.postMessage({clientGroupID, idbName});\n    // Send expected format to V0 channel for old clients.\n    const channelV0 = new BroadcastChannel(makeChannelNameV0(replicacheName));\n    channelV0.postMessage([clientGroupID]);\n    channelV0.close();\n  }\n\n  channelV1.onmessage = async (e: MessageEvent) => {\n    const {data} = e;\n    if (isNewClientChannelMessageV1(data)) {\n      const {clientGroupID: newClientGroupID, idbName: newClientIDBName} = data;\n      if (newClientGroupID !== clientGroupID) {\n        if (newClientIDBName === idbName) {\n          // Check if this client can see the new client's newClientGroupID in its\n          // perdag. It should be able to if the clients share persistent\n          // storage. However, with `ReplicacheOption.kvStore`\n          // and `IDBStoreWithMemFallback` clients may not actually share\n          // persistent storage.  If storage is not shared, then there is no point\n          // in updating, since clients cannot sync locally.  If clients do update\n          // in this case, they can continually cause each other to update, since\n          // on each update the clients get assigned a new client group.\n          const updateNeeded = await withRead(\n            perdag,\n            async (perdagRead: Read) =>\n              (await getClientGroup(newClientGroupID, perdagRead)) !==\n              undefined,\n          );\n          if (updateNeeded) {\n            onUpdateNeeded();\n          }\n        } else {\n          // Idb name is different, indicating new schema or format version.\n          // Update to get assigned to newClientIDBName, and hopefully\n          // newClientGroupID.\n          // If storage is not actually shared (i.e. due to\n          // `ReplicacheOption.kvStore`\n          // or `IDBStoreWithMemFallback`) the new client will not\n          // get assigned to newClientGroupID, but should get the\n          // newClientIDBName.\n          // Note: we don't try to read from newClientIDBName to see\n          // if this client shares storage with the new client, because\n          // the newClientIDBName may have a format version this client\n          // cannot read.\n          onUpdateNeeded();\n          return;\n        }\n      }\n    }\n  };\n\n  signal.addEventListener('abort', () => channelV1.close(), {once: true});\n}\n","import {assertObject, assertString} from '../../shared/src/asserts.ts';\nimport {BroadcastChannel} from '../../shared/src/broadcast-channel.ts';\nimport type {ClientGroupID, ClientID} from './sync/ids.ts';\n\nfunction makeChannelName(replicacheName: string): string {\n  return `replicache-on-persist:${replicacheName}`;\n}\n\nexport type PersistInfo = {\n  clientGroupID: ClientGroupID;\n  clientID: ClientID;\n};\n\nexport type OnPersist = (persistInfo: PersistInfo) => void;\n\ntype HandlePersist = OnPersist;\n\nfunction assertPersistInfo(value: unknown): asserts value is PersistInfo {\n  assertObject(value);\n  assertString(value.clientGroupID);\n  assertString(value.clientID);\n}\n\nexport function initOnPersistChannel(\n  replicacheName: string,\n  signal: AbortSignal,\n  handlePersist: HandlePersist,\n): OnPersist {\n  if (signal.aborted) {\n    return () => undefined;\n  }\n  const channel = new BroadcastChannel(makeChannelName(replicacheName));\n\n  channel.onmessage = e => {\n    const {data} = e;\n    assertPersistInfo(data);\n    handlePersist({\n      clientGroupID: data.clientGroupID,\n      clientID: data.clientID,\n    });\n  };\n\n  signal.addEventListener('abort', () => channel.close(), {once: true});\n\n  return (persistInfo: PersistInfo) => {\n    if (signal.aborted) {\n      return;\n    }\n    channel.postMessage(persistInfo);\n    handlePersist(persistInfo);\n  };\n}\n","import type {ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {mustGetHeadHash, type Read} from './dag/store.ts';\nimport {DEFAULT_HEAD_NAME, localMutationsDD31} from './db/commit.ts';\nimport type {ClientID} from './sync/ids.ts';\n\nexport type PendingMutation = {\n  readonly name: string;\n  readonly id: number;\n  readonly args: ReadonlyJSONValue;\n  readonly clientID: ClientID;\n};\n\n/**\n * This returns the pending changes with the oldest mutations first.\n */\nexport async function pendingMutationsForAPI(\n  dagRead: Read,\n): Promise<readonly PendingMutation[]> {\n  const mainHeadHash = await mustGetHeadHash(DEFAULT_HEAD_NAME, dagRead);\n  const pending = await localMutationsDD31(mainHeadHash, dagRead);\n  return pending\n    .map(p => ({\n      id: p.meta.mutationID,\n      name: p.meta.mutatorName,\n      args: p.meta.mutatorArgsJSON,\n      clientID: p.meta.clientID,\n    }))\n    .reverse();\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport type {Store} from '../dag/store.ts';\nimport {addDeletedClients} from '../deleted-clients.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport type {Client, OnClientsDeleted} from './clients.ts';\nimport {type ClientMap, getClients, setClients} from './clients.ts';\n\n/**\n * The maximum time a client can be inactive before it is garbage collected.\n * This means that this is the maximum time a tab can be in the background\n * (frozen) and still be able to sync when it comes back to the foreground.\n */\nexport const CLIENT_MAX_INACTIVE_TIME = 24 * 60 * 60 * 1000; // 24 hours\n\n/**\n * How frequently to try to garbage collect clients.\n */\nexport const GC_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\nlet latestGCUpdate: Promise<ClientMap> | undefined;\nexport function getLatestGCUpdate(): Promise<ClientMap> | undefined {\n  return latestGCUpdate;\n}\n\nexport function initClientGC(\n  clientID: ClientID,\n  dagStore: Store,\n  clientMaxInactiveTime: number,\n  gcInterval: number,\n  onClientsDeleted: OnClientsDeleted,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  initBgIntervalProcess(\n    'ClientGC',\n    () => {\n      latestGCUpdate = gcClients(\n        clientID,\n        dagStore,\n        clientMaxInactiveTime,\n        onClientsDeleted,\n      );\n      return latestGCUpdate;\n    },\n    () => gcInterval,\n    lc,\n    signal,\n  );\n}\n\nfunction gcClients(\n  clientID: ClientID,\n  dagStore: Store,\n  clientMaxInactiveTime: number,\n  onClientsDeleted: OnClientsDeleted,\n): Promise<ClientMap> {\n  return withWrite(dagStore, async dagWrite => {\n    const now = Date.now();\n    const clients = await getClients(dagWrite);\n    const deletedClients: ClientID[] = [];\n    const newClients: Map<ClientID, Client> = new Map();\n    for (const [id, client] of clients) {\n      if (\n        id === clientID /* never collect ourself */ ||\n        now - client.heartbeatTimestampMs <= clientMaxInactiveTime\n      ) {\n        newClients.set(id, client);\n      } else {\n        deletedClients.push(id);\n      }\n    }\n\n    if (newClients.size === clients.size) {\n      return clients;\n    }\n    await setClients(newClients, dagWrite);\n    const {clientIDs, clientGroupIDs} = await addDeletedClients(\n      dagWrite,\n      deletedClients,\n      // gcClients does not delete client groups\n      [],\n    );\n    onClientsDeleted(clientIDs, clientGroupIDs);\n    return newClients;\n  });\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport type {Store} from '../dag/store.ts';\nimport type {ClientGroupID} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport {\n  clientGroupHasPendingMutations,\n  getClientGroups,\n  setClientGroups,\n  type ClientGroupMap,\n} from './client-groups.ts';\nimport {getClients, type OnClientsDeleted} from './clients.ts';\n\nconst GC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes\n\nlet latestGCUpdate: Promise<ClientGroupMap> | undefined;\nexport function getLatestGCUpdate(): Promise<ClientGroupMap> | undefined {\n  return latestGCUpdate;\n}\n\nexport function initClientGroupGC(\n  dagStore: Store,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  initBgIntervalProcess(\n    'ClientGroupGC',\n    () => {\n      latestGCUpdate = gcClientGroups(\n        dagStore,\n        enableMutationRecovery,\n        onClientsDeleted,\n      );\n      return latestGCUpdate;\n    },\n    () => GC_INTERVAL_MS,\n    lc,\n    signal,\n  );\n}\n\n/**\n * This removes client groups that have no clients and no pending mutations.\n * If {@linkcode enableMutationRecovery} is true, it will keep client groups with\n * pending mutations. If it is false, it will remove client groups even when they\n * have pending mutations.\n */\nexport function gcClientGroups(\n  dagStore: Store,\n  enableMutationRecovery: boolean,\n  onClientsDeleted: OnClientsDeleted,\n): Promise<ClientGroupMap> {\n  return withWrite(dagStore, async tx => {\n    const clients = await getClients(tx);\n    const clientGroupIDs = new Set();\n    for (const client of clients.values()) {\n      clientGroupIDs.add(client.clientGroupID);\n    }\n    const clientGroups = new Map();\n    const removeClientGroups: Set<ClientGroupID> = new Set();\n    for (const [clientGroupID, clientGroup] of await getClientGroups(tx)) {\n      if (\n        clientGroupIDs.has(clientGroupID) ||\n        (enableMutationRecovery && clientGroupHasPendingMutations(clientGroup))\n      ) {\n        clientGroups.set(clientGroupID, clientGroup);\n      } else {\n        removeClientGroups.add(clientGroupID);\n      }\n    }\n    await setClientGroups(clientGroups, tx);\n    onClientsDeleted([], [...removeClientGroups].sort());\n    return clientGroups;\n  });\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {initBgIntervalProcess} from '../bg-interval.ts';\nimport type {Store} from '../dag/store.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport {withWrite} from '../with-transactions.ts';\nimport {\n  type ClientMap,\n  ClientStateNotFoundError,\n  getClients,\n  setClients,\n} from './clients.ts';\n\nexport const HEARTBEAT_INTERVAL = 60 * 1000;\n\nexport let latestHeartbeatUpdate: Promise<ClientMap> | undefined;\n\nexport function startHeartbeats(\n  clientID: ClientID,\n  dagStore: Store,\n  onClientStateNotFound: () => void,\n  heartbeatIntervalMs: number,\n  lc: LogContext,\n  signal: AbortSignal,\n): void {\n  initBgIntervalProcess(\n    'Heartbeat',\n    async () => {\n      latestHeartbeatUpdate = writeHeartbeat(clientID, dagStore);\n      try {\n        return await latestHeartbeatUpdate;\n      } catch (e) {\n        if (e instanceof ClientStateNotFoundError) {\n          onClientStateNotFound();\n          return;\n        }\n        throw e;\n      }\n    },\n    () => heartbeatIntervalMs,\n    lc,\n    signal,\n  );\n}\n\nexport function writeHeartbeat(\n  clientID: ClientID,\n  dagStore: Store,\n): Promise<ClientMap> {\n  return withWrite(dagStore, async dagWrite => {\n    const clients = await getClients(dagWrite);\n    const client = clients.get(clientID);\n    if (!client) {\n      throw new ClientStateNotFoundError(clientID);\n    }\n\n    const newClient = {\n      ...client,\n      heartbeatTimestampMs: Date.now(),\n    };\n    const newClients = new Map(clients).set(clientID, newClient);\n\n    await setClients(newClients, dagWrite);\n    return newClients;\n  });\n}\n","import type {Hash} from '../hash.ts';\nimport type {Chunk} from './chunk.ts';\nimport type {MustGetChunk} from './store.ts';\n\n/**\n * A visitor walks the DAG starting at a given root and visits each chunk.\n */\nexport class Visitor {\n  #seen: Set<Hash> = new Set();\n  #dagRead: MustGetChunk;\n\n  constructor(dagRead: MustGetChunk) {\n    this.#dagRead = dagRead;\n  }\n\n  async visit(h: Hash) {\n    if (this.#seen.has(h)) {\n      return;\n    }\n    this.#seen.add(h);\n    const chunk = await this.#dagRead.mustGetChunk(h);\n    await this.visitChunk(chunk);\n  }\n\n  async visitChunk(chunk: Chunk<unknown>) {\n    await Promise.all(chunk.meta.map(ref => this.visit(ref)));\n  }\n}\n","import {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {Chunk} from '../dag/chunk.ts';\nimport type {LazyRead} from '../dag/lazy-store.ts';\nimport {Visitor} from '../dag/visitor.ts';\nimport type {Hash} from '../hash.ts';\n\nexport class GatherMemoryOnlyVisitor extends Visitor {\n  readonly #gatheredChunks: Map<Hash, Chunk> = new Map();\n  readonly #lazyRead: LazyRead;\n\n  constructor(dagRead: LazyRead) {\n    super(dagRead);\n    this.#lazyRead = dagRead;\n  }\n\n  get gatheredChunks(): ReadonlyMap<Hash, Chunk> {\n    return this.#gatheredChunks;\n  }\n\n  override visit(h: Hash): Promise<void> {\n    if (!this.#lazyRead.isMemOnlyChunkHash(h)) {\n      // Not a memory-only hash, no need to visit anything else.\n      return promiseVoid;\n    }\n    return super.visit(h);\n  }\n\n  override visitChunk(chunk: Chunk): Promise<void> {\n    this.#gatheredChunks.set(chunk.hash, chunk);\n    return super.visitChunk(chunk);\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport type {Chunk} from '../dag/chunk.ts';\nimport type {LazyStore} from '../dag/lazy-store.ts';\nimport type {Read, Store, Write} from '../dag/store.ts';\nimport {\n  Commit,\n  DEFAULT_HEAD_NAME,\n  type LocalMetaDD31,\n  type Meta,\n  assertSnapshotCommitDD31,\n  baseSnapshotFromCommit,\n  commitFromHash,\n  commitFromHead,\n  compareCookiesForSnapshots,\n  localMutationsDD31,\n  localMutationsGreaterThan,\n} from '../db/commit.ts';\nimport {rebaseMutationAndPutCommit} from '../db/rebase.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\nimport type {ClientGroupID, ClientID} from '../sync/ids.ts';\nimport type {MutatorDefs} from '../types.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {\n  type ClientGroup,\n  getClientGroup,\n  setClientGroup,\n} from './client-groups.ts';\nimport {\n  assertClientV6,\n  assertHasClientState,\n  getClientGroupIDForClient,\n  mustGetClient,\n  setClient,\n} from './clients.ts';\nimport {GatherMemoryOnlyVisitor} from './gather-mem-only-visitor.ts';\nimport type {ZeroOption, ZeroTxData} from '../replicache-options.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\n/**\n * Persists the client's memdag state to the client's perdag client group.\n *\n * Persists the base snapshot from memdag to the client's perdag client group,\n * but only if it’s newer than the client's perdag client group’s base snapshot.\n * The base snapshot is persisted by gathering all memory-only chunks in the dag\n * subgraph rooted at the base snapshot's commit and writing them to the perdag.\n * Once the base snapshot is persisted, rebases onto this new base snapshot all\n * local commits from the client's perdag client group that are not already\n * reflected in the base snapshot.\n *\n * Whether or not the base snapshot is persisted, rebases onto the client's\n * perdag client group all memdag local commits not already in the client's\n * perdag client group's history.\n *\n * Also updates the `lastMutationIDs` and `lastServerAckdMutationIDs` properties\n * of the client's client group's entry in the `ClientGroupMap`.\n */\nexport async function persistDD31(\n  lc: LogContext,\n  clientID: ClientID,\n  memdag: LazyStore,\n  perdag: Store,\n  mutators: MutatorDefs,\n  closed: () => boolean,\n  formatVersion: FormatVersion,\n  getZeroData: ZeroOption['getTxData'] | undefined,\n  onGatherMemOnlyChunksForTest = () => Promise.resolve(),\n): Promise<void> {\n  if (closed()) {\n    return;\n  }\n\n  const [perdagLMID, perdagBaseSnapshot, mainClientGroupID] = await withRead(\n    perdag,\n    async perdagRead => {\n      await assertHasClientState(clientID, perdagRead);\n      const mainClientGroupID = await getClientGroupIDForClient(\n        clientID,\n        perdagRead,\n      );\n      assert(\n        mainClientGroupID,\n        `No main client group for clientID: ${clientID}`,\n      );\n      const [, perdagMainClientGroupHeadCommit] = await getClientGroupInfo(\n        perdagRead,\n        mainClientGroupID,\n      );\n      const perdagLMID = await perdagMainClientGroupHeadCommit.getMutationID(\n        clientID,\n        perdagRead,\n      );\n      const perdagBaseSnapshot = await baseSnapshotFromCommit(\n        perdagMainClientGroupHeadCommit,\n        perdagRead,\n      );\n      assertSnapshotCommitDD31(perdagBaseSnapshot);\n      return [perdagLMID, perdagBaseSnapshot, mainClientGroupID];\n    },\n  );\n\n  if (closed()) {\n    return;\n  }\n  const [newMemdagMutations, memdagBaseSnapshot, gatheredChunks] =\n    await withRead(memdag, async memdagRead => {\n      const memdagHeadCommit = await commitFromHead(\n        DEFAULT_HEAD_NAME,\n        memdagRead,\n      );\n      const newMutations = await localMutationsGreaterThan(\n        memdagHeadCommit,\n        {[clientID]: perdagLMID || 0},\n        memdagRead,\n      );\n      const memdagBaseSnapshot = await baseSnapshotFromCommit(\n        memdagHeadCommit,\n        memdagRead,\n      );\n      assertSnapshotCommitDD31(memdagBaseSnapshot);\n\n      let gatheredChunks: ReadonlyMap<Hash, Chunk> | undefined;\n      if (\n        compareCookiesForSnapshots(memdagBaseSnapshot, perdagBaseSnapshot) > 0\n      ) {\n        await onGatherMemOnlyChunksForTest();\n        // Might need to persist snapshot, we will have to double check\n        // after gathering the snapshot chunks from memdag\n        const memdagBaseSnapshotHash = memdagBaseSnapshot.chunk.hash;\n        // Gather all memory only chunks from base snapshot on the memdag.\n        const visitor = new GatherMemoryOnlyVisitor(memdagRead);\n        await visitor.visit(memdagBaseSnapshotHash);\n        gatheredChunks = visitor.gatheredChunks;\n      }\n\n      return [newMutations, memdagBaseSnapshot, gatheredChunks];\n    });\n\n  if (closed()) {\n    return;\n  }\n\n  let memdagBaseSnapshotPersisted = false;\n  const zeroDataForMemdagBaseSnapshot =\n    getZeroData && (await getZeroData(memdagBaseSnapshot.chunk.hash));\n\n  await withWrite(perdag, async perdagWrite => {\n    const [mainClientGroup, latestPerdagMainClientGroupHeadCommit] =\n      await getClientGroupInfo(perdagWrite, mainClientGroupID);\n\n    // These initial values for newMainClientGroupHeadHash, mutationIDs,\n    // lastServerAckdMutationIDs are correct for the case where the memdag\n    // snapshot is *not* persisted.  If the memdag snapshot is persisted\n    // these values are overwritten appropriately.\n    let newMainClientGroupHeadHash: Hash =\n      latestPerdagMainClientGroupHeadCommit.chunk.hash;\n    let mutationIDs: Record<ClientID, number> = {\n      ...mainClientGroup.mutationIDs,\n    };\n    let {lastServerAckdMutationIDs} = mainClientGroup;\n\n    if (gatheredChunks) {\n      // check if memdag snapshot still newer than perdag snapshot\n\n      const client = await mustGetClient(clientID, perdagWrite);\n      assertClientV6(client);\n\n      const latestPerdagBaseSnapshot = await baseSnapshotFromCommit(\n        latestPerdagMainClientGroupHeadCommit,\n        perdagWrite,\n      );\n      assertSnapshotCommitDD31(latestPerdagBaseSnapshot);\n\n      // check if memdag snapshot still newer than perdag snapshot\n      if (\n        compareCookiesForSnapshots(\n          memdagBaseSnapshot,\n          latestPerdagBaseSnapshot,\n        ) > 0\n      ) {\n        // still newer, persist memdag snapshot by writing chunks\n        memdagBaseSnapshotPersisted = true;\n        await Promise.all(\n          Array.from(gatheredChunks.values(), c => perdagWrite.putChunk(c)),\n        );\n\n        await setClient(\n          clientID,\n          {\n            ...client,\n            persistHash: memdagBaseSnapshot.chunk.hash,\n          },\n          perdagWrite,\n        );\n        // Rebase local mutations from perdag main client group onto new\n        // snapshot\n        newMainClientGroupHeadHash = memdagBaseSnapshot.chunk.hash;\n        const mainClientGroupLocalMutations = await localMutationsDD31(\n          mainClientGroup.headHash,\n          perdagWrite,\n        );\n\n        lastServerAckdMutationIDs = memdagBaseSnapshot.meta.lastMutationIDs;\n        mutationIDs = {...lastServerAckdMutationIDs};\n\n        newMainClientGroupHeadHash = await rebase(\n          mainClientGroupLocalMutations,\n          newMainClientGroupHeadHash,\n          perdagWrite,\n          mutators,\n          mutationIDs,\n          lc,\n          formatVersion,\n          zeroDataForMemdagBaseSnapshot,\n        );\n      }\n    }\n\n    let zeroDataForPerdagHeadCommit: ZeroTxData | undefined;\n    if (!memdagBaseSnapshotPersisted) {\n      zeroDataForPerdagHeadCommit =\n        getZeroData &&\n        (await getZeroData(newMainClientGroupHeadHash, {\n          openLazySourceRead: perdagWrite,\n        }));\n    }\n\n    // rebase new memdag mutations onto perdag\n    newMainClientGroupHeadHash = await rebase(\n      newMemdagMutations,\n      newMainClientGroupHeadHash,\n      perdagWrite,\n      mutators,\n      mutationIDs,\n      lc,\n      formatVersion,\n      zeroDataForPerdagHeadCommit ?? zeroDataForMemdagBaseSnapshot,\n    );\n\n    const newMainClientGroup = {\n      ...mainClientGroup,\n      headHash: newMainClientGroupHeadHash,\n      mutationIDs,\n      lastServerAckdMutationIDs,\n    };\n\n    await setClientGroup(mainClientGroupID, newMainClientGroup, perdagWrite);\n  });\n\n  if (gatheredChunks && memdagBaseSnapshotPersisted) {\n    await withWrite(memdag, memdagWrite =>\n      memdagWrite.chunksPersisted([...gatheredChunks.keys()]),\n    );\n  }\n}\n\nasync function getClientGroupInfo(\n  perdagRead: Read,\n  clientGroupID: ClientGroupID,\n): Promise<[ClientGroup, Commit<Meta>]> {\n  const clientGroup = await getClientGroup(clientGroupID, perdagRead);\n  assert(clientGroup, `No client group for clientGroupID: ${clientGroupID}`);\n  return [clientGroup, await commitFromHash(clientGroup.headHash, perdagRead)];\n}\n\nasync function rebase(\n  mutations: Commit<LocalMetaDD31>[],\n  basis: Hash,\n  write: Write,\n  mutators: MutatorDefs,\n  mutationIDs: Record<ClientID, number>,\n  lc: LogContext,\n  formatVersion: FormatVersion,\n  zeroData: ZeroTxData | undefined,\n): Promise<Hash> {\n  for (let i = mutations.length - 1; i >= 0; i--) {\n    const mutationCommit = mutations[i];\n    const {meta} = mutationCommit;\n    const newMainHead = await commitFromHash(basis, write);\n    if (\n      (await mutationCommit.getMutationID(meta.clientID, write)) >\n      (await newMainHead.getMutationID(meta.clientID, write))\n    ) {\n      mutationIDs[meta.clientID] = meta.mutationID;\n      basis = (\n        await rebaseMutationAndPutCommit(\n          mutationCommit,\n          write,\n          basis,\n          mutators,\n          lc,\n          meta.clientID,\n          formatVersion,\n          zeroData,\n        )\n      ).chunk.hash;\n    }\n  }\n  return basis;\n}\n","import {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {Chunk} from '../dag/chunk.ts';\nimport type {LazyStore} from '../dag/lazy-store.ts';\nimport type {Read} from '../dag/store.ts';\nimport {Visitor} from '../dag/visitor.ts';\nimport type {Hash} from '../hash.ts';\nimport {getSizeOfValue} from '../size-of-value.ts';\n\nexport type ChunkWithSize = {chunk: Chunk; size: number};\n\nexport class GatherNotCachedVisitor extends Visitor {\n  readonly #gatheredChunks: Map<Hash, ChunkWithSize> = new Map();\n  #gatheredChunksTotalSize = 0;\n  readonly #lazyStore: LazyStore;\n  readonly #gatherSizeLimit: number;\n  readonly #getSizeOfChunk: (chunk: Chunk) => number;\n\n  constructor(\n    dagRead: Read,\n    lazyStore: LazyStore,\n    gatherSizeLimit: number,\n    getSizeOfChunk: (chunk: Chunk) => number = getSizeOfValue,\n  ) {\n    super(dagRead);\n    this.#lazyStore = lazyStore;\n    this.#gatherSizeLimit = gatherSizeLimit;\n    this.#getSizeOfChunk = getSizeOfChunk;\n  }\n\n  get gatheredChunks(): ReadonlyMap<Hash, ChunkWithSize> {\n    return this.#gatheredChunks;\n  }\n\n  override visit(h: Hash): Promise<void> {\n    if (\n      this.#gatheredChunksTotalSize >= this.#gatherSizeLimit ||\n      this.#lazyStore.isCached(h)\n    ) {\n      return promiseVoid;\n    }\n    return super.visit(h);\n  }\n\n  override visitChunk(chunk: Chunk): Promise<void> {\n    if (this.#gatheredChunksTotalSize < this.#gatherSizeLimit) {\n      const size = this.#getSizeOfChunk(chunk);\n      this.#gatheredChunks.set(chunk.hash, {chunk, size});\n      this.#gatheredChunksTotalSize += size;\n    }\n\n    return super.visitChunk(chunk);\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport type {Enum} from '../../../shared/src/enum.ts';\nimport {sleep} from '../../../shared/src/sleep.ts';\nimport type {LazyStore} from '../dag/lazy-store.ts';\nimport type {Store} from '../dag/store.ts';\nimport {\n  Commit,\n  DEFAULT_HEAD_NAME,\n  type SnapshotMetaDD31,\n  assertSnapshotCommitDD31,\n  baseSnapshotFromCommit,\n  baseSnapshotFromHash,\n  baseSnapshotFromHead,\n  commitFromHash,\n  commitFromHead,\n  compareCookiesForSnapshots,\n  localMutationsGreaterThan,\n} from '../db/commit.ts';\nimport {rebaseMutationAndPutCommit} from '../db/rebase.ts';\nimport * as FormatVersion from '../format-version-enum.ts';\nimport type {Hash} from '../hash.ts';\nimport {\n  type DiffComputationConfig,\n  DiffsMap,\n  diffCommits,\n} from '../sync/diff.ts';\nimport type {ClientID} from '../sync/ids.ts';\nimport type {MutatorDefs} from '../types.ts';\nimport {withRead, withWrite} from '../with-transactions.ts';\nimport {\n  ClientStateNotFoundError,\n  type ClientV6,\n  assertClientV6,\n  getClientGroupForClient,\n  mustGetClient,\n  setClient,\n} from './clients.ts';\nimport {\n  type ChunkWithSize,\n  GatherNotCachedVisitor,\n} from './gather-not-cached-visitor.ts';\nimport type {ZeroOption} from '../replicache-options.ts';\n\ntype FormatVersion = Enum<typeof FormatVersion>;\n\nconst GATHER_SIZE_LIMIT = 5 * 2 ** 20; // 5 MB\nconst DELAY_MS = 300;\n\ntype RefreshResult =\n  | {\n      type: 'aborted';\n      refreshHashesForRevert?: readonly Hash[] | undefined;\n    }\n  | {\n      type: 'complete';\n      diffs: DiffsMap;\n      newPerdagClientHeadHash: Hash;\n      oldHead: Hash;\n      newHead: Hash;\n    };\n\n/**\n * This returns the diff between the state of the btree before and after\n * refresh. It returns `undefined` if the refresh was aborted.\n */\nexport async function refresh(\n  lc: LogContext,\n  memdag: LazyStore,\n  perdag: Store,\n  clientID: ClientID,\n  mutators: MutatorDefs,\n  diffConfig: DiffComputationConfig,\n  closed: () => boolean,\n  formatVersion: FormatVersion,\n  zero: ZeroOption | undefined,\n): Promise<{oldHead: Hash; newHead: Hash; diffs: DiffsMap} | undefined> {\n  if (closed()) {\n    return;\n  }\n  const memdagBaseSnapshot = await withRead(memdag, memdagRead =>\n    baseSnapshotFromHead(DEFAULT_HEAD_NAME, memdagRead),\n  );\n  assertSnapshotCommitDD31(memdagBaseSnapshot);\n\n  type PerdagWriteResult = [\n    perdagClientGroupHeadHash: Hash,\n    perdagClientGroupBaseSnapshot: Commit<SnapshotMetaDD31>,\n    perdagLmid: number,\n    gatheredChunks: ReadonlyMap<Hash, ChunkWithSize>,\n    refreshHashesForRevert: readonly Hash[],\n  ];\n\n  // Suspend eviction and deletion of chunks cached by the lazy store\n  // to prevent cache misses.  If eviction and deletion are not suspended\n  // some chunks that are not gathered due to already being cached, may be\n  // evicted or deleted by the time the write lock is acquired on the memdag,\n  // which can lead to cache misses when performing the rebase and diff.\n  // It is important to avoid these cache misses because they often create jank\n  // because they block local mutations, pulls and queries on reading from idb.\n  // Cache misses can still happen during the rebase and diff, but only\n  // if the gather step hits its size limit.\n  const result: RefreshResult =\n    await memdag.withSuspendedSourceCacheEvictsAndDeletes(async () => {\n      const perdagWriteResult: PerdagWriteResult | undefined = await withWrite(\n        perdag,\n        async perdagWrite => {\n          const clientGroup = await getClientGroupForClient(\n            clientID,\n            perdagWrite,\n          );\n          if (!clientGroup) {\n            throw new ClientStateNotFoundError(clientID);\n          }\n\n          const perdagClientGroupHeadHash = clientGroup.headHash;\n          const perdagClientGroupHeadCommit = await commitFromHash(\n            perdagClientGroupHeadHash,\n            perdagWrite,\n          );\n          const perdagLmid = await perdagClientGroupHeadCommit.getMutationID(\n            clientID,\n            perdagWrite,\n          );\n\n          // Need to pull this head into memdag, but can't have it disappear if\n          // perdag moves forward while we're rebasing in memdag. Can't change\n          // client headHash until our rebase in memdag is complete, because if\n          // rebase fails, then nothing is keeping client's chunks alive in\n          // perdag.\n          const client = await mustGetClient(clientID, perdagWrite);\n          assertClientV6(client);\n          const perdagClientGroupBaseSnapshot = await baseSnapshotFromHash(\n            perdagClientGroupHeadHash,\n            perdagWrite,\n          );\n          assertSnapshotCommitDD31(perdagClientGroupBaseSnapshot);\n          if (\n            shouldAbortRefresh(\n              memdagBaseSnapshot,\n              perdagClientGroupBaseSnapshot,\n              perdagClientGroupHeadHash,\n            )\n          ) {\n            return undefined;\n          }\n\n          // To avoid pulling the entire perdag graph into the memdag\n          // the amount of chunk data gathered is limited by size.\n          const visitor = new GatherNotCachedVisitor(\n            perdagWrite,\n            memdag,\n            GATHER_SIZE_LIMIT,\n          );\n          await visitor.visit(perdagClientGroupHeadHash);\n          const {gatheredChunks} = visitor;\n\n          const refreshHashesSet = new Set(client.refreshHashes);\n          refreshHashesSet.add(perdagClientGroupHeadHash);\n\n          const newClient: ClientV6 = {\n            ...client,\n            refreshHashes: [...refreshHashesSet],\n          };\n\n          await setClient(clientID, newClient, perdagWrite);\n          return [\n            perdagClientGroupHeadHash,\n            perdagClientGroupBaseSnapshot,\n            perdagLmid,\n            gatheredChunks,\n            client.refreshHashes,\n          ];\n        },\n      );\n\n      if (closed() || !perdagWriteResult) {\n        return {\n          type: 'aborted',\n        } as const;\n      }\n      // pull/poke and refresh are racing to see who gets to update\n      // the memdag (the one with the newer base snapshot cookie wins)\n      // pull/poke updates are preferable so delay refresh slightly to\n      // make pull/poke the winner except when pull/pokes are slow.\n      // This is especially important for pokes, as refresh winning\n      // will result in the next poke's cookie not matching necessitating\n      // a disconnect/reconnect.\n      await sleep(DELAY_MS);\n      if (closed()) {\n        return {\n          type: 'aborted',\n        };\n      }\n\n      const [\n        perdagClientGroupHeadHash,\n        perdagClientGroupBaseSnapshot,\n        perdagLmid,\n        gatheredChunks,\n        refreshHashesForRevert,\n      ] = perdagWriteResult;\n      return withWrite(memdag, async memdagWrite => {\n        const memdagHeadCommit = await commitFromHead(\n          DEFAULT_HEAD_NAME,\n          memdagWrite,\n        );\n        const memdagBaseSnapshot = await baseSnapshotFromCommit(\n          memdagHeadCommit,\n          memdagWrite,\n        );\n        assertSnapshotCommitDD31(memdagBaseSnapshot);\n        if (\n          shouldAbortRefresh(\n            memdagBaseSnapshot,\n            perdagClientGroupBaseSnapshot,\n            perdagClientGroupHeadHash,\n          )\n        ) {\n          return {\n            type: 'aborted',\n            refreshHashesForRevert,\n          };\n        }\n\n        const newMemdagMutations = await localMutationsGreaterThan(\n          memdagHeadCommit,\n          {[clientID]: perdagLmid},\n          memdagWrite,\n        );\n        const ps = [];\n        for (const {chunk, size} of gatheredChunks.values()) {\n          ps.push(memdagWrite.putChunk(chunk, size));\n        }\n        await Promise.all(ps);\n\n        let newMemdagHeadHash = perdagClientGroupHeadHash;\n        if (newMemdagMutations.length > 0) {\n          const zeroData = await zero?.getTxData?.(newMemdagHeadHash, {\n            openLazyRead: memdagWrite,\n          });\n          for (let i = newMemdagMutations.length - 1; i >= 0; i--) {\n            newMemdagHeadHash = (\n              await rebaseMutationAndPutCommit(\n                newMemdagMutations[i],\n                memdagWrite,\n                newMemdagHeadHash,\n                mutators,\n                lc,\n                newMemdagMutations[i].meta.clientID,\n                formatVersion,\n                zeroData,\n              )\n            ).chunk.hash;\n          }\n        }\n\n        const newMemdagHeadCommit = await commitFromHash(\n          newMemdagHeadHash,\n          memdagWrite,\n        );\n        const diffs = await diffCommits(\n          memdagHeadCommit,\n          newMemdagHeadCommit,\n          memdagWrite,\n          diffConfig,\n          formatVersion,\n        );\n\n        await memdagWrite.setHead(DEFAULT_HEAD_NAME, newMemdagHeadHash);\n        return {\n          type: 'complete',\n          diffs,\n          oldHead: memdagHeadCommit.chunk.hash,\n          newHead: newMemdagHeadHash,\n          newPerdagClientHeadHash: perdagClientGroupHeadHash,\n        } as const;\n      });\n    });\n\n  if (closed()) {\n    return;\n  }\n\n  const setRefreshHashes = (refreshHashes: readonly Hash[]) =>\n    withWrite(perdag, async perdagWrite => {\n      const client = await mustGetClient(clientID, perdagWrite);\n      const newClient = {\n        ...client,\n        refreshHashes,\n      };\n\n      // If this cleanup never happens, it's no big deal, some data will stay\n      // alive longer but next refresh will fix it.\n      await setClient(clientID, newClient, perdagWrite);\n    });\n\n  if (result.type === 'aborted') {\n    if (result.refreshHashesForRevert) {\n      await setRefreshHashes(result.refreshHashesForRevert);\n    }\n    return undefined;\n  }\n\n  // Advance zero here before setting refresh hashes\n  // since we must advance before delegating control of the microtask\n  // loop.\n  zero?.advance(result.oldHead, result.newHead, result.diffs.get('') ?? []);\n  await setRefreshHashes([result.newPerdagClientHeadHash]);\n  return {\n    oldHead: result.oldHead,\n    newHead: result.newHead,\n    diffs: result.diffs,\n  };\n}\n\nfunction shouldAbortRefresh(\n  memdagBaseSnapshot: Commit<SnapshotMetaDD31>,\n  perdagClientGroupBaseSnapshot: Commit<SnapshotMetaDD31>,\n  perdagClientGroupHeadHash: Hash,\n): boolean {\n  const baseSnapshotCookieCompareResult = compareCookiesForSnapshots(\n    memdagBaseSnapshot,\n    perdagClientGroupBaseSnapshot,\n  );\n  return (\n    baseSnapshotCookieCompareResult > 0 ||\n    (baseSnapshotCookieCompareResult === 0 &&\n      perdagClientGroupHeadHash === perdagClientGroupBaseSnapshot.chunk.hash)\n  );\n}\n","import {type Resolver, resolver} from '@rocicorp/resolver';\nimport {AbortError} from '../../shared/src/abort-error.ts';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {sleep} from '../../shared/src/sleep.ts';\nimport {requestIdle as defaultRequestIdle} from './request-idle.ts';\n\nexport class ProcessScheduler {\n  readonly #process: () => Promise<void>;\n  readonly #idleTimeoutMs: number;\n  readonly #throttleMs: number;\n  readonly #abortSignal: AbortSignal;\n  readonly #requestIdle: typeof defaultRequestIdle;\n  #scheduledResolver: Resolver<void> | undefined = undefined;\n  #runResolver: Resolver<void> | undefined = undefined;\n  #runPromise = Promise.resolve();\n  #throttlePromise = Promise.resolve();\n\n  /**\n   * Supports scheduling a `process` to be run with certain constraints.\n   *  - Process runs are never concurrent.\n   *  - Multiple calls to schedule will be fulfilled by a single process\n   *    run started after the call to schedule.  A call is never fulfilled by an\n   *    already running process run.  This can be thought of as debouncing.\n   *  - Process runs are throttled so that the process runs at most once every\n   *    `throttleMs`.\n   *  - Process runs try to run during an idle period, but will delay at most\n   *    `idleTimeoutMs`.\n   *  - Scheduled runs which have not completed when `abortSignal` is aborted\n   *    will reject with an `AbortError`.\n   */\n  constructor(\n    process: () => Promise<void>,\n    idleTimeoutMs: number,\n    throttleMs: number,\n    abortSignal: AbortSignal,\n    requestIdle = defaultRequestIdle,\n  ) {\n    this.#process = process;\n    this.#idleTimeoutMs = idleTimeoutMs;\n    this.#throttleMs = throttleMs;\n    this.#abortSignal = abortSignal;\n    this.#requestIdle = requestIdle;\n    this.#abortSignal.addEventListener(\n      'abort',\n      () => {\n        const abortError = new AbortError('Aborted');\n        this.#runResolver?.reject(abortError);\n        this.#scheduledResolver?.reject(abortError);\n        this.#runResolver = undefined;\n        this.#scheduledResolver = undefined;\n      },\n      {once: true},\n    );\n  }\n\n  schedule(): Promise<void> {\n    if (this.#abortSignal.aborted) {\n      return Promise.reject(new AbortError('Aborted'));\n    }\n    if (this.#scheduledResolver) {\n      return this.#scheduledResolver.promise;\n    }\n    this.#scheduledResolver = resolver();\n    void this.#scheduleInternal();\n    return this.#scheduledResolver.promise;\n  }\n\n  async #scheduleInternal(): Promise<void> {\n    try {\n      await this.#runPromise;\n      // Prevent errors thrown by process from cancelling scheduled runs.\n      // this._runPromise is also awaited below and errors are explicitly\n      // propagated to promises returned from schedule.\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n    await this.#throttlePromise;\n    if (!this.#scheduledResolver) {\n      return;\n    }\n    await this.#requestIdle(this.#idleTimeoutMs);\n    if (!this.#scheduledResolver) {\n      return;\n    }\n    this.#throttlePromise = throttle(this.#throttleMs, this.#abortSignal);\n    this.#runResolver = this.#scheduledResolver;\n    this.#scheduledResolver = undefined;\n    try {\n      this.#runPromise = this.#process();\n      await this.#runPromise;\n      this.#runResolver?.resolve();\n    } catch (e) {\n      this.#runResolver?.reject(e);\n    }\n    this.#runResolver = undefined;\n  }\n}\n\nasync function throttle(\n  timeMs: number,\n  abortSignal: AbortSignal,\n): Promise<void> {\n  try {\n    await sleep(timeMs, abortSignal);\n  } catch (e) {\n    assert(e instanceof AbortError);\n  }\n}\n","// TODO(arv): Remove workaround once docs/ builds cleanly without this.\ndeclare function requestIdleCallback(\n  callback: () => void,\n  options?: {timeout?: number},\n): number;\n\n/**\n * A Promise wrapper for requestIdleCallback with fallback to setTimeout for\n * browsers without support (aka Safari)\n */\nexport function requestIdle(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    if (typeof requestIdleCallback === 'function') {\n      requestIdleCallback(() => resolve(), {timeout});\n    } else {\n      setTimeout(() => resolve(), timeout);\n    }\n  });\n}\n","export function setIntervalWithSignal(\n  fn: () => void,\n  ms: number,\n  signal: AbortSignal,\n): void {\n  if (!signal.aborted) {\n    const interval = setInterval(fn, ms);\n    signal.addEventListener('abort', () => {\n      clearInterval(interval);\n    });\n  }\n}\n","import type {LogContext} from '@rocicorp/logger';\nimport {compareUTF8, greaterThan, lessThan, lessThanEq} from 'compare-utf8';\nimport {assert} from '../../shared/src/asserts.ts';\nimport {binarySearch} from '../../shared/src/binary-search.ts';\nimport type {Enum} from '../../shared/src/enum.ts';\nimport {deepEqual} from '../../shared/src/json.ts';\nimport type {\n  Diff,\n  DiffOperation,\n  IndexDiff,\n  InternalDiff,\n  InternalDiffOperation,\n  NoIndexDiff,\n} from './btree/node.ts';\nimport type {IndexKey} from './db/index.ts';\nimport {decodeIndexKey} from './db/index.ts';\nimport type {ScanOptions} from './db/scan.ts';\nimport * as InvokeKind from './invoke-kind-enum.ts';\nimport type {DiffComputationConfig, DiffsMap} from './sync/diff.ts';\nimport {\n  type ReadTransaction,\n  SubscriptionTransactionWrapper,\n} from './transactions.ts';\nimport type {QueryInternal} from './types.ts';\n\ntype InvokeKind = Enum<typeof InvokeKind>;\n\nexport interface Subscription<R> {\n  hasIndexSubscription(indexName: string): boolean;\n\n  invoke(\n    tx: ReadTransaction,\n    kind: InvokeKind,\n    diffs: DiffsMap | undefined,\n  ): Promise<R>;\n\n  matches(diffs: DiffsMap): boolean;\n\n  updateDeps(\n    keys: ReadonlySet<string>,\n    scans: ReadonlyArray<Readonly<ScanSubscriptionInfo>>,\n  ): void;\n\n  readonly onData: (result: R) => void;\n  readonly onError: ((error: unknown) => void) | undefined;\n  readonly onDone: (() => void) | undefined;\n}\n\nconst emptySet: ReadonlySet<string> = new Set();\n\nconst unitializedLastValue = Symbol();\ntype UnitializedLastValue = typeof unitializedLastValue;\n\nexport class SubscriptionImpl<R> implements Subscription<R> {\n  readonly #body: (tx: ReadTransaction) => Promise<R>;\n  readonly #onData: (result: R) => void;\n  #lastValue: R | UnitializedLastValue = unitializedLastValue;\n  #keys = emptySet;\n  #scans: readonly Readonly<ScanSubscriptionInfo>[] = [];\n\n  readonly onError: ((error: unknown) => void) | undefined;\n  readonly onDone: (() => void) | undefined;\n  readonly #isEqual: (a: R, b: R) => boolean;\n\n  constructor(\n    body: (tx: ReadTransaction) => Promise<R>,\n    onData: (result: R) => void,\n    onError: ((error: unknown) => void) | undefined,\n    onDone: (() => void) | undefined,\n    // deepEqual operates on any JSON value but argument might be more specific.\n    isEqual: (a: R, b: R) => boolean = deepEqual as (a: R, b: R) => boolean,\n  ) {\n    this.#body = body;\n    this.#onData = onData;\n    this.onError = onError;\n    this.onDone = onDone;\n    this.#isEqual = isEqual;\n  }\n\n  hasIndexSubscription(indexName: string): boolean {\n    for (const scan of this.#scans) {\n      if (scan.options.indexName === indexName) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  invoke(\n    tx: ReadTransaction,\n    _kind: InvokeKind,\n    _diffs: DiffsMap | undefined,\n  ): Promise<R> {\n    return this.#body(tx);\n  }\n\n  matches(diffs: DiffsMap): boolean {\n    for (const [indexName, diff] of diffs) {\n      if (diffMatchesSubscription(this.#keys, this.#scans, indexName, diff)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  updateDeps(\n    keys: ReadonlySet<string>,\n    scans: readonly Readonly<ScanSubscriptionInfo>[],\n  ): void {\n    this.#keys = keys;\n    this.#scans = scans;\n  }\n\n  onData(result: R): void {\n    if (\n      this.#lastValue === unitializedLastValue ||\n      !this.#isEqual(this.#lastValue, result)\n    ) {\n      this.#lastValue = result;\n      this.#onData(result);\n    }\n  }\n}\n\nexport {SubscriptionImpl as SubscriptionImplForTesting};\n\n/**\n * Function that gets passed into {@link Replicache.experimentalWatch} and gets\n * called when the data in Replicache changes.\n *\n * @experimental This type is experimental and may change in the future.\n */\nexport type WatchNoIndexCallback = (diff: NoIndexDiff) => void;\n\nexport type WatchCallbackForOptions<Options extends WatchOptions> =\n  Options extends WatchIndexOptions ? WatchIndexCallback : WatchNoIndexCallback;\n\n/**\n * Function that gets passed into {@link Replicache.experimentalWatch} when doing a\n * watch on a secondary index map and gets called when the data in Replicache\n * changes.\n *\n * @experimental This type is experimental and may change in the future.\n */\nexport type WatchIndexCallback = (diff: IndexDiff) => void;\n\n/**\n * Options for {@link Replicache.experimentalWatch}.\n *\n * @experimental This interface is experimental and may change in the future.\n */\nexport type WatchOptions = WatchIndexOptions | WatchNoIndexOptions;\n\n/**\n * Options object passed to {@link Replicache.experimentalWatch}. This is for an\n * index watch.\n */\nexport type WatchIndexOptions = WatchNoIndexOptions & {\n  /**\n   * When provided, the `watch` is limited to the changes that apply to the index map.\n   */\n  indexName: string;\n};\n\n/**\n * Options object passed to {@link Replicache.experimentalWatch}. This is for a non\n * index watch.\n */\nexport type WatchNoIndexOptions = {\n  /**\n   * When provided, the `watch` is limited to changes where the `key` starts\n   * with `prefix`.\n   */\n  prefix?: string | undefined;\n\n  /**\n   * When this is set to `true` (default is `false`), the `watch` callback will\n   * be called once asynchronously when watch is called. The arguments in that\n   * case is a diff where we consider all the existing values in Replicache as\n   * being added.\n   */\n  initialValuesInFirstDiff?: boolean | undefined;\n};\n\nexport type WatchCallback = (diff: Diff) => void;\n\nexport class WatchSubscription implements Subscription<Diff | undefined> {\n  readonly #callback: WatchCallback;\n  readonly #prefix: string;\n  readonly #indexName: string | undefined;\n  readonly #initialValuesInFirstDiff: boolean;\n\n  readonly onError: ((error: unknown) => void) | undefined = undefined;\n  readonly onDone: (() => void) | undefined = undefined;\n\n  constructor(callback: WatchCallback, options?: WatchOptions) {\n    this.#callback = callback;\n    this.#prefix = options?.prefix ?? '';\n    this.#indexName = (options as WatchIndexOptions)?.indexName;\n    this.#initialValuesInFirstDiff = options?.initialValuesInFirstDiff ?? false;\n  }\n\n  hasIndexSubscription(indexName: string): boolean {\n    return this.#indexName === indexName;\n  }\n\n  onData(result: Diff | undefined): void {\n    if (result !== undefined) {\n      this.#callback(result);\n    }\n  }\n\n  invoke(\n    tx: ReadTransaction,\n    kind: InvokeKind,\n    diffs: DiffsMap | undefined,\n  ): Promise<Diff | undefined> {\n    const invoke = async <Key extends IndexKey | string>(\n      indexName: string | undefined,\n      prefix: string,\n      compareKey: (diff: DiffOperation<Key>) => string,\n      convertInternalDiff: (\n        diff: InternalDiff,\n      ) => readonly DiffOperation<Key>[],\n    ): Promise<readonly DiffOperation<Key>[] | undefined> => {\n      let diff: readonly DiffOperation<Key>[];\n      if (kind === InvokeKind.InitialRun) {\n        if (!this.#initialValuesInFirstDiff) {\n          // We are using `undefined` here as a sentinel value to indicate that we\n          // should not call the callback in `onDone`.\n          return undefined;\n        }\n\n        // For the initial run, we need to get the \"diffs\" for the whole tree.\n        assert(diffs === undefined);\n\n        const newDiff: DiffOperation<Key>[] = [];\n        for await (const entry of tx.scan({prefix, indexName}).entries()) {\n          newDiff.push({\n            op: 'add',\n            key: entry[0] as Key,\n            newValue: entry[1],\n          });\n        }\n        diff = newDiff;\n      } else {\n        assert(diffs);\n        const maybeDiff = diffs.get(indexName ?? '') ?? [];\n        diff = convertInternalDiff(maybeDiff);\n      }\n      const newDiff: DiffOperation<Key>[] = [];\n      const {length} = diff;\n      for (\n        let i = diffBinarySearch(diff, prefix, compareKey);\n        i < length;\n        i++\n      ) {\n        if (compareKey(diff[i]).startsWith(prefix)) {\n          newDiff.push(diff[i]);\n        } else {\n          break;\n        }\n      }\n\n      // For initial run we should always return something.\n      return kind === InvokeKind.InitialRun || newDiff.length > 0\n        ? newDiff\n        : undefined;\n    };\n\n    if (this.#indexName) {\n      return invoke<IndexKey>(\n        this.#indexName,\n        this.#prefix,\n        diff => diff.key[0],\n        internalDiff => convertDiffValues(internalDiff, decodeIndexKey),\n      );\n    }\n\n    return invoke<string>(\n      undefined,\n      this.#prefix,\n      diff => diff.key,\n      internalDiff => convertDiffValues(internalDiff, k => k),\n    );\n  }\n\n  matches(diffs: DiffsMap): boolean {\n    const diff = diffs.get(this.#indexName ?? '');\n    if (diff === undefined) {\n      return false;\n    }\n\n    return watcherMatchesDiff(diff, this.#prefix, this.#indexName);\n  }\n\n  updateDeps(\n    _keys: ReadonlySet<string>,\n    _scans: readonly Readonly<ScanSubscriptionInfo>[],\n  ): void {\n    // not used\n  }\n}\n\nfunction convertDiffValues<Key>(\n  diff: InternalDiff,\n  convertKey: (k: string) => Key,\n): DiffOperation<Key>[] {\n  return diff.map(op => {\n    const key = convertKey(op.key);\n    switch (op.op) {\n      case 'add':\n        return {\n          op: 'add',\n          key,\n          newValue: op.newValue,\n        };\n      case 'change':\n        return {\n          op: 'change',\n          key,\n          oldValue: op.oldValue,\n          newValue: op.newValue,\n        };\n      case 'del':\n        return {\n          op: 'del',\n          key,\n          oldValue: op.oldValue,\n        };\n    }\n  });\n}\n\n/**\n * The options passed to {@link Replicache.subscribe}.\n */\nexport interface SubscribeOptions<R> {\n  /**\n   * Called when the return value of the body function changes.\n   */\n  onData: (result: R) => void;\n\n  /**\n   * If present, called when an error occurs.\n   */\n  onError?: ((error: unknown) => void) | undefined;\n\n  /**\n   * If present, called when the subscription is removed/done.\n   */\n  onDone?: (() => void) | undefined;\n\n  /**\n   * If present this function is used to determine if the value returned by the\n   * body function has changed. If not provided a JSON deep equality check is\n   * used.\n   */\n  isEqual?: ((a: R, b: R) => boolean) | undefined;\n}\n\nexport type UnknownSubscription = Subscription<unknown>;\n\ntype SubscriptionSet = Set<UnknownSubscription>;\n\nexport interface SubscriptionsManager extends DiffComputationConfig {\n  clear(): void;\n  fire(diffs: DiffsMap): Promise<void>;\n  hasPendingSubscriptionRuns: boolean;\n  add<R>(subscription: Subscription<R>): () => void;\n}\n\nexport class SubscriptionsManagerImpl implements SubscriptionsManager {\n  readonly #subscriptions: SubscriptionSet = new Set();\n  readonly #pendingSubscriptions: SubscriptionSet = new Set();\n  readonly #queryInternal: QueryInternal;\n  readonly #lc: LogContext;\n  hasPendingSubscriptionRuns = false;\n  readonly #signal: AbortSignal;\n\n  constructor(\n    queryInternal: QueryInternal,\n    lc: LogContext,\n    signal: AbortSignal,\n  ) {\n    this.#queryInternal = queryInternal;\n    this.#lc = lc;\n    this.#signal = signal;\n  }\n\n  add<R>(subscription: Subscription<R>): () => void {\n    this.#subscriptions.add(subscription as UnknownSubscription);\n    void this.#scheduleInitialSubscriptionRun(\n      subscription as UnknownSubscription,\n    );\n    return () =>\n      this.#subscriptions.delete(subscription as UnknownSubscription);\n  }\n\n  clear(): void {\n    for (const subscription of this.#subscriptions) {\n      subscription.onDone?.();\n    }\n    this.#subscriptions.clear();\n  }\n\n  fire(diffs: DiffsMap): Promise<void> {\n    const subscriptions = subscriptionsForDiffs(this.#subscriptions, diffs);\n    return this.#fireSubscriptions(subscriptions, InvokeKind.Regular, diffs);\n  }\n\n  async #fireSubscriptions(\n    subscriptions: Iterable<UnknownSubscription>,\n    kind: InvokeKind,\n    diffs: DiffsMap | undefined,\n  ) {\n    if (this.#signal.aborted) {\n      return;\n    }\n\n    const subs = [...subscriptions] as readonly Subscription<unknown>[];\n    if (subs.length === 0) {\n      return;\n    }\n\n    // Use allSettled to gather fulfilled and rejected promises.\n    const results = await this.#queryInternal(tx =>\n      Promise.allSettled(\n        subs.map(async s => {\n          const stx = new SubscriptionTransactionWrapper(tx);\n          try {\n            return await s.invoke(stx, kind, diffs);\n          } finally {\n            // We need to keep track of the subscription keys even if there was an\n            // exception because changes to the keys can make the subscription\n            // body succeed.\n            s.updateDeps(stx.keys, stx.scans);\n          }\n        }),\n      ),\n    );\n\n    this.callCallbacks(subs, results);\n  }\n\n  // Public method so that ZQL can wrap it in a transaction.\n  callCallbacks(\n    subs: readonly Subscription<unknown>[],\n    results: PromiseSettledResult<unknown>[],\n  ) {\n    for (let i = 0; i < subs.length; i++) {\n      const s = subs[i];\n      const result = results[i];\n      if (result.status === 'fulfilled') {\n        s.onData(result.value);\n      } else {\n        if (s.onError) {\n          s.onError(result.reason);\n        } else {\n          this.#lc.error?.('Error in subscription body:', result.reason);\n        }\n      }\n    }\n  }\n\n  async #scheduleInitialSubscriptionRun(s: UnknownSubscription) {\n    this.#pendingSubscriptions.add(s);\n\n    if (!this.hasPendingSubscriptionRuns) {\n      this.hasPendingSubscriptionRuns = true;\n      await Promise.resolve();\n      this.hasPendingSubscriptionRuns = false;\n      const subscriptions = [...this.#pendingSubscriptions];\n      this.#pendingSubscriptions.clear();\n      await this.#fireSubscriptions(\n        subscriptions,\n        InvokeKind.InitialRun,\n        undefined,\n      );\n    }\n  }\n\n  shouldComputeDiffs(): boolean {\n    return this.#subscriptions.size > 0;\n  }\n\n  shouldComputeDiffsForIndex(indexName: string): boolean {\n    for (const s of this.#subscriptions) {\n      if (s.hasIndexSubscription(indexName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport type ScanSubscriptionInfo = {\n  options: ScanOptions;\n  inclusiveLimitKey?: string | undefined;\n};\n\nfunction diffMatchesSubscription(\n  keys: ReadonlySet<string>,\n  scans: Iterable<Readonly<ScanSubscriptionInfo>>,\n  indexName: string,\n  diff: InternalDiff,\n): boolean {\n  // Keys can only match for non index scans.\n  if (indexName === '') {\n    for (const diffEntry of diff) {\n      if (keys.has(diffEntry.key)) {\n        return true;\n      }\n    }\n  }\n\n  for (const scanInfo of scans) {\n    if (scanInfoMatchesDiff(scanInfo, indexName, diff)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction scanInfoMatchesDiff(\n  scanInfo: ScanSubscriptionInfo,\n  changeIndexName: string,\n  diff: InternalDiff,\n): boolean {\n  // TODO(arv): Use binary search\n  for (const diffEntry of diff) {\n    if (scanInfoMatchesKey(scanInfo, changeIndexName, diffEntry.key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function scanInfoMatchesKey(\n  scanInfo: ScanSubscriptionInfo,\n  changeIndexName: string,\n  changedKey: string,\n): boolean {\n  const {\n    indexName = '',\n    limit,\n    prefix,\n    startKey,\n    startExclusive,\n    startSecondaryKey,\n  } = scanInfo.options;\n\n  if (changeIndexName !== indexName) {\n    return false;\n  }\n\n  if (!indexName) {\n    // A scan with limit <= 0 can have no matches\n    if (limit !== undefined && limit <= 0) {\n      return false;\n    }\n\n    // No prefix and no start. Must recompute the subscription because all keys\n    // will have an effect on the subscription.\n    if (!prefix && !startKey) {\n      return true;\n    }\n\n    if (\n      prefix &&\n      (!changedKey.startsWith(prefix) ||\n        isKeyPastInclusiveLimit(scanInfo, changedKey))\n    ) {\n      return false;\n    }\n\n    if (\n      startKey &&\n      ((startExclusive && lessThanEq(changedKey, startKey)) ||\n        lessThan(changedKey, startKey) ||\n        isKeyPastInclusiveLimit(scanInfo, changedKey))\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // No prefix and no start. Must recompute the subscription because all keys\n  // will have an effect on the subscription.\n  if (!prefix && !startKey && !startSecondaryKey) {\n    return true;\n  }\n\n  const [changedKeySecondary, changedKeyPrimary] = decodeIndexKey(changedKey);\n\n  if (prefix) {\n    if (!changedKeySecondary.startsWith(prefix)) {\n      return false;\n    }\n  }\n\n  if (\n    startSecondaryKey &&\n    ((startExclusive && lessThanEq(changedKeySecondary, startSecondaryKey)) ||\n      lessThan(changedKeySecondary, startSecondaryKey))\n  ) {\n    return false;\n  }\n\n  if (\n    startKey &&\n    ((startExclusive && lessThanEq(changedKeyPrimary, startKey)) ||\n      lessThan(changedKeyPrimary, startKey))\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isKeyPastInclusiveLimit(\n  scanInfo: ScanSubscriptionInfo,\n  changedKey: string,\n): boolean {\n  const {inclusiveLimitKey} = scanInfo;\n  return (\n    scanInfo.options.limit !== undefined &&\n    inclusiveLimitKey !== undefined &&\n    greaterThan(changedKey, inclusiveLimitKey)\n  );\n}\n\nfunction* subscriptionsForDiffs<V>(\n  subscriptions: Set<Subscription<V>>,\n  diffs: DiffsMap,\n): Generator<Subscription<V>> {\n  for (const subscription of subscriptions) {\n    if (subscription.matches(diffs)) {\n      yield subscription;\n    }\n  }\n}\n\nfunction watcherMatchesDiff(\n  diff: InternalDiff,\n  prefix: string,\n  indexName: string | undefined,\n): boolean {\n  if (prefix === '') {\n    return true;\n  }\n\n  const compareKey = indexName\n    ? (diffOp: InternalDiffOperation) => decodeIndexKey(diffOp.key)[0]\n    : (diffOp: InternalDiffOperation) => diffOp.key;\n  const i = diffBinarySearch(diff, prefix, compareKey);\n  return i < diff.length && compareKey(diff[i]).startsWith(prefix);\n}\n\nexport function diffBinarySearch<Key, Value>(\n  diff: readonly InternalDiffOperation<Key, Value>[],\n  prefix: string,\n  compareKey: (diff: InternalDiffOperation<Key, Value>) => string,\n): number {\n  return binarySearch(diff.length, i =>\n    compareUTF8(prefix, compareKey(diff[i])),\n  );\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const InitialRun = 0;\nexport const Regular = 1;\n\nexport type InitialRun = typeof InitialRun;\nexport type Regular = typeof Regular;\n","import {getNonCryptoRandomValues} from '../../../shared/src/random-values.ts';\nimport type {ClientID} from './ids.ts';\n\nlet sessionID = '';\nfunction getSessionID() {\n  if (sessionID === '') {\n    const buf = new Uint8Array(4);\n    getNonCryptoRandomValues(buf);\n    sessionID = Array.from(buf, x => x.toString(16)).join('');\n  }\n  return sessionID;\n}\n\nconst REQUEST_COUNTERS: Map<string, number> = new Map();\n\n/**\n * Returns a new requestID of the form <client ID>-<session ID>-<request\n * count>. The request count enables one to find the request following or\n * preceding a given request. The sessionid scopes the request count, ensuring\n * the requestID is probabilistically unique across restarts (which is good\n * enough).\n */\nexport function newRequestID(clientID: ClientID): string {\n  const counter = REQUEST_COUNTERS.get(clientID) ?? 0;\n  REQUEST_COUNTERS.set(clientID, counter + 1);\n  return `${clientID}-${getSessionID()}-${counter}`;\n}\n","// The env value should be filled in by esbuild.\n\ndeclare const process: {\n  env: {\n    ['REPLICACHE_VERSION']?: string;\n  };\n};\n\n/**\n * The current version of Replicache.\n */\nexport const version: string = process.env.REPLICACHE_VERSION ?? '0.0.0';\n","export class Subscribable<\n  TArgs,\n  TListener extends (obj: TArgs) => unknown = (obj: TArgs) => unknown,\n> {\n  protected _listeners = new Set<TListener>();\n\n  /**\n   * Subscribe to the subscribable.\n   *\n   * @param listener - The listener to subscribe to.\n   * @returns A function to unsubscribe from the subscribable.\n   */\n  subscribe = (listener: TListener): (() => void) => {\n    this._listeners.add(listener);\n\n    return () => {\n      this._listeners.delete(listener);\n    };\n  };\n\n  /**\n   * Notify all listeners.\n   *\n   * @param update - The update to notify listeners with.\n   */\n  notify = (update: TArgs): void => {\n    this._listeners.forEach(listener => listener(update));\n  };\n\n  hasListeners = (): boolean => this._listeners.size > 0;\n\n  /**\n   * Unsubscribe all listeners.\n   */\n  cleanup = (): void => {\n    this._listeners.clear();\n  };\n}\n","import * as v from '../../shared/src/valita.ts';\n\nexport const deleteClientsBodySchema = v.union(\n  v.readonlyObject({\n    clientIDs: v.readonlyArray(v.string()).optional(),\n    clientGroupIDs: v.readonlyArray(v.string()).optional(),\n  }),\n);\n\nexport const deleteClientsMessageSchema = v.tuple([\n  v.literal('deleteClients'),\n  deleteClientsBodySchema,\n]);\n\nexport type DeleteClientsBody = v.Infer<typeof deleteClientsBodySchema>;\nexport type DeleteClientsMessage = v.Infer<typeof deleteClientsMessageSchema>;\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {astSchema} from './ast.ts';\n\nexport const putOpSchema = v.object({\n  op: v.literal('put'),\n  hash: v.string(),\n  ttl: v.number().optional(),\n});\n\nexport const upPutOpSchema = putOpSchema.extend({\n  // All fields are optional in this transitional period.\n  // - ast is filled in for client queries\n  // - name and args are filled in for custom queries\n  ast: astSchema.optional(),\n  name: v.string().optional(),\n  args: v.readonly(v.array(jsonSchema)).optional(),\n});\n\nconst delOpSchema = v.object({\n  op: v.literal('del'),\n  hash: v.string(),\n});\n\nconst clearOpSchema = v.object({\n  op: v.literal('clear'),\n});\n\nconst patchOpSchema = v.union(putOpSchema, delOpSchema, clearOpSchema);\nconst upPatchOpSchema = v.union(upPutOpSchema, delOpSchema, clearOpSchema);\n\nexport const queriesPatchSchema = v.array(patchOpSchema);\nexport const upQueriesPatchSchema = v.array(upPatchOpSchema);\n\nexport type QueriesPutOp = v.Infer<typeof putOpSchema>;\nexport type QueriesDelOp = v.Infer<typeof delOpSchema>;\nexport type QueriesClearOp = v.Infer<typeof clearOpSchema>;\nexport type QueriesPatchOp = v.Infer<typeof patchOpSchema>;\nexport type UpQueriesPatchOp = v.Infer<typeof upPatchOpSchema>;\nexport type QueriesPatch = v.Infer<typeof queriesPatchSchema>;\nexport type UpQueriesPatch = v.Infer<typeof upQueriesPatchSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {clientSchemaSchema} from './client-schema.ts';\nimport {deleteClientsBodySchema} from './delete-clients.ts';\nimport {upQueriesPatchSchema} from './queries-patch.ts';\n\n/**\n * After opening a websocket the client waits for a `connected` message\n * from the server.  It then sends an `initConnection` message to the\n * server.  The server waits for the `initConnection` message before\n * beginning to send pokes to the newly connected client, so as to avoid\n * syncing lots of queries which are no longer desired by the client.\n */\n\nexport const connectedBodySchema = v.object({\n  wsid: v.string(),\n  timestamp: v.number().optional(),\n});\n\nexport const connectedMessageSchema = v.tuple([\n  v.literal('connected'),\n  connectedBodySchema,\n]);\n\nconst userQueryMutateParamsSchema = v.object({\n  /**\n   * A client driven URL to send queries or mutations to.\n   * This URL must match one of the URLs set in the zero config.\n   *\n   * E.g., Given the following environment variable:\n   * ZERO_GET_QUERIES_URL=[https://*.example.com/query]\n   *\n   * Then this URL could be:\n   * https://myapp.example.com/query\n   */\n  url: v.string().optional(),\n  // The query string to use for query or mutation calls.\n  queryParams: v.record(v.string()).optional(),\n});\n\nconst initConnectionBodySchema = v.object({\n  desiredQueriesPatch: upQueriesPatchSchema,\n  clientSchema: clientSchemaSchema.optional(),\n  deleted: deleteClientsBodySchema.optional(),\n  // parameters to configure the mutate endpoint\n  userPushParams: userQueryMutateParamsSchema.optional(),\n  // parameters to configure the query endpoint\n  userQueryParams: userQueryMutateParamsSchema.optional(),\n\n  /**\n   * `activeClients` is an optional array of client IDs that are currently active\n   * in the client group. This is used to inform the server about the clients\n   * that are currently active (aka running, aka alive), so it can inactive\n   * queries from inactive clients.\n   */\n  activeClients: v.array(v.string()).optional(),\n});\n\nexport const initConnectionMessageSchema = v.tuple([\n  v.literal('initConnection'),\n  initConnectionBodySchema,\n]);\n\nexport type ConnectedBody = v.Infer<typeof connectedBodySchema>;\nexport type ConnectedMessage = v.Infer<typeof connectedMessageSchema>;\nexport type UserMutateParams = v.Infer<typeof userQueryMutateParamsSchema>;\nexport type UserQueryParams = v.Infer<typeof userQueryMutateParamsSchema>;\n\nexport type InitConnectionBody = v.Infer<typeof initConnectionBodySchema>;\nexport type InitConnectionMessage = v.Infer<typeof initConnectionMessageSchema>;\n\nexport function encodeSecProtocols(\n  initConnectionMessage: InitConnectionMessage | undefined,\n  authToken: string | undefined,\n): string {\n  const protocols = {\n    initConnectionMessage,\n    authToken,\n  };\n  // WS sec protocols needs to be URI encoded. To save space, we base64 encode\n  // the JSON before URI encoding it. But InitConnectionMessage can contain\n  // arbitrary unicode strings, so we need to encode the JSON as UTF-8 first.\n  // Phew!\n  const bytes = new TextEncoder().encode(JSON.stringify(protocols));\n\n  // Convert bytes to string without spreading all bytes as arguments\n  // to avoid \"Maximum call stack size exceeded\" error with large data\n  const s = Array.from(bytes, byte => String.fromCharCode(byte)).join('');\n\n  return encodeURIComponent(btoa(s));\n}\n\nexport function decodeSecProtocols(secProtocol: string): {\n  initConnectionMessage: InitConnectionMessage | undefined;\n  authToken: string | undefined;\n} {\n  const binString = atob(decodeURIComponent(secProtocol));\n  const bytes = Uint8Array.from(binString, c => c.charCodeAt(0));\n  return JSON.parse(new TextDecoder().decode(bytes));\n}\n","import * as v from '../../shared/src/valita.ts';\nimport {ErrorKind} from './error-kind.ts';\n\nconst basicErrorKindSchema = v.literalUnion(\n  ErrorKind.AuthInvalidated,\n  ErrorKind.ClientNotFound,\n  ErrorKind.InvalidConnectionRequest,\n  ErrorKind.InvalidConnectionRequestBaseCookie,\n  ErrorKind.InvalidConnectionRequestLastMutationID,\n  ErrorKind.InvalidConnectionRequestClientDeleted,\n  ErrorKind.InvalidMessage,\n  ErrorKind.InvalidPush,\n  ErrorKind.MutationRateLimited,\n  ErrorKind.MutationFailed,\n  ErrorKind.Unauthorized,\n  ErrorKind.VersionNotSupported,\n  ErrorKind.SchemaVersionNotSupported,\n  ErrorKind.Internal,\n);\n\nconst basicErrorBodySchema = v.object({\n  kind: basicErrorKindSchema,\n  message: v.string(),\n});\n\nconst backoffErrorKindSchema = v.literalUnion(\n  ErrorKind.Rebalance,\n  ErrorKind.Rehome,\n  ErrorKind.ServerOverloaded,\n);\n\nconst backoffBodySchema = v.object({\n  kind: backoffErrorKindSchema,\n  message: v.string(),\n  minBackoffMs: v.number().optional(),\n  maxBackoffMs: v.number().optional(),\n  // Query parameters to send in the next reconnect. In the event of\n  // a conflict, these will be overridden by the parameters used by\n  // the client; it is the responsibility of the server to avoid\n  // parameter name conflicts.\n  //\n  // The parameters will only be added to the immediately following\n  // reconnect, and not after that.\n  reconnectParams: v.record(v.string()).optional(),\n});\n\nexport const errorKindSchema: v.Type<ErrorKind> = v.union(\n  basicErrorKindSchema,\n  backoffErrorKindSchema,\n);\n\nexport const errorBodySchema = v.union(basicErrorBodySchema, backoffBodySchema);\n\nexport type BackoffBody = v.Infer<typeof backoffBodySchema>;\n\nexport type ErrorBody = v.Infer<typeof errorBodySchema>;\n\nexport const errorMessageSchema: v.Type<ErrorMessage> = v.tuple([\n  v.literal('error'),\n  errorBodySchema,\n]);\n\nexport type ErrorMessage = ['error', ErrorBody];\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const CRUD = 'crud';\nexport const Custom = 'custom';\nexport type MutationType = typeof CRUD | typeof Custom;\n\nexport type CRUD = typeof CRUD;\nexport type Custom = typeof Custom;\n","import {jsonSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport type {NameMapper} from '../../zero-schema/src/name-mapper.ts';\nimport {rowSchema} from './data.ts';\nimport * as MutationType from './mutation-type-enum.ts';\nimport {primaryKeySchema, primaryKeyValueRecordSchema} from './primary-key.ts';\n\n// NOTE! If you change this name you must also change the\n// string in `replicache-impl.ts` But CRUD mutators are being\n// deleted soon so this should not happen.\nexport const CRUD_MUTATION_NAME = '_zero_crud';\n\n/**\n * Inserts if entity with id does not already exist.\n */\nconst insertOpSchema = v.object({\n  op: v.literal('insert'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  value: rowSchema,\n});\n\n/**\n * Upsert semantics. Inserts if entity with id does not already exist,\n * otherwise updates existing entity with id.\n */\nconst upsertOpSchema = v.object({\n  op: v.literal('upsert'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  value: rowSchema,\n});\n\n/**\n * Updates if entity with id exists, otherwise does nothing.\n */\nconst updateOpSchema = v.object({\n  op: v.literal('update'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  // Partial value with at least the primary key fields\n  value: rowSchema,\n});\n\n/**\n * Deletes entity with id if it exists, otherwise does nothing.\n */\nconst deleteOpSchema = v.object({\n  op: v.literal('delete'),\n  tableName: v.string(),\n  primaryKey: primaryKeySchema,\n  // Partial value representing the primary key\n  value: primaryKeyValueRecordSchema,\n});\n\nconst crudOpSchema = v.union(\n  insertOpSchema,\n  upsertOpSchema,\n  updateOpSchema,\n  deleteOpSchema,\n);\n\nconst crudArgSchema = v.object({\n  ops: v.array(crudOpSchema),\n});\n\nconst crudArgsSchema = v.tuple([crudArgSchema]);\n\nexport const crudMutationSchema = v.object({\n  type: v.literal(MutationType.CRUD),\n  id: v.number(),\n  clientID: v.string(),\n  name: v.literal(CRUD_MUTATION_NAME),\n  args: crudArgsSchema,\n  timestamp: v.number(),\n});\n\nexport const customMutationSchema = v.object({\n  type: v.literal(MutationType.Custom),\n  id: v.number(),\n  clientID: v.string(),\n  name: v.string(),\n  args: v.array(jsonSchema),\n  timestamp: v.number(),\n});\n\nexport const mutationSchema = v.union(crudMutationSchema, customMutationSchema);\n\nexport const pushBodySchema = v.object({\n  clientGroupID: v.string(),\n  mutations: v.array(mutationSchema),\n  pushVersion: v.number(),\n  // For legacy (CRUD) mutations, the schema is tied to the client group /\n  // sync connection. For custom mutations, schema versioning is delegated\n  // to the custom protocol / api-server.\n  schemaVersion: v.number().optional(),\n  timestamp: v.number(),\n  requestID: v.string(),\n});\n\nexport const pushMessageSchema = v.tuple([v.literal('push'), pushBodySchema]);\nexport const mutationIDSchema = v.object({\n  id: v.number(),\n  clientID: v.string(),\n});\n\nconst appErrorSchema = v.object({\n  error: v.literal('app'),\n  // The user can return any additional data here\n  details: jsonSchema.optional(),\n});\nconst zeroErrorSchema = v.object({\n  error: v.literalUnion('oooMutation', 'alreadyProcessed'),\n  details: jsonSchema.optional(),\n});\n\nconst mutationOkSchema = v.object({\n  // The user can return any additional data here\n  data: jsonSchema.optional(),\n});\nconst mutationErrorSchema = v.union(appErrorSchema, zeroErrorSchema);\n\nexport const mutationResultSchema = v.union(\n  mutationOkSchema,\n  mutationErrorSchema,\n);\n\nexport const mutationResponseSchema = v.object({\n  id: mutationIDSchema,\n  result: mutationResultSchema,\n});\n\nconst pushOkSchema = v.object({\n  mutations: v.array(mutationResponseSchema),\n});\n\nconst unsupportedPushVersionSchema = v.object({\n  error: v.literal('unsupportedPushVersion'),\n  // optional for backwards compatibility\n  // This field is included so the client knows which mutations\n  // were not processed by the server.\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\nconst unsupportedSchemaVersionSchema = v.object({\n  error: v.literal('unsupportedSchemaVersion'),\n  // optional for backwards compatibility\n  // This field is included so the client knows which mutations\n  // were not processed by the server.\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\nconst httpErrorSchema = v.object({\n  error: v.literal('http'),\n  status: v.number(),\n  details: v.string(),\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\nconst zeroPusherErrorSchema = v.object({\n  error: v.literal('zeroPusher'),\n  details: v.string(),\n  mutationIDs: v.array(mutationIDSchema).optional(),\n});\n\nconst pushErrorSchema = v.union(\n  unsupportedPushVersionSchema,\n  unsupportedSchemaVersionSchema,\n  httpErrorSchema,\n  zeroPusherErrorSchema,\n);\n\nexport const pushResponseSchema = v.union(pushOkSchema, pushErrorSchema);\nexport const pushResponseMessageSchema = v.tuple([\n  v.literal('pushResponse'),\n  pushResponseSchema,\n]);\n\nexport const ackMutationResponsesMessageSchema = v.tuple([\n  v.literal('ackMutationResponses'),\n  mutationIDSchema,\n]);\n\n/**\n * The schema for the querystring parameters of the custom push endpoint.\n */\nexport const pushParamsSchema = v.object({\n  schema: v.string(),\n  appID: v.string(),\n});\n\nexport type InsertOp = v.Infer<typeof insertOpSchema>;\nexport type UpsertOp = v.Infer<typeof upsertOpSchema>;\nexport type UpdateOp = v.Infer<typeof updateOpSchema>;\nexport type DeleteOp = v.Infer<typeof deleteOpSchema>;\nexport type CRUDOp = v.Infer<typeof crudOpSchema>;\nexport type CRUDOpKind = CRUDOp['op'];\nexport type CRUDMutationArg = v.Infer<typeof crudArgSchema>;\nexport type CRUDMutation = v.Infer<typeof crudMutationSchema>;\nexport type CustomMutation = v.Infer<typeof customMutationSchema>;\nexport type Mutation = v.Infer<typeof mutationSchema>;\nexport type PushBody = v.Infer<typeof pushBodySchema>;\nexport type PushMessage = v.Infer<typeof pushMessageSchema>;\nexport type PushResponse = v.Infer<typeof pushResponseSchema>;\nexport type PushResponseMessage = v.Infer<typeof pushResponseMessageSchema>;\nexport type MutationResponse = v.Infer<typeof mutationResponseSchema>;\nexport type MutationOk = v.Infer<typeof mutationOkSchema>;\nexport type MutationError = v.Infer<typeof mutationErrorSchema>;\nexport type PushError = v.Infer<typeof pushErrorSchema>;\nexport type PushOk = v.Infer<typeof pushOkSchema>;\nexport type MutationID = v.Infer<typeof mutationIDSchema>;\nexport type MutationResult = v.Infer<typeof mutationResultSchema>;\nexport type AckMutationMessage = v.Infer<\n  typeof ackMutationResponsesMessageSchema\n>;\n\nexport function mapCRUD(\n  arg: CRUDMutationArg,\n  map: NameMapper,\n): CRUDMutationArg {\n  return {\n    ops: arg.ops.map(\n      ({op, tableName, primaryKey, value}) =>\n        ({\n          op,\n          tableName: map.tableName(tableName),\n          primaryKey: map.columns(tableName, primaryKey),\n          value: map.row(tableName, value),\n          // The cast is necessary because ts objects to the `value` field\n          // for \"delete\" ops being different.\n        }) as unknown as CRUDOp,\n    ),\n  };\n}\n","import * as v from '../../shared/src/valita.ts';\nimport {mutationIDSchema, mutationResponseSchema} from './push.ts';\n\n/**\n * Mutation results are stored ephemerally in the client\n * hence why we only have the `put` operation.\n *\n * On put the mutation promise is resolved/rejected\n * and reference released.\n */\nexport const putOpSchema = v.object({\n  op: v.literal('put'),\n  mutation: mutationResponseSchema,\n});\nexport const delOpSchema = v.object({\n  op: v.literal('del'),\n  id: mutationIDSchema,\n});\n\nconst patchOpSchema = v.union(putOpSchema, delOpSchema);\nexport const mutationsPatchSchema = v.array(patchOpSchema);\nexport type MutationPatch = v.Infer<typeof patchOpSchema>;\n","import {jsonObjectSchema} from '../../shared/src/json-schema.ts';\nimport * as v from '../../shared/src/valita.ts';\nimport {rowSchema} from './data.ts';\nimport {primaryKeyValueRecordSchema} from './primary-key.ts';\n\nconst putOpSchema = v.object({\n  op: v.literal('put'),\n  tableName: v.string(),\n  value: rowSchema,\n});\n\nconst updateOpSchema = v.object({\n  op: v.literal('update'),\n  tableName: v.string(),\n  id: primaryKeyValueRecordSchema,\n  merge: jsonObjectSchema.optional(),\n  constrain: v.array(v.string()).optional(),\n});\n\nconst delOpSchema = v.object({\n  op: v.literal('del'),\n  tableName: v.string(),\n  id: primaryKeyValueRecordSchema,\n});\n\nconst clearOpSchema = v.object({\n  op: v.literal('clear'),\n});\n\nconst rowPatchOpSchema = v.union(\n  putOpSchema,\n  updateOpSchema,\n  delOpSchema,\n  clearOpSchema,\n);\n\nexport const rowsPatchSchema = v.array(rowPatchOpSchema);\nexport type RowPatchOp = v.Infer<typeof rowPatchOpSchema>;\n","import * as v from '../../shared/src/valita.ts';\n\nexport const versionSchema = v.string();\nexport const nullableVersionSchema = v.union(versionSchema, v.null());\n\nexport type Version = v.Infer<typeof versionSchema>;\nexport type NullableVersion = v.Infer<typeof nullableVersionSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {mutationsPatchSchema} from './mutations-patch.ts';\nimport {queriesPatchSchema} from './queries-patch.ts';\nimport {rowsPatchSchema} from './row-patch.ts';\nimport {nullableVersionSchema, versionSchema} from './version.ts';\n\n/**\n * Pokes use a multi-part format. Pokes send entity data to the client and can\n * be multiple mega-bytes in size. Using a multi-part format allows the server\n * to avoid having to have the full poke in memory at one time.\n *\n * Each poke is assigned a `pokeID`, a unique id (within the context of the\n * connection) for identifying the poke.  All messages for a poke will have the\n * same `pokeID`.\n *\n * A poke begins with a `poke-start` message which contains the `baseCookie`\n * the poke is updating from and the `cookie` the poke is updating to.\n *\n * The poke continues with zero to many `poke-part` messages, each of which\n * can contain patch parts.  These patch parts should be merged in the order\n * received.\n *\n * Finally, the poke ends with a `poke-end` message.  The merged `poke-parts`\n * can now be applied as a whole to update from `baseCookie` to `cookie`.\n *\n * Poke messages can be intermingled with other `down` messages, but cannot be\n * intermingled with poke messages for a different `pokeID`. If this is\n * observed it is an unexpected error; the client should ignore both pokes,\n * disconnect, and reconnect.\n */\n\nexport const pokeStartBodySchema = v.object({\n  pokeID: v.string(),\n  // We always specify a Version as our cookie, but Replicache starts clients\n  // with initial cookie `null`, before the first request. So we have to be\n  // able to send a base cookie with value `null` to match that state.\n  baseCookie: nullableVersionSchema,\n  /**\n   * This field is always set if the poke contains a `rowsPatch`.\n   * It may be absent for patches that only update clients and queries.\n   */\n  schemaVersions: v\n    .object({\n      minSupportedVersion: v.number(),\n      maxSupportedVersion: v.number(),\n    })\n    .optional(),\n  timestamp: v.number().optional(),\n});\n\nexport const pokePartBodySchema = v.object({\n  pokeID: v.string(),\n  // Changes to last mutation id by client id.\n  lastMutationIDChanges: v.record(v.number()).optional(),\n  // Patches to the desired query sets by client id.\n  desiredQueriesPatches: v.record(queriesPatchSchema).optional(),\n  // Patches to the set of queries for which entities are sync'd in\n  // rowsPatch.\n  gotQueriesPatch: queriesPatchSchema.optional(),\n  // Patches to the rows set.\n  rowsPatch: rowsPatchSchema.optional(),\n  // Mutation results patch\n  mutationsPatch: mutationsPatchSchema.optional(),\n});\n\nexport const pokeEndBodySchema = v.object({\n  pokeID: v.string(),\n  // Note: This should be ignored (and may be empty) if cancel === `true`.\n  cookie: versionSchema,\n  // If `true`, the poke with id `pokeID` should be discarded without\n  // applying it.\n  cancel: v.boolean().optional(),\n});\n\nexport const pokeStartMessageSchema = v.tuple([\n  v.literal('pokeStart'),\n  pokeStartBodySchema,\n]);\nexport const pokePartMessageSchema = v.tuple([\n  v.literal('pokePart'),\n  pokePartBodySchema,\n]);\nexport const pokeEndMessageSchema = v.tuple([\n  v.literal('pokeEnd'),\n  pokeEndBodySchema,\n]);\n\nexport type PokeStartBody = v.Infer<typeof pokeStartBodySchema>;\nexport type PokePartBody = v.Infer<typeof pokePartBodySchema>;\nexport type PokeEndBody = v.Infer<typeof pokeEndBodySchema>;\n\nexport type PokeStartMessage = v.Infer<typeof pokeStartMessageSchema>;\nexport type PokePartMessage = v.Infer<typeof pokePartMessageSchema>;\nexport type PokeEndMessage = v.Infer<typeof pokeEndMessageSchema>;\n","import * as v from '../../shared/src/valita.ts';\n\nexport const pongBodySchema = v.object({});\nexport const pongMessageSchema = v.tuple([v.literal('pong'), pongBodySchema]);\n\nexport type PongBody = v.Infer<typeof pongBodySchema>;\nexport type PongMessage = v.Infer<typeof pongMessageSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {nullableVersionSchema, versionSchema} from './version.ts';\n\nexport const pullRequestBodySchema = v.object({\n  clientGroupID: v.string(),\n  cookie: nullableVersionSchema,\n  requestID: v.string(),\n});\n\nexport const pullResponseBodySchema = v.object({\n  cookie: versionSchema,\n  // Matches pullRequestBodySchema requestID that initiated this response\n  requestID: v.string(),\n  lastMutationIDChanges: v.record(v.number()),\n  // Pull is currently only used for mutation recovery which does not use\n  // the patch so we save work by not computing the patch.\n});\n\nexport const pullRequestMessageSchema = v.tuple([\n  v.literal('pull'),\n  pullRequestBodySchema,\n]);\n\nexport const pullResponseMessageSchema = v.tuple([\n  v.literal('pull'),\n  pullResponseBodySchema,\n]);\n\nexport type PullRequestBody = v.Infer<typeof pullRequestBodySchema>;\nexport type PullResponseBody = v.Infer<typeof pullResponseBodySchema>;\n\nexport type PullRequestMessage = v.Infer<typeof pullRequestMessageSchema>;\nexport type PullResponseMessage = v.Infer<typeof pullResponseMessageSchema>;\n","import * as v from '../../shared/src/valita.ts';\nimport {connectedMessageSchema} from './connect.ts';\nimport {transformErrorMessageSchema} from './custom-queries.ts';\nimport {deleteClientsMessageSchema} from './delete-clients.ts';\nimport {errorMessageSchema} from './error.ts';\nimport {inspectDownMessageSchema} from './inspect-down.ts';\nimport {\n  pokeEndMessageSchema,\n  pokePartMessageSchema,\n  pokeStartMessageSchema,\n} from './poke.ts';\nimport {pongMessageSchema} from './pong.ts';\nimport {pullResponseMessageSchema} from './pull.ts';\nimport {pushResponseMessageSchema} from './push.ts';\n\nexport const downstreamSchema = v.union(\n  connectedMessageSchema,\n  errorMessageSchema,\n  pongMessageSchema,\n  pokeStartMessageSchema,\n  pokePartMessageSchema,\n  pokeEndMessageSchema,\n  pullResponseMessageSchema,\n  deleteClientsMessageSchema,\n  pushResponseMessageSchema,\n  inspectDownMessageSchema,\n  transformErrorMessageSchema,\n);\n\nexport type Downstream = v.Infer<typeof downstreamSchema>;\n","import {assert} from '../../shared/src/asserts.ts';\n\n/**\n * The current `PROTOCOL_VERSION` of the code.\n *\n * The `PROTOCOL_VERSION` encompasses both the wire-protocol of the `/sync/...`\n * connection between the browser and `zero-cache`, as well as the format of\n * the `AST` objects stored in both components (i.e. IDB and CVR).\n *\n * A change in the `AST` schema (e.g. new functionality added) must be\n * accompanied by an increment of the `PROTOCOL_VERSION` and a new major\n * release. The server (`zero-cache`) must be deployed before clients start\n * running the new code.\n */\n// History:\n// -- Version 5 adds support for `pokeEnd.cookie`. (0.14)\n// -- Version 6 makes `pokeStart.cookie` optional. (0.16)\n// -- Version 7 introduces the initConnection.clientSchema field. (0.17)\n// -- Version 8 drops support for Version 5 (0.18).\n// -- Version 11 adds inspect queries. (0.18)\n// -- Version 12 adds 'timestamp' and 'date' types to the ClientSchema ValueType. (not shipped, reversed by version 14)\n// -- Version 14 removes 'timestamp' and 'date' types from the ClientSchema ValueType. (0.18)\n// -- Version 15 adds a `userPushParams` field to `initConnection` (0.19)\n// -- Version 16 adds a new error type (alreadyProcessed) to mutation responses (0.19)\n// -- Version 17 deprecates `AST` in downstream query puts. It was never used anyway. (0.21)\n// -- Version 18 adds `name` and `args` to the `queries-patch` protocol (0.21)\n// -- Version 19 adds `activeClients` to the `initConnection` protocol (0.22)\n// -- Version 20 changes inspector down message (0.22)\n// -- Version 21 removes `AST` in downstream query puts which was deprecated in Version 17, removes support for versions < 18 (0.22)\n// -- Version 22 adds an optional 'userQueryParams' field to `initConnection` (0.22)\n// -- Version 23 add `mutationResults` to poke (0.22)\n// -- Version 24 adds `ackMutationResults` to upstream (0.22).\n// -- version 25 modifies `mutationsResults` to include `del` patches (0.22)\n// -- version 26 adds inspect/metrics and adds metrics to inspect/query (0.23)\n// -- version 27 adds inspect/version (0.23)\n// -- version 28 adds more inspect/metrics (0.23)\n// -- version 29 adds error responses for custom queries (0.23)\nexport const PROTOCOL_VERSION = 29;\n\n/**\n * The minimum server-supported sync protocol version (i.e. the version\n * declared in the \"/sync/v{#}/connect\" URL). The contract for\n * backwards compatibility is that a `zero-cache` supports the current\n * `PROTOCOL_VERSION` and at least the previous one (i.e. `PROTOCOL_VERSION - 1`)\n * if not earlier ones as well. This corresponds to supporting clients running\n * the current release and the previous (major) release. Any client connections\n * from protocol versions before `MIN_SERVER_SUPPORTED_PROTOCOL_VERSION` are\n * closed with a `VersionNotSupported` error.\n */\nexport const MIN_SERVER_SUPPORTED_SYNC_PROTOCOL = 18;\n\nassert(MIN_SERVER_SUPPORTED_SYNC_PROTOCOL < PROTOCOL_VERSION);\n","import type {JSONValue} from '../../shared/src/json.ts';\nimport type {Value} from '../../zero-protocol/src/data.ts';\nimport type {TableSchema} from './table-schema.ts';\n\ntype ColumnNames = {[src: string]: string};\n\ntype DestNames = {\n  tableName: string;\n  columns: ColumnNames;\n  allColumnsSame: boolean;\n};\n\nexport function clientToServer(\n  tables: Record<string, TableSchema>,\n): NameMapper {\n  return createMapperFrom('client', tables);\n}\n\nexport function serverToClient(\n  tables: Record<string, TableSchema>,\n): NameMapper {\n  return createMapperFrom('server', tables);\n}\n\nfunction createMapperFrom(\n  src: 'client' | 'server',\n  tables: Record<string, TableSchema>,\n): NameMapper {\n  const mapping = new Map(\n    Object.entries(tables).map(\n      ([tableName, {serverName: serverTableName, columns}]) => {\n        let allColumnsSame = true;\n        const names: Record<string, string> = {};\n        for (const [name, {serverName}] of Object.entries(columns)) {\n          if (serverName && serverName !== name) {\n            allColumnsSame = false;\n          }\n          if (src === 'client') {\n            names[name] = serverName ?? name;\n          } else {\n            names[serverName ?? name] = name;\n          }\n        }\n        return [\n          src === 'client' ? tableName : (serverTableName ?? tableName),\n          {\n            tableName:\n              src === 'client' ? (serverTableName ?? tableName) : tableName,\n            columns: names,\n            allColumnsSame,\n          },\n        ];\n      },\n    ),\n  );\n  return new NameMapper(mapping);\n}\n\n/**\n * Returns an \"identity\" NameMapper that simply serves the purpose\n * of validating that all table and column names conform to the\n * specified `tablesToColumns` map.\n */\nexport function validator(tablesToColumns: Map<string, string[]>): NameMapper {\n  const identity = new Map(\n    [...tablesToColumns.entries()].map(([tableName, columns]) => [\n      tableName,\n      {\n        tableName,\n        columns: Object.fromEntries(columns.map(c => [c, c])),\n        allColumnsSame: true,\n      },\n    ]),\n  );\n  return new NameMapper(identity);\n}\n\nexport class NameMapper {\n  readonly #tables = new Map<string, DestNames>();\n\n  constructor(tables: Map<string, DestNames>) {\n    this.#tables = tables;\n  }\n\n  #getTable(src: string, ctx?: JSONValue | undefined): DestNames {\n    const table = this.#tables.get(src);\n    if (!table) {\n      throw new Error(\n        `unknown table \"${src}\" ${!ctx ? '' : `in ${JSON.stringify(ctx)}`}`,\n      );\n    }\n    return table;\n  }\n\n  tableName(src: string, context?: JSONValue): string {\n    return this.#getTable(src, context).tableName;\n  }\n\n  columnName(table: string, src: string, ctx?: JSONValue): string {\n    const dst = this.#getTable(table, ctx).columns[src];\n    if (!dst) {\n      throw new Error(\n        `unknown column \"${src}\" of \"${table}\" table ${\n          !ctx ? '' : `in ${JSON.stringify(ctx)}`\n        }`,\n      );\n    }\n    return dst;\n  }\n\n  row<V extends Value>(\n    table: string,\n    row: Readonly<Record<string, V>>,\n  ): Readonly<Record<string, V>> {\n    const dest = this.#getTable(table);\n    const {allColumnsSame, columns} = dest;\n    if (allColumnsSame) {\n      return row;\n    }\n    const clientRow: Record<string, V> = {};\n    for (const col in row) {\n      // Note: columns with unknown names simply pass through.\n      clientRow[columns[col] ?? col] = row[col];\n    }\n    return clientRow;\n  }\n\n  columns<Columns extends readonly string[] | undefined>(\n    table: string,\n    cols: Columns,\n  ): Columns {\n    const dest = this.#getTable(table);\n    const {allColumnsSame, columns} = dest;\n\n    // Note: Columns not defined in the schema simply pass through.\n    return cols === undefined || allColumnsSame\n      ? cols\n      : (cols.map(col => columns[col] ?? col) as unknown as Columns);\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport type {Expand} from '../../../shared/src/expand.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {\n  SchemaValueToTSType,\n  TableSchema,\n} from '../../../zero-schema/src/table-schema.ts';\nimport type {Query} from '../query/query.ts';\n\ntype ClientID = string;\n\nexport type Location = 'client' | 'server';\nexport type TransactionReason = 'optimistic' | 'rebase' | 'authoritative';\n\nexport interface TransactionBase<S extends Schema> {\n  readonly location: Location;\n  readonly clientID: ClientID;\n  /**\n   * The ID of the mutation that is being applied.\n   */\n  readonly mutationID: number;\n\n  /**\n   * The reason for the transaction.\n   */\n  readonly reason: TransactionReason;\n\n  readonly mutate: SchemaCRUD<S>;\n  readonly query: SchemaQuery<S>;\n}\n\nexport type Transaction<S extends Schema, TWrappedTransaction = unknown> =\n  | ServerTransaction<S, TWrappedTransaction>\n  | ClientTransaction<S>;\n\nexport interface ServerTransaction<S extends Schema, TWrappedTransaction>\n  extends TransactionBase<S> {\n  readonly location: 'server';\n  readonly reason: 'authoritative';\n  readonly dbTransaction: DBTransaction<TWrappedTransaction>;\n}\n\n/**\n * An instance of this is passed to custom mutator implementations and\n * allows reading and writing to the database and IVM at the head\n * at which the mutator is being applied.\n */\nexport interface ClientTransaction<S extends Schema>\n  extends TransactionBase<S> {\n  readonly location: 'client';\n  readonly reason: 'optimistic' | 'rebase';\n}\n\nexport interface Row {\n  [column: string]: unknown;\n}\n\nexport interface DBConnection<TWrappedTransaction> {\n  transaction: <T>(\n    cb: (tx: DBTransaction<TWrappedTransaction>) => Promise<T>,\n  ) => Promise<T>;\n}\n\nexport interface DBTransaction<T> extends Queryable {\n  readonly wrappedTransaction: T;\n}\n\ninterface Queryable {\n  query: (query: string, args: unknown[]) => Promise<Iterable<Row>>;\n}\n\nexport type SchemaCRUD<S extends Schema> = {\n  [Table in keyof S['tables']]: TableCRUD<S['tables'][Table]>;\n};\n\nexport type TableCRUD<S extends TableSchema> = {\n  /**\n   * Writes a row if a row with the same primary key doesn't already exists.\n   * Non-primary-key fields that are 'optional' can be omitted or set to\n   * `undefined`. Such fields will be assigned the value `null` optimistically\n   * and then the default value as defined by the server.\n   */\n  insert: (value: InsertValue<S>) => Promise<void>;\n\n  /**\n   * Writes a row unconditionally, overwriting any existing row with the same\n   * primary key. Non-primary-key fields that are 'optional' can be omitted or\n   * set to `undefined`. Such fields will be assigned the value `null`\n   * optimistically and then the default value as defined by the server.\n   */\n  upsert: (value: UpsertValue<S>) => Promise<void>;\n\n  /**\n   * Updates a row with the same primary key. If no such row exists, this\n   * function does nothing. All non-primary-key fields can be omitted or set to\n   * `undefined`. Such fields will be left unchanged from previous value.\n   */\n  update: (value: UpdateValue<S>) => Promise<void>;\n\n  /**\n   * Deletes the row with the specified primary key. If no such row exists, this\n   * function does nothing.\n   */\n  delete: (id: DeleteID<S>) => Promise<void>;\n};\n\nexport type SchemaQuery<S extends Schema> = {\n  readonly [K in keyof S['tables'] & string]: Query<S, K>;\n};\n\nexport type DeleteID<S extends TableSchema> = Expand<PrimaryKeyFields<S>>;\n\ntype PrimaryKeyFields<S extends TableSchema> = {\n  [K in Extract<\n    S['primaryKey'][number],\n    keyof S['columns']\n  >]: SchemaValueToTSType<S['columns'][K]>;\n};\n\nexport type InsertValue<S extends TableSchema> = Expand<\n  PrimaryKeyFields<S> & {\n    [K in keyof S['columns'] as S['columns'][K] extends {optional: true}\n      ? K\n      : never]?: SchemaValueToTSType<S['columns'][K]> | undefined;\n  } & {\n    [K in keyof S['columns'] as S['columns'][K] extends {optional: true}\n      ? never\n      : K]: SchemaValueToTSType<S['columns'][K]>;\n  }\n>;\n\nexport type UpsertValue<S extends TableSchema> = InsertValue<S>;\n\nexport type UpdateValue<S extends TableSchema> = Expand<\n  PrimaryKeyFields<S> & {\n    [K in keyof S['columns']]?:\n      | SchemaValueToTSType<S['columns'][K]>\n      | undefined;\n  }\n>;\n\nexport function customMutatorKey(namespace: string, name: string) {\n  assert(!namespace.includes('|'), 'mutator namespaces must not include a |');\n  assert(!name.includes('|'), 'mutator names must not include a |');\n  return `${namespace}|${name}`;\n}\n\nexport function splitMutatorKey(key: string) {\n  return key.split('|') as [string, string];\n}\n","import type {AST} from '../../../zero-protocol/src/ast.ts';\n\nexport type ClientMetricMap = {\n  'query-materialization-client': [queryID: string];\n  'query-materialization-end-to-end': [queryID: string, ast: AST];\n  'query-update-client': [queryID: string];\n};\n\nexport type ServerMetricMap = {\n  'query-materialization-server': [queryID: string];\n  'query-update-server': [queryID: string];\n};\n\nexport type MetricMap = ClientMetricMap & ServerMetricMap;\n\nexport interface MetricsDelegate {\n  addMetric<K extends keyof MetricMap>(\n    metric: K,\n    value: number,\n    ...args: MetricMap[K]\n  ): void;\n}\n\nexport function isClientMetric(\n  metric: keyof MetricMap,\n): metric is keyof ClientMetricMap {\n  return metric.endsWith('-client') || metric.endsWith('-end-to-end');\n}\n\nexport function isServerMetric(\n  metric: keyof MetricMap,\n): metric is keyof ServerMetricMap {\n  return metric.endsWith('-server');\n}\n","import type {Upstream} from '../../../zero-protocol/src/up.ts';\n\nexport function send(ws: WebSocket, data: Upstream) {\n  ws.send(JSON.stringify(data));\n}\n","import {resolver} from '@rocicorp/resolver';\nimport {BroadcastChannel} from '../../../shared/src/broadcast-channel.ts';\nimport {getBrowserGlobal} from '../../../shared/src/browser-env.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\n\n/**\n * The prefix for the keys used for the locks and the broadcast channels.\n */\nconst keyPrefix = 'zero-active';\n\nfunction toLockName(clientGroupID: string, clientID: string): string {\n  return `${keyPrefix}/${clientGroupID}/${clientID}`;\n}\n\nfunction toBroadcastChannelName(clientGroupID: string): string {\n  return `${keyPrefix}/${clientGroupID}`;\n}\n\nfunction fromLockName(\n  lockKey: string | undefined,\n): {clientGroupID: string; clientID: string} | undefined {\n  if (!lockKey || !lockKey.startsWith(keyPrefix)) {\n    return undefined;\n  }\n  const parts = lockKey.slice(keyPrefix.length).split('/');\n  if (parts.length !== 3) {\n    return undefined;\n  }\n  return {\n    clientGroupID: parts[1],\n    clientID: parts[2],\n  };\n}\n\nfunction ignoreAbortError(e: unknown) {\n  if (e instanceof Error && e.name === 'AbortError') {\n    // Ignore the AbortError, it is expected when the signal is aborted.\n    return;\n  }\n  throw e;\n}\n\n/**\n * A class that lists the active clients in a client group. It uses the\n * `navigator.locks` API to manage locks for each client. The class is designed\n * to be used in a browser environment where the `navigator.locks` API is\n * available.\n *\n * When navigator.locks is not available, it will return a set only containing\n * the clients in the current scripting context (window, worker, etc).\n *\n * It uses one exclusive lock per client, identified by a combination of\n * `clientGroupID` and `clientID`. Then the `query` method is used to get the\n * list of all clients that hold or are waiting for locks in the same client\n * group.\n *\n * It also tries to get a shared lock for each client in the group, so that it\n * can be notified when the exclusive lock is released. This allows the class to\n * keep track of the active clients in the group and notify when an existing\n * client is removed.\n *\n * The class also uses a `BroadcastChannel` to notify other clients in the\n * same client group when a new client is added. This allows the class to keep\n * track of the active clients in the group and notify when a new client is\n * added.\n */\nexport class ActiveClientsManager {\n  readonly clientGroupID: string;\n  readonly clientID: string;\n  readonly #resolver = resolver<void>();\n  readonly #lockManager: ClientLockManager;\n  readonly #activeClients: Set<string> = new Set();\n\n  /**\n   * A callback that is called when a client is added to the client group.\n   * It receives the client ID of the added client.\n   */\n  onAdd: ((clientID: string) => void) | undefined;\n\n  /**\n   * A callback that is called when a client is deleted from the client group.\n   * It receives the client ID of the deleted client.\n   */\n  onDelete: ((clientID: string) => void) | undefined;\n\n  /**\n   * Creates an instance of `ActiveClientsManager` for the specified client\n   * group and client ID. It will return a promise that resolves when the\n   * instance is ready to use, which means that it has successfully acquired the\n   * exclusive lock for the client and has retrieved the list of active clients.\n   */\n  static async create(\n    clientGroupID: string,\n    clientID: string,\n    signal: AbortSignal,\n  ): Promise<ActiveClientsManager> {\n    const instance = new ActiveClientsManager(clientGroupID, clientID, signal);\n    await instance.#init(signal);\n    return instance;\n  }\n\n  private constructor(\n    clientGroupID: string,\n    clientID: string,\n    signal: AbortSignal,\n  ) {\n    this.clientGroupID = clientGroupID;\n    this.clientID = clientID;\n    this.#lockManager = getClientLockManager(signal);\n    this.#activeClients.add(clientID);\n  }\n\n  async #init(signal: AbortSignal): Promise<void> {\n    const {clientGroupID, clientID} = this;\n    const name = toLockName(clientGroupID, clientID);\n\n    // The BroadcastChannel is used to notify other clients in the same client\n    // group when a new client is added. It listens for messages that contain\n    // the lock name, which is used to identify the client. When a message is\n    // received, it checks if the client belongs to the same client group and\n    // adds it to the list of active clients. It also adds a shared lock for\n    // the client, so that it can be notified when the exclusive lock is\n    // released.\n    const channel = new BroadcastChannel(toBroadcastChannelName(clientGroupID));\n    channel.addEventListener(\n      'message',\n      e => {\n        const client = fromLockName(e.data);\n        if (client?.clientGroupID === this.clientGroupID) {\n          this.#addClient(client.clientID);\n        }\n      },\n      {signal},\n    );\n\n    this.#lockManager\n      .request(name, 'exclusive', () => this.#resolver.promise)\n      .catch(ignoreAbortError);\n\n    signal.addEventListener(\n      'abort',\n      () => {\n        this.#lockManager.release(name, () => this.#resolver.resolve());\n        channel.close();\n      },\n      {once: true},\n    );\n\n    for (const clientID of await this.#getActiveClients()) {\n      if (clientID !== this.clientID) {\n        this.#addClient(clientID);\n      }\n    }\n\n    if (!signal.aborted) {\n      channel.postMessage(name);\n    }\n  }\n\n  get activeClients(): ReadonlySet<string> {\n    return this.#activeClients;\n  }\n\n  async #getActiveClients(): Promise<Set<string>> {\n    const activeClients: Set<string> = new Set();\n\n    for await (const lockName of this.#lockManager.queryExclusive()) {\n      const client = fromLockName(lockName);\n      if (client?.clientGroupID === this.clientGroupID) {\n        activeClients.add(client.clientID);\n      }\n    }\n\n    return activeClients;\n  }\n\n  /**\n   * This gets called when a new client is added to the client group.\n   *\n   * It will request a shared lock for the client, and when the exclusive lock\n   * is released, it will notify that the client has been deactivated.\n   */\n  #addSharedLockForOtherClient(clientID: string): void {\n    const name = toLockName(this.clientGroupID, clientID);\n    this.#lockManager\n      .request(name, 'shared', () => this.#removeClient(clientID))\n      .catch(ignoreAbortError);\n  }\n\n  #addClient(clientID: string): void {\n    if (!this.#activeClients.has(clientID)) {\n      this.#activeClients.add(clientID);\n      this.#addSharedLockForOtherClient(clientID);\n      this.onAdd?.(clientID);\n    }\n  }\n\n  #removeClient(clientID: string): void {\n    if (this.#activeClients.delete(clientID)) {\n      this.onDelete?.(clientID);\n    }\n  }\n}\n\nfunction getClientLockManager(signal: AbortSignal): ClientLockManager {\n  const locks = getBrowserGlobal('navigator')?.locks;\n  if (locks) {\n    return new NativeClientLockManager(locks, signal);\n  }\n  return new MockClientLockManager();\n}\n\ninterface ClientLockManager {\n  request(\n    name: string,\n    mode: 'exclusive' | 'shared',\n    fn: () => MaybePromise<void>,\n  ): Promise<void>;\n  release(name: string, fn: () => void): void;\n  queryExclusive(): AsyncIterable<string>;\n}\n\nclass NativeClientLockManager implements ClientLockManager {\n  readonly #locks: LockManager;\n  readonly #signal: AbortSignal;\n\n  constructor(locks: LockManager, signal: AbortSignal) {\n    this.#locks = locks;\n    this.#signal = signal;\n  }\n\n  request(\n    name: string,\n    mode: 'exclusive' | 'shared',\n    fn: () => Promise<void>,\n  ): Promise<void> {\n    return this.#locks.request(name, {mode, signal: this.#signal}, fn);\n  }\n\n  release(_name: string, fn: () => void): void {\n    fn();\n  }\n\n  async *queryExclusive(): AsyncIterable<string> {\n    const snapshot = await this.#locks.query();\n    for (const lock of [\n      ...(snapshot.held ?? []),\n      ...(snapshot.pending ?? []),\n    ]) {\n      if (lock.mode === 'exclusive' && lock.name) {\n        yield lock.name;\n      }\n    }\n  }\n}\n\nconst mockLockNames = new Set<string>();\n\nconst mockListeners: Set<(name: string) => void> = new Set();\n\nclass MockClientLockManager implements ClientLockManager {\n  readonly #listeners: Set<(name: string) => void> = new Set();\n\n  request(\n    name: string,\n    mode: 'exclusive' | 'shared',\n    fn: () => void | Promise<void>,\n  ): Promise<void> {\n    if (mode === 'exclusive') {\n      mockLockNames.add(name);\n    } else {\n      mode satisfies 'shared';\n\n      // For the mock locks we will add a listener that will notify us when the\n      // lock is deleted from the `allMockLocks` set.\n      const listener = (removed: string) => {\n        if (removed === name) {\n          mockListeners.delete(listener);\n          return fn();\n        }\n      };\n      mockListeners.add(listener);\n      this.#listeners.add(listener);\n    }\n    return Promise.resolve();\n  }\n\n  release(name: string, fn: () => void): void {\n    mockLockNames.delete(name);\n    for (const listener of mockListeners) {\n      listener(name);\n    }\n    for (const listener of this.#listeners) {\n      mockListeners.delete(listener);\n    }\n    fn();\n  }\n\n  async *queryExclusive(): AsyncIterable<string> {\n    yield* mockLockNames;\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const Disconnected = 0;\nexport const Connecting = 1;\nexport const Connected = 2;\n\nexport type Disconnected = typeof Disconnected;\nexport type Connecting = typeof Connecting;\nexport type Connected = typeof Connected;\n","import {compareUTF8} from 'compare-utf8';\nimport {BTreeSet} from '../../../shared/src/btree-set.ts';\nimport type {JSONValue} from '../../../shared/src/json.ts';\nimport type {Storage} from './operator.ts';\nimport type {Stream} from './stream.ts';\n\ntype Entry = [key: string, value: JSONValue];\n\nfunction comparator(a: Entry, b: Entry): number {\n  return compareUTF8(a[0], b[0]);\n}\n\n/**\n * MemoryStorage is a simple in-memory implementation of `Storage` for use\n * on the client and in tests.\n */\nexport class MemoryStorage implements Storage {\n  #data: BTreeSet<Entry> = new BTreeSet(comparator);\n\n  set(key: string, value: JSONValue) {\n    this.#data.add([key, value]);\n  }\n\n  get(key: string, def?: JSONValue): JSONValue | undefined {\n    const r = this.#data.get([key, null]);\n    if (r !== undefined) {\n      return r[1];\n    }\n    return def;\n  }\n\n  del(key: string) {\n    this.#data.delete([key, null]);\n  }\n\n  *scan(options?: {prefix: string}): Stream<[string, JSONValue]> {\n    for (const entry of this.#data.valuesFrom(\n      options && [options.prefix, null],\n    )) {\n      if (options && !entry[0].startsWith(options.prefix)) {\n        return;\n      }\n      yield entry;\n    }\n  }\n\n  cloneData(): Record<string, JSONValue> {\n    return structuredClone(Object.fromEntries(this.#data.values()));\n  }\n}\n","import {assert} from './asserts.ts';\n\nconst MAX_NODE_SIZE = 32;\n\ntype Comparator<K> = (a: K, b: K) => number;\nexport class BTreeSet<K> {\n  #root: BNode<K> = emptyLeaf as BNode<K>;\n  size: number = 0;\n\n  readonly comparator: Comparator<K>;\n\n  constructor(comparator: Comparator<K>, entries?: IterableIterator<K>) {\n    this.comparator = comparator;\n    if (entries) {\n      for (const key of entries) {\n        this.add(key);\n      }\n    }\n  }\n\n  /** Releases the tree so that its size is 0. */\n  clear() {\n    this.#root = emptyLeaf as BNode<K>;\n    this.size = 0;\n  }\n\n  clone() {\n    this.#root.isShared = true;\n    const ret = new BTreeSet<K>(this.comparator);\n    ret.#root = this.#root;\n    ret.size = this.size;\n    return ret;\n  }\n\n  get(key: K): K | undefined {\n    return this.#root.get(key, this);\n  }\n\n  add(key: K): this {\n    if (this.#root.isShared) this.#root = this.#root.clone();\n    const result = this.#root.set(key, this);\n    if (result === null) return this;\n    // Root node has split, so create a new root node.\n    this.#root = new BNodeInternal<K>([this.#root, result]);\n    return this;\n  }\n\n  /**\n   * Returns true if the key exists in the B+ tree, false if not.\n   * Use get() for best performance; use has() if you need to\n   * distinguish between \"undefined value\" and \"key not present\".\n   * @param key Key to detect\n   * @description Computational complexity: O(log size)\n   */\n  has(key: K): boolean {\n    return this.#root.has(key, this);\n  }\n\n  /**\n   * Removes a single key-value pair from the B+ tree.\n   * @param key Key to find\n   * @returns true if a pair was found and removed, false otherwise.\n   * @description Computational complexity: O(log size)\n   */\n  delete(key: K): boolean {\n    return this.#delete(key);\n  }\n\n  #delete(key: K): boolean {\n    let root = this.#root;\n    if (root.isShared) {\n      this.#root = root = root.clone();\n    }\n    try {\n      return root.delete(key, this);\n    } finally {\n      let isShared;\n      while (root.keys.length <= 1 && root.isInternal()) {\n        isShared ||= root.isShared;\n        this.#root = root =\n          root.keys.length === 0 ? emptyLeaf : root.children[0];\n      }\n      // If any ancestor of the new root was shared, the new root must also be shared\n      if (isShared) {\n        root.isShared = true;\n      }\n    }\n  }\n\n  keys(): IterableIterator<K> {\n    return valuesFrom(this.#root, this.comparator, undefined, true);\n  }\n\n  values(): IterableIterator<K> {\n    return valuesFrom(this.#root, this.comparator, undefined, true);\n  }\n\n  valuesFrom(lowestKey?: K, inclusive: boolean = true): IterableIterator<K> {\n    return valuesFrom(this.#root, this.comparator, lowestKey, inclusive);\n  }\n\n  valuesReversed(): IterableIterator<K> {\n    return valuesFromReversed(\n      this.#maxKey(),\n      this.#root,\n      this.comparator,\n      undefined,\n      true,\n    );\n  }\n\n  valuesFromReversed(\n    highestKey?: K,\n    inclusive: boolean = true,\n  ): IterableIterator<K> {\n    return valuesFromReversed(\n      this.#maxKey(),\n      this.#root,\n      this.comparator,\n      highestKey,\n      inclusive,\n    );\n  }\n\n  /** Gets the highest key in the tree. Complexity: O(1) */\n  #maxKey(): K | undefined {\n    return this.#root.maxKey();\n  }\n\n  [Symbol.iterator](): IterableIterator<K> {\n    return this.keys();\n  }\n}\n\nfunction valuesFrom<K>(\n  root: BNode<K>,\n  comparator: Comparator<K>,\n  lowestKey: K | undefined,\n  inclusive: boolean,\n): IterableIterator<K> {\n  const info = findPath(lowestKey, root, comparator);\n  if (info === undefined) {\n    return iterator<K>(() => ({done: true, value: undefined}));\n  }\n\n  // eslint-disable-next-line prefer-const\n  let [nodeQueue, nodeIndex, leaf] = info;\n  let i =\n    lowestKey === undefined\n      ? -1\n      : indexOf(lowestKey, leaf.keys, 0, comparator) - 1;\n\n  if (\n    !inclusive &&\n    i < leaf.keys.length &&\n    // +1 because we did -1 above.\n    comparator(leaf.keys[i + 1], lowestKey!) === 0\n  ) {\n    i++;\n  }\n\n  return iterator<K>(() => {\n    for (;;) {\n      if (++i < leaf.keys.length) {\n        return {done: false, value: leaf.keys[i]};\n      }\n\n      let level = -1;\n      for (;;) {\n        if (++level >= nodeQueue.length) {\n          return {done: true, value: undefined};\n        }\n        if (++nodeIndex[level] < nodeQueue[level].length) {\n          break;\n        }\n      }\n      for (; level > 0; level--) {\n        nodeQueue[level - 1] = (\n          nodeQueue[level][nodeIndex[level]] as BNodeInternal<K>\n        ).children;\n        nodeIndex[level - 1] = 0;\n      }\n      leaf = nodeQueue[0][nodeIndex[0]];\n      i = -1;\n    }\n  });\n}\n\nfunction valuesFromReversed<K>(\n  maxKey: K | undefined,\n  root: BNode<K>,\n  comparator: Comparator<K>,\n  highestKey: K | undefined,\n  inclusive: boolean,\n): IterableIterator<K> {\n  if (highestKey === undefined) {\n    highestKey = maxKey;\n    if (highestKey === undefined)\n      return iterator<K>(() => ({done: true, value: undefined})); // collection is empty\n  }\n  // eslint-disable-next-line prefer-const\n  let [nodeQueue, nodeIndex, leaf] =\n    findPath(highestKey, root, comparator) ||\n    findPath(maxKey, root, comparator)!;\n  assert(!nodeQueue[0] || leaf === nodeQueue[0][nodeIndex[0]]);\n  let i = indexOf(highestKey, leaf.keys, 0, comparator);\n  if (\n    inclusive &&\n    i < leaf.keys.length &&\n    comparator(leaf.keys[i], highestKey) <= 0\n  ) {\n    i++;\n  }\n\n  return iterator<K>(() => {\n    for (;;) {\n      if (--i >= 0) {\n        return {done: false, value: leaf.keys[i]};\n      }\n\n      let level;\n      // Advance to the next leaf node\n      for (level = -1; ; ) {\n        if (++level >= nodeQueue.length) {\n          return {done: true, value: undefined};\n        }\n        if (--nodeIndex[level] >= 0) {\n          break;\n        }\n      }\n      for (; level > 0; level--) {\n        nodeQueue[level - 1] = (\n          nodeQueue[level][nodeIndex[level]] as BNodeInternal<K>\n        ).children;\n        nodeIndex[level - 1] = nodeQueue[level - 1].length - 1;\n      }\n      leaf = nodeQueue[0][nodeIndex[0]];\n      i = leaf.keys.length;\n    }\n  });\n}\n\nfunction findPath<K>(\n  key: K | undefined,\n  root: BNode<K>,\n  comparator: Comparator<K>,\n): [nodeQueue: BNode<K>[][], nodeIndex: number[], leaf: BNode<K>] | undefined {\n  let nextNode = root;\n  const nodeQueue: BNode<K>[][] = [];\n  const nodeIndex: number[] = [];\n\n  if (nextNode.isInternal()) {\n    for (let d = 0; nextNode.isInternal(); d++) {\n      nodeQueue[d] = nextNode.children;\n      nodeIndex[d] =\n        key === undefined ? 0 : indexOf(key, nextNode.keys, 0, comparator);\n      if (nodeIndex[d] >= nodeQueue[d].length) return; // first key > maxKey()\n      nextNode = nodeQueue[d][nodeIndex[d]];\n    }\n    nodeQueue.reverse();\n    nodeIndex.reverse();\n  }\n  return [nodeQueue, nodeIndex, nextNode];\n}\n\nfunction iterator<T>(next: () => IteratorResult<T>): IterableIterator<T> {\n  return {\n    next,\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\n/** Leaf node / base class. **************************************************/\nclass BNode<K> {\n  // If this is an internal node, _keys[i] is the highest key in children[i].\n  keys: K[];\n  // True if this node might be within multiple `BTree`s (or have multiple parents).\n  // If so, it must be cloned before being mutated to avoid changing an unrelated tree.\n  // This is transitive: if it's true, children are also shared even if `isShared!=true`\n  // in those children. (Certain operations will propagate isShared=true to children.)\n  isShared: true | undefined;\n\n  constructor(keys: K[]) {\n    this.keys = keys;\n    this.isShared = undefined;\n  }\n\n  isInternal(): this is BNodeInternal<K> {\n    return false;\n  }\n\n  maxKey() {\n    return this.keys[this.keys.length - 1];\n  }\n\n  minKey(): K | undefined {\n    return this.keys[0];\n  }\n\n  clone(): BNode<K> {\n    return new BNode<K>(this.keys.slice(0));\n  }\n\n  get(key: K, tree: BTreeSet<K>): K | undefined {\n    const i = indexOf(key, this.keys, -1, tree.comparator);\n    return i < 0 ? undefined : this.keys[i];\n  }\n\n  has(key: K, tree: BTreeSet<K>): boolean {\n    const i = indexOf(key, this.keys, -1, tree.comparator);\n    return i >= 0 && i < this.keys.length;\n  }\n\n  set(key: K, tree: BTreeSet<K>): null | BNode<K> {\n    let i = indexOf(key, this.keys, -1, tree.comparator);\n    if (i < 0) {\n      // key does not exist yet\n      i = ~i;\n      tree.size++;\n\n      if (this.keys.length < MAX_NODE_SIZE) {\n        this.keys.splice(i, 0, key);\n        return null;\n      }\n      // This leaf node is full and must split\n      const newRightSibling = this.splitOffRightSide();\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let target: BNode<K> = this;\n      if (i > this.keys.length) {\n        i -= this.keys.length;\n        target = newRightSibling;\n      }\n      // target.#insertInLeaf(i, key);\n      target.keys.splice(i, 0, key);\n\n      return newRightSibling;\n    }\n\n    // usually this is a no-op, but some users may wish to edit the key\n    this.keys[i] = key;\n    return null;\n  }\n\n  takeFromRight(rhs: BNode<K>) {\n    this.keys.push(rhs.keys.shift()!);\n  }\n\n  takeFromLeft(lhs: BNode<K>) {\n    this.keys.unshift(lhs.keys.pop()!);\n  }\n\n  splitOffRightSide(): BNode<K> {\n    const half = this.keys.length >> 1;\n    const keys = this.keys.splice(half);\n    return new BNode<K>(keys);\n  }\n\n  delete(key: K, tree: BTreeSet<K>): boolean {\n    const cmp = tree.comparator;\n    const iLow = indexOf(key, this.keys, -1, cmp);\n    const iHigh = iLow + 1;\n\n    if (iLow < 0) {\n      return false;\n    }\n\n    const {keys} = this;\n    for (let i = iLow; i < iHigh; i++) {\n      const key = keys[i];\n\n      if (key !== keys[i] || this.isShared === true) {\n        throw new Error('BTree illegally changed or cloned in delete');\n      }\n\n      this.keys.splice(i, 1);\n      tree.size--;\n      return true;\n    }\n\n    return false;\n  }\n\n  mergeSibling(rhs: BNode<K>, _: number) {\n    this.keys.push(...rhs.keys);\n  }\n}\n\n/** Internal node (non-leaf node) ********************************************/\nclass BNodeInternal<K> extends BNode<K> {\n  // Note: conventionally B+ trees have one fewer key than the number of\n  // children, but I find it easier to keep the array lengths equal: each\n  // keys[i] caches the value of children[i].maxKey().\n  children: BNode<K>[];\n\n  /**\n   * This does not mark `children` as shared, so it is the responsibility of the caller\n   * to ensure children are either marked shared, or aren't included in another tree.\n   */\n  constructor(children: BNode<K>[], keys?: K[]) {\n    if (!keys) {\n      keys = [];\n      for (let i = 0; i < children.length; i++) {\n        keys[i] = children[i].maxKey();\n      }\n    }\n    super(keys);\n    this.children = children;\n  }\n\n  isInternal(): this is BNodeInternal<K> {\n    return true;\n  }\n\n  clone(): BNode<K> {\n    const children = this.children.slice(0);\n    for (let i = 0; i < children.length; i++) {\n      children[i].isShared = true;\n    }\n    return new BNodeInternal<K>(children, this.keys.slice(0));\n  }\n\n  minKey() {\n    return this.children[0].minKey();\n  }\n\n  get(key: K, tree: BTreeSet<K>): K | undefined {\n    const i = indexOf(key, this.keys, 0, tree.comparator);\n    const {children} = this;\n    return i < children.length ? children[i].get(key, tree) : undefined;\n  }\n\n  has(key: K, tree: BTreeSet<K>): boolean {\n    const i = indexOf(key, this.keys, 0, tree.comparator);\n    const {children} = this;\n    return i < children.length ? children[i].has(key, tree) : false;\n  }\n\n  set(key: K, tree: BTreeSet<K>): null | BNode<K> {\n    const c = this.children;\n    const cmp = tree.comparator;\n    let i = Math.min(indexOf(key, this.keys, 0, cmp), c.length - 1);\n    let child = c[i];\n\n    if (child.isShared) {\n      c[i] = child = child.clone();\n    }\n    if (child.keys.length >= MAX_NODE_SIZE) {\n      // child is full; inserting anything else will cause a split.\n      // Shifting an item to the left or right sibling may avoid a split.\n      // We can do a shift if the adjacent node is not full and if the\n      // current key can still be placed in the same node after the shift.\n      let other: BNode<K>;\n      if (\n        i > 0 &&\n        (other = c[i - 1]).keys.length < MAX_NODE_SIZE &&\n        cmp(child.keys[0], key) < 0\n      ) {\n        if (other.isShared) {\n          c[i - 1] = other = other.clone();\n        }\n        other.takeFromRight(child);\n        this.keys[i - 1] = other.maxKey();\n      } else if (\n        (other = c[i + 1]) !== undefined &&\n        other.keys.length < MAX_NODE_SIZE &&\n        cmp(child.maxKey(), key) < 0\n      ) {\n        if (other.isShared) c[i + 1] = other = other.clone();\n        other.takeFromLeft(child);\n        this.keys[i] = c[i].maxKey();\n      }\n    }\n\n    const result = child.set(key, tree);\n    this.keys[i] = child.maxKey();\n    if (result === null) return null;\n\n    // The child has split and `result` is a new right child... does it fit?\n    if (this.keys.length < MAX_NODE_SIZE) {\n      // yes\n      this.insert(i + 1, result);\n      return null;\n    }\n    // no, we must split also\n    const newRightSibling = this.splitOffRightSide();\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let target: BNodeInternal<K> = this;\n    if (cmp(result.maxKey(), this.maxKey()) > 0) {\n      target = newRightSibling;\n      i -= this.keys.length;\n    }\n    target.insert(i + 1, result);\n    return newRightSibling;\n  }\n\n  /**\n   * Inserts `child` at index `i`.\n   * This does not mark `child` as shared, so it is the responsibility of the caller\n   * to ensure that either child is marked shared, or it is not included in another tree.\n   */\n  insert(i: number, child: BNode<K>) {\n    this.children.splice(i, 0, child);\n    this.keys.splice(i, 0, child.maxKey());\n  }\n\n  /**\n   * Split this node.\n   * Modifies this to remove the second half of the items, returning a separate node containing them.\n   */\n  splitOffRightSide() {\n    const half = this.children.length >> 1;\n    return new BNodeInternal<K>(\n      this.children.splice(half),\n      this.keys.splice(half),\n    );\n  }\n\n  takeFromRight(rhs: BNode<K>) {\n    this.keys.push(rhs.keys.shift()!);\n    this.children.push((rhs as BNodeInternal<K>).children.shift()!);\n  }\n\n  takeFromLeft(lhs: BNode<K>) {\n    this.keys.unshift(lhs.keys.pop()!);\n    this.children.unshift((lhs as BNodeInternal<K>).children.pop()!);\n  }\n\n  delete(key: K, tree: BTreeSet<K>): boolean {\n    const cmp = tree.comparator;\n    const {keys} = this;\n    const {children} = this;\n    let iLow = indexOf(key, this.keys, 0, cmp);\n    let i = iLow;\n    const iHigh = Math.min(iLow, keys.length - 1);\n    if (i <= iHigh) {\n      try {\n        if (children[i].isShared) {\n          children[i] = children[i].clone();\n        }\n        const result = children[i].delete(key, tree);\n        // Note: if children[i] is empty then keys[i]=undefined.\n        //       This is an invalid state, but it is fixed below.\n        keys[i] = children[i].maxKey();\n        return result;\n      } finally {\n        // Deletions may have occurred, so look for opportunities to merge nodes.\n        const half = MAX_NODE_SIZE >> 1;\n        if (iLow > 0) iLow--;\n        for (i = iHigh; i >= iLow; i--) {\n          if (children[i].keys.length <= half) {\n            if (children[i].keys.length !== 0) {\n              this.tryMerge(i, MAX_NODE_SIZE);\n            } else {\n              // child is empty! delete it!\n              keys.splice(i, 1);\n              children.splice(i, 1);\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Merges child i with child i+1 if their combined size is not too large */\n  tryMerge(i: number, maxSize: number): boolean {\n    const {children} = this;\n    if (i >= 0 && i + 1 < children.length) {\n      if (children[i].keys.length + children[i + 1].keys.length <= maxSize) {\n        if (children[i].isShared)\n          // cloned already UNLESS i is outside scan range\n          children[i] = children[i].clone();\n        children[i].mergeSibling(children[i + 1], maxSize);\n        children.splice(i + 1, 1);\n        this.keys.splice(i + 1, 1);\n        this.keys[i] = children[i].maxKey();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Move children from `rhs` into this.\n   * `rhs` must be part of this tree, and be removed from it after this call\n   * (otherwise isShared for its children could be incorrect).\n   */\n  mergeSibling(rhs: BNode<K>, maxNodeSize: number) {\n    // assert !this.isShared;\n    const oldLength = this.keys.length;\n    this.keys.push(...rhs.keys);\n    const rhsChildren = (rhs as unknown as BNodeInternal<K>).children;\n    this.children.push(...rhsChildren);\n\n    if (rhs.isShared && !this.isShared) {\n      // All children of a shared node are implicitly shared, and since their new\n      // parent is not shared, they must now be explicitly marked as shared.\n      for (let i = 0; i < rhsChildren.length; i++) {\n        rhsChildren[i].isShared = true;\n      }\n    }\n\n    // If our children are themselves almost empty due to a mass-delete,\n    // they may need to be merged too (but only the oldLength-1 and its\n    // right sibling should need this).\n    this.tryMerge(oldLength - 1, maxNodeSize);\n  }\n}\n\n// If key not found, returns i^failXor where i is the insertion index.\n// Callers that don't care whether there was a match will set failXor=0.\nfunction indexOf<K>(\n  key: K,\n  keys: K[],\n  failXor: number,\n  comparator: Comparator<K>,\n): number {\n  let lo = 0;\n  let hi = keys.length;\n  let mid = hi >> 1;\n  while (lo < hi) {\n    const c = comparator(keys[mid], key);\n    if (c < 0) {\n      lo = mid + 1;\n    } else if (c > 0) {\n      // key < keys[mid]\n      hi = mid;\n    } else if (c === 0) {\n      return mid;\n    } else {\n      // c is NaN or otherwise invalid\n      if (key === key) {\n        // at least the search key is not NaN\n        return keys.length;\n      }\n      throw new Error('NaN was used as a key');\n    }\n    mid = (lo + hi) >> 1;\n  }\n  return mid ^ failXor;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst emptyLeaf = new BNode<any>([]);\nemptyLeaf.isShared = true;\n","import type {Change} from '../ivm/change.ts';\nimport type {Node} from '../ivm/data.ts';\nimport {\n  throwOutput,\n  type FetchRequest,\n  type Input,\n  type Operator,\n  type Output,\n} from '../ivm/operator.ts';\nimport type {SourceSchema} from '../ivm/schema.ts';\nimport type {Stream} from '../ivm/stream.ts';\nimport type {MetricsDelegate} from './metrics-delegate.ts';\n\ntype MetricName = 'query-update-client' | 'query-update-server';\n\nexport class MeasurePushOperator implements Operator {\n  readonly #input: Input;\n  readonly #queryID: string;\n  readonly #metricsDelegate: MetricsDelegate;\n\n  #output: Output = throwOutput;\n  readonly #metricName: MetricName;\n\n  constructor(\n    input: Input,\n    queryID: string,\n    metricsDelegate: MetricsDelegate,\n    metricName: MetricName,\n  ) {\n    this.#input = input;\n    this.#queryID = queryID;\n    this.#metricsDelegate = metricsDelegate;\n    this.#metricName = metricName;\n    input.setOutput(this);\n  }\n\n  setOutput(output: Output): void {\n    this.#output = output;\n  }\n\n  fetch(req: FetchRequest): Stream<Node> {\n    return this.#input.fetch(req);\n  }\n\n  cleanup(req: FetchRequest): Stream<Node> {\n    return this.#input.cleanup(req);\n  }\n\n  getSchema(): SourceSchema {\n    return this.#input.getSchema();\n  }\n\n  destroy(): void {\n    this.#input.destroy();\n  }\n\n  push(change: Change): void {\n    const startTime = performance.now();\n    this.#output.push(change);\n    this.#metricsDelegate.addMetric(\n      this.#metricName,\n      performance.now() - startTime,\n      this.#queryID,\n    );\n  }\n}\n","import {assert} from '../../../shared/src/asserts.ts';\nimport {stringCompare} from '../../../shared/src/string-compare.ts';\nimport type {Writable} from '../../../shared/src/writable.ts';\nimport type {\n  Condition,\n  SimpleCondition,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport {valuesEqual} from './data.ts';\n\nexport type Constraint = {\n  readonly [key: string]: Value;\n};\n\nexport function constraintMatchesRow(\n  constraint: Constraint,\n  row: Row,\n): boolean {\n  for (const key in constraint) {\n    if (!valuesEqual(row[key], constraint[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function constraintMatchesPrimaryKey(\n  constraint: Constraint,\n  primary: PrimaryKey,\n): boolean {\n  const constraintKeys = Object.keys(constraint);\n\n  if (constraintKeys.length !== primary.length) {\n    return false;\n  }\n\n  // Primary key is always sorted\n  // Constraint does not have to be sorted\n  constraintKeys.sort(stringCompare);\n\n  for (let i = 0; i < constraintKeys.length; i++) {\n    if (constraintKeys[i][0] !== primary[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Pulls top level `and` components out of a condition tree.\n * The resulting array of simple conditions would match a superset of\n * values that the original condition would match.\n *\n * Examples:\n * a AND b OR c\n *\n * In this case we cannot pull anything because the `or` is at the top level.\n *\n * a AND b AND c\n * We can pull all three.\n *\n * a AND (b OR c)\n * We can only pull `a`.\n */\nexport function pullSimpleAndComponents(\n  condition: Condition,\n): SimpleCondition[] {\n  if (condition.type === 'and') {\n    return condition.conditions.flatMap(pullSimpleAndComponents);\n  }\n\n  if (condition.type === 'simple') {\n    return [condition];\n  }\n\n  if (condition.type === 'or' && condition.conditions.length === 1) {\n    return pullSimpleAndComponents(condition.conditions[0]);\n  }\n\n  return [];\n}\n\n/**\n * Checks if the supplied filters constitute a primary key lookup.\n * If so, returns the constraint that would be used to look up the primary key.\n * If not, returns undefined.\n */\nexport function primaryKeyConstraintFromFilters(\n  condition: Condition | undefined,\n  primary: PrimaryKey,\n): Constraint | undefined {\n  if (condition === undefined) {\n    return undefined;\n  }\n\n  const conditions = pullSimpleAndComponents(condition);\n  if (conditions.length === 0) {\n    return undefined;\n  }\n\n  const ret: Writable<Constraint> = {};\n  for (const subCondition of conditions) {\n    if (subCondition.op === '=') {\n      const column = extractColumn(subCondition);\n      if (column !== undefined) {\n        if (!primary.includes(column.name)) {\n          continue;\n        }\n        ret[column.name] = column.value;\n      }\n    }\n  }\n\n  if (Object.keys(ret).length !== primary.length) {\n    return undefined;\n  }\n\n  return ret;\n}\n\nfunction extractColumn(\n  condition: SimpleCondition,\n): {name: string; value: Value} | undefined {\n  if (condition.left.type === 'column') {\n    assert(condition.right.type === 'literal');\n    return {name: condition.left.name, value: condition.right.value};\n  }\n\n  return undefined;\n}\n\ndeclare const TESTING: boolean;\n\nexport class SetOfConstraint {\n  #data: Constraint[] = [];\n\n  constructor() {\n    // Only used in testing\n    assert(TESTING);\n  }\n\n  #indexOf(value: Constraint): number {\n    return this.#data.findIndex(v => constraintEquals(v, value));\n  }\n\n  has(value: Constraint): boolean {\n    return this.#indexOf(value) !== -1;\n  }\n\n  add(value: Constraint): this {\n    if (!this.has(value)) {\n      this.#data.push(value);\n    }\n    return this;\n  }\n}\n\nfunction constraintEquals(a: Constraint, b: Constraint): boolean {\n  const aEntries = Object.entries(a);\n  const bEntries = Object.entries(b);\n  if (aEntries.length !== bEntries.length) {\n    return false;\n  }\n  for (let i = 0; i < aEntries.length; i++) {\n    if (\n      aEntries[i][0] !== bEntries[i][0] ||\n      !valuesEqual(aEntries[i][1], bEntries[i][1])\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n","import {assert, unreachable} from '../../../shared/src/asserts.ts';\nimport {BTreeSet} from '../../../shared/src/btree-set.ts';\nimport {hasOwn} from '../../../shared/src/has-own.ts';\nimport type {\n  Condition,\n  Ordering,\n  OrderPart,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {Row, Value} from '../../../zero-protocol/src/data.ts';\nimport type {PrimaryKey} from '../../../zero-protocol/src/primary-key.ts';\nimport type {SchemaValue} from '../../../zero-schema/src/table-schema.ts';\nimport {assertOrderingIncludesPK} from '../builder/builder.ts';\nimport {\n  createPredicate,\n  transformFilters,\n  type NoSubqueryCondition,\n} from '../builder/filter.ts';\nimport type {AddChange, Change, RemoveChange} from './change.ts';\nimport {\n  constraintMatchesPrimaryKey,\n  constraintMatchesRow,\n  primaryKeyConstraintFromFilters,\n  type Constraint,\n} from './constraint.ts';\nimport {\n  compareValues,\n  valuesEqual,\n  makeComparator,\n  type Comparator,\n  type Node,\n} from './data.ts';\nimport {filterPush} from './filter-push.ts';\nimport {\n  type FetchRequest,\n  type Input,\n  type Output,\n  type Start,\n} from './operator.ts';\nimport type {SourceSchema} from './schema.ts';\nimport type {\n  Source,\n  SourceChange,\n  SourceChangeSet,\n  SourceInput,\n} from './source.ts';\nimport type {Stream} from './stream.ts';\nimport {once} from '../../../shared/src/iterables.ts';\nimport type {DebugDelegate} from '../builder/debug-delegate.ts';\n\nexport type Overlay = {\n  outputIndex: number;\n  change: SourceChange;\n};\n\nexport type Overlays = {\n  add: Row | undefined;\n  remove: Row | undefined;\n};\n\ntype Index = {\n  comparator: Comparator;\n  data: BTreeSet<Row>;\n  usedBy: Set<Connection>;\n};\n\nexport type Connection = {\n  input: Input;\n  output: Output | undefined;\n  sort: Ordering;\n  splitEditKeys: Set<string> | undefined;\n  compareRows: Comparator;\n  filters:\n    | {\n        condition: NoSubqueryCondition;\n        predicate: (row: Row) => boolean;\n      }\n    | undefined;\n  readonly debug?: DebugDelegate | undefined;\n};\n\n/**\n * A `MemorySource` is a source that provides data to the pipeline from an\n * in-memory data source.\n *\n * This data is kept in sorted order as downstream pipelines will always expect\n * the data they receive from `pull` to be in sorted order.\n */\nexport class MemorySource implements Source {\n  readonly #tableName: string;\n  readonly #columns: Record<string, SchemaValue>;\n  readonly #primaryKey: PrimaryKey;\n  readonly #primaryIndexSort: Ordering;\n  readonly #indexes: Map<string, Index> = new Map();\n  readonly #connections: Connection[] = [];\n\n  #overlay: Overlay | undefined;\n  #splitEditOverlay: Overlay | undefined;\n\n  constructor(\n    tableName: string,\n    columns: Record<string, SchemaValue>,\n    primaryKey: PrimaryKey,\n    primaryIndexData?: BTreeSet<Row> | undefined,\n  ) {\n    this.#tableName = tableName;\n    this.#columns = columns;\n    this.#primaryKey = primaryKey;\n    this.#primaryIndexSort = primaryKey.map(k => [k, 'asc']);\n    const comparator = makeBoundComparator(this.#primaryIndexSort);\n    this.#indexes.set(JSON.stringify(this.#primaryIndexSort), {\n      comparator,\n      data: primaryIndexData ?? new BTreeSet<Row>(comparator),\n      usedBy: new Set(),\n    });\n    assertOrderingIncludesPK(this.#primaryIndexSort, this.#primaryKey);\n  }\n\n  // Mainly for tests.\n  getSchemaInfo() {\n    return {\n      tableName: this.#tableName,\n      columns: this.#columns,\n      primaryKey: this.#primaryKey,\n    };\n  }\n\n  fork() {\n    const primaryIndex = this.#getPrimaryIndex();\n    return new MemorySource(\n      this.#tableName,\n      this.#columns,\n      this.#primaryKey,\n      primaryIndex.data.clone(),\n    );\n  }\n\n  get data(): BTreeSet<Row> {\n    return this.#getPrimaryIndex().data;\n  }\n\n  #getSchema(connection: Connection): SourceSchema {\n    return {\n      tableName: this.#tableName,\n      columns: this.#columns,\n      primaryKey: this.#primaryKey,\n      sort: connection.sort,\n      system: 'client',\n      relationships: {},\n      isHidden: false,\n      compareRows: connection.compareRows,\n    };\n  }\n\n  connect(\n    sort: Ordering,\n    filters?: Condition | undefined,\n    splitEditKeys?: Set<string> | undefined,\n  ): SourceInput {\n    const transformedFilters = transformFilters(filters);\n\n    const input: SourceInput = {\n      getSchema: () => schema,\n      fetch: req => this.#fetch(req, connection),\n      cleanup: req => this.#cleanup(req, connection),\n      setOutput: output => {\n        connection.output = output;\n      },\n      destroy: () => {\n        this.#disconnect(input);\n      },\n      fullyAppliedFilters: !transformedFilters.conditionsRemoved,\n    };\n\n    const connection: Connection = {\n      input,\n      output: undefined,\n      sort,\n      splitEditKeys,\n      compareRows: makeComparator(sort),\n      filters: transformedFilters.filters\n        ? {\n            condition: transformedFilters.filters,\n            predicate: createPredicate(transformedFilters.filters),\n          }\n        : undefined,\n    };\n    const schema = this.#getSchema(connection);\n    assertOrderingIncludesPK(sort, this.#primaryKey);\n    this.#connections.push(connection);\n    return input;\n  }\n\n  #disconnect(input: Input): void {\n    const idx = this.#connections.findIndex(c => c.input === input);\n    assert(idx !== -1, 'Connection not found');\n    this.#connections.splice(idx, 1);\n\n    // TODO: We used to delete unused indexes here. But in common cases like\n    // navigating into issue detail pages it caused a ton of constantly\n    // building and destroying indexes.\n    //\n    // Perhaps some intelligent LRU or something is needed here but for now,\n    // the opposite extreme of keeping all indexes for the lifetime of the\n    // page seems better.\n  }\n\n  #getPrimaryIndex(): Index {\n    const index = this.#indexes.get(JSON.stringify(this.#primaryIndexSort));\n    assert(index, 'Primary index not found');\n    return index;\n  }\n\n  #getOrCreateIndex(sort: Ordering, usedBy: Connection): Index {\n    const key = JSON.stringify(sort);\n    const index = this.#indexes.get(key);\n    // Future optimization could use existing index if it's the same just sorted\n    // in reverse of needed.\n    if (index) {\n      index.usedBy.add(usedBy);\n      return index;\n    }\n\n    const comparator = makeBoundComparator(sort);\n\n    // When creating these synchronously becomes a problem, a few options:\n    // 1. Allow users to specify needed indexes up front\n    // 2. Create indexes in a different thread asynchronously (this would require\n    // modifying the BTree to be able to be passed over structured-clone, or using\n    // a different library.)\n    // 3. We could even theoretically do (2) on multiple threads and then merge the\n    // results!\n    const data = new BTreeSet<Row>(comparator);\n\n    // I checked, there's no special path for adding data in bulk faster.\n    // The constructor takes an array, but it just calls add/set over and over.\n    for (const row of this.#getPrimaryIndex().data) {\n      data.add(row);\n    }\n\n    const newIndex = {comparator, data, usedBy: new Set([usedBy])};\n    this.#indexes.set(key, newIndex);\n    return newIndex;\n  }\n\n  // For unit testing that we correctly clean up indexes.\n  getIndexKeys(): string[] {\n    return [...this.#indexes.keys()];\n  }\n\n  *#fetch(req: FetchRequest, from: Connection): Stream<Node> {\n    const callingConnectionIndex = this.#connections.indexOf(from);\n    assert(callingConnectionIndex !== -1, 'Output not found');\n    const conn = this.#connections[callingConnectionIndex];\n    const {sort: requestedSort} = conn;\n\n    const pkConstraint = primaryKeyConstraintFromFilters(\n      conn.filters?.condition,\n      this.#primaryKey,\n    );\n    // The primary key constraint will be more limiting than the constraint\n    // so swap out to that if it exists.\n    const fetchOrPkConstraint = pkConstraint ?? req.constraint;\n\n    // If there is a constraint, we need an index sorted by it first.\n    const indexSort: OrderPart[] = [];\n    if (fetchOrPkConstraint) {\n      for (const key of Object.keys(fetchOrPkConstraint)) {\n        indexSort.push([key, 'asc']);\n      }\n    }\n\n    // For the special case of constraining by PK, we don't need to worry about\n    // any requested sort since there can only be one result. Otherwise we also\n    // need the index sorted by the requested sort.\n    if (\n      this.#primaryKey.length > 1 ||\n      !fetchOrPkConstraint ||\n      !constraintMatchesPrimaryKey(fetchOrPkConstraint, this.#primaryKey)\n    ) {\n      indexSort.push(...requestedSort);\n    }\n\n    const index = this.#getOrCreateIndex(indexSort, from);\n    const {data, comparator: compare} = index;\n    const comparator = (r1: Row, r2: Row) =>\n      compare(r1, r2) * (req.reverse ? -1 : 1);\n\n    const startAt = req.start?.row;\n\n    // If there is a constraint, we want to start our scan at the first row that\n    // matches the constraint. But because the next OrderPart can be `desc`,\n    // it's not true that {[constraintKey]: constraintValue} is the first\n    // matching row. Because in that case, the other fields will all be\n    // `undefined`, and in Zero `undefined` is always less than any other value.\n    // So if the second OrderPart is descending then `undefined` values will\n    // actually be the *last* row. We need a way to stay \"start at the first row\n    // with this constraint value\". RowBound with the corresponding compareBound\n    // comparator accomplishes this. The right thing is probably to teach the\n    // btree library to support this concept.\n    let scanStart: RowBound | undefined;\n\n    if (fetchOrPkConstraint) {\n      scanStart = {};\n      for (const [key, dir] of indexSort) {\n        if (hasOwn(fetchOrPkConstraint, key)) {\n          scanStart[key] = fetchOrPkConstraint[key];\n        } else {\n          if (req.reverse) {\n            scanStart[key] = dir === 'asc' ? maxValue : minValue;\n          } else {\n            scanStart[key] = dir === 'asc' ? minValue : maxValue;\n          }\n        }\n      }\n    } else {\n      scanStart = startAt;\n    }\n\n    const rowsIterable = generateRows(data, scanStart, req.reverse);\n    const withOverlay = generateWithOverlay(\n      startAt,\n      pkConstraint ? once(rowsIterable) : rowsIterable,\n      // use `req.constraint` here and not `fetchOrPkConstraint` since `fetchOrPkConstraint` could be the\n      // primary key constraint. The primary key constraint comes from filters and is acting as a filter\n      // rather than as the fetch constraint.\n      req.constraint,\n      this.#overlay,\n      this.#splitEditOverlay,\n      callingConnectionIndex,\n      comparator,\n      conn.filters?.predicate,\n    );\n\n    const withConstraint = generateWithConstraint(\n      generateWithStart(withOverlay, req.start, comparator),\n      // we use `req.constraint` and not `fetchOrPkConstraint` here because we need to\n      // AND the constraint with what could have been the primary key constraint\n      req.constraint,\n    );\n\n    yield* conn.filters\n      ? generateWithFilter(withConstraint, conn.filters.predicate)\n      : withConstraint;\n  }\n\n  #cleanup(req: FetchRequest, connection: Connection): Stream<Node> {\n    return this.#fetch(req, connection);\n  }\n\n  push(change: SourceChange | SourceChangeSet): void {\n    for (const _ of this.genPush(change)) {\n      // Nothing to do.\n    }\n  }\n\n  *genPush(change: SourceChange | SourceChangeSet) {\n    const primaryIndex = this.#getPrimaryIndex();\n    const {data} = primaryIndex;\n    const exists = (row: Row) => data.has(row);\n    const setOverlay = (o: Overlay | undefined) => (this.#overlay = o);\n    const setSplitEditOverlay = (o: Overlay | undefined) =>\n      (this.#splitEditOverlay = o);\n\n    if (change.type === 'set') {\n      const existing = data.get(change.row);\n      if (existing !== undefined) {\n        change = {\n          type: 'edit',\n          row: change.row,\n          oldRow: existing,\n        };\n      } else {\n        change = {\n          type: 'add',\n          row: change.row,\n        };\n      }\n    }\n\n    for (const x of genPush(\n      change,\n      exists,\n      this.#connections.entries(),\n      setOverlay,\n      setSplitEditOverlay,\n    )) {\n      yield x;\n    }\n\n    for (const {data} of this.#indexes.values()) {\n      switch (change.type) {\n        case 'add': {\n          const added = data.add(change.row);\n          // must succeed since we checked has() above.\n          assert(added);\n          break;\n        }\n        case 'remove': {\n          const removed = data.delete(change.row);\n          // must succeed since we checked has() above.\n          assert(removed);\n          break;\n        }\n        case 'edit': {\n          // TODO: We could see if the PK (form the index tree's perspective)\n          // changed and if not we could use set.\n\n          // We cannot just do `set` with the new value since the `oldRow` might\n          // not map to the same entry as the new `row` in the index btree.\n          const removed = data.delete(change.oldRow);\n          // must succeed since we checked has() above.\n          assert(removed);\n          data.add(change.row);\n          break;\n        }\n        default:\n          unreachable(change);\n      }\n    }\n  }\n}\n\nfunction* generateWithConstraint(\n  it: Stream<Node>,\n  constraint: Constraint | undefined,\n) {\n  for (const node of it) {\n    if (constraint && !constraintMatchesRow(constraint, node.row)) {\n      break;\n    }\n    yield node;\n  }\n}\n\nfunction* generateWithFilter(it: Stream<Node>, filter: (row: Row) => boolean) {\n  for (const node of it) {\n    if (filter(node.row)) {\n      yield node;\n    }\n  }\n}\n\nexport function* genPush(\n  change: SourceChange,\n  exists: (row: Row) => boolean,\n  connections: Iterable<[number, Connection]>,\n  setOverlay: (o: Overlay | undefined) => void,\n  setSplitEditOverlay: (o: Overlay | undefined) => void,\n) {\n  switch (change.type) {\n    case 'add':\n      assert(\n        !exists(change.row),\n        () => `Row already exists ${stringify(change)}`,\n      );\n      break;\n    case 'remove':\n      assert(exists(change.row), () => `Row not found ${stringify(change)}`);\n      break;\n    case 'edit':\n      assert(exists(change.oldRow), () => `Row not found ${stringify(change)}`);\n      break;\n    default:\n      unreachable(change);\n  }\n\n  for (const [outputIndex, {output, splitEditKeys, filters}] of connections) {\n    if (output) {\n      let splitEdit = false;\n      if (change.type === 'edit' && splitEditKeys) {\n        for (const key of splitEditKeys) {\n          if (!valuesEqual(change.row[key], change.oldRow[key])) {\n            splitEdit = true;\n            break;\n          }\n        }\n      }\n      if (splitEdit) {\n        assert(change.type === 'edit');\n        setSplitEditOverlay({\n          outputIndex,\n          change: {\n            type: 'remove',\n            row: change.oldRow,\n          },\n        });\n        const outputRemove: RemoveChange = {\n          type: 'remove',\n          node: {\n            row: change.oldRow,\n            relationships: {},\n          },\n        };\n        filterPush(outputRemove, output, filters?.predicate);\n        yield;\n        setSplitEditOverlay(undefined);\n        setOverlay({outputIndex, change});\n        const outputAdd: AddChange = {\n          type: 'add',\n          node: {\n            row: change.row,\n            relationships: {},\n          },\n        };\n        filterPush(outputAdd, output, filters?.predicate);\n        yield;\n      } else {\n        setOverlay({outputIndex, change});\n        const outputChange: Change =\n          change.type === 'edit'\n            ? {\n                type: change.type,\n                oldNode: {\n                  row: change.oldRow,\n                  relationships: {},\n                },\n                node: {\n                  row: change.row,\n                  relationships: {},\n                },\n              }\n            : {\n                type: change.type,\n                node: {\n                  row: change.row,\n                  relationships: {},\n                },\n              };\n        filterPush(outputChange, output, filters?.predicate);\n        yield;\n      }\n    }\n  }\n  setOverlay(undefined);\n}\n\nexport function* generateWithStart(\n  nodes: Iterable<Node>,\n  start: Start | undefined,\n  compare: (r1: Row, r2: Row) => number,\n): Stream<Node> {\n  if (!start) {\n    yield* nodes;\n    return;\n  }\n  let started = false;\n  for (const node of nodes) {\n    if (!started) {\n      if (start.basis === 'at') {\n        if (compare(node.row, start.row) >= 0) {\n          started = true;\n        }\n      } else if (start.basis === 'after') {\n        if (compare(node.row, start.row) > 0) {\n          started = true;\n        }\n      }\n    }\n    if (started) {\n      yield node;\n    }\n  }\n}\n\n/**\n * Takes an iterator and overlay.\n * Splices the overlay into the iterator at the correct position.\n *\n * @param startAt - if there is a lower bound to the stream. If the lower bound of the stream\n * is above the overlay, the overlay will be skipped.\n * @param rows - the stream into which the overlay should be spliced\n * @param constraint - constraint that was applied to the rowIterator and should\n * also be applied to the overlay.\n * @param overlay - the overlay values to splice in\n * @param compare - the comparator to use to find the position for the overlay\n */\nexport function* generateWithOverlay(\n  startAt: Row | undefined,\n  rows: Iterable<Row>,\n  constraint: Constraint | undefined,\n  overlay: Overlay | undefined,\n  splitEditOverlay: Overlay | undefined,\n  connectionIndex: number,\n  compare: Comparator,\n  filterPredicate?: (row: Row) => boolean | undefined,\n) {\n  let overlayToApply: Overlay | undefined = undefined;\n  if (splitEditOverlay && splitEditOverlay.outputIndex === connectionIndex) {\n    overlayToApply = splitEditOverlay;\n  } else if (overlay && connectionIndex <= overlay.outputIndex) {\n    overlayToApply = overlay;\n  }\n  const overlays = computeOverlays(\n    startAt,\n    constraint,\n    overlayToApply,\n    compare,\n    filterPredicate,\n  );\n  yield* generateWithOverlayInner(rows, overlays, compare);\n}\n\nfunction computeOverlays(\n  startAt: Row | undefined,\n  constraint: Constraint | undefined,\n  overlay: Overlay | undefined,\n  compare: Comparator,\n  filterPredicate?: (row: Row) => boolean | undefined,\n): Overlays {\n  let overlays: Overlays = {\n    add: undefined,\n    remove: undefined,\n  };\n  switch (overlay?.change.type) {\n    case 'add':\n      overlays = {\n        add: overlay.change.row,\n        remove: undefined,\n      };\n      break;\n    case 'remove':\n      overlays = {\n        add: undefined,\n        remove: overlay.change.row,\n      };\n      break;\n    case 'edit':\n      overlays = {\n        add: overlay.change.row,\n        remove: overlay.change.oldRow,\n      };\n      break;\n  }\n\n  if (startAt) {\n    overlays = overlaysForStartAt(overlays, startAt, compare);\n  }\n\n  if (constraint) {\n    overlays = overlaysForConstraint(overlays, constraint);\n  }\n\n  if (filterPredicate) {\n    overlays = overlaysForFilterPredicate(overlays, filterPredicate);\n  }\n\n  return overlays;\n}\n\nexport {overlaysForStartAt as overlaysForStartAtForTest};\n\nfunction overlaysForStartAt(\n  {add, remove}: Overlays,\n  startAt: Row,\n  compare: Comparator,\n): Overlays {\n  const undefinedIfBeforeStartAt = (row: Row | undefined) =>\n    row === undefined || compare(row, startAt) < 0 ? undefined : row;\n  return {\n    add: undefinedIfBeforeStartAt(add),\n    remove: undefinedIfBeforeStartAt(remove),\n  };\n}\n\nexport {overlaysForConstraint as overlaysForConstraintForTest};\n\nfunction overlaysForConstraint(\n  {add, remove}: Overlays,\n  constraint: Constraint,\n): Overlays {\n  const undefinedIfDoesntMatchConstraint = (row: Row | undefined) =>\n    row === undefined || !constraintMatchesRow(constraint, row)\n      ? undefined\n      : row;\n\n  return {\n    add: undefinedIfDoesntMatchConstraint(add),\n    remove: undefinedIfDoesntMatchConstraint(remove),\n  };\n}\n\nfunction overlaysForFilterPredicate(\n  {add, remove}: Overlays,\n  filterPredicate: (row: Row) => boolean | undefined,\n): Overlays {\n  const undefinedIfDoesntMatchFilter = (row: Row | undefined) =>\n    row === undefined || !filterPredicate(row) ? undefined : row;\n\n  return {\n    add: undefinedIfDoesntMatchFilter(add),\n    remove: undefinedIfDoesntMatchFilter(remove),\n  };\n}\n\nexport function* generateWithOverlayInner(\n  rowIterator: Iterable<Row>,\n  overlays: Overlays,\n  compare: (r1: Row, r2: Row) => number,\n) {\n  let addOverlayYielded = false;\n  let removeOverlaySkipped = false;\n  for (const row of rowIterator) {\n    if (!addOverlayYielded && overlays.add) {\n      const cmp = compare(overlays.add, row);\n      if (cmp < 0) {\n        addOverlayYielded = true;\n        yield {row: overlays.add, relationships: {}};\n      }\n    }\n\n    if (!removeOverlaySkipped && overlays.remove) {\n      const cmp = compare(overlays.remove, row);\n      if (cmp === 0) {\n        removeOverlaySkipped = true;\n        continue;\n      }\n    }\n    yield {row, relationships: {}};\n  }\n\n  if (!addOverlayYielded && overlays.add) {\n    yield {row: overlays.add, relationships: {}};\n  }\n}\n\n/**\n * A location to begin scanning an index from. Can either be a specific value\n * or the min or max possible value for the type. This is used to start a scan\n * at the beginning of the rows matching a constraint.\n */\ntype Bound = Value | MinValue | MaxValue;\ntype RowBound = Record<string, Bound>;\nconst minValue = Symbol('min-value');\ntype MinValue = typeof minValue;\nconst maxValue = Symbol('max-value');\ntype MaxValue = typeof maxValue;\n\nfunction makeBoundComparator(sort: Ordering) {\n  return (a: RowBound, b: RowBound) => {\n    // Hot! Do not use destructuring\n    for (const entry of sort) {\n      const key = entry[0];\n      const cmp = compareBounds(a[key], b[key]);\n      if (cmp !== 0) {\n        return entry[1] === 'asc' ? cmp : -cmp;\n      }\n    }\n    return 0;\n  };\n}\n\nfunction compareBounds(a: Bound, b: Bound): number {\n  if (a === b) {\n    return 0;\n  }\n  if (a === minValue) {\n    return -1;\n  }\n  if (b === minValue) {\n    return 1;\n  }\n  if (a === maxValue) {\n    return 1;\n  }\n  if (b === maxValue) {\n    return -1;\n  }\n  return compareValues(a, b);\n}\n\nfunction* generateRows(\n  data: BTreeSet<Row>,\n  scanStart: RowBound | undefined,\n  reverse: boolean | undefined,\n) {\n  yield* data[reverse ? 'valuesFromReversed' : 'valuesFrom'](\n    scanStart as Row | undefined,\n  );\n}\n\nexport function stringify(change: SourceChange) {\n  return JSON.stringify(change, (_, v) =>\n    typeof v === 'bigint' ? v.toString() : v,\n  );\n}\n","import {MemorySource} from '../../../zql/src/ivm/memory-source.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport {wrapIterable} from '../../../shared/src/iterables.ts';\nimport {type Read, type Store} from '../../../replicache/src/dag/store.ts';\nimport {using, withRead} from '../../../replicache/src/with-transactions.ts';\nimport type {Hash} from '../../../replicache/src/hash.ts';\nimport * as FormatVersion from '../../../replicache/src/format-version-enum.ts';\nimport {ENTITIES_KEY_PREFIX, sourceNameFromKey} from './keys.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport {diff, DiffsMap} from '../../../replicache/src/sync/diff.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {\n  InternalDiff,\n  InternalDiffOperation,\n  NoIndexDiff,\n} from '../../../replicache/src/btree/node.ts';\nimport {diffBinarySearch} from '../../../replicache/src/subscriptions.ts';\nimport {readFromHash} from '../../../replicache/src/db/read.ts';\nimport type {ZeroReadOptions} from '../../../replicache/src/replicache-options.ts';\nimport type {LazyStore} from '../../../replicache/src/dag/lazy-store.ts';\n\n/**\n * Replicache needs to rebase mutations onto different\n * commits of it's b-tree. These mutations can have reads\n * in them and those reads must be run against the IVM sources.\n *\n * To ensure the reads get the correct state, the IVM\n * sources need to reflect the state of the commit\n * being rebased onto. `IVMSourceBranch` allows us to:\n * 1. fork the IVM sources\n * 2. patch them up to match the desired head\n * 3. run the reads against the forked sources\n *\n * (2) is expected to be a cheap operation as there should only\n * ever be a few outstanding diffs to apply given Zero is meant\n * to be run in a connected state.\n */\nexport class IVMSourceBranch {\n  readonly #sources: Map<string, MemorySource | undefined>;\n  readonly #tables: Record<string, TableSchema>;\n  hash: Hash | undefined;\n\n  constructor(\n    tables: Record<string, TableSchema>,\n    hash?: Hash | undefined,\n    sources: Map<string, MemorySource | undefined> = new Map(),\n  ) {\n    this.#tables = tables;\n    this.#sources = sources;\n    this.hash = hash;\n  }\n\n  getSource(name: string): MemorySource | undefined {\n    if (this.#sources.has(name)) {\n      return this.#sources.get(name);\n    }\n\n    const schema = this.#tables[name];\n    const source = schema\n      ? new MemorySource(name, schema.columns, schema.primaryKey)\n      : undefined;\n    this.#sources.set(name, source);\n    return source;\n  }\n\n  clear() {\n    this.#sources.clear();\n  }\n\n  /**\n   * Mutates the current branch, advancing it to the new head\n   * by applying the given diffs.\n   */\n  advance(expectedHead: Hash | undefined, newHead: Hash, diffs: NoIndexDiff) {\n    assert(\n      this.hash === expectedHead,\n      () =>\n        `Expected head must match the main head. Got: ${this.hash}, expected: ${expectedHead}`,\n    );\n\n    applyDiffs(diffs, this);\n    this.hash = newHead;\n  }\n\n  /**\n   * Fork the branch and patch it up to match the desired head.\n   */\n  async forkToHead(\n    store: LazyStore,\n    desiredHead: Hash,\n    readOptions?: ZeroReadOptions | undefined,\n  ): Promise<IVMSourceBranch> {\n    const fork = this.fork();\n\n    if (fork.hash === desiredHead) {\n      return fork;\n    }\n\n    await patchBranch(desiredHead, store, fork, readOptions);\n    fork.hash = desiredHead;\n    return fork;\n  }\n\n  /**\n   * Creates a new IVMSourceBranch that is a copy of the current one.\n   * This is a cheap operation since the b-trees are shared until a write is performed\n   * and then only the modified nodes are copied.\n   *\n   * IVM branches are forked when we need to rebase mutations.\n   * The mutations modify the fork rather than original branch.\n   */\n  fork() {\n    return new IVMSourceBranch(\n      this.#tables,\n      this.hash,\n      new Map(\n        wrapIterable(this.#sources.entries()).map(([name, source]) => [\n          name,\n          source?.fork(),\n        ]),\n      ),\n    );\n  }\n}\n\nexport async function initFromStore(\n  branch: IVMSourceBranch,\n  hash: Hash,\n  store: Store,\n) {\n  const diffs: InternalDiffOperation[] = [];\n  await withRead(store, async dagRead => {\n    const read = await readFromHash(hash, dagRead, FormatVersion.Latest);\n    for await (const entry of read.map.scan(ENTITIES_KEY_PREFIX)) {\n      if (!entry[0].startsWith(ENTITIES_KEY_PREFIX)) {\n        break;\n      }\n      diffs.push({\n        op: 'add',\n        key: entry[0],\n        newValue: entry[1],\n      });\n    }\n  });\n\n  branch.advance(undefined, hash, diffs);\n}\n\nasync function patchBranch(\n  desiredHead: Hash,\n  store: LazyStore,\n  fork: IVMSourceBranch,\n  readOptions: ZeroReadOptions | undefined,\n) {\n  const diffs = await computeDiffs(\n    must(fork.hash),\n    desiredHead,\n    store,\n    readOptions,\n  );\n  if (!diffs) {\n    return;\n  }\n  applyDiffs(diffs, fork);\n}\n\nasync function computeDiffs(\n  startHash: Hash,\n  endHash: Hash,\n  store: LazyStore,\n  readOptions: ZeroReadOptions | undefined,\n): Promise<InternalDiff | undefined> {\n  const readFn = (dagRead: Read) =>\n    diff(\n      startHash,\n      endHash,\n      dagRead,\n      {\n        shouldComputeDiffs: () => true,\n        shouldComputeDiffsForIndex(_name) {\n          return false;\n        },\n      },\n      FormatVersion.Latest,\n    );\n\n  let diffs: DiffsMap;\n  if (readOptions?.openLazySourceRead) {\n    diffs = await using(store.read(readOptions.openLazySourceRead), readFn);\n  } else if (readOptions?.openLazyRead) {\n    diffs = await readFn(readOptions.openLazyRead);\n  } else {\n    diffs = await withRead(store, readFn);\n  }\n\n  return diffs.get('');\n}\n\nfunction applyDiffs(diffs: NoIndexDiff, branch: IVMSourceBranch) {\n  for (\n    let i = diffBinarySearch(diffs, ENTITIES_KEY_PREFIX, diff => diff.key);\n    i < diffs.length;\n    i++\n  ) {\n    const diff = diffs[i];\n    const {key} = diff;\n    if (!key.startsWith(ENTITIES_KEY_PREFIX)) {\n      break;\n    }\n    const name = sourceNameFromKey(key);\n    const source = must(branch.getSource(name));\n    switch (diff.op) {\n      case 'del':\n        source.push({\n          type: 'remove',\n          row: diff.oldValue as Row,\n        });\n        break;\n      case 'add':\n        source.push({\n          type: 'add',\n          row: diff.newValue as Row,\n        });\n        break;\n      case 'change':\n        source.push({\n          type: 'edit',\n          row: diff.newValue as Row,\n          oldRow: diff.oldValue as Row,\n        });\n        break;\n    }\n  }\n}\n","import type {NoIndexDiff} from '../../../replicache/src/btree/node.ts';\nimport type {Hash} from '../../../replicache/src/hash.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {AST} from '../../../zero-protocol/src/ast.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport type {FilterInput} from '../../../zql/src/ivm/filter-operators.ts';\nimport {MemoryStorage} from '../../../zql/src/ivm/memory-storage.ts';\nimport type {Input, Storage} from '../../../zql/src/ivm/operator.ts';\nimport type {Source, SourceInput} from '../../../zql/src/ivm/source.ts';\nimport {MeasurePushOperator} from '../../../zql/src/query/measure-push-operator.ts';\nimport type {MetricsDelegate} from '../../../zql/src/query/metrics-delegate.ts';\nimport type {\n  CommitListener,\n  QueryDelegate,\n} from '../../../zql/src/query/query-delegate.ts';\nimport type {RunOptions} from '../../../zql/src/query/query.ts';\nimport {type IVMSourceBranch} from './ivm-branch.ts';\nimport type {QueryManager} from './query-manager.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\nexport type AddQuery = QueryManager['addLegacy'];\nexport type AddCustomQuery = QueryManager['addCustom'];\n\nexport type UpdateQuery = QueryManager['updateLegacy'];\nexport type UpdateCustomQuery = QueryManager['updateCustom'];\nexport type FlushQueryChanges = QueryManager['flushBatch'];\n\n/**\n * ZeroContext glues together zql and Replicache. It listens to changes in\n * Replicache data and pushes them into IVM and on tells the server about new\n * queries.\n */\nexport class ZeroContext implements QueryDelegate {\n  // It is a bummer to have to maintain separate MemorySources here and copy the\n  // data in from the Replicache db. But we want the data to be accessible via\n  // pipelines *synchronously* and the core Replicache infra is all async. So\n  // that needs to be fixed.\n  readonly #mainSources: IVMSourceBranch;\n  readonly addServerQuery: AddQuery;\n  readonly addCustomQuery: AddCustomQuery;\n  readonly updateServerQuery: UpdateQuery;\n  readonly updateCustomQuery: UpdateCustomQuery;\n  readonly flushQueryChanges: () => void;\n  readonly #batchViewUpdates: (applyViewUpdates: () => void) => void;\n  readonly #commitListeners: Set<CommitListener> = new Set();\n\n  readonly #lc: ZeroLogContext;\n  readonly assertValidRunOptions: (options?: RunOptions) => void;\n\n  /**\n   * Client-side queries start out as \"unknown\" and are then updated to\n   * \"complete\" once the server has sent back the query result.\n   */\n  readonly defaultQueryComplete = false;\n\n  readonly addMetric: MetricsDelegate['addMetric'];\n\n  constructor(\n    lc: ZeroLogContext,\n    mainSources: IVMSourceBranch,\n    addQuery: AddQuery,\n    addCustomQuery: AddCustomQuery,\n    updateQuery: UpdateQuery,\n    updateCustomQuery: UpdateCustomQuery,\n    flushQueryChanges: () => void,\n    batchViewUpdates: (applyViewUpdates: () => void) => void,\n    addMetric: MetricsDelegate['addMetric'],\n    assertValidRunOptions: (options?: RunOptions) => void,\n  ) {\n    this.#mainSources = mainSources;\n    this.addServerQuery = addQuery;\n    this.updateServerQuery = updateQuery;\n    this.updateCustomQuery = updateCustomQuery;\n    this.#batchViewUpdates = batchViewUpdates;\n    this.#lc = lc;\n    this.assertValidRunOptions = assertValidRunOptions;\n    this.addCustomQuery = addCustomQuery;\n    this.flushQueryChanges = flushQueryChanges;\n    this.addMetric = addMetric;\n  }\n\n  getSource(name: string): Source | undefined {\n    return this.#mainSources.getSource(name);\n  }\n\n  mapAst(ast: AST): AST {\n    return ast;\n  }\n\n  createStorage(): Storage {\n    return new MemoryStorage();\n  }\n\n  decorateInput(input: Input): Input {\n    return input;\n  }\n\n  decorateFilterInput(input: FilterInput): FilterInput {\n    return input;\n  }\n\n  decorateSourceInput(input: SourceInput, queryID: string): Input {\n    return new MeasurePushOperator(input, queryID, this, 'query-update-client');\n  }\n\n  addEdge() {}\n\n  onTransactionCommit(cb: CommitListener): () => void {\n    this.#commitListeners.add(cb);\n    return () => {\n      this.#commitListeners.delete(cb);\n    };\n  }\n\n  batchViewUpdates<T>(applyViewUpdates: () => T) {\n    let result: T | undefined;\n    let viewChangesPerformed = false;\n    this.#batchViewUpdates(() => {\n      result = applyViewUpdates();\n      viewChangesPerformed = true;\n    });\n    assert(\n      viewChangesPerformed,\n      'batchViewUpdates must call applyViewUpdates synchronously.',\n    );\n    return result as T;\n  }\n\n  processChanges(\n    expectedHead: Hash | undefined,\n    newHead: Hash,\n    changes: NoIndexDiff,\n  ) {\n    this.batchViewUpdates(() => {\n      try {\n        this.#mainSources.advance(expectedHead, newHead, changes);\n      } finally {\n        this.#endTransaction();\n      }\n    });\n  }\n\n  #endTransaction() {\n    for (const listener of this.#commitListeners) {\n      try {\n        listener();\n      } catch (e) {\n        // We should not fatal the inner-workings of Zero due to the user's application\n        // code throwing an error.\n        // Hence we wrap notifications in a try-catch block.\n        this.#lc.error?.(\n          ErrorKind.Internal,\n          'Failed notifying a commit listener of IVM updates',\n          e,\n        );\n      }\n    }\n  }\n}\n","import type {ReadonlyJSONObject} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport type {Row} from '../../../zero-protocol/src/data.ts';\nimport {\n  CRUD_MUTATION_NAME,\n  type CRUDMutationArg,\n  type CRUDOp,\n  type DeleteOp,\n  type InsertOp,\n  type UpdateOp,\n  type UpsertOp,\n} from '../../../zero-protocol/src/push.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport type {IVMSourceBranch} from './ivm-branch.ts';\nimport {toPrimaryKeyString} from './keys.ts';\nimport type {MutatorDefs, WriteTransaction} from './replicache-types.ts';\nimport type {\n  InsertValue,\n  UpdateValue,\n  UpsertValue,\n  DeleteID,\n} from '../../../zql/src/mutate/custom.ts';\n\n/**\n * This is the type of the generated mutate.<name>.<verb> function.\n */\nexport type TableMutator<S extends TableSchema> = {\n  /**\n   * Writes a row if a row with the same primary key doesn't already exists.\n   * Non-primary-key fields that are 'optional' can be omitted or set to\n   * `undefined`. Such fields will be assigned the value `null` optimistically\n   * and then the default value as defined by the server.\n   */\n  insert: (value: InsertValue<S>) => Promise<void>;\n\n  /**\n   * Writes a row unconditionally, overwriting any existing row with the same\n   * primary key. Non-primary-key fields that are 'optional' can be omitted or\n   * set to `undefined`. Such fields will be assigned the value `null`\n   * optimistically and then the default value as defined by the server.\n   */\n  upsert: (value: UpsertValue<S>) => Promise<void>;\n\n  /**\n   * Updates a row with the same primary key. If no such row exists, this\n   * function does nothing. All non-primary-key fields can be omitted or set to\n   * `undefined`. Such fields will be left unchanged from previous value.\n   */\n  update: (value: UpdateValue<S>) => Promise<void>;\n\n  /**\n   * Deletes the row with the specified primary key. If no such row exists, this\n   * function does nothing.\n   */\n  delete: (id: DeleteID<S>) => Promise<void>;\n};\n\nexport type DBMutator<S extends Schema> =\n  S['enableLegacyMutators'] extends false\n    ? {} // eslint-disable-line @typescript-eslint/ban-types -- {} is needed here for intersection type identity\n    : {\n        [K in keyof S['tables']]: TableMutator<S['tables'][K]>;\n      };\n\nexport type BatchMutator<S extends Schema> = <R>(\n  body: (m: DBMutator<S>) => MaybePromise<R>,\n) => Promise<R>;\n\ntype ZeroCRUDMutate = {\n  [CRUD_MUTATION_NAME]: CRUDMutate;\n};\n\n/**\n * This is the zero.mutate object part representing the CRUD operations. If the\n * queries are `issue` and `label`, then this object will have `issue` and\n * `label` properties.\n */\nexport function makeCRUDMutate<const S extends Schema>(\n  schema: S,\n  repMutate: ZeroCRUDMutate,\n): {mutate: DBMutator<S>; mutateBatch: BatchMutator<S>} {\n  const {[CRUD_MUTATION_NAME]: zeroCRUD} = repMutate;\n\n  const mutateBatch = async <R>(body: (m: DBMutator<S>) => R): Promise<R> => {\n    const ops: CRUDOp[] = [];\n    const m = {} as Record<string, unknown>;\n    for (const name of Object.keys(schema.tables)) {\n      m[name] = makeBatchCRUDMutate(name, schema, ops);\n    }\n\n    const rv = await body(m as DBMutator<S>);\n    await zeroCRUD({ops});\n    return rv;\n  };\n\n  const mutate: Record<string, TableMutator<TableSchema>> = {};\n  for (const [name, tableSchema] of Object.entries(schema.tables)) {\n    mutate[name] = makeEntityCRUDMutate(name, tableSchema.primaryKey, zeroCRUD);\n  }\n  return {\n    mutate: mutate as DBMutator<S>,\n    mutateBatch: mutateBatch as BatchMutator<S>,\n  };\n}\n\n/**\n * Creates the `{insert, upsert, update, delete}` object for use outside a\n * batch.\n */\nfunction makeEntityCRUDMutate<S extends TableSchema>(\n  tableName: string,\n  primaryKey: S['primaryKey'],\n  zeroCRUD: CRUDMutate,\n): TableMutator<S> {\n  return {\n    insert: (value: InsertValue<S>) => {\n      const op: InsertOp = {\n        op: 'insert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n    upsert: (value: UpsertValue<S>) => {\n      const op: UpsertOp = {\n        op: 'upsert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n    update: (value: UpdateValue<S>) => {\n      const op: UpdateOp = {\n        op: 'update',\n        tableName,\n        primaryKey,\n        value,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n    delete: (id: DeleteID<S>) => {\n      const op: DeleteOp = {\n        op: 'delete',\n        tableName,\n        primaryKey,\n        value: id,\n      };\n      return zeroCRUD({ops: [op]});\n    },\n  };\n}\n\n/**\n * Creates the `{inesrt, upsert, update, delete}` object for use inside a\n * batch.\n */\nexport function makeBatchCRUDMutate<S extends TableSchema>(\n  tableName: string,\n  schema: Schema,\n  ops: CRUDOp[],\n): TableMutator<S> {\n  const {primaryKey} = schema.tables[tableName];\n  return {\n    insert: (value: InsertValue<S>) => {\n      const op: InsertOp = {\n        op: 'insert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n    upsert: (value: UpsertValue<S>) => {\n      const op: UpsertOp = {\n        op: 'upsert',\n        tableName,\n        primaryKey,\n        value,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n    update: (value: UpdateValue<S>) => {\n      const op: UpdateOp = {\n        op: 'update',\n        tableName,\n        primaryKey,\n        value,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n    delete: (id: DeleteID<S>) => {\n      const op: DeleteOp = {\n        op: 'delete',\n        tableName,\n        primaryKey,\n        value: id,\n      };\n      ops.push(op);\n      return promiseVoid;\n    },\n  };\n}\n\nexport type WithCRUD<MD extends MutatorDefs> = MD & {\n  [CRUD_MUTATION_NAME]: CRUDMutator;\n};\n\nexport type CRUDMutate = (crudArg: CRUDMutationArg) => Promise<void>;\n\nexport type CRUDMutator = (\n  tx: WriteTransaction,\n  crudArg: CRUDMutationArg,\n) => Promise<void>;\n\n// Zero crud mutators cannot function at the same\n// time as custom mutators as the rebase of crud mutators will not\n// update the IVM branch. That's ok, we're removing crud mutators\n// in favor of custom mutators.\nexport function makeCRUDMutator(schema: Schema): CRUDMutator {\n  return async function zeroCRUDMutator(\n    tx: WriteTransaction,\n    crudArg: CRUDMutationArg,\n  ): Promise<void> {\n    for (const op of crudArg.ops) {\n      switch (op.op) {\n        case 'insert':\n          await insertImpl(tx, op, schema, undefined);\n          break;\n        case 'upsert':\n          await upsertImpl(tx, op, schema, undefined);\n          break;\n        case 'update':\n          await updateImpl(tx, op, schema, undefined);\n          break;\n        case 'delete':\n          await deleteImpl(tx, op, schema, undefined);\n          break;\n      }\n    }\n  };\n}\n\nfunction defaultOptionalFieldsToNull(\n  schema: TableSchema,\n  value: ReadonlyJSONObject,\n): ReadonlyJSONObject {\n  let rv = value;\n  for (const name in schema.columns) {\n    if (rv[name] === undefined) {\n      rv = {...rv, [name]: null};\n    }\n  }\n  return rv;\n}\n\nexport async function insertImpl(\n  tx: WriteTransaction,\n  arg: InsertOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  if (!(await tx.has(key))) {\n    const val = defaultOptionalFieldsToNull(\n      schema.tables[arg.tableName],\n      arg.value,\n    );\n    await tx.set(key, val);\n    if (ivmBranch) {\n      must(ivmBranch.getSource(arg.tableName)).push({\n        type: 'add',\n        row: arg.value,\n      });\n    }\n  }\n}\n\nexport async function upsertImpl(\n  tx: WriteTransaction,\n  arg: InsertOp | UpsertOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  const val = defaultOptionalFieldsToNull(\n    schema.tables[arg.tableName],\n    arg.value,\n  );\n  await tx.set(key, val);\n  if (ivmBranch) {\n    must(ivmBranch.getSource(arg.tableName)).push({\n      type: 'set',\n      row: arg.value,\n    });\n  }\n}\n\nexport async function updateImpl(\n  tx: WriteTransaction,\n  arg: UpdateOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  const prev = await tx.get(key);\n  if (prev === undefined) {\n    return;\n  }\n  const update = arg.value;\n  const next = {...(prev as ReadonlyJSONObject)};\n  for (const k in update) {\n    if (update[k] !== undefined) {\n      next[k] = update[k];\n    }\n  }\n  await tx.set(key, next);\n  if (ivmBranch) {\n    must(ivmBranch.getSource(arg.tableName)).push({\n      type: 'edit',\n      oldRow: prev as Row,\n      row: next,\n    });\n  }\n}\n\nexport async function deleteImpl(\n  tx: WriteTransaction,\n  arg: DeleteOp,\n  schema: Schema,\n  ivmBranch: IVMSourceBranch | undefined,\n): Promise<void> {\n  const key = toPrimaryKeyString(\n    arg.tableName,\n    schema.tables[arg.tableName].primaryKey,\n    arg.value,\n  );\n  const prev = await tx.get(key);\n  if (prev === undefined) {\n    return;\n  }\n  await tx.del(key);\n  if (ivmBranch) {\n    must(ivmBranch.getSource(arg.tableName)).push({\n      type: 'remove',\n      row: prev as Row,\n    });\n  }\n}\n","export function emptyFunction() {}\nexport const emptyObject = Object.freeze({});\n","import {\n  WriteTransactionImpl,\n  zeroData,\n} from '../../../replicache/src/transactions.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {emptyFunction} from '../../../shared/src/sentinels.ts';\nimport type {MutationOk} from '../../../zero-protocol/src/push.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport type {\n  ClientTransaction,\n  DeleteID,\n  InsertValue,\n  SchemaCRUD,\n  SchemaQuery,\n  TableCRUD,\n  Transaction,\n  UpdateValue,\n  UpsertValue,\n} from '../../../zql/src/mutate/custom.ts';\nimport {newQuery} from '../../../zql/src/query/query-impl.ts';\nimport {type Query, type RunOptions} from '../../../zql/src/query/query.ts';\nimport type {ClientID} from '../types/client-state.ts';\nimport {ZeroContext} from './context.ts';\nimport {deleteImpl, insertImpl, updateImpl, upsertImpl} from './crud.ts';\nimport type {IVMSourceBranch} from './ivm-branch.ts';\nimport type {WriteTransaction} from './replicache-types.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\n/**\n * The shape which a user's custom mutator definitions must conform to.\n */\nexport type CustomMutatorDefs = {\n  [namespaceOrKey: string]:\n    | {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [key: string]: CustomMutatorImpl<any>;\n      }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | CustomMutatorImpl<any>;\n};\n\nexport type MutatorResult = {\n  client: Promise<void>;\n  server: Promise<MutationOk>;\n};\n\nexport type CustomMutatorImpl<\n  S extends Schema,\n  TWrappedTransaction = unknown,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TArgs = any,\n> = (\n  tx: Transaction<S, TWrappedTransaction>,\n  // TODO: many args. See commit: 52657c2f934b4a458d628ea77e56ce92b61eb3c6 which did have many args.\n  // The issue being that it will be a protocol change to support varargs.\n  args: TArgs,\n) => Promise<void>;\n\n/**\n * The shape exposed on the `Zero.mutate` instance.\n * The signature of a custom mutator takes a `transaction` as its first arg\n * but the user does not provide this arg when calling the mutator.\n *\n * This utility strips the `tx` arg from the user's custom mutator signatures.\n */\nexport type MakeCustomMutatorInterfaces<\n  S extends Schema,\n  MD extends CustomMutatorDefs,\n> = {\n  readonly [NamespaceOrName in keyof MD]: MD[NamespaceOrName] extends (\n    tx: Transaction<S>,\n    ...args: infer Args\n  ) => Promise<void>\n    ? (...args: Args) => MutatorResult\n    : {\n        readonly [P in keyof MD[NamespaceOrName]]: MakeCustomMutatorInterface<\n          S,\n          MD[NamespaceOrName][P]\n        >;\n      };\n};\n\nexport type MakeCustomMutatorInterface<\n  S extends Schema,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  F,\n> = F extends (tx: ClientTransaction<S>, ...args: infer Args) => Promise<void>\n  ? (...args: Args) => MutatorResult\n  : never;\n\nexport class TransactionImpl<S extends Schema> implements ClientTransaction<S> {\n  constructor(lc: ZeroLogContext, repTx: WriteTransaction, schema: S) {\n    const castedRepTx = repTx as WriteTransactionImpl;\n    must(repTx.reason === 'initial' || repTx.reason === 'rebase');\n    this.clientID = repTx.clientID;\n    this.mutationID = repTx.mutationID;\n    this.reason = repTx.reason === 'initial' ? 'optimistic' : 'rebase';\n    const txData = must(\n      castedRepTx[zeroData],\n      'zero was not set on replicache internal options!',\n    );\n    this.mutate = makeSchemaCRUD(\n      schema,\n      repTx,\n      txData.ivmSources as IVMSourceBranch,\n    );\n    this.query = makeSchemaQuery(\n      lc,\n      schema,\n      txData.ivmSources as IVMSourceBranch,\n    );\n    this.token = txData.token;\n  }\n\n  readonly clientID: ClientID;\n  readonly mutationID: number;\n  readonly reason: 'optimistic' | 'rebase';\n  readonly location = 'client';\n  readonly mutate: SchemaCRUD<S>;\n  readonly query: SchemaQuery<S>;\n  readonly token: string | undefined;\n}\n\nexport function makeReplicacheMutator<S extends Schema, TWrappedTransaction>(\n  lc: ZeroLogContext,\n  mutator: CustomMutatorImpl<S, TWrappedTransaction>,\n  schema: S,\n) {\n  return async (\n    repTx: WriteTransaction,\n    args: ReadonlyJSONValue,\n  ): Promise<void> => {\n    const tx = new TransactionImpl(lc, repTx, schema);\n    await mutator(tx, args);\n  };\n}\n\nfunction makeSchemaCRUD<S extends Schema>(\n  schema: S,\n  tx: WriteTransaction,\n  ivmBranch: IVMSourceBranch,\n) {\n  // Only creates the CRUD mutators on demand\n  // rather than creating them all up-front for each mutation.\n  return new Proxy(\n    {},\n    {\n      get(target: Record<string, TableCRUD<TableSchema>>, prop: string) {\n        if (prop in target) {\n          return target[prop];\n        }\n\n        target[prop] = makeTableCRUD(schema, prop, tx, ivmBranch);\n        return target[prop];\n      },\n    },\n  ) as SchemaCRUD<S>;\n}\n\nfunction assertValidRunOptions(options: RunOptions | undefined): void {\n  // TODO(arv): We should enforce this with the type system too.\n  assert(\n    options?.type !== 'complete',\n    'Cannot wait for complete results in custom mutations',\n  );\n}\n\nfunction makeSchemaQuery<S extends Schema>(\n  lc: ZeroLogContext,\n  schema: S,\n  ivmBranch: IVMSourceBranch,\n) {\n  const context = new ZeroContext(\n    lc,\n    ivmBranch,\n    () => emptyFunction,\n    () => emptyFunction,\n    emptyFunction,\n    emptyFunction,\n    emptyFunction,\n    applyViewUpdates => applyViewUpdates(),\n    emptyFunction,\n    assertValidRunOptions,\n  );\n\n  return new Proxy(\n    {},\n    {\n      get(target: Record<string, Query<S, string>>, prop: string) {\n        if (prop in target) {\n          return target[prop];\n        }\n\n        target[prop] = newQuery(context, schema, prop);\n        return target[prop];\n      },\n    },\n  ) as SchemaQuery<S>;\n}\n\nfunction makeTableCRUD(\n  schema: Schema,\n  tableName: string,\n  tx: WriteTransaction,\n  ivmBranch: IVMSourceBranch,\n) {\n  const table = must(schema.tables[tableName]);\n  const {primaryKey} = table;\n  return {\n    insert: (value: InsertValue<TableSchema>) =>\n      insertImpl(\n        tx,\n        {op: 'insert', tableName, primaryKey, value},\n        schema,\n        ivmBranch,\n      ),\n    upsert: (value: UpsertValue<TableSchema>) =>\n      upsertImpl(\n        tx,\n        {op: 'upsert', tableName, primaryKey, value},\n        schema,\n        ivmBranch,\n      ),\n    update: (value: UpdateValue<TableSchema>) =>\n      updateImpl(\n        tx,\n        {op: 'update', tableName, primaryKey, value},\n        schema,\n        ivmBranch,\n      ),\n    delete: (id: DeleteID<TableSchema>) =>\n      deleteImpl(\n        tx,\n        {op: 'delete', tableName, primaryKey, value: id},\n        schema,\n        ivmBranch,\n      ),\n  };\n}\n","import type {Store} from '../../../replicache/src/dag/store.ts';\nimport {\n  getDeletedClients,\n  removeDeletedClients,\n  type DeletedClients,\n} from '../../../replicache/src/deleted-clients.ts';\nimport type {\n  ClientGroupID,\n  ClientID,\n} from '../../../replicache/src/sync/ids.ts';\nimport {\n  withRead,\n  withWrite,\n} from '../../../replicache/src/with-transactions.ts';\nimport {promiseVoid} from '../../../shared/src/resolved-promises.ts';\nimport type {\n  DeleteClientsBody,\n  DeleteClientsMessage,\n} from '../../../zero-protocol/src/delete-clients.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\n/**\n * Replicache will tell us when it deletes clients from the persistent storage\n * due to GC. When this happens we tell the server about the deleted clients.\n * Replicache also store the deleted clients in IDB in case the server is\n * currently offline.\n *\n * The server will reply with the client it actually deleted. When we get that\n * we remove those IDs from our local storage.\n */\nexport class DeleteClientsManager {\n  readonly #send: (msg: DeleteClientsMessage) => void;\n  readonly #lc: ZeroLogContext;\n  readonly #dagStore: Store;\n\n  constructor(\n    send: (msg: DeleteClientsMessage) => void,\n    dagStore: Store,\n    lc: ZeroLogContext,\n  ) {\n    this.#send = send;\n    this.#dagStore = dagStore;\n    this.#lc = lc;\n  }\n\n  /**\n   * This gets called by Replicache when it deletes clients from the persistent\n   * storage.\n   */\n  onClientsDeleted(\n    clientIDs: readonly ClientID[],\n    clientGroupIDs: readonly ClientGroupID[],\n  ): void {\n    this.#lc.debug?.('DeletedClientsManager, send:', clientIDs);\n    this.#send(['deleteClients', {clientIDs, clientGroupIDs}]);\n  }\n\n  /**\n   * Zero calls this after it connects to ensure that the server knows about all\n   * the clients that might have been deleted locally since the last connection.\n   */\n  async sendDeletedClientsToServer(): Promise<void> {\n    const deleted = await withRead(this.#dagStore, dagRead =>\n      getDeletedClients(dagRead),\n    );\n    if (deleted.clientIDs.length > 0 || deleted.clientGroupIDs.length > 0) {\n      this.#send(['deleteClients', deleted]);\n      this.#lc.debug?.('DeletedClientsManager, send:', deleted);\n    }\n  }\n\n  /**\n   * This is called as a response to the server telling us which clients it\n   * actually deleted.\n   */\n  clientsDeletedOnServer(deletedClients: DeleteClientsBody): Promise<void> {\n    const {clientIDs = [], clientGroupIDs = []} = deletedClients;\n    if (clientIDs.length > 0 || clientGroupIDs.length > 0) {\n      // Get the deleted clients from the dag and remove the ones from the server.\n      // then write them back to the dag.\n      return withWrite(this.#dagStore, async dagWrite => {\n        this.#lc.debug?.('clientsDeletedOnServer:', clientIDs, clientGroupIDs);\n        await removeDeletedClients(dagWrite, clientIDs, clientGroupIDs);\n      });\n    }\n    return promiseVoid;\n  }\n\n  getDeletedClients(): Promise<DeletedClients> {\n    return withRead(this.#dagStore, getDeletedClients);\n  }\n}\n","// https://www.oreilly.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\nconst IPV4_ADDRESS_REGEX =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n// This doesn't ensure a valid ipv6, but any ipv6 hostname will\n// match this regex, and no domain based hostnames will.\nconst IPV6_ADDRESS_HOSTNAME_REGEX = /^\\[[a-fA-F0-9:]*:[a-fA-F0-9:]*\\]$/;\n\nexport const IP_ADDRESS_HOSTNAME_REGEX = new RegExp(\n  `(${IPV4_ADDRESS_REGEX.source}|${IPV6_ADDRESS_HOSTNAME_REGEX.source})`,\n);\n\nexport function shouldEnableAnalytics(\n  server: string | null,\n  enableAnalytics = true,\n): boolean {\n  if (!enableAnalytics) {\n    return false;\n  }\n  const serverURL = server === null ? null : new URL(server);\n  const socketHostname = serverURL?.hostname;\n  // If the hostname is undefined, localhost, or an ip address, then\n  // this is most likely a test or local development, in which case we\n  // do not want to enable analytics.\n  return (\n    server !== null &&\n    socketHostname !== undefined &&\n    socketHostname !== 'localhost' &&\n    !IP_ADDRESS_HOSTNAME_REGEX.test(socketHostname)\n  );\n}\n","import {assert} from '../../../shared/src/asserts.ts';\n\nexport type HTTPString = `http${'' | 's'}://${string}`;\n\nexport type WSString = `ws${'' | 's'}://${string}`;\n\nexport function toWSString(url: HTTPString): WSString {\n  return ('ws' + url.slice(4)) as WSString;\n}\n\nexport function toHTTPString(url: WSString): HTTPString {\n  return ('http' + url.slice(2)) as HTTPString;\n}\n\nexport function assertHTTPString(url: string): asserts url is HTTPString {\n  assert(/^https?:\\/\\//.test(url));\n}\n\nexport function assertWSString(url: string): asserts url is WSString {\n  assert(/^wss?:\\/\\//.test(url));\n}\n\nexport function appendPath<T extends HTTPString | WSString>(\n  url: T,\n  toAppend: `/${string}`,\n): T {\n  return (url + (url.endsWith('/') ? toAppend.substring(1) : toAppend)) as T;\n}\n","import {\n  TeeLogSink,\n  consoleLogSink,\n  type Context,\n  type LogLevel,\n  type LogSink,\n} from '@rocicorp/logger';\nimport {\n  DatadogLogSink,\n  type DatadogLogSinkOptions,\n} from '../../../datadog/src/datadog-log-sink.ts';\nimport {appendPath, type HTTPString} from './http-string.ts';\nimport {version} from './version.ts';\n\nclass LevelFilterLogSink implements LogSink {\n  readonly #wrappedLogSink: LogSink;\n  readonly #level: LogLevel;\n\n  constructor(wrappedLogSink: LogSink, level: LogLevel) {\n    this.#wrappedLogSink = wrappedLogSink;\n    this.#level = level;\n  }\n\n  log(level: LogLevel, context: Context | undefined, ...args: unknown[]): void {\n    if (this.#level === 'error' && level !== 'error') {\n      return;\n    }\n    if (this.#level === 'info' && level === 'debug') {\n      return;\n    }\n    this.#wrappedLogSink.log(level, context, ...args);\n  }\n\n  async flush() {\n    await consoleLogSink.flush?.();\n  }\n}\n\nconst DATADOG_LOG_LEVEL = 'info';\nconst ZERO_SASS_DOMAIN = '.reflect-server.net';\n\nexport type LogOptions = {\n  readonly logLevel: LogLevel;\n  readonly logSink: LogSink;\n};\n\nexport function createLogOptions(\n  options: {\n    consoleLogLevel: LogLevel;\n    server: HTTPString | null;\n    enableAnalytics: boolean;\n  },\n  createDatadogLogSink: (options: DatadogLogSinkOptions) => LogSink = (\n    options: DatadogLogSinkOptions,\n  ) => new DatadogLogSink(options),\n): LogOptions {\n  const {consoleLogLevel, server, enableAnalytics} = options;\n\n  if (!enableAnalytics || server === null) {\n    return {\n      logLevel: consoleLogLevel,\n      logSink: consoleLogSink,\n    };\n  }\n\n  const serverURL = new URL(server);\n  const {hostname} = serverURL;\n  const datadogServiceLabel = hostname.endsWith(ZERO_SASS_DOMAIN)\n    ? hostname\n        .substring(0, hostname.length - ZERO_SASS_DOMAIN.length)\n        .toLowerCase()\n    : hostname;\n  const baseURL = new URL(appendPath(server, '/logs/v0/log'));\n  const logLevel = consoleLogLevel === 'debug' ? 'debug' : 'info';\n  const logSink = new TeeLogSink([\n    new LevelFilterLogSink(consoleLogSink, consoleLogLevel),\n    new LevelFilterLogSink(\n      createDatadogLogSink({\n        service: datadogServiceLabel,\n        host: location.host,\n        version,\n        baseURL,\n      }),\n      DATADOG_LOG_LEVEL,\n    ),\n  ]);\n  return {\n    logLevel,\n    logSink,\n  };\n}\n","import {Lock} from '@rocicorp/lock';\nimport type {Context, LogLevel, LogSink} from '@rocicorp/logger';\n\nexport interface DatadogLogSinkOptions {\n  apiKey?: string | undefined;\n  source?: string | undefined;\n  service?: string | undefined;\n  host?: string | undefined;\n  version?: string | undefined;\n  interval?: number | undefined;\n  baseURL?: URL | undefined;\n}\n\nconst DD_BASE_URL = new URL(\n  'https://http-intake.logs.datadoghq.com/api/v2/logs',\n);\n\n// https://docs.datadoghq.com/api/latest/logs/\nexport const MAX_LOG_ENTRIES_PER_FLUSH = 1000;\nexport const FORCE_FLUSH_THRESHOLD = 250;\nconst MAX_ENTRY_BYTES = 5 * 1024 * 1024;\nconst MAX_MESSAGE_RETRIES = 2;\n\n// Conservative limit that assumes all chars are encoded as 4 UTF-8 bytes.\n// This makes the actual limit somewhere closer to 1.25 MB, which is still\n// a reasonable amount of log data to send per request.\nexport const MAX_ENTRY_CHARS = MAX_ENTRY_BYTES / 4;\n\nexport class DatadogLogSink implements LogSink {\n  #messages: Message[] = [];\n  readonly #apiKey: string | undefined;\n  readonly #source: string | undefined;\n  readonly #service: string | undefined;\n  readonly #host: string | undefined;\n  readonly #version: string | undefined;\n  readonly #interval: number;\n  readonly #baseURL: string;\n  #timerID: ReturnType<typeof setTimeout> | 0 = 0;\n  #flushLock = new Lock();\n\n  constructor(options: DatadogLogSinkOptions) {\n    const {\n      apiKey,\n      source,\n      service,\n      host,\n      version,\n      interval = 5_000,\n      baseURL: baseUrl = DD_BASE_URL,\n    } = options;\n\n    this.#apiKey = apiKey;\n    this.#source = source;\n    this.#service = service;\n    this.#host = host;\n    this.#version = version;\n    this.#interval = interval;\n    this.#baseURL = baseUrl.toString();\n  }\n\n  log(level: LogLevel, context: Context | undefined, ...args: unknown[]): void {\n    this.#messages.push(makeMessage(args, context, level));\n    if (level === 'error' || this.#messages.length === FORCE_FLUSH_THRESHOLD) {\n      // Do not await. Later calls to flush will await as needed.\n      void this.flush();\n    } else {\n      this.#startTimer();\n    }\n  }\n  #startTimer() {\n    if (this.#timerID) {\n      return;\n    }\n\n    this.#timerID = setTimeout(() => {\n      this.#timerID = 0;\n\n      void this.flush();\n    }, this.#interval);\n  }\n\n  flush(): Promise<void> {\n    return this.#flushLock.withLock(async () => {\n      const {length} = this.#messages;\n      if (length === 0) {\n        return;\n      }\n      do {\n        const flushTime = Date.now();\n        const stringified = [];\n        let totalBytes = 0;\n\n        for (const m of this.#messages) {\n          // As a small perf optimization, we directly mutate\n          // the message rather than making a shallow copy.\n          // The LOG_SINK_FLUSH_DELAY_ATTRIBUTE will be clobbered by\n          // the next flush if this flush fails (which is the desired behavior).\n          m.flushDelayMs = flushTime - m.date;\n\n          let str = JSON.stringify(m);\n          if (str.length > MAX_ENTRY_CHARS) {\n            // A single message above the total payload limit will otherwise halt\n            // log flushing progress. Drop and replace with a message indicating so.\n            m.message = `[Dropped message of length ${str.length}]`;\n            str = JSON.stringify(m);\n          }\n          // Calculate the totalBytes with the newline characters between messages.\n          if (str.length + totalBytes + stringified.length > MAX_ENTRY_CHARS) {\n            break;\n          }\n          totalBytes += str.length;\n          stringified.push(str);\n\n          if (stringified.length === MAX_LOG_ENTRIES_PER_FLUSH) {\n            break;\n          }\n        }\n\n        const body = stringified.join('\\n');\n        const url = new URL(this.#baseURL);\n        if (this.#apiKey !== undefined) {\n          url.searchParams.set('dd-api-key', this.#apiKey);\n        }\n\n        if (this.#source) {\n          // Both need to be set for server to treat us as the browser SDK for\n          // value 'browser'.\n          url.searchParams.set('ddsource', this.#source);\n          url.searchParams.set('dd-evp-origin', this.#source);\n        }\n\n        if (this.#service) {\n          url.searchParams.set('service', this.#service);\n        }\n\n        if (this.#host) {\n          url.searchParams.set('host', this.#host);\n        }\n\n        if (this.#version) {\n          url.searchParams.set('ddtags', `version:${this.#version}`);\n        }\n\n        let ok = false;\n        try {\n          const response = await fetch(url.toString(), {\n            method: 'POST',\n            body,\n            keepalive: true,\n          } as RequestInit);\n\n          ok = response.ok;\n          if (!ok) {\n            // Log to console so that we might catch this in `wrangler tail`.\n            // eslint-disable-next-line no-console\n            console.error(\n              'response',\n              response.status,\n              response.statusText,\n              await response.text,\n            );\n          }\n        } catch (e) {\n          // Log to console so that we might catch this in `wrangler tail`.\n          // eslint-disable-next-line no-console\n          console.error('Log flush to datadog failed', e);\n        }\n\n        if (ok) {\n          // Remove messages that were successfully flushed.\n          this.#messages.splice(0, stringified.length);\n        } else {\n          let numWithTooManyRetries = 0;\n          for (let i = 0; i < stringified.length; i++) {\n            const m = this.#messages[i];\n            m.flushRetryCount = (m.flushRetryCount ?? 0) + 1;\n            if (m.flushRetryCount > MAX_MESSAGE_RETRIES) {\n              numWithTooManyRetries++;\n            }\n          }\n          if (numWithTooManyRetries > 0) {\n            // eslint-disable-next-line no-console\n            console.error(\n              `Dropping ${numWithTooManyRetries} datadog log messages which failed to send ${\n                MAX_MESSAGE_RETRIES + 1\n              } times.`,\n            );\n            // Remove messages that have failed too many times.\n            this.#messages.splice(0, numWithTooManyRetries);\n          }\n        }\n      } while (this.#messages.length >= FORCE_FLUSH_THRESHOLD);\n      // If any messages left at this point schedule another flush.\n      if (this.#messages.length) {\n        this.#startTimer();\n      }\n    });\n  }\n}\n\ntype Message = Context & {\n  status: LogLevel;\n  date: number;\n  message: unknown;\n  error?: {origin: 'logger'};\n  flushDelayMs?: number;\n  flushRetryCount?: number;\n};\n\nfunction flattenMessage(message: unknown): unknown {\n  if (Array.isArray(message) && message.length === 1) {\n    return flattenMessage(message[0]);\n  }\n  return message;\n}\n\nfunction convertError(e: Error): {\n  name: string;\n  message: string;\n  stack: string | undefined;\n} {\n  return {\n    name: e.name,\n    message: e.message,\n    stack: e.stack,\n  };\n}\n\nfunction convertErrors(message: unknown): unknown {\n  if (message instanceof Error) {\n    return convertError(message);\n  }\n  if (message instanceof Array) {\n    const convertedMessage: unknown[] = [];\n    for (const item of message) {\n      if (item instanceof Error) {\n        convertedMessage.push(convertError(item));\n      } else {\n        convertedMessage.push(item);\n      }\n    }\n    return convertedMessage;\n  }\n  return message;\n}\n\nconst LOG_SINK_FLUSH_RETRY_COUNT = 'flushRetryCount';\nconst LOG_SINK_FLUSH_DELAY_ATTRIBUTE = 'flushDelayMs';\n// This code assumes that no context keys will start with\n// @DATADOG_RESERVED_ (a fairly safe assumption).\nconst RESERVED_KEY_PREFIX = '@DATADOG_RESERVED_';\n// See https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#reserved-attributes\n// Note 'msg' and 'date' are not documented.\n// We should avoid using these as context keys.  We escape them here\n// because otherwise the impact on the data dog log UI is very confusing\n// (e.g. using 'msg' as a context key results, in the context value\n// replacing the log message.)\nconst RESERVED_KEYS: ReadonlyArray<string> = [\n  'host',\n  'source',\n  'status',\n  'service',\n  'version',\n  'trace_id',\n  'message',\n  'msg', // alias for message\n  'date',\n  // The following are attributes reserved by the DataDogLogSink\n  // itself (as opposed to DataDog), to report on its own behavior.\n  LOG_SINK_FLUSH_DELAY_ATTRIBUTE,\n  LOG_SINK_FLUSH_RETRY_COUNT,\n];\n\nfunction makeMessage(\n  message: unknown,\n  context: Context | undefined,\n  logLevel: LogLevel,\n): Message {\n  let safeContext = undefined;\n  if (context !== undefined) {\n    for (const reservedKey of RESERVED_KEYS) {\n      if (Object.hasOwn(context, reservedKey)) {\n        if (safeContext === undefined) {\n          safeContext = {...context};\n        }\n        safeContext[RESERVED_KEY_PREFIX + reservedKey] =\n          safeContext[reservedKey];\n        delete safeContext[reservedKey];\n      }\n    }\n  }\n  const msg: Message = {\n    ...(safeContext ?? context),\n    date: Date.now(),\n    message: convertErrors(flattenMessage(message)),\n    status: logLevel,\n  };\n  if (logLevel === 'error') {\n    msg.error = {origin: 'logger'};\n  }\n  return msg;\n}\n","// The env value should be filled in by esbuild.\n\ndeclare const process: {\n  env: {\n    ['ZERO_VERSION']?: string;\n  };\n};\n\n/**\n * The current version of Zero.\n */\nexport const version = process.env.ZERO_VERSION ?? '0.0.0';\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const TimeToConnectMs = 'time_to_connect_ms';\nexport const LastConnectError = 'last_connect_error';\nexport const TimeToConnectMsV2 = 'time_to_connect_ms_v2';\nexport const LastConnectErrorV2 = 'last_connect_error_v2';\nexport const TotalTimeToConnectMs = 'total_time_to_connect_ms';\nexport const NotConnected = 'not_connected';\n\nexport type TimeToConnectMs = typeof TimeToConnectMs;\nexport type LastConnectError = typeof LastConnectError;\nexport type TimeToConnectMsV2 = typeof TimeToConnectMsV2;\nexport type LastConnectErrorV2 = typeof LastConnectErrorV2;\nexport type TotalTimeToConnectMs = typeof TotalTimeToConnectMs;\nexport type NotConnected = typeof NotConnected;\n","import type {MaybePromise} from '../../../shared/src/types.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport * as MetricName from './metric-name-enum.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\n// This value is used to indicate that the client's last connection attempt\n// failed. We don't make this -1 because we want to stack this never connected\n// state in a graph on top of actual connection times, so it should be greater\n// than any other value.\nexport const DID_NOT_CONNECT_VALUE = 100 * 1000;\n\nexport const REPORT_INTERVAL_MS = 5_000;\n\ntype ClientDisconnectReason =\n  | 'AbruptClose'\n  | 'CleanClose'\n  | 'ClientClosed'\n  | 'ConnectTimeout'\n  | 'UnexpectedBaseCookie'\n  | 'PingTimeout'\n  | 'Hidden';\n\ntype NotConnectedReason =\n  | 'init'\n  | 'error'\n  | 'hidden'\n  | 'hidden_was_init'\n  | 'hidden_was_error';\n\nexport type DisconnectReason =\n  | {\n      server: ErrorKind;\n    }\n  | {\n      client: ClientDisconnectReason;\n    };\n\nexport function getLastConnectErrorValue(reason: DisconnectReason): string {\n  if ('server' in reason) {\n    return `server_${camelToSnake(reason.server)}`;\n  }\n  return `client_${camelToSnake(reason.client)}`;\n}\n\n// camelToSnake is used to convert a protocol ErrorKind into a suitable\n// metric name, eg AuthInvalidated => auth_invalidated. It converts\n// both PascalCase and camelCase to snake_case.\nfunction camelToSnake(s: string): string {\n  return s\n    .split(/\\.?(?=[A-Z])/)\n    .join('_')\n    .toLowerCase();\n}\n\ntype MetricsReporter = (metrics: Series[]) => MaybePromise<void>;\n\nexport type MetricManagerOptions = {\n  reportIntervalMs: number;\n  host: string;\n  source: string;\n  reporter: MetricsReporter;\n  lc: ZeroLogContext;\n};\n\n/**\n * MetricManager keeps track of the set of metrics in use and flushes them\n * to a format suitable for reporting.\n */\nexport class MetricManager {\n  #reportIntervalMs: number;\n  #host: string;\n  #reporter: MetricsReporter;\n  #lc: ZeroLogContext;\n  #timerID: ReturnType<typeof setInterval> | null;\n\n  constructor(opts: MetricManagerOptions) {\n    this.#reportIntervalMs = opts.reportIntervalMs;\n    this.#host = opts.host;\n    this.#reporter = opts.reporter;\n    this.#lc = opts.lc;\n\n    this.tags.push(`source:${opts.source}`);\n\n    this.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n    this.#setNotConnectedReason('init');\n\n    this.#timerID = setInterval(() => {\n      void this.flush();\n    }, this.#reportIntervalMs);\n  }\n\n  #metrics: Flushable[] = [];\n\n  // timeToConnectMs measures the time from the call to connect() to receiving\n  // the 'connected' ws message. We record the DID_NOT_CONNECT_VALUE if the previous\n  // connection attempt failed for any reason.\n  //\n  // We set the gauge using #connectStart as follows:\n  // - #connectStart is undefined if we are disconnected or connected; it is\n  //   defined only in the Connecting state, as a number representing the timestamp\n  //   at which we started connecting.\n  // - #connectStart is set to the current time when connect() is called.\n  // - When we receive the 'connected' message we record the time to connect and\n  //   set #connectStart to undefined.\n  // - If disconnect() is called with a defined #connectStart then we record\n  //   DID_NOT_CONNECT_VALUE and set #connectStart to undefined.\n  //\n  // TODO It's clear after playing with the connection code we should encapsulate\n  // the ConnectionState along with its state transitions and possibly behavior.\n  // In that world the metric gauge(s) and bookkeeping like #connectStart would\n  // be encapsulated with the ConnectionState. This will probably happen as part\n  // of https://github.com/rocicorp/reflect-server/issues/255.\n  readonly timeToConnectMs = this.#register(\n    new Gauge(MetricName.TimeToConnectMs),\n  );\n\n  // lastConnectError records the last error that occurred when connecting,\n  // if any. It is cleared when connecting successfully or when reported, so this\n  // state only gets reported if there was a failure during the reporting period and\n  // we are still not connected.\n  readonly lastConnectError = this.#register(\n    new State(\n      MetricName.LastConnectError,\n      true, // clearOnFlush\n    ),\n  );\n\n  // notConnected records the reason why the client is not currently connected.\n  // It is cleared when the client successfully connects.\n  readonly #notConnected = this.#register(new State(MetricName.NotConnected));\n\n  // The time from the call to connect() to receiving the 'connected' ws message\n  // for the current connection.  Cleared when the client is not connected.\n  // TODO: Not actually currently cleared on disconnect untill there is a\n  // connect error, or client reports disconnected and waiting for visible.\n  // Should have a value iff _notConnected has no value.\n  readonly #timeToConnectMsV2 = this.#register(\n    new Gauge(MetricName.TimeToConnectMsV2),\n  );\n\n  // lastConnectErrorV2 records the last error that occurred when connecting,\n  // if any. It is cleared when the client successfully connects or\n  // stops trying to connect due to being hidden.\n  // Should have a value iff notConnected state is NotConnectedReason.Error.\n  readonly #lastConnectErrorV2 = this.#register(\n    new State(MetricName.LastConnectErrorV2),\n  );\n\n  // The total time it took to connect across retries for the current\n  // connection.  Cleared when the client is not connected.\n  // TODO: Not actually currently cleared on disconnect until there is a\n  // connect error, or client reports disconnected and waiting for visible.\n  // See Zero.#totalToConnectStart for details of how this total is computed.\n  // Should have a value iff _notConnected has no value.\n  readonly #totalTimeToConnectMs = this.#register(\n    new Gauge(MetricName.TotalTimeToConnectMs),\n  );\n\n  #setNotConnectedReason(reason: NotConnectedReason) {\n    this.#notConnected.set(reason);\n  }\n\n  setConnected(timeToConnectMs: number, totalTimeToConnectMs: number) {\n    this.#notConnected.clear();\n    this.#lastConnectErrorV2.clear();\n    this.#timeToConnectMsV2.set(timeToConnectMs);\n    this.#totalTimeToConnectMs.set(totalTimeToConnectMs);\n  }\n\n  setDisconnectedWaitingForVisible() {\n    this.#timeToConnectMsV2.clear();\n    this.#totalTimeToConnectMs.clear();\n    this.#lastConnectErrorV2.clear();\n    let notConnectedReason: NotConnectedReason;\n    switch (this.#notConnected.get()) {\n      case 'init':\n        notConnectedReason = 'hidden_was_init';\n        break;\n      case 'error':\n        notConnectedReason = 'hidden_was_error';\n        break;\n      default:\n        notConnectedReason = 'hidden';\n        break;\n    }\n    this.#setNotConnectedReason(notConnectedReason);\n  }\n\n  setConnectError(reason: DisconnectReason) {\n    this.#timeToConnectMsV2.clear();\n    this.#totalTimeToConnectMs.clear();\n    this.#setNotConnectedReason('error');\n    this.#lastConnectErrorV2.set(getLastConnectErrorValue(reason));\n  }\n\n  /**\n   * Tags to include in all metrics.\n   */\n  readonly tags: string[] = [];\n\n  // Flushes all metrics to an array of time series (plural), one Series\n  // per metric.\n  async flush() {\n    const lc = this.#lc;\n    if (this.#timerID === null) {\n      lc.error?.('MetricManager.flush() called but already stopped');\n      return;\n    }\n    const allSeries: Series[] = [];\n    for (const metric of this.#metrics) {\n      const series = metric.flush();\n      if (series !== undefined) {\n        allSeries.push({\n          ...series,\n          host: this.#host,\n          tags: this.tags,\n        });\n      }\n    }\n    if (allSeries.length === 0) {\n      lc?.debug?.('No metrics to report');\n      return;\n    }\n    try {\n      await this.#reporter(allSeries);\n    } catch (e) {\n      lc?.error?.('Error reporting metrics', e);\n    }\n  }\n\n  stop() {\n    if (this.#timerID === null) {\n      this.#lc.error?.('MetricManager.stop() called but already stopped');\n      return;\n    }\n    clearInterval(this.#timerID);\n    this.#timerID = null;\n  }\n\n  #register<M extends Flushable>(metric: M) {\n    this.#metrics.push(metric);\n    return metric;\n  }\n}\n\n// These two types are influenced by Datadog's API's needs. We could change what\n// we use internally if necessary, but we'd just have to convert to/from before\n// sending to DD. So for convenience we go with their format.\n\n/** Series is a time series of points for a single metric. */\nexport type Series = {\n  host: string;\n  metric: string; // We call this 'name' bc 'metric' is overloaded in code.\n  points: Point[];\n  tags?: string[];\n};\n/**\n * A point is a second-resolution timestamp and a set of values for that\n * timestamp. A point represents exactly one second in time and the values\n * are those recorded for that second. The first element of this array\n * is the timestamp and the second element is an array of values.\n */\nexport type Point = [number, number[]];\n\nfunction makePoint(ts: number, value: number): Point {\n  return [ts, [value]];\n}\n\ntype Flushable = {\n  flush(): Pick<Series, 'metric' | 'points'> | undefined;\n};\n\n/**\n * Gauge is a metric type that represents a single value that can go up and\n * down. It's typically used to track discrete values or counts eg the number\n * of active users, number of connections, cpu load, etc. A gauge retains\n * its value when flushed.\n *\n * We use a Gauge to sample at the client. If we are interested in tracking\n * a metric value *per client*, the client can note the latest value in\n * a Gauge metric. The metric is periodically reported via Reporter. On the\n * server, we graph the value of the metric rolled up over the periodic\n * reporting period, that is, counted over a span of time equal to the\n * reporting period. The result is ~one point per client per reporting\n * period.\n */\nexport class Gauge implements Flushable {\n  readonly #name: string;\n  #value: number | undefined = undefined;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  set(value: number) {\n    this.#value = value;\n  }\n\n  get() {\n    return this.#value;\n  }\n\n  clear() {\n    this.#value = undefined;\n  }\n\n  flush() {\n    if (this.#value === undefined) {\n      return undefined;\n    }\n    // Gauge reports the timestamp at flush time, not at the point the value was\n    // recorded.\n    const points = [makePoint(t(), this.#value)];\n    return {metric: this.#name, points};\n  }\n}\n\nfunction t() {\n  return Math.round(Date.now() / 1000);\n}\n\n/**\n * State is a metric type that represents a specific state that the system is\n * in, for example the state of a connection which may be 'open' or 'closed'.\n * The state is given a name/prefix at construction time (eg 'connection') and\n * then can be set to a specific state (eg 'open'). The prefix is prepended to\n * the set state (eg, 'connection_open') and a value of 1 is reported.\n * Unset/cleared states are not reported.\n *\n * Example:\n *   const s = new State('connection');\n *   s.set('open');\n *   s.flush(); // returns {metric: 'connection_open', points: [[now(), [1]]]}\n */\nexport class State implements Flushable {\n  readonly #prefix: string;\n  readonly #clearOnFlush: boolean;\n  #current: string | undefined = undefined;\n\n  constructor(prefix: string, clearOnFlush = false) {\n    this.#prefix = prefix;\n    this.#clearOnFlush = clearOnFlush;\n  }\n\n  set(state: string) {\n    this.#current = state;\n  }\n\n  get() {\n    return this.#current;\n  }\n\n  clear() {\n    this.#current = undefined;\n  }\n\n  flush() {\n    if (this.#current === undefined) {\n      return undefined;\n    }\n    const gauge = new Gauge([this.#prefix, this.#current].join('_'));\n    gauge.set(1);\n    const series = gauge.flush();\n    if (this.#clearOnFlush) {\n      this.clear();\n    }\n    return series;\n  }\n}\n","import {resolver, type Resolver} from '@rocicorp/resolver';\nimport type {\n  EphemeralID,\n  MutationTrackingData,\n} from '../../../replicache/src/replicache-options.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport {emptyObject} from '../../../shared/src/sentinels.ts';\nimport {\n  mutationResultSchema,\n  type MutationError,\n  type MutationID,\n  type MutationOk,\n  type PushError,\n  type PushOk,\n  type PushResponse,\n} from '../../../zero-protocol/src/push.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\nimport type {ReplicacheImpl} from '../../../replicache/src/impl.ts';\nimport {MUTATIONS_KEY_PREFIX} from './keys.ts';\nimport type {NoIndexDiff} from '../../../replicache/src/btree/node.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport * as v from '../../../shared/src/valita.ts';\n\ntype ErrorType =\n  | MutationError\n  | Omit<PushError, 'mutationIDs'>\n  | Error\n  | unknown;\n\nlet currentEphemeralID = 0;\nfunction nextEphemeralID(): EphemeralID {\n  return ++currentEphemeralID as EphemeralID;\n}\n\n/**\n * Tracks what pushes are in-flight and resolves promises when they're acked.\n */\nexport class MutationTracker {\n  readonly #outstandingMutations: Map<\n    EphemeralID,\n    {\n      mutationID?: number | undefined;\n      resolver: Resolver<MutationOk, ErrorType>;\n    }\n  >;\n  readonly #ephemeralIDsByMutationID: Map<number, EphemeralID>;\n  readonly #allMutationsAppliedListeners: Set<() => void>;\n  readonly #lc: ZeroLogContext;\n\n  readonly #ackMutations: (upTo: MutationID) => void;\n  #clientID: string | undefined;\n  #largestOutstandingMutationID: number;\n  #currentMutationID: number;\n\n  constructor(lc: ZeroLogContext, ackMutations: (upTo: MutationID) => void) {\n    this.#lc = lc.withContext('MutationTracker');\n    this.#outstandingMutations = new Map();\n    this.#ephemeralIDsByMutationID = new Map();\n    this.#allMutationsAppliedListeners = new Set();\n    this.#largestOutstandingMutationID = 0;\n    this.#currentMutationID = 0;\n    this.#ackMutations = ackMutations;\n  }\n\n  setClientIDAndWatch(\n    clientID: string,\n    experimentalWatch: ReplicacheImpl['experimentalWatch'],\n  ) {\n    assert(this.#clientID === undefined, 'clientID already set');\n    this.#clientID = clientID;\n    experimentalWatch(\n      diffs => {\n        this.#processMutationResponses(diffs);\n      },\n      {\n        prefix: MUTATIONS_KEY_PREFIX + clientID + '/',\n        initialValuesInFirstDiff: true,\n      },\n    );\n  }\n\n  trackMutation(): MutationTrackingData {\n    const id = nextEphemeralID();\n    const mutationResolver = resolver<MutationOk, ErrorType>();\n\n    this.#outstandingMutations.set(id, {\n      resolver: mutationResolver,\n    });\n    return {ephemeralID: id, serverPromise: mutationResolver.promise};\n  }\n\n  mutationIDAssigned(id: EphemeralID, mutationID: number): void {\n    const entry = this.#outstandingMutations.get(id);\n    if (entry) {\n      entry.mutationID = mutationID;\n      this.#ephemeralIDsByMutationID.set(mutationID, id);\n      this.#largestOutstandingMutationID = Math.max(\n        this.#largestOutstandingMutationID,\n        mutationID,\n      );\n    }\n  }\n\n  /**\n   * Reject the mutation due to an unhandled exception on the client.\n   * The mutation must not have been persisted to the client store.\n   */\n  rejectMutation(id: EphemeralID, e: unknown): void {\n    const entry = this.#outstandingMutations.get(id);\n    if (entry) {\n      this.#settleMutation(id, entry, 'reject', e);\n    }\n  }\n\n  /**\n   * Used when zero-cache pokes down mutation results.\n   */\n  #processMutationResponses(diffs: NoIndexDiff): void {\n    const clientID = must(this.#clientID);\n    let largestLmid = 0;\n    for (const diff of diffs) {\n      const mutationID = Number(\n        diff.key.slice(MUTATIONS_KEY_PREFIX.length + clientID.length + 1),\n      );\n      assert(\n        !isNaN(mutationID),\n        `MutationTracker received a diff with an invalid mutation ID: ${diff.key}`,\n      );\n      largestLmid = Math.max(largestLmid, mutationID);\n      switch (diff.op) {\n        case 'add': {\n          const result = v.parse(diff.newValue, mutationResultSchema);\n          if ('error' in result) {\n            this.#processMutationError(clientID, mutationID, result);\n          } else {\n            this.#processMutationOk(clientID, mutationID, result);\n          }\n          break;\n        }\n        case 'del':\n          break;\n        case 'change':\n          throw new Error('MutationTracker does not expect change operations');\n      }\n    }\n\n    if (largestLmid > 0) {\n      this.#ackMutations({\n        clientID: must(this.#clientID),\n        id: largestLmid,\n      });\n    }\n  }\n\n  processPushResponse(response: PushResponse): void {\n    if ('error' in response) {\n      this.#lc.error?.(\n        'Received an error response when pushing mutations',\n        response,\n      );\n    } else {\n      this.#processPushOk(response);\n    }\n  }\n\n  /**\n   * DEPRECATED: to be removed when we switch to fully driving\n   * mutation resolution via poke.\n   *\n   * When we reconnect to zero-cache, we resolve all outstanding mutations\n   * whose ID is less than or equal to the lastMutationID.\n   *\n   * The reason is that any responses the API server sent\n   * to those mutations have been lost.\n   *\n   * An example case: the API server responds while the connection\n   * is down. Those responses are lost.\n   *\n   * Mutations whose LMID is > the lastMutationID are not resolved\n   * since they will be retried by the client, giving us another chance\n   * at getting a response.\n   *\n   * The only way to ensure that all API server responses are\n   * received would be to have the API server write them\n   * to the DB while writing the LMID.\n   */\n  onConnected(lastMutationID: number) {\n    this.lmidAdvanced(lastMutationID);\n  }\n\n  /**\n   * lmid advance will:\n   * 1. notify \"allMutationsApplied\" listeners if the lastMutationID\n   *    is greater than or equal to the largest outstanding mutation ID.\n   * 2. resolve all mutations whose mutation ID is less than or equal to\n   *    the lastMutationID.\n   */\n  lmidAdvanced(lastMutationID: number): void {\n    assert(\n      lastMutationID >= this.#currentMutationID,\n      'lmid must be greater than or equal to current lmid',\n    );\n    if (lastMutationID === this.#currentMutationID) {\n      return;\n    }\n\n    try {\n      this.#currentMutationID = lastMutationID;\n      this.#resolveMutations(lastMutationID);\n    } finally {\n      if (lastMutationID >= this.#largestOutstandingMutationID) {\n        // this is very important otherwise we hang query de-registration\n        this.#notifyAllMutationsAppliedListeners();\n      }\n    }\n  }\n\n  get size() {\n    return this.#outstandingMutations.size;\n  }\n\n  #resolveMutations(upTo: number): void {\n    // We resolve all mutations whose mutation ID is less than or equal to\n    // the upTo mutation ID.\n    for (const [id, entry] of this.#outstandingMutations) {\n      if (entry.mutationID && entry.mutationID <= upTo) {\n        this.#settleMutation(id, entry, 'resolve', emptyObject);\n      } else {\n        break; // the map is in insertion order which is in mutation ID order\n      }\n    }\n  }\n\n  #processPushOk(ok: PushOk): void {\n    for (const mutation of ok.mutations) {\n      if ('error' in mutation.result) {\n        this.#processMutationError(\n          mutation.id.clientID,\n          mutation.id.id,\n          mutation.result,\n        );\n      } else {\n        this.#processMutationOk(\n          mutation.id.clientID,\n          mutation.id.id,\n          mutation.result,\n        );\n      }\n    }\n  }\n\n  #processMutationError(\n    clientID: string,\n    mid: number,\n    error: MutationError | Omit<PushError, 'mutationIDs'>,\n  ): void {\n    assert(\n      clientID === this.#clientID,\n      'received mutation for the wrong client',\n    );\n\n    const ephemeralID = this.#ephemeralIDsByMutationID.get(mid);\n    if (!ephemeralID && error.error === 'alreadyProcessed') {\n      return;\n    }\n\n    // Each tab sends all mutations for the client group\n    // and the server responds back to the individual client that actually\n    // ran the mutation. This means that N clients can send the same\n    // mutation concurrently. If that happens, the promise for the mutation tracked\n    // by this class will try to be resolved N times.\n    // Every time after the first, the ephemeral ID will not be\n    // found in the map. These later times, however, should always have been\n    // \"mutation already processed\" events which we ignore (above).\n    assert(\n      ephemeralID,\n      `ephemeral ID is missing for mutation error: ${error.error}.`,\n    );\n\n    const entry = this.#outstandingMutations.get(ephemeralID);\n    assert(entry && entry.mutationID === mid);\n    // Resolving the promise with an error was an intentional API decision\n    // so the user receives typed errors.\n    this.#settleMutation(ephemeralID, entry, 'reject', error);\n  }\n\n  #processMutationOk(clientID: string, mid: number, result: MutationOk): void {\n    assert(\n      clientID === this.#clientID,\n      'received mutation for the wrong client',\n    );\n\n    const ephemeralID = this.#ephemeralIDsByMutationID.get(mid);\n    assert(\n      ephemeralID,\n      'ephemeral ID is missing. This can happen if a mutation response is received twice ' +\n        'but it should be impossible to receive a success response twice for the same mutation.',\n    );\n    const entry = this.#outstandingMutations.get(ephemeralID);\n    assert(entry && entry.mutationID === mid);\n    this.#settleMutation(ephemeralID, entry, 'resolve', result);\n  }\n\n  #settleMutation<Type extends 'resolve' | 'reject'>(\n    ephemeralID: EphemeralID,\n    entry: {\n      mutationID?: number | undefined;\n      resolver: Resolver<MutationOk, ErrorType>;\n    },\n    type: Type,\n    result: 'resolve' extends Type ? MutationOk : unknown,\n  ): void {\n    switch (type) {\n      case 'resolve':\n        entry.resolver.resolve(result as MutationOk);\n        break;\n      case 'reject':\n        entry.resolver.reject(result);\n        break;\n    }\n\n    this.#outstandingMutations.delete(ephemeralID);\n    if (entry.mutationID) {\n      this.#ephemeralIDsByMutationID.delete(entry.mutationID);\n    }\n  }\n\n  /**\n   * Be notified when all mutations have been included in the server snapshot.\n   *\n   * The query manager will not de-register queries from the server until there\n   * are no pending mutations.\n   *\n   * The reason is that a mutation may need to be rebased. We do not want\n   * data that was available the first time it was run to not be available\n   * on a rebase.\n   */\n  onAllMutationsApplied(listener: () => void): void {\n    this.#allMutationsAppliedListeners.add(listener);\n  }\n\n  #notifyAllMutationsAppliedListeners() {\n    for (const listener of this.#allMutationsAppliedListeners) {\n      listener();\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const TimedOut = 0;\nexport const Success = 1;\n\nexport type TimedOut = typeof TimedOut;\nexport type Success = typeof Success;\n","import type {ReplicacheImpl} from '../../../replicache/src/replicache-impl.ts';\nimport type {ClientID} from '../../../replicache/src/sync/ids.ts';\nimport {assert} from '../../../shared/src/asserts.ts';\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport {TDigest} from '../../../shared/src/tdigest.ts';\nimport {\n  mapAST,\n  normalizeAST,\n  type AST,\n} from '../../../zero-protocol/src/ast.ts';\nimport type {ChangeDesiredQueriesMessage} from '../../../zero-protocol/src/change-desired-queries.ts';\nimport type {UpQueriesPatchOp} from '../../../zero-protocol/src/queries-patch.ts';\nimport {\n  hashOfAST,\n  hashOfNameAndArgs,\n} from '../../../zero-protocol/src/query-hash.ts';\nimport {\n  clientToServer,\n  serverToClient,\n  type NameMapper,\n} from '../../../zero-schema/src/name-mapper.ts';\nimport type {TableSchema} from '../../../zero-schema/src/table-schema.ts';\nimport type {ClientMetricMap} from '../../../zql/src/query/metrics-delegate.ts';\nimport type {CustomQueryID} from '../../../zql/src/query/named.ts';\nimport type {GotCallback} from '../../../zql/src/query/query-delegate.ts';\nimport {clampTTL, compareTTL, type TTL} from '../../../zql/src/query/ttl.ts';\nimport type {InspectorDelegate} from './inspector/inspector.ts';\nimport {desiredQueriesPrefixForClient, GOT_QUERIES_KEY_PREFIX} from './keys.ts';\nimport type {MutationTracker} from './mutation-tracker.ts';\nimport type {ReadTransaction} from './replicache-types.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\ntype QueryHash = string;\n\ntype Entry = {\n  // We keep track of the AST so we can use it in the inspector.\n  normalized: AST;\n  name: string | undefined;\n  args: readonly ReadonlyJSONValue[] | undefined;\n  count: number;\n  gotCallbacks: GotCallback[];\n  ttl: TTL;\n};\n\ntype ClientMetric = {\n  [K in keyof ClientMetricMap]: TDigest;\n};\n\n/**\n * Tracks what queries the client is currently subscribed to on the server.\n * Sends `changeDesiredQueries` message to server when this changes.\n * Deduplicates requests so that we only listen to a given unique query once.\n */\nexport class QueryManager implements InspectorDelegate {\n  readonly #clientID: ClientID;\n  readonly #clientToServer: NameMapper;\n  readonly #serverToClient: NameMapper;\n  readonly #send: (change: ChangeDesiredQueriesMessage) => void;\n  readonly #queries: Map<QueryHash, Entry> = new Map();\n  readonly #recentQueriesMaxSize: number;\n  readonly #recentQueries: Set<string> = new Set();\n  readonly #gotQueries: Set<string> = new Set();\n  readonly #mutationTracker: MutationTracker;\n  readonly #pendingQueryChanges: UpQueriesPatchOp[] = [];\n  readonly #queryChangeThrottleMs: number;\n  #pendingRemovals: Array<() => void> = [];\n  #batchTimer: ReturnType<typeof setTimeout> | undefined;\n  readonly #lc: ZeroLogContext;\n  readonly #metrics: ClientMetric = newMetrics();\n  readonly #queryMetrics: Map<string, ClientMetric> = new Map();\n  readonly #slowMaterializeThreshold: number;\n\n  constructor(\n    lc: ZeroLogContext,\n    mutationTracker: MutationTracker,\n    clientID: ClientID,\n    tables: Record<string, TableSchema>,\n    send: (change: ChangeDesiredQueriesMessage) => void,\n    experimentalWatch: ReplicacheImpl['experimentalWatch'],\n    recentQueriesMaxSize: number,\n    queryChangeThrottleMs: number,\n    slowMaterializeThreshold: number,\n  ) {\n    this.#lc = lc.withContext('QueryManager');\n    this.#clientID = clientID;\n    this.#clientToServer = clientToServer(tables);\n    this.#serverToClient = serverToClient(tables);\n    this.#recentQueriesMaxSize = recentQueriesMaxSize;\n    this.#send = send;\n    this.#mutationTracker = mutationTracker;\n    this.#queryChangeThrottleMs = queryChangeThrottleMs;\n    this.#slowMaterializeThreshold = slowMaterializeThreshold;\n\n    this.#mutationTracker.onAllMutationsApplied(() => {\n      if (this.#pendingRemovals.length === 0) {\n        return;\n      }\n      const pendingRemovals = this.#pendingRemovals;\n      this.#pendingRemovals = [];\n      for (const removal of pendingRemovals) {\n        removal();\n      }\n    });\n\n    experimentalWatch(\n      diff => {\n        for (const diffOp of diff) {\n          const queryHash = diffOp.key.substring(GOT_QUERIES_KEY_PREFIX.length);\n          switch (diffOp.op) {\n            case 'add':\n              this.#gotQueries.add(queryHash);\n              this.#fireGotCallbacks(queryHash, true);\n              break;\n            case 'del':\n              this.#gotQueries.delete(queryHash);\n              this.#fireGotCallbacks(queryHash, false);\n              break;\n          }\n        }\n      },\n      {\n        prefix: GOT_QUERIES_KEY_PREFIX,\n        initialValuesInFirstDiff: true,\n      },\n    );\n  }\n\n  getAST(queryID: string): AST | undefined {\n    const ast = this.#queries.get(queryID)?.normalized;\n    return ast && mapAST(ast, this.#serverToClient);\n  }\n\n  #fireGotCallbacks(queryHash: string, got: boolean) {\n    const gotCallbacks = this.#queries.get(queryHash)?.gotCallbacks ?? [];\n    for (const gotCallback of gotCallbacks) {\n      gotCallback(got);\n    }\n  }\n\n  /**\n   * Get the queries that need to be registered with the server.\n   *\n   * An optional `lastPatch` can be provided. This is the last patch that was\n   * sent to the server and may not yet have been acked. If `lastPatch` is provided,\n   * this method will return a patch that does not include any events sent in `lastPatch`.\n   *\n   * This diffing of last patch and current patch is needed since we send\n   * a set of queries to the server when we first connect inside of the `sec-protocol` as\n   * the `initConnectionMessage`.\n   *\n   * While we're waiting for the `connected` response to come back from the server,\n   * the client may have registered more queries. We need to diff the `initConnectionMessage`\n   * queries with the current set of queries to understand what those were.\n   */\n  async getQueriesPatch(\n    tx: ReadTransaction,\n    lastPatch?: Map<string, UpQueriesPatchOp> | undefined,\n  ): Promise<Map<string, UpQueriesPatchOp>> {\n    const existingQueryHashes = new Set<string>();\n    const prefix = desiredQueriesPrefixForClient(this.#clientID);\n    for await (const key of tx.scan({prefix}).keys()) {\n      existingQueryHashes.add(key.substring(prefix.length, key.length));\n    }\n    const patch: Map<string, UpQueriesPatchOp> = new Map();\n    for (const hash of existingQueryHashes) {\n      if (!this.#queries.has(hash)) {\n        patch.set(hash, {op: 'del', hash});\n      }\n    }\n\n    for (const [hash, {normalized, ttl, name, args}] of this.#queries) {\n      if (!existingQueryHashes.has(hash)) {\n        patch.set(hash, {\n          op: 'put',\n          hash,\n          ast: name === undefined ? normalized : undefined,\n          name,\n          args,\n          // We get TTL out of the DagStore so it is possible that the TTL was written\n          // with a too high TTL.\n          ttl: clampTTL(ttl), // no lc here since no need to log here\n        });\n      }\n    }\n\n    if (lastPatch) {\n      // if there are any `puts` in `lastPatch` that are not in `patch` then we need to\n      // send a `del` event in `patch`.\n      for (const [hash, {op}] of lastPatch) {\n        if (op === 'put' && !patch.has(hash)) {\n          patch.set(hash, {op: 'del', hash});\n        }\n      }\n      // Remove everything from `patch` that was already sent in `lastPatch`.\n      for (const [hash, {op}] of patch) {\n        const lastPatchOp = lastPatch.get(hash);\n        if (lastPatchOp && lastPatchOp.op === op) {\n          patch.delete(hash);\n        }\n      }\n    }\n\n    return patch;\n  }\n\n  addCustom(\n    ast: AST,\n    {name, args}: CustomQueryID,\n    ttl: TTL,\n    gotCallback?: GotCallback | undefined,\n  ): () => void {\n    const normalized = normalizeAST(ast);\n    const queryId = hashOfNameAndArgs(name, args);\n    return this.#add(queryId, normalized, name, args, ttl, gotCallback);\n  }\n\n  addLegacy(\n    ast: AST,\n    ttl: TTL,\n    gotCallback?: GotCallback | undefined,\n  ): () => void {\n    const normalized = normalizeAST(ast);\n    const astHash = hashOfAST(normalized);\n    return this.#add(\n      astHash,\n      normalized,\n      undefined, // name is undefined for legacy queries\n      undefined, // args are undefined for legacy queries\n      ttl,\n      gotCallback,\n    );\n  }\n\n  #add(\n    queryId: string,\n    normalized: AST,\n    name: string | undefined,\n    args: readonly ReadonlyJSONValue[] | undefined,\n    ttl: TTL,\n    gotCallback?: GotCallback | undefined,\n  ) {\n    assert(\n      (name === undefined) === (args === undefined),\n      'If name is defined, args must be defined',\n    );\n    ttl = clampTTL(ttl, this.#lc);\n    let entry = this.#queries.get(queryId);\n    this.#recentQueries.delete(queryId);\n    if (!entry) {\n      normalized = mapAST(normalized, this.#clientToServer);\n\n      entry = {\n        normalized,\n        name,\n        args,\n        count: 1,\n        gotCallbacks: gotCallback ? [gotCallback] : [],\n        ttl,\n      };\n      this.#queries.set(queryId, entry);\n      this.#queueQueryChange({\n        op: 'put',\n        hash: queryId,\n        ast: name === undefined ? normalized : undefined,\n        name,\n        args,\n        ttl,\n      });\n    } else {\n      ++entry.count;\n      this.#updateEntry(entry, queryId, ttl);\n\n      if (gotCallback) {\n        entry.gotCallbacks.push(gotCallback);\n      }\n    }\n\n    if (gotCallback) {\n      gotCallback(this.#gotQueries.has(queryId));\n    }\n\n    let removed = false;\n    return () => {\n      if (removed) {\n        return;\n      }\n      removed = true;\n\n      // We cannot remove queries while mutations are pending\n      // as that could take data out of scope that is needed in a rebase\n      if (this.#mutationTracker.size > 0) {\n        this.#pendingRemovals.push(() =>\n          this.#remove(entry, queryId, gotCallback),\n        );\n        return;\n      }\n\n      this.#remove(entry, queryId, gotCallback);\n    };\n  }\n\n  updateCustom({name, args}: CustomQueryID, ttl: TTL) {\n    const queryID = hashOfNameAndArgs(name, args);\n    const entry = must(this.#queries.get(queryID));\n    this.#updateEntry(entry, queryID, ttl);\n  }\n\n  updateLegacy(ast: AST, ttl: TTL) {\n    const normalized = normalizeAST(ast);\n    const queryID = hashOfAST(normalized);\n    const entry = must(this.#queries.get(queryID));\n    this.#updateEntry(entry, queryID, ttl);\n  }\n\n  #updateEntry(entry: Entry, queryID: string, ttl: TTL): void {\n    // If the query already exists and the new ttl is larger than the old one\n    // we send a changeDesiredQueries message to the server to update the ttl.\n    ttl = clampTTL(ttl, this.#lc);\n    if (compareTTL(ttl, entry.ttl) > 0) {\n      entry.ttl = ttl;\n      this.#queueQueryChange({\n        op: 'put',\n        hash: queryID,\n        ast: entry.name === undefined ? entry.normalized : undefined,\n        name: entry.name,\n        args: entry.args,\n        ttl,\n      });\n    }\n  }\n\n  #queueQueryChange(op: UpQueriesPatchOp) {\n    this.#pendingQueryChanges.push(op);\n    this.#scheduleBatch();\n  }\n\n  #scheduleBatch() {\n    if (this.#batchTimer === undefined) {\n      this.#batchTimer = setTimeout(\n        () => this.flushBatch(),\n        this.#queryChangeThrottleMs,\n      );\n    }\n  }\n\n  flushBatch() {\n    if (this.#batchTimer !== undefined) {\n      clearTimeout(this.#batchTimer);\n      this.#batchTimer = undefined;\n    }\n    if (this.#pendingQueryChanges.length > 0) {\n      this.#send([\n        'changeDesiredQueries',\n        {\n          desiredQueriesPatch: [...this.#pendingQueryChanges],\n        },\n      ]);\n      this.#pendingQueryChanges.length = 0;\n    }\n  }\n\n  #remove(entry: Entry, astHash: string, gotCallback: GotCallback | undefined) {\n    if (gotCallback) {\n      const index = entry.gotCallbacks.indexOf(gotCallback);\n      entry.gotCallbacks.splice(index, 1);\n    }\n    --entry.count;\n    if (entry.count === 0) {\n      this.#recentQueries.add(astHash);\n      if (this.#recentQueries.size > this.#recentQueriesMaxSize) {\n        const lruQueryID = this.#recentQueries.values().next().value;\n        assert(lruQueryID);\n        this.#queries.delete(lruQueryID);\n        this.#recentQueries.delete(lruQueryID);\n        this.#queryMetrics.delete(lruQueryID);\n        this.#queueQueryChange({op: 'del', hash: lruQueryID});\n      }\n    }\n  }\n\n  /**\n   * Gets the aggregated metrics for all queries managed by this QueryManager.\n   */\n  get metrics(): ClientMetric {\n    return this.#metrics;\n  }\n\n  addMetric<K extends keyof ClientMetricMap>(\n    metric: K,\n    value: number,\n    ...args: ClientMetricMap[K]\n  ): void {\n    // Only query metrics are tracked at this point.\n    // If this check fails then we need to add a runtime check.\n    metric satisfies `query-${string}`;\n\n    // We track all materializations of queries as well as per\n    // query materializations.\n    this.#metrics[metric].add(value);\n\n    const queryID = args[0];\n\n    // Handle slow query logging for end-to-end materialization\n    if (metric === 'query-materialization-end-to-end') {\n      const ast = args[1];\n\n      if (\n        this.#slowMaterializeThreshold !== undefined &&\n        value > this.#slowMaterializeThreshold\n      ) {\n        this.#lc.warn?.(\n          'Slow query materialization (including server/network)',\n          queryID,\n          ast,\n          value,\n        );\n      } else {\n        this.#lc.debug?.(\n          'Materialized query (including server/network)',\n          queryID,\n          ast,\n          value,\n        );\n      }\n    }\n\n    // The query manager manages metrics that are per query.\n    let existing = this.#queryMetrics.get(queryID);\n    if (!existing) {\n      existing = newMetrics();\n      this.#queryMetrics.set(queryID, existing);\n    }\n    existing[metric].add(value);\n  }\n\n  getQueryMetrics(queryID: string): ClientMetric | undefined {\n    return this.#queryMetrics.get(queryID);\n  }\n}\n\nfunction newMetrics(): ClientMetric {\n  return {\n    'query-materialization-client': new TDigest(),\n    'query-materialization-end-to-end': new TDigest(),\n    'query-update-client': new TDigest(),\n  };\n}\n","import type {LogLevel} from '@rocicorp/logger';\nimport type {StoreProvider} from '../../../replicache/src/kv/store.ts';\nimport type {MaybePromise} from '../../../shared/src/types.ts';\nimport * as v from '../../../shared/src/valita.ts';\nimport type {\n  UserMutateParams,\n  UserQueryParams,\n} from '../../../zero-protocol/src/connect.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {CustomMutatorDefs} from './custom.ts';\nimport type {OnError} from './on-error.ts';\nimport {UpdateNeededReasonType} from './update-needed-reason-type.ts';\n\n/**\n * Configuration for {@linkcode Zero}.\n */\nexport interface ZeroOptions<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> {\n  /**\n   * URL to the zero-cache. This can be a simple hostname, e.g.\n   * - \"https://myapp-myteam.zero.ms\"\n   * or a prefix with a single path component, e.g.\n   * - \"https://myapp-myteam.zero.ms/zero\"\n   * - \"https://myapp-myteam.zero.ms/db\"\n   *\n   * The latter is useful for configuring routing rules (e.g. \"/zero/\\*\") when\n   * the zero-cache is hosted on the same domain as the application. **Note that\n   * only a single path segment is allowed (e.g. it cannot be \"/proxy/zero/\\*\")**.\n   */\n  server?: string | null | undefined;\n\n  /**\n   * A JWT to identify and authenticate the user. Can be provided as either:\n   * - A string containing the JWT token\n   * - A function that returns a JWT token\n   * - `undefined` if there is no logged in user\n   *\n   * Token validation behavior:\n   * 1. **For function providers:**\n   *    When zero-cache reports that a token is invalid (expired, malformed,\n   *    or has an invalid signature), Zero will call the function again with\n   *    `error='invalid-token'` to obtain a new token.\n   *\n   * 2. **For string tokens:**\n   *    Zero will continue to use the provided token even if zero-cache initially\n   *    reports it as invalid. This is because zero-cache may be able to validate\n   *    the token after fetching new public keys from its configured JWKS URL\n   *    (if `ZERO_AUTH_JWKS_URL` is set).\n   */\n  auth?:\n    | string\n    | ((error?: 'invalid-token') => MaybePromise<string | undefined>)\n    | undefined;\n\n  /**\n   * A unique identifier for the user. Must be non-empty.\n   *\n   * Each userID gets its own client-side storage so that the app can switch\n   * between users without losing state.\n   *\n   * This must match the `sub` claim of the `auth` token if\n   * `auth` is provided.\n   */\n  userID: string;\n\n  /**\n   * Distinguishes the storage used by this Zero instance from that of other\n   * instances with the same userID. Useful in the case where the app wants to\n   * have multiple Zero instances for the same user for different parts of the\n   * app.\n   */\n  storageKey?: string | undefined;\n\n  /**\n   * Determines the level of detail at which Zero logs messages about\n   * its operation. Messages are logged to the `console`.\n   *\n   * When this is set to `'debug'`, `'info'` and `'error'` messages are also\n   * logged. When set to `'info'`, `'info'` and `'error'` but not\n   * `'debug'` messages are logged. When set to `'error'` only `'error'`\n   * messages are logged.\n   *\n   * Default is `'error'`.\n   */\n  logLevel?: LogLevel | undefined;\n\n  /**\n   * This defines the schema of the tables used in Zero and their relationships\n   * to one another.\n   */\n  schema: S;\n\n  /**\n   * `mutators` is a map of custom mutator definitions. The keys are\n   * namespaces or names of the mutators. The values are the mutator\n   * implementations. Client side mutators must be idempotent as a\n   * mutation can be rebased multiple times when folding in authoritative\n   * changes from the server to the client.\n   */\n  mutators?: MD | undefined;\n\n  /**\n   * Custom mutations are pushed to zero-cache and then to\n   * your API server.\n   *\n   * push.queryParams can be used to augment the URL\n   * used to connect to your API server so it includes\n   * variables in the query string.\n   *\n   * DEPRECATED: Use `userMutateParams` instead.\n   */\n  push?: UserMutateParams;\n  mutate?: UserMutateParams;\n  query?: UserQueryParams;\n\n  /**\n   * `onOnlineChange` is called when the Zero instance's online status changes.\n   *\n   * @deprecated Use `onOnline` on the Zero instance instead. e.g.\n   * ```ts\n   * const zero = new Zero({...});\n   * zero.onOnline((online) => { ... });\n   * ```\n   */\n  onOnlineChange?: ((online: boolean) => void) | undefined;\n\n  /**\n   * `onUpdateNeeded` is called when a client code update is needed.\n   *\n   * See {@link UpdateNeededReason} for why updates can be needed.\n   *\n   * The default behavior is to reload the page (using `location.reload()`).\n   * Provide your own function to prevent the page from\n   * reloading automatically. You may want to display a toast to inform the end\n   * user there is a new version of your app available and prompt them to\n   * refresh.\n   */\n  onUpdateNeeded?: ((reason: UpdateNeededReason) => void) | undefined;\n\n  /**\n   * `onClientStateNotFound` is called when this client is no longer able\n   * to sync with the zero-cache due to missing synchronization state.  This\n   * can be because:\n   * - the local persistent synchronization state has been garbage collected.\n   *   This can happen if the client has no pending mutations and has not been\n   *   used for a while (e.g. the client's tab has been hidden for a long time).\n   * - the zero-cache fails to find the server side synchronization state for\n   *   this client.\n   *\n   * The default behavior is to reload the page (using `location.reload()`).\n   * Provide your own function to prevent the page from reloading automatically.\n   */\n  onClientStateNotFound?: (() => void) | undefined;\n\n  /**\n   * The number of milliseconds to wait before disconnecting a Zero\n   * instance whose tab has become hidden.\n   *\n   * Instances in hidden tabs are disconnected to save resources.\n   *\n   * Default is 5_000.\n   */\n  hiddenTabDisconnectDelay?: number | undefined;\n\n  /**\n   * This gets called when the Zero instance encounters an error. The default\n   * behavior is to log the error to the console. Provide your own function to\n   * prevent the default behavior.\n   */\n  onError?: OnError | undefined;\n\n  /**\n   * Determines what kind of storage implementation to use on the client.\n   *\n   * Defaults to `'idb'` which means that Zero uses an IndexedDB storage\n   * implementation. This allows the data to be persisted on the client and\n   * enables faster syncs between application restarts.\n   *\n   * By setting this to `'mem'`, Zero uses an in memory storage and\n   * the data is not persisted on the client.\n   *\n   * You can also set this to a function that is used to create new KV stores,\n   * allowing a custom implementation of the underlying storage layer.\n   */\n  kvStore?: 'mem' | 'idb' | StoreProvider | undefined;\n\n  /**\n   * The maximum number of bytes to allow in a single header.\n   *\n   * Zero adds some extra information to headers on initialization if possible.\n   * This speeds up data synchronization. This number should be kept less than\n   * or equal to the maximum header size allowed by the zero-cache and any load\n   * balancers.\n   *\n   * Default value: 8kb.\n   */\n  maxHeaderLength?: number | undefined;\n\n  /**\n   * The maximum amount of milliseconds to wait for a materialization to\n   * complete (including network/server time) before printing a warning to the\n   * console.\n   *\n   * Default value: 5_000.\n   */\n  slowMaterializeThreshold?: number | undefined;\n\n  /**\n   * UI rendering libraries will often provide a utility for batching multiple\n   * state updates into a single render. Some examples are React's\n   * `unstable_batchedUpdates`, and solid-js's `batch`.\n   *\n   * This option enables integrating these batch utilities with Zero.\n   *\n   * When `batchViewUpdates` is provided, Zero will call it whenever\n   * it updates query view state with an `applyViewUpdates` function\n   * that performs the actual state updates.\n   *\n   * Zero updates query view state when:\n   * 1. creating a new view\n   * 2. updating all existing queries' views to a new consistent state\n   *\n   * When creating a new view, that single view's creation will be wrapped\n   * in a `batchViewUpdates` call.\n   *\n   * When updating existing queries, all queries will be updated in a single\n   * `batchViewUpdates` call, so that the transition to the new consistent\n   * state can be done in a single render.\n   *\n   * Implementations must always call `applyViewUpdates` synchronously.\n   */\n  batchViewUpdates?: ((applyViewUpdates: () => void) => void) | undefined;\n\n  /**\n   * The maximum number of recent queries, no longer subscribed to by a preload\n   * or view, to continue syncing.\n   *\n   * Defaults is 0.\n   *\n   * @deprecated Use ttl instead\n   */\n  maxRecentQueries?: number | undefined;\n\n  /**\n   * Changes to queries are sent to server in batches. This option controls\n   * the number of milliseconds to wait before sending the next batch.\n   *\n   * Defaults is 10.\n   */\n  queryChangeThrottleMs?: number | undefined;\n}\n\n/**\n * @deprecated Use {@link ZeroOptions} instead.\n */\nexport interface ZeroAdvancedOptions<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> extends ZeroOptions<S, MD> {}\n\nexport type UpdateNeededReason =\n  | {type: UpdateNeededReasonType.NewClientGroup}\n  | {type: UpdateNeededReasonType.VersionNotSupported}\n  | {type: UpdateNeededReasonType.SchemaVersionNotSupported};\n\nexport const updateNeededReasonTypeSchema: v.Type<UpdateNeededReason['type']> =\n  v.literalUnion(\n    UpdateNeededReasonType.NewClientGroup,\n    UpdateNeededReasonType.VersionNotSupported,\n    UpdateNeededReasonType.SchemaVersionNotSupported,\n  );\n","import * as v from '../../../shared/src/valita.ts';\nimport {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport {errorKindSchema} from '../../../zero-protocol/src/error.ts';\nimport {updateNeededReasonTypeSchema} from './options.ts';\nimport type {UpdateNeededReasonType} from './update-needed-reason-type.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\n\nexport const RELOAD_REASON_STORAGE_KEY = '_zeroReloadReason';\nexport const RELOAD_BACKOFF_STATE_KEY = '_zeroReloadBackoffState';\n\nconst reloadReasonSchema = v.tuple([\n  v.union(updateNeededReasonTypeSchema, errorKindSchema),\n  v.string(),\n]);\n\nconst backoffStateSchema = v.object({\n  lastReloadTime: v.number().default(0),\n  nextIntervalMs: v.number().default(0),\n});\n\nexport type BackoffState = v.Infer<typeof backoffStateSchema>;\n\nexport const MIN_RELOAD_INTERVAL_MS = 500;\nexport const MAX_RELOAD_INTERVAL_MS = 60_000;\n\n// For the fraction of browsers that do not support sessionStorage.\nexport const FALLBACK_RELOAD_INTERVAL_MS = 10_000;\n\nlet reloadTimer: ReturnType<typeof setTimeout> | null = null;\n\n// TODO: This should get pushed down into Replicache and used for reloads we\n// do there.\nexport function reloadWithReason(\n  lc: ZeroLogContext,\n  reload: () => void,\n  reason: UpdateNeededReasonType | ErrorKind,\n  message: string,\n) {\n  if (reloadTimer) {\n    lc.info?.('reload timer already scheduled');\n    return;\n  }\n  const now = Date.now();\n  const backoff = nextBackoff(lc, now);\n\n  // Record state immediately so that it persists if the user manually reloads first.\n  if (typeof sessionStorage !== 'undefined') {\n    sessionStorage.setItem(RELOAD_BACKOFF_STATE_KEY, JSON.stringify(backoff));\n    sessionStorage.setItem(\n      RELOAD_REASON_STORAGE_KEY,\n      JSON.stringify([reason, message]),\n    );\n  }\n\n  const delay = backoff.lastReloadTime - now;\n  lc.error?.(\n    reason,\n    '\\n',\n    'reloading',\n    delay > 0 ? `in ${delay / 1000} seconds` : '',\n  );\n  reloadTimer = setTimeout(() => {\n    reloadTimer = null;\n    reload();\n  }, delay);\n}\n\nexport function reportReloadReason(lc: ZeroLogContext) {\n  if (typeof sessionStorage !== 'undefined') {\n    const value = sessionStorage.getItem(RELOAD_REASON_STORAGE_KEY);\n    if (value) {\n      sessionStorage.removeItem(RELOAD_REASON_STORAGE_KEY);\n      try {\n        const parsed = JSON.parse(value);\n        const [reasonType, message] = v.parse(parsed, reloadReasonSchema);\n        lc.error?.(reasonType, 'Zero reloaded the page.', message);\n      } catch (e) {\n        lc.error?.('Zero reloaded the page.', e);\n        // ignore if not able to parse\n        return;\n      }\n    }\n  }\n}\n\n/** If a reload is scheduled, do not attempt to reconnect. */\nexport function reloadScheduled() {\n  return reloadTimer !== null;\n}\n\n/** Call upon a successful connection, indicating that backoff should be reset. */\nexport function resetBackoff() {\n  if (typeof sessionStorage !== 'undefined') {\n    sessionStorage.removeItem(RELOAD_BACKOFF_STATE_KEY);\n  }\n}\n\nfunction nextBackoff(lc: ZeroLogContext, now: number): BackoffState {\n  if (typeof sessionStorage === 'undefined') {\n    lc.warn?.(\n      `sessionStorage not supported. backing off in ${\n        FALLBACK_RELOAD_INTERVAL_MS / 1000\n      } seconds`,\n    );\n    return {\n      lastReloadTime: now + FALLBACK_RELOAD_INTERVAL_MS,\n      nextIntervalMs: MIN_RELOAD_INTERVAL_MS,\n    };\n  }\n  const val = sessionStorage.getItem(RELOAD_BACKOFF_STATE_KEY);\n  if (!val) {\n    return {lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS};\n  }\n  let parsed: BackoffState;\n  try {\n    parsed = v.parse(JSON.parse(val), backoffStateSchema, 'passthrough');\n  } catch (e) {\n    lc.warn?.('ignoring unparsable backoff state', val, e);\n    return {lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS};\n  }\n  const {lastReloadTime, nextIntervalMs} = parsed;\n\n  // Backoff state might not have been cleared. Reset for sufficiently old state.\n  if (now - lastReloadTime > MAX_RELOAD_INTERVAL_MS * 2) {\n    return {lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS};\n  }\n  if (now < lastReloadTime) {\n    // If the user manually reloaded, stick to the existing schedule.\n    return parsed;\n  }\n  const nextReloadTime = Math.max(now, lastReloadTime + nextIntervalMs);\n  return {\n    lastReloadTime: nextReloadTime,\n    nextIntervalMs: Math.min(nextIntervalMs * 2, MAX_RELOAD_INTERVAL_MS),\n  };\n}\n","import {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';\nimport {\n  type BackoffBody,\n  type ErrorBody,\n} from '../../../zero-protocol/src/error.ts';\n\n/**\n * Represents an error sent by server as part of Zero protocol.\n */\nexport class ServerError<K extends ErrorKind = ErrorKind> extends Error {\n  readonly name = 'ServerError';\n  readonly errorBody: ErrorBody;\n  get kind(): K {\n    return this.errorBody.kind as K;\n  }\n\n  constructor(errorBody: ErrorBody) {\n    super(errorBody.kind + ': ' + errorBody.message);\n    this.errorBody = errorBody;\n  }\n}\n\nexport function isServerError(ex: unknown): ex is ServerError {\n  return ex instanceof ServerError;\n}\n\nexport function isAuthError(\n  ex: unknown,\n): ex is\n  | ServerError<ErrorKind.AuthInvalidated>\n  | ServerError<ErrorKind.Unauthorized> {\n  return isServerError(ex) && isAuthErrorKind(ex.kind);\n}\n\nfunction isAuthErrorKind(\n  kind: ErrorKind,\n): kind is ErrorKind.AuthInvalidated | ErrorKind.Unauthorized {\n  return kind === ErrorKind.AuthInvalidated || kind === ErrorKind.Unauthorized;\n}\n\nexport function isBackoffError(ex: unknown): BackoffBody | undefined {\n  if (isServerError(ex)) {\n    switch (ex.errorBody.kind) {\n      case ErrorKind.Rebalance:\n      case ErrorKind.Rehome:\n      case ErrorKind.ServerOverloaded:\n        return ex.errorBody;\n    }\n  }\n  return undefined;\n}\n","import {getBrowserGlobal} from '../../../shared/src/browser-env.ts';\nimport type {HTTPString} from './http-string.ts';\n\nfunction validateServerParam(paramName: string, server: string): HTTPString {\n  const expectedProtocol = 'http';\n  const forExample = (path: string = '') =>\n    ` For example: \"${expectedProtocol}s://myapp-myteam.zero.ms/${path}\".`;\n\n  if (\n    !server.startsWith(`${expectedProtocol}://`) &&\n    !server.startsWith(`${expectedProtocol}s://`)\n  ) {\n    throw new Error(\n      `ZeroOptions.${paramName} must use the \"${expectedProtocol}\" or \"${expectedProtocol}s\" scheme.`,\n    );\n  }\n  let url;\n  try {\n    url = new URL(server);\n  } catch {\n    throw new Error(\n      `ZeroOptions.${paramName} must be a valid URL.${forExample()}`,\n    );\n  }\n\n  const urlString = url.toString();\n\n  const pathComponents = url.pathname.split('/');\n  if (pathComponents[0] === '') {\n    pathComponents.shift();\n  }\n  if (pathComponents[pathComponents.length - 1] === '') {\n    pathComponents.pop();\n  }\n  if (pathComponents.length > 1) {\n    throw new Error(\n      `ZeroOptions.${paramName} may have at most one path component.${forExample(\n        'zero',\n      )}`,\n    );\n  }\n\n  for (const [property, invalidEndsWith] of [\n    ['search', '?'],\n    ['hash', '#'],\n  ] as const) {\n    if (url[property] || urlString.endsWith(invalidEndsWith)) {\n      throw new Error(\n        `ZeroOptions.${paramName} must not contain a ${property} component.${forExample()}`,\n      );\n    }\n  }\n\n  return urlString as HTTPString;\n}\n\nexport function getServer(\n  server: string | undefined | null,\n): HTTPString | null {\n  const WS = getBrowserGlobal('WebSocket');\n  if (!WS) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Zero started in an unsupported environment, no data will be synced.',\n    );\n    return null;\n  }\n  if (server === undefined || server === null) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Zero starting up with no server URL. No data will be synced.',\n    );\n    return null;\n  }\n  return validateServerParam('server', server);\n}\n","import {LogContext} from '@rocicorp/logger';\nimport type {OnErrorParameters} from './on-error.ts';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const ZeroLogContext = LogContext<OnErrorParameters>;\nexport type ZeroLogContext = LogContext<OnErrorParameters>;\n","import {Lock} from '@rocicorp/lock';\nimport type {\n  PatchOperationInternal,\n  PokeInternal,\n} from '../../../replicache/src/impl.ts';\nimport type {PatchOperation} from '../../../replicache/src/patch-operation.ts';\nimport type {ClientID} from '../../../replicache/src/sync/ids.ts';\nimport {getBrowserGlobalMethod} from '../../../shared/src/browser-env.ts';\nimport type {JSONValue} from '../../../shared/src/json.ts';\nimport type {\n  PokeEndBody,\n  PokePartBody,\n  PokeStartBody,\n} from '../../../zero-protocol/src/poke.ts';\nimport type {QueriesPatchOp} from '../../../zero-protocol/src/queries-patch.ts';\nimport type {RowPatchOp} from '../../../zero-protocol/src/row-patch.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {\n  serverToClient,\n  type NameMapper,\n} from '../../../zero-schema/src/name-mapper.ts';\nimport {\n  toDesiredQueriesKey,\n  toGotQueriesKey,\n  toMutationResponseKey,\n  toPrimaryKeyString,\n} from './keys.ts';\nimport type {ZeroLogContext} from './zero-log-context.ts';\nimport {unreachable} from '../../../shared/src/asserts.ts';\nimport type {MutationPatch} from '../../../zero-protocol/src/mutations-patch.ts';\nimport type {MutationTracker} from './mutation-tracker.ts';\n\ntype PokeAccumulator = {\n  readonly pokeStart: PokeStartBody;\n  readonly parts: PokePartBody[];\n  readonly pokeEnd: PokeEndBody;\n};\n\n/**\n * Handles the multi-part format of zero pokes.\n * As an optimization it also debounces pokes, only poking Replicache with a\n * merged poke at most once per frame (as determined by requestAnimationFrame).\n * The client cannot control how fast the server sends pokes, and it can only\n * update the UI once per frame. This debouncing avoids wastefully\n * computing separate diffs and IVM updates for intermediate states that will\n * never been displayed to the UI.\n */\nexport class PokeHandler {\n  readonly #replicachePoke: (poke: PokeInternal) => Promise<void>;\n  readonly #onPokeError: () => void;\n  readonly #clientID: ClientID;\n  readonly #lc: ZeroLogContext;\n  #receivingPoke: Omit<PokeAccumulator, 'pokeEnd'> | undefined = undefined;\n  readonly #pokeBuffer: PokeAccumulator[] = [];\n  #pokePlaybackLoopRunning = false;\n  #lastRafPerfTimestamp = 0;\n  // Serializes calls to this.#replicachePoke otherwise we can cause out of\n  // order poke errors.\n  readonly #pokeLock = new Lock();\n  readonly #schema: Schema;\n  readonly #serverToClient: NameMapper;\n  readonly #mutationTracker: MutationTracker;\n\n  readonly #raf =\n    getBrowserGlobalMethod('requestAnimationFrame') ?? rafFallback;\n\n  constructor(\n    replicachePoke: (poke: PokeInternal) => Promise<void>,\n    onPokeError: () => void,\n    clientID: ClientID,\n    schema: Schema,\n    lc: ZeroLogContext,\n    mutationTracker: MutationTracker,\n  ) {\n    this.#replicachePoke = replicachePoke;\n    this.#onPokeError = onPokeError;\n    this.#clientID = clientID;\n    this.#schema = schema;\n    this.#serverToClient = serverToClient(schema.tables);\n    this.#lc = lc.withContext('PokeHandler');\n    this.#mutationTracker = mutationTracker;\n  }\n\n  handlePokeStart(pokeStart: PokeStartBody) {\n    if (this.#receivingPoke) {\n      this.#handlePokeError(\n        `pokeStart ${JSON.stringify(\n          pokeStart,\n        )} while still receiving  ${JSON.stringify(\n          this.#receivingPoke.pokeStart,\n        )} `,\n      );\n      return;\n    }\n    this.#receivingPoke = {\n      pokeStart,\n      parts: [],\n    };\n  }\n\n  handlePokePart(pokePart: PokePartBody): number | undefined {\n    if (pokePart.pokeID !== this.#receivingPoke?.pokeStart.pokeID) {\n      this.#handlePokeError(\n        `pokePart for ${pokePart.pokeID}, when receiving ${\n          this.#receivingPoke?.pokeStart.pokeID\n        }`,\n      );\n      return;\n    }\n    this.#receivingPoke.parts.push(pokePart);\n    return pokePart.lastMutationIDChanges?.[this.#clientID];\n  }\n\n  handlePokeEnd(pokeEnd: PokeEndBody): void {\n    if (pokeEnd.pokeID !== this.#receivingPoke?.pokeStart.pokeID) {\n      this.#handlePokeError(\n        `pokeEnd for ${pokeEnd.pokeID}, when receiving ${\n          this.#receivingPoke?.pokeStart.pokeID\n        }`,\n      );\n      return;\n    }\n    if (pokeEnd.cancel) {\n      this.#receivingPoke = undefined;\n      return;\n    }\n    this.#pokeBuffer.push({...this.#receivingPoke, pokeEnd});\n    this.#receivingPoke = undefined;\n    if (!this.#pokePlaybackLoopRunning) {\n      this.#startPlaybackLoop();\n    }\n  }\n\n  handleDisconnect(): void {\n    this.#lc.debug?.('clearing due to disconnect');\n    this.#clear();\n  }\n\n  #startPlaybackLoop() {\n    this.#lc.debug?.('starting playback loop');\n    this.#pokePlaybackLoopRunning = true;\n    this.#raf(this.#rafCallback);\n  }\n\n  #rafCallback = async () => {\n    const rafLC = this.#lc.withContext('rafAt', Math.floor(performance.now()));\n    if (this.#pokeBuffer.length === 0) {\n      rafLC.debug?.('stopping playback loop');\n      this.#pokePlaybackLoopRunning = false;\n      return;\n    }\n    this.#raf(this.#rafCallback);\n    const start = performance.now();\n    rafLC.debug?.(\n      'raf fired, processing pokes.  Since last raf',\n      start - this.#lastRafPerfTimestamp,\n    );\n    this.#lastRafPerfTimestamp = start;\n    await this.#processPokesForFrame(rafLC);\n    rafLC.debug?.('processing pokes took', performance.now() - start);\n  };\n\n  #processPokesForFrame(lc: ZeroLogContext): Promise<void> {\n    return this.#pokeLock.withLock(async () => {\n      const now = Date.now();\n      lc.debug?.('got poke lock at', now);\n      lc.debug?.('merging', this.#pokeBuffer.length);\n      try {\n        const merged = mergePokes(\n          this.#pokeBuffer,\n          this.#schema,\n          this.#serverToClient,\n        );\n        this.#pokeBuffer.length = 0;\n        if (merged === undefined) {\n          lc.debug?.('frame is empty');\n          return;\n        }\n        const start = performance.now();\n        lc.debug?.('poking replicache');\n        await this.#replicachePoke(merged);\n        lc.debug?.('poking replicache took', performance.now() - start);\n\n        if (!('error' in merged.pullResponse)) {\n          const lmid =\n            merged.pullResponse.lastMutationIDChanges[this.#clientID];\n          if (lmid !== undefined) {\n            this.#mutationTracker.lmidAdvanced(lmid);\n          }\n        }\n      } catch (e) {\n        this.#handlePokeError(e);\n      }\n    });\n  }\n\n  #handlePokeError(e: unknown) {\n    if (String(e).includes('unexpected base cookie for poke')) {\n      // This can happen if cookie changes due to refresh from idb due\n      // to an update arriving to different tabs in the same\n      // client group at very different times.  Unusual but possible.\n      this.#lc.debug?.('clearing due to', e);\n    } else {\n      this.#lc.error?.('clearing due to unexpected poke error', e);\n    }\n    this.#clear();\n    this.#onPokeError();\n  }\n\n  #clear() {\n    this.#receivingPoke = undefined;\n    this.#pokeBuffer.length = 0;\n  }\n}\n\nexport function mergePokes(\n  pokeBuffer: PokeAccumulator[],\n  schema: Schema,\n  serverToClient: NameMapper,\n):\n  | (PokeInternal & {mutationResults?: MutationPatch[] | undefined})\n  | undefined {\n  if (pokeBuffer.length === 0) {\n    return undefined;\n  }\n  const {baseCookie} = pokeBuffer[0].pokeStart;\n  const lastPoke = pokeBuffer[pokeBuffer.length - 1];\n  const {cookie} = lastPoke.pokeEnd;\n  const mergedPatch: PatchOperationInternal[] = [];\n  const mergedLastMutationIDChanges: Record<string, number> = {};\n  const mutationResults: MutationPatch[] = [];\n\n  let prevPokeEnd = undefined;\n  for (const pokeAccumulator of pokeBuffer) {\n    if (\n      prevPokeEnd &&\n      pokeAccumulator.pokeStart.baseCookie &&\n      pokeAccumulator.pokeStart.baseCookie > prevPokeEnd.cookie\n    ) {\n      throw Error(\n        `unexpected cookie gap ${JSON.stringify(prevPokeEnd)} ${JSON.stringify(\n          pokeAccumulator.pokeStart,\n        )}`,\n      );\n    }\n    prevPokeEnd = pokeAccumulator.pokeEnd;\n    for (const pokePart of pokeAccumulator.parts) {\n      if (pokePart.lastMutationIDChanges) {\n        for (const [clientID, lastMutationID] of Object.entries(\n          pokePart.lastMutationIDChanges,\n        )) {\n          mergedLastMutationIDChanges[clientID] = lastMutationID;\n        }\n      }\n      if (pokePart.desiredQueriesPatches) {\n        for (const [clientID, queriesPatch] of Object.entries(\n          pokePart.desiredQueriesPatches,\n        )) {\n          for (const op of queriesPatch) {\n            mergedPatch.push(\n              queryPatchOpToReplicachePatchOp(op, hash =>\n                toDesiredQueriesKey(clientID, hash),\n              ),\n            );\n          }\n        }\n      }\n      if (pokePart.gotQueriesPatch) {\n        for (const op of pokePart.gotQueriesPatch) {\n          mergedPatch.push(\n            queryPatchOpToReplicachePatchOp(op, toGotQueriesKey),\n          );\n        }\n      }\n      if (pokePart.rowsPatch) {\n        for (const p of pokePart.rowsPatch) {\n          mergedPatch.push(\n            rowsPatchOpToReplicachePatchOp(p, schema, serverToClient),\n          );\n        }\n      }\n      if (pokePart.mutationsPatch) {\n        for (const op of pokePart.mutationsPatch) {\n          mergedPatch.push(mutationPatchOpToReplicachePatchOp(op));\n        }\n      }\n    }\n  }\n  const ret: PokeInternal & {mutationResults?: MutationPatch[] | undefined} = {\n    baseCookie,\n    pullResponse: {\n      lastMutationIDChanges: mergedLastMutationIDChanges,\n      patch: mergedPatch,\n      cookie,\n    },\n  };\n\n  // For backwards compatibility. Because we're strict on our validation,\n  // zero-client must be able to parse pokes with this field before we introduce it.\n  // So users can update their clients and then start using custom mutators that write responses to the db.\n  if (mutationResults.length > 0) {\n    ret.mutationResults = mutationResults;\n  }\n  return ret;\n}\n\nfunction queryPatchOpToReplicachePatchOp(\n  op: QueriesPatchOp,\n  toKey: (hash: string) => string,\n): PatchOperation {\n  switch (op.op) {\n    case 'clear':\n      return op;\n    case 'del':\n      return {\n        op: 'del',\n        key: toKey(op.hash),\n      };\n    case 'put':\n      return {\n        op: 'put',\n        key: toKey(op.hash),\n        value: null,\n      };\n    default:\n      unreachable(op);\n  }\n}\n\nexport function mutationPatchOpToReplicachePatchOp(\n  op: MutationPatch,\n): PatchOperationInternal {\n  switch (op.op) {\n    case 'put':\n      return {\n        op: 'put',\n        key: toMutationResponseKey(op.mutation.id),\n        value: op.mutation.result,\n      };\n    case 'del':\n      return {\n        op: 'del',\n        key: toMutationResponseKey(op.id),\n      };\n  }\n}\n\nfunction rowsPatchOpToReplicachePatchOp(\n  op: RowPatchOp,\n  schema: Schema,\n  serverToClient: NameMapper,\n): PatchOperationInternal {\n  if (op.op === 'clear') {\n    return op;\n  }\n  const tableName = serverToClient.tableName(op.tableName, op as JSONValue);\n  switch (op.op) {\n    case 'del':\n      return {\n        op: 'del',\n        key: toPrimaryKeyString(\n          tableName,\n          schema.tables[tableName].primaryKey,\n          serverToClient.row(op.tableName, op.id),\n        ),\n      };\n    case 'put':\n      return {\n        op: 'put',\n        key: toPrimaryKeyString(\n          tableName,\n          schema.tables[tableName].primaryKey,\n          serverToClient.row(op.tableName, op.value),\n        ),\n        value: serverToClient.row(op.tableName, op.value),\n      };\n    case 'update':\n      return {\n        op: 'update',\n        key: toPrimaryKeyString(\n          tableName,\n          schema.tables[tableName].primaryKey,\n          serverToClient.row(op.tableName, op.id),\n        ),\n        merge: op.merge\n          ? serverToClient.row(op.tableName, op.merge)\n          : undefined,\n        constrain: serverToClient.columns(op.tableName, op.constrain),\n      };\n    default:\n      unreachable(op);\n  }\n}\n\n/**\n * Some environments we run in don't have `requestAnimationFrame` (such as\n * Node, Cloudflare Workers).\n */\nfunction rafFallback(callback: () => void): void {\n  setTimeout(callback, 0);\n}\n","import type {\n  InternalDiff,\n  InternalDiffOperation,\n} from '../../../replicache/src/btree/node.ts';\nimport {readFromHash} from '../../../replicache/src/db/read.ts';\nimport type {Hash} from '../../../replicache/src/hash.ts';\nimport {withRead} from '../../../replicache/src/with-transactions.ts';\nimport type {ZeroContext} from './context.ts';\nimport * as FormatVersion from '../../../replicache/src/format-version-enum.ts';\nimport type {IVMSourceBranch} from './ivm-branch.ts';\nimport {ENTITIES_KEY_PREFIX} from './keys.ts';\nimport {must} from '../../../shared/src/must.ts';\nimport type {LazyStore} from '../../../replicache/src/dag/lazy-store.ts';\nimport type {\n  EphemeralID,\n  MutationTrackingData,\n  ZeroOption,\n  ZeroReadOptions,\n} from '../../../replicache/src/replicache-options.ts';\nimport type {MutationTracker} from './mutation-tracker.ts';\n\ntype TxData = {\n  ivmSources: IVMSourceBranch;\n  token: string | undefined;\n};\n\nexport class ZeroRep implements ZeroOption {\n  readonly #context: ZeroContext;\n  readonly #ivmMain: IVMSourceBranch;\n  readonly #customMutatorsEnabled: boolean;\n  readonly #mutationTracker: MutationTracker;\n  #store: LazyStore | undefined;\n  #auth: string | undefined;\n\n  constructor(\n    context: ZeroContext,\n    ivmMain: IVMSourceBranch,\n    customMutatorsEnabled: boolean,\n    mutationTracker: MutationTracker,\n  ) {\n    this.#context = context;\n    this.#ivmMain = ivmMain;\n    this.#customMutatorsEnabled = customMutatorsEnabled;\n    this.#mutationTracker = mutationTracker;\n  }\n\n  set auth(auth: string) {\n    if (auth === '') {\n      this.#auth = undefined;\n    } else {\n      this.#auth = auth;\n    }\n  }\n\n  async init(hash: Hash, store: LazyStore) {\n    const diffs: InternalDiffOperation[] = [];\n    await withRead(store, async dagRead => {\n      const read = await readFromHash(hash, dagRead, FormatVersion.Latest);\n      for await (const entry of read.map.scan(ENTITIES_KEY_PREFIX)) {\n        if (!entry[0].startsWith(ENTITIES_KEY_PREFIX)) {\n          break;\n        }\n        diffs.push({\n          op: 'add',\n          key: entry[0],\n          newValue: entry[1],\n        });\n      }\n    });\n    this.#store = store;\n\n    this.#context.processChanges(undefined, hash, diffs);\n  }\n\n  getTxData = (\n    desiredHead: Hash,\n    readOptions?: ZeroReadOptions | undefined,\n  ): Promise<TxData> | undefined => {\n    // getTxData requires some extensive testing for complete confidence\n    // that it will not break. Do not enable `getTxData` unless the user\n    // has opted into custom mutators.\n    if (!this.#customMutatorsEnabled) {\n      return;\n    }\n\n    return this.#ivmMain\n      .forkToHead(must(this.#store), desiredHead, readOptions)\n      .then(branch => ({\n        ivmSources: branch,\n        token: this.#auth,\n      }));\n  };\n\n  advance = (expectedHash: Hash, newHash: Hash, diffs: InternalDiff): void => {\n    this.#context.processChanges(expectedHash, newHash, diffs);\n  };\n\n  trackMutation(): MutationTrackingData {\n    return this.#mutationTracker.trackMutation();\n  }\n  mutationIDAssigned(ephemeralID: EphemeralID, mutationID: number): void {\n    this.#mutationTracker.mutationIDAssigned(ephemeralID, mutationID);\n  }\n  rejectMutation(ephemeralID: EphemeralID, ex: unknown): void {\n    this.#mutationTracker.rejectMutation(ephemeralID, ex);\n  }\n}\n"],"names":["v","db","resolver","promiseVoid","resolver","process","ReadImpl","WriteImpl","ReadImpl","WriteImpl","ReadImpl","ReadImpl","WriteImpl","string","number","table","table","name","serverName","SchemaVersionNotSupported","VersionNotSupported","resolver","consoleLogSink","resolver","resolver","resolver","resolver","t","ok","RWLock","RWLock","greaterThan","greaterThan","zeroData","clientID","localMutations","latestGCUpdate","latestGCUpdate","mainClientGroupID","perdagLMID","perdagBaseSnapshot","memdagBaseSnapshot","gatheredChunks","zeroData","perdagClientGroupHeadHash","perdagLmid","perdagClientGroupBaseSnapshot","gatheredChunks","memdagBaseSnapshot","zeroData","resolver","process","requestIdle","resolver","greaterThan","scan","diff","diff","newDiff","greaterThan","noop","consoleLogSink","resolver","hasClientState","zeroData","pusherResult","requestID","beginPullResponse","zeroErrorSchema","putOpSchema","delOpSchema","patchOpSchema","putOpSchema","updateOpSchema","delOpSchema","clearOpSchema","table","resolver","resolver","clientID","compareUTF8","comparator","key","compareUTF8","comparator","data","diff","assertValidRunOptions","table","send","TeeLogSink","consoleLogSink","Lock","version","version","consoleLogSink","options","TeeLogSink","version","resolver","resolver","diff","send","diff","reload","LogContext","Lock","Lock","serverToClient","version","resolver","assertValidRunOptions","e"],"mappings":"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","debugId":null}},
    {"offset": {"line": 19065, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/next%4015.5.4_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n"],"names":["module","exports","require","vendored","ReactJsxRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,gOACRC,QAAQ,CAAC,YAAY,CAAEC,eAAe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 19070, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/components/mark-icon.tsx"],"sourcesContent":["import type {FC, SVGProps} from 'react';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const MarkIcon: FC<SVGProps<SVGSVGElement>> = props => (\n  <svg\n    width=\"18\"\n    height=\"18\"\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <title>Show Zero Inspector</title>\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M0.407235 15.1075C-0.661857 11.1041 0.374032 6.65546 3.51478 3.51471C8.20106 -1.17157 15.799 -1.17157 20.4854 3.51471C20.8969 3.92627 21.2723 4.36029 21.6115 4.81284L17.6063 8.81802H12.7576L16.7275 4.84814C13.3994 2.64322 8.87135 3.00687 5.9391 5.93909C4.24366 7.63455 3.40687 9.86362 3.42896 12.0857L0.407235 15.1075ZM18.0609 18.0609C15.1287 20.9931 10.6006 21.3568 7.27247 19.1519L11.2423 15.182H6.39356L2.38844 19.1872C2.72767 19.6397 3.10316 20.0737 3.51466 20.4853C8.20094 25.1716 15.799 25.1716 20.4852 20.4853C23.626 17.3445 24.6619 12.8959 23.5927 8.89255L20.5709 11.9143C20.593 14.1364 19.7564 16.3654 18.0609 18.0609Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n);\n"],"names":[],"mappings":";;;;;AAIE,SAQE,KARF;;AADK,IAAM,WAAwC,CAAA,QACnD,aAAA,GAAA,IAAA,sYAAA,EAAC,OAAA;QACC,OAAM;QACN,QAAO;QACP,SAAQ;QACR,MAAK;QACL,OAAM;QACL,GAAG,KAAA;QAEJ,UAAA;YAAA,aAAA,GAAA,IAAA,qYAAA,EAAC,SAAA;gBAAM,UAAA;YAAA,CAAmB;YAC1B,aAAA,GAAA,IAAA,qYAAA,EAAC,QAAA;gBACC,UAAS;gBACT,UAAS;gBACT,GAAE;gBACF,MAAK;YAAA;SACP;IAAA","debugId":null}},
    {"offset": {"line": 19102, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/next%4015.5.4_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n"],"names":["module","exports","require","vendored","React"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,gOACRC,QAAQ,CAAC,YAAY,CAAEC,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 19107, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/components/zero-inspector.tsx","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/use-query.tsx","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/shared/src/deep-clone.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/zero-provider.tsx","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-react/src/use-zero-online.tsx"],"sourcesContent":["import {lazy, Suspense, useState} from 'react';\nimport type {CustomMutatorDefs} from '../../../zero-client/src/client/custom.ts';\nimport type {Zero} from '../../../zero-client/src/client/zero.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport {MarkIcon} from './mark-icon.tsx';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Inspector = lazy(() => import('./inspector.tsx'));\n\nexport function ZeroInspector<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>({zero}: {zero: Zero<S, MD>}): JSX.Element {\n  const [show, setShow] = useState(false);\n  return show ? (\n    <Suspense fallback={<div>Loading Inspector...</div>}>\n      <Inspector\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        zero={zero as any}\n        onClose={() => setShow(false)}\n      />\n    </Suspense>\n  ) : (\n    <button\n      onClick={() => setShow(!show)}\n      style={{\n        position: 'fixed',\n        bottom: 0,\n        right: 0,\n        zIndex: 1000,\n        padding: '5px',\n        color: 'white',\n        backgroundColor: '#333',\n        borderTopLeftRadius: '8px',\n        opacity: 0.95,\n      }}\n    >\n      <MarkIcon\n        style={{\n          width: '20px',\n          height: '20px',\n          fill: 'currentColor',\n        }}\n      />\n    </button>\n  );\n}\n","import React, {useSyncExternalStore} from 'react';\nimport {resolver} from '@rocicorp/resolver';\nimport {deepClone} from '../../shared/src/deep-clone.ts';\nimport type {Immutable} from '../../shared/src/immutable.ts';\nimport type {ReadonlyJSONValue} from '../../shared/src/json.ts';\nimport {Zero} from '../../zero-client/src/client/zero.ts';\nimport type {Schema} from '../../zero-schema/src/builder/schema-builder.ts';\nimport type {Format} from '../../zql/src/ivm/view.ts';\nimport {AbstractQuery} from '../../zql/src/query/query-impl.ts';\nimport {type HumanReadable, type Query} from '../../zql/src/query/query.ts';\nimport {DEFAULT_TTL_MS, type TTL} from '../../zql/src/query/ttl.ts';\nimport type {ResultType, TypedView} from '../../zql/src/query/typed-view.ts';\nimport {useZero} from './zero-provider.tsx';\n\nexport type QueryResultDetails = Readonly<{\n  type: ResultType;\n}>;\n\nexport type QueryResult<TReturn> = readonly [\n  HumanReadable<TReturn>,\n  QueryResultDetails,\n];\n\nexport type UseQueryOptions = {\n  enabled?: boolean | undefined;\n  /**\n   * Time to live (TTL) in seconds. Controls how long query results are cached\n   * after the query is removed. During this time, Zero continues to sync the query.\n   * Default is 'never'.\n   */\n  ttl?: TTL | undefined;\n};\n\nexport type UseSuspenseQueryOptions = UseQueryOptions & {\n  /**\n   * Whether to suspend until:\n   * - 'partial': the query has partial results (partial array or defined\n   *   value for singular results) which may be of result type 'unknown',\n   *   or the query result type is 'complete' (in which case results may be\n   *   empty).  This is useful for suspending until there are partial\n   *   optimistic local results, or the query has completed loading from the\n   *   server.\n   * - 'complete': the query result type is 'complete'.\n   *\n   * Default is 'partial'.\n   */\n  suspendUntil?: 'complete' | 'partial';\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\nconst reactUse = (React as unknown as {use?: (p: Promise<unknown>) => void})\n  .use;\nconst suspend: (p: Promise<unknown>) => void = reactUse\n  ? reactUse\n  : p => {\n      throw p;\n    };\n\nexport function useQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn,\n>(\n  query: Query<TSchema, TTable, TReturn>,\n  options?: UseQueryOptions | boolean,\n): QueryResult<TReturn> {\n  let enabled = true;\n  let ttl: TTL = DEFAULT_TTL_MS;\n  if (typeof options === 'boolean') {\n    enabled = options;\n  } else if (options) {\n    ({enabled = true, ttl = DEFAULT_TTL_MS} = options);\n  }\n\n  const view = viewStore.getView(\n    useZero(),\n    query as AbstractQuery<TSchema, TTable, TReturn>,\n    enabled,\n    ttl,\n  );\n  // https://react.dev/reference/react/useSyncExternalStore\n  return useSyncExternalStore(\n    view.subscribeReactInternals,\n    view.getSnapshot,\n    view.getSnapshot,\n  );\n}\n\nexport function useSuspenseQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn,\n>(\n  query: Query<TSchema, TTable, TReturn>,\n  options?: UseSuspenseQueryOptions | boolean,\n): QueryResult<TReturn> {\n  let enabled = true;\n  let ttl: TTL = DEFAULT_TTL_MS;\n  let suspendUntil: 'complete' | 'partial' = 'partial';\n  if (typeof options === 'boolean') {\n    enabled = options;\n  } else if (options) {\n    ({\n      enabled = true,\n      ttl = DEFAULT_TTL_MS,\n      suspendUntil = 'complete',\n    } = options);\n  }\n\n  const view = viewStore.getView(\n    useZero(),\n    query as AbstractQuery<TSchema, TTable, TReturn>,\n    enabled,\n    ttl,\n  );\n  // https://react.dev/reference/react/useSyncExternalStore\n  const snapshot = useSyncExternalStore(\n    view.subscribeReactInternals,\n    view.getSnapshot,\n    view.getSnapshot,\n  );\n\n  if (enabled) {\n    if (suspendUntil === 'complete' && !view.complete) {\n      suspend(view.waitForComplete());\n    }\n\n    if (suspendUntil === 'partial' && !view.nonEmpty) {\n      suspend(view.waitForNonEmpty());\n    }\n  }\n\n  return snapshot;\n}\n\nconst emptyArray: unknown[] = [];\nconst disabledSubscriber = () => () => {};\n\nconst resultTypeUnknown = {type: 'unknown'} as const;\nconst resultTypeComplete = {type: 'complete'} as const;\n\nconst emptySnapshotSingularUnknown = [undefined, resultTypeUnknown] as const;\nconst emptySnapshotSingularComplete = [undefined, resultTypeComplete] as const;\nconst emptySnapshotPluralUnknown = [emptyArray, resultTypeUnknown] as const;\nconst emptySnapshotPluralComplete = [emptyArray, resultTypeComplete] as const;\n\nfunction getDefaultSnapshot<TReturn>(singular: boolean): QueryResult<TReturn> {\n  return (\n    singular ? emptySnapshotSingularUnknown : emptySnapshotPluralUnknown\n  ) as QueryResult<TReturn>;\n}\n\n/**\n * Returns a new snapshot or one of the empty predefined ones. Returning the\n * predefined ones is important to prevent unnecessary re-renders in React.\n */\nfunction getSnapshot<TReturn>(\n  singular: boolean,\n  data: HumanReadable<TReturn>,\n  resultType: string,\n): QueryResult<TReturn> {\n  if (singular && data === undefined) {\n    return (resultType === 'complete'\n      ? emptySnapshotSingularComplete\n      : emptySnapshotSingularUnknown) as unknown as QueryResult<TReturn>;\n  }\n\n  if (!singular && (data as unknown[]).length === 0) {\n    return (\n      resultType === 'complete'\n        ? emptySnapshotPluralComplete\n        : emptySnapshotPluralUnknown\n    ) as QueryResult<TReturn>;\n  }\n\n  return [\n    data,\n    resultType === 'complete' ? resultTypeComplete : resultTypeUnknown,\n  ];\n}\n\ndeclare const TESTING: boolean;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ViewWrapperAny = ViewWrapper<any, any, any>;\n\nconst allViews = new WeakMap<ViewStore, Map<string, ViewWrapperAny>>();\n\nexport function getAllViewsSizeForTesting(store: ViewStore): number {\n  if (TESTING) {\n    return allViews.get(store)?.size ?? 0;\n  }\n  return 0;\n}\n\n/**\n * A global store of all active views.\n *\n * React subscribes and unsubscribes to these views\n * via `useSyncExternalStore`.\n *\n * Managing views through `useEffect` or `useLayoutEffect` causes\n * inconsistencies because effects run after render.\n *\n * For example, if useQuery used use*Effect in the component below:\n * ```ts\n * function Foo({issueID}) {\n *   const issue = useQuery(z.query.issue.where('id', issueID).one());\n *   if (issue?.id !== undefined && issue.id !== issueID) {\n *     console.log('MISMATCH!', issue.id, issueID);\n *   }\n * }\n * ```\n *\n * `MISMATCH` will be printed whenever the `issueID` prop changes.\n *\n * This is because the component will render once with\n * the old state returned from `useQuery`. Then the effect inside\n * `useQuery` will run. The component will render again with the new\n * state. This inconsistent transition can cause unexpected results.\n *\n * Emulating `useEffect` via `useState` and `if` causes resource leaks.\n * That is:\n *\n * ```ts\n * function useQuery(q) {\n *   const [oldHash, setOldHash] = useState();\n *   if (hash(q) !== oldHash) {\n *      // make new view\n *   }\n *\n *   useEffect(() => {\n *     return () => view.destroy();\n *   }, []);\n * }\n * ```\n *\n * I'm not sure why but in strict mode the cleanup function\n * fails to be called for the first instance of the view and only\n * cleans up later instances.\n *\n * Swapping `useState` to `useRef` has similar problems.\n */\nexport class ViewStore {\n  #views = new Map<string, ViewWrapperAny>();\n\n  constructor() {\n    if (TESTING) {\n      allViews.set(this, this.#views);\n    }\n  }\n\n  getView<\n    TSchema extends Schema,\n    TTable extends keyof TSchema['tables'] & string,\n    TReturn,\n  >(\n    zero: Zero<TSchema>,\n    query: Query<TSchema, TTable, TReturn>,\n    enabled: boolean,\n    ttl: TTL,\n  ): {\n    getSnapshot: () => QueryResult<TReturn>;\n    subscribeReactInternals: (internals: () => void) => () => void;\n    updateTTL: (ttl: TTL) => void;\n    waitForComplete: () => Promise<void>;\n    waitForNonEmpty: () => Promise<void>;\n    complete: boolean;\n    nonEmpty: boolean;\n  } {\n    const {format} = query;\n    if (!enabled) {\n      return {\n        getSnapshot: () => getDefaultSnapshot(format.singular),\n        subscribeReactInternals: disabledSubscriber,\n        updateTTL: () => {},\n        waitForComplete: () => Promise.resolve(),\n        waitForNonEmpty: () => Promise.resolve(),\n        complete: false,\n        nonEmpty: false,\n      };\n    }\n\n    const hash = query.hash() + zero.clientID;\n    let existing = this.#views.get(hash);\n    if (!existing) {\n      existing = new ViewWrapper(\n        zero,\n        query,\n        format,\n        ttl,\n        view => {\n          const lastView = this.#views.get(hash);\n          // I don't think this can happen\n          // but lets guard against it so we don't\n          // leak resources.\n          if (lastView && lastView !== view) {\n            throw new Error('View already exists');\n          }\n          this.#views.set(hash, view);\n        },\n        () => {\n          this.#views.delete(hash);\n        },\n      );\n      this.#views.set(hash, existing);\n    } else {\n      existing.updateTTL(ttl);\n    }\n    return existing as ViewWrapper<TSchema, TTable, TReturn>;\n  }\n}\n\nconst viewStore = new ViewStore();\n\n/**\n * This wraps and ref counts a view.\n *\n * The only signal we have from React as to whether or not it is\n * done with a view is when it calls `unsubscribe`.\n *\n * In non-strict-mode we can clean up the view as soon\n * as the listener count goes to 0.\n *\n * In strict-mode, the listener count will go to 0 then a\n * new listener for the same view is immediately added back.\n *\n * This is why the `onMaterialized` and `onDematerialized` callbacks exist --\n * they allow a view which React is still referencing to be added\n * back into the store when React re-subscribes to it.\n *\n * This wrapper also exists to deal with the various\n * `useSyncExternalStore` caveats that cause excessive\n * re-renders and materializations.\n *\n * See: https://react.dev/reference/react/useSyncExternalStore#caveats\n * Especially:\n * 1. The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.\n * 2. If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component.\n */\nclass ViewWrapper<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn,\n> {\n  #zero: Zero<TSchema>;\n  #view: TypedView<HumanReadable<TReturn>> | undefined;\n  readonly #onDematerialized;\n  readonly #onMaterialized;\n  readonly #query: Query<TSchema, TTable, TReturn>;\n  readonly #format: Format;\n  #snapshot: QueryResult<TReturn>;\n  #reactInternals: Set<() => void>;\n  #ttl: TTL;\n  #complete = false;\n  #completeResolver = resolver<void>();\n  #nonEmpty = false;\n  #nonEmptyResolver = resolver<void>();\n\n  constructor(\n    zero: Zero<TSchema>,\n    query: Query<TSchema, TTable, TReturn>,\n    format: Format,\n    ttl: TTL,\n    onMaterialized: (view: ViewWrapper<TSchema, TTable, TReturn>) => void,\n    onDematerialized: () => void,\n  ) {\n    this.#zero = zero;\n    this.#query = query;\n    this.#format = format;\n    this.#ttl = ttl;\n    this.#onMaterialized = onMaterialized;\n    this.#onDematerialized = onDematerialized;\n    this.#snapshot = getDefaultSnapshot(format.singular);\n    this.#reactInternals = new Set();\n    this.#materializeIfNeeded();\n  }\n\n  #onData = (\n    snap: Immutable<HumanReadable<TReturn>>,\n    resultType: ResultType,\n  ) => {\n    const data =\n      snap === undefined\n        ? snap\n        : (deepClone(snap as ReadonlyJSONValue) as HumanReadable<TReturn>);\n    this.#snapshot = getSnapshot(this.#format.singular, data, resultType);\n    if (resultType === 'complete') {\n      this.#complete = true;\n      this.#completeResolver.resolve();\n      this.#nonEmpty = true;\n      this.#nonEmptyResolver.resolve();\n    }\n\n    if (\n      this.#format.singular\n        ? this.#snapshot[0] !== undefined\n        : (this.#snapshot[0] as unknown[]).length !== 0\n    ) {\n      this.#nonEmpty = true;\n      this.#nonEmptyResolver.resolve();\n    }\n\n    for (const internals of this.#reactInternals) {\n      internals();\n    }\n  };\n\n  #materializeIfNeeded = () => {\n    if (this.#view) {\n      return;\n    }\n\n    this.#view = this.#zero.materialize(this.#query, {ttl: this.#ttl});\n    this.#view.addListener(this.#onData);\n\n    this.#onMaterialized(this);\n  };\n\n  getSnapshot = () => this.#snapshot;\n\n  subscribeReactInternals = (internals: () => void): (() => void) => {\n    this.#reactInternals.add(internals);\n    this.#materializeIfNeeded();\n    return () => {\n      this.#reactInternals.delete(internals);\n\n      // only schedule a cleanup task if we have no listeners left\n      if (this.#reactInternals.size === 0) {\n        setTimeout(() => {\n          // Someone re-registered a listener on this view before the timeout elapsed.\n          // This happens often in strict-mode which forces a component\n          // to mount, unmount, remount.\n          if (this.#reactInternals.size > 0) {\n            return;\n          }\n          // We already destroyed the view\n          if (this.#view === undefined) {\n            return;\n          }\n          this.#view.destroy();\n          this.#view = undefined;\n          this.#complete = false;\n          this.#completeResolver = resolver();\n          this.#nonEmpty = false;\n          this.#nonEmptyResolver = resolver();\n          this.#onDematerialized();\n        }, 10);\n      }\n    };\n  };\n\n  updateTTL(ttl: TTL): void {\n    this.#ttl = ttl;\n    this.#view?.updateTTL(ttl);\n  }\n\n  get complete() {\n    return this.#complete;\n  }\n\n  waitForComplete(): Promise<void> {\n    return this.#completeResolver.promise;\n  }\n\n  get nonEmpty() {\n    return this.#nonEmpty;\n  }\n\n  waitForNonEmpty(): Promise<void> {\n    return this.#nonEmptyResolver.promise;\n  }\n}\n","import {hasOwn} from './has-own.ts';\nimport type {JSONValue, ReadonlyJSONValue} from './json.ts';\n\nexport function deepClone(value: ReadonlyJSONValue): JSONValue {\n  const seen: Array<ReadonlyJSONValue> = [];\n  return internalDeepClone(value, seen);\n}\n\nexport function internalDeepClone(\n  value: ReadonlyJSONValue,\n  seen: Array<ReadonlyJSONValue>,\n): JSONValue {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n    case 'undefined':\n      return value;\n    case 'object': {\n      if (value === null) {\n        return null;\n      }\n      if (seen.includes(value)) {\n        throw new Error('Cyclic object');\n      }\n      seen.push(value);\n      if (Array.isArray(value)) {\n        const rv = value.map(v => internalDeepClone(v, seen));\n        seen.pop();\n        return rv;\n      }\n\n      const obj: JSONValue = {};\n\n      for (const k in value) {\n        if (hasOwn(value, k)) {\n          const v = (value as Record<string, ReadonlyJSONValue>)[k];\n          if (v !== undefined) {\n            obj[k] = internalDeepClone(v, seen);\n          }\n        }\n      }\n      seen.pop();\n      return obj;\n    }\n\n    default:\n      throw new Error(`Invalid type: ${typeof value}`);\n  }\n}\n","import {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  type ReactNode,\n} from 'react';\nimport {Zero} from '../../zero-client/src/client/zero.ts';\nimport type {Schema} from '../../zero-schema/src/builder/schema-builder.ts';\nimport type {CustomMutatorDefs} from '../../zero-client/src/client/custom.ts';\nimport type {ZeroOptions} from '../../zero-client/src/client/options.ts';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst ZeroContext = createContext<unknown | undefined>(undefined);\n\nexport function useZero<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>(): Zero<S, MD> {\n  const zero = useContext(ZeroContext);\n  if (zero === undefined) {\n    throw new Error('useZero must be used within a ZeroProvider');\n  }\n  return zero as Zero<S, MD>;\n}\n\nexport function createUseZero<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>() {\n  return () => useZero<S, MD>();\n}\n\nexport type ZeroProviderProps<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n> = (ZeroOptions<S, MD> | {zero: Zero<S, MD>}) & {\n  init?: (zero: Zero<S, MD>) => void;\n  children: ReactNode;\n};\n\nexport function ZeroProvider<\n  S extends Schema,\n  MD extends CustomMutatorDefs | undefined = undefined,\n>({children, init, ...props}: ZeroProviderProps<S, MD>) {\n  const [zero, setZero] = useState<Zero<S, MD> | undefined>(\n    'zero' in props ? props.zero : undefined,\n  );\n\n  // If Zero is not passed in, we construct it, but only client-side.\n  // Zero doesn't really work SSR today so this is usually the right thing.\n  // When we support Zero SSR this will either become a breaking change or\n  // more likely server support will be opt-in with a new prop on this\n  // component.\n  useEffect(() => {\n    if ('zero' in props) {\n      setZero(props.zero);\n      return;\n    }\n\n    const z = new Zero(props);\n    init?.(z);\n    setZero(z);\n\n    return () => {\n      void z.close();\n      setZero(undefined);\n    };\n  }, [init, ...Object.values(props)]);\n\n  return (\n    zero && <ZeroContext.Provider value={zero}>{children}</ZeroContext.Provider>\n  );\n}\n","import {useSyncExternalStore} from 'react';\nimport {useZero} from './zero-provider.tsx';\n\n/**\n * Hook to subscribe to the online status of the Zero instance.\n *\n * This is useful when you want to update state based on the online status.\n *\n * @returns The online status of the Zero instance.\n */\nexport function useZeroOnline(): boolean {\n  const zero = useZero();\n  return useSyncExternalStore(\n    zero.onOnline,\n    () => zero.online,\n    () => zero.online,\n  );\n}\n"],"names":["useState","jsx","useState","useSyncExternalStore","useSyncExternalStore"],"mappings":"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","debugId":null}},
    {"offset": {"line": 19474, "column": 0}, "map": {"version":3,"sources":["file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/builder/relationship-builder.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/static-query.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zero-schema/src/permissions.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/escape-like.ts","file:///Users/avy/Code/todoit/node_modules/.pnpm/%40rocicorp%2Bzero%400.23.2025090100_%40opentelemetry%2Bcore%402.1.0_%40opentelemetry%2Bapi%401.9.0__typescript%405.9.3/node_modules/%40rocicorp/zql/src/query/named.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {Relationship, TableSchema} from '../table-schema.ts';\nimport type {TableBuilderWithColumns} from './table-builder.ts';\n\ntype ConnectArg<TSourceField, TDestField, TDest extends TableSchema> = {\n  readonly sourceField: TSourceField;\n  readonly destField: TDestField;\n  readonly destSchema: TableBuilderWithColumns<TDest>;\n};\n\ntype ManyConnection<TSourceField, TDestField, TDest extends TableSchema> = {\n  readonly sourceField: TSourceField;\n  readonly destField: TDestField;\n  readonly destSchema: TDest['name'];\n  readonly cardinality: 'many';\n};\n\ntype OneConnection<TSourceField, TDestField, TDest extends TableSchema> = {\n  readonly sourceField: TSourceField;\n  readonly destField: TDestField;\n  readonly destSchema: TDest['name'];\n  readonly cardinality: 'one';\n};\n\ntype Prev = [-1, 0, 1, 2, 3, 4, 5, 6];\n\nexport type PreviousSchema<\n  TSource extends TableSchema,\n  K extends number,\n  TDests extends TableSchema[],\n> = K extends 0 ? TSource : TDests[Prev[K]];\n\nexport type Relationships = {\n  name: string; // table name\n  relationships: Record<string, Relationship>; // relationships for that table\n};\n\nexport function relationships<\n  TSource extends TableSchema,\n  TRelationships extends Record<string, Relationship>,\n>(\n  table: TableBuilderWithColumns<TSource>,\n  cb: (connects: {\n    many: <\n      TDests extends TableSchema[],\n      TSourceFields extends {\n        [K in keyof TDests]: (keyof PreviousSchema<\n          TSource,\n          K & number,\n          TDests\n        >['columns'] &\n          string)[];\n      },\n      TDestFields extends {\n        [K in keyof TDests]: (keyof TDests[K]['columns'] & string)[];\n      },\n    >(\n      ...args: {\n        [K in keyof TDests]: ConnectArg<\n          TSourceFields[K],\n          TDestFields[K],\n          TDests[K]\n        >;\n      }\n    ) => {\n      [K in keyof TDests]: ManyConnection<\n        TSourceFields[K],\n        TDestFields[K],\n        TDests[K]\n      >;\n    };\n    one: <\n      TDests extends TableSchema[],\n      TSourceFields extends {\n        [K in keyof TDests]: (keyof PreviousSchema<\n          TSource,\n          K & number,\n          TDests\n        >['columns'] &\n          string)[];\n      },\n      TDestFields extends {\n        [K in keyof TDests]: (keyof TDests[K]['columns'] & string)[];\n      },\n    >(\n      ...args: {\n        [K in keyof TDests]: ConnectArg<\n          TSourceFields[K],\n          TDestFields[K],\n          TDests[K]\n        >;\n      }\n    ) => {\n      [K in keyof TDests]: OneConnection<\n        TSourceFields[K],\n        TDestFields[K],\n        TDests[K]\n      >;\n    };\n  }) => TRelationships,\n): {name: TSource['name']; relationships: TRelationships} {\n  const relationships = cb({many, one} as any);\n\n  return {\n    name: table.schema.name,\n    relationships,\n  };\n}\n\nfunction many(\n  ...args: readonly ConnectArg<any, any, TableSchema>[]\n): ManyConnection<any, any, any>[] {\n  return args.map(arg => ({\n    sourceField: arg.sourceField,\n    destField: arg.destField,\n    destSchema: arg.destSchema.schema.name,\n    cardinality: 'many',\n  }));\n}\n\nfunction one(\n  ...args: readonly ConnectArg<any, any, TableSchema>[]\n): OneConnection<any, any, any>[] {\n  return args.map(arg => ({\n    sourceField: arg.sourceField,\n    destField: arg.destField,\n    destSchema: arg.destSchema.schema.name,\n    cardinality: 'one',\n  }));\n}\n","import type {AST, System} from '../../../zero-protocol/src/ast.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {Format} from '../ivm/view.ts';\nimport {ExpressionBuilder} from './expression.ts';\nimport type {CustomQueryID} from './named.ts';\nimport type {QueryDelegate} from './query-delegate.ts';\nimport {AbstractQuery, defaultFormat, newQuerySymbol} from './query-impl.ts';\nimport type {HumanReadable, PullRow, Query} from './query.ts';\nimport type {TypedView} from './typed-view.ts';\n\nexport function staticQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(schema: TSchema, tableName: TTable): Query<TSchema, TTable> {\n  return new StaticQuery<TSchema, TTable>(\n    schema,\n    tableName,\n    {table: tableName},\n    defaultFormat,\n  );\n}\n\n/**\n * A query that cannot be run.\n * Only serves to generate ASTs.\n */\nexport class StaticQuery<\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n  TReturn = PullRow<TTable, TSchema>,\n> extends AbstractQuery<TSchema, TTable, TReturn> {\n  constructor(\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST,\n    format: Format,\n    system: System = 'permissions',\n    customQueryID?: CustomQueryID | undefined,\n    currentJunction?: string | undefined,\n  ) {\n    super(\n      undefined,\n      schema,\n      tableName,\n      ast,\n      format,\n      system,\n      customQueryID,\n      currentJunction,\n    );\n  }\n\n  expressionBuilder() {\n    return new ExpressionBuilder(this._exists);\n  }\n\n  protected [newQuerySymbol]<\n    TSchema extends Schema,\n    TTable extends keyof TSchema['tables'] & string,\n    TReturn,\n  >(\n    _delegate: QueryDelegate | undefined,\n    schema: TSchema,\n    tableName: TTable,\n    ast: AST,\n    format: Format,\n    customQueryID: CustomQueryID | undefined,\n    currentJunction: string | undefined,\n  ): StaticQuery<TSchema, TTable, TReturn> {\n    return new StaticQuery(\n      schema,\n      tableName,\n      ast,\n      format,\n      'permissions',\n      customQueryID,\n      currentJunction,\n    );\n  }\n\n  get ast() {\n    return this._completeAst();\n  }\n\n  materialize(): TypedView<HumanReadable<TReturn>> {\n    throw new Error('StaticQuery cannot be materialized');\n  }\n\n  run(): Promise<HumanReadable<TReturn>> {\n    return Promise.reject(new Error('StaticQuery cannot be run'));\n  }\n\n  preload(): {\n    cleanup: () => void;\n    complete: Promise<void>;\n  } {\n    throw new Error('StaticQuery cannot be preloaded');\n  }\n}\n","import {assert} from '../../shared/src/asserts.ts';\nimport {\n  mapCondition,\n  toStaticParam,\n  type Condition,\n  type Parameter,\n} from '../../zero-protocol/src/ast.ts';\nimport type {ExpressionBuilder} from '../../zql/src/query/expression.ts';\nimport {defaultFormat, staticParam} from '../../zql/src/query/query-impl.ts';\nimport type {Query} from '../../zql/src/query/query.ts';\nimport {StaticQuery} from '../../zql/src/query/static-query.ts';\nimport type {Schema} from './builder/schema-builder.ts';\nimport type {\n  AssetPermissions as CompiledAssetPermissions,\n  PermissionsConfig as CompiledPermissionsConfig,\n} from './compiled-permissions.ts';\nimport {clientToServer, NameMapper} from './name-mapper.ts';\n\nexport const ANYONE_CAN = [\n  (_: unknown, eb: ExpressionBuilder<Schema, never>) => eb.and(),\n];\n\n/**\n * @deprecated Use {@link ANYONE_CAN} instead.\n */\nexport const ANYONE_CAN_DO_ANYTHING = {\n  row: {\n    select: ANYONE_CAN,\n    insert: ANYONE_CAN,\n    update: {\n      preMutation: ANYONE_CAN,\n      postMutation: ANYONE_CAN,\n    },\n    delete: ANYONE_CAN,\n  },\n};\n\nexport const NOBODY_CAN = [];\n\nexport type Anchor = 'authData' | 'preMutationRow';\n\nexport type Queries<TSchema extends Schema> = {\n  [K in keyof TSchema['tables']]: Query<Schema, K & string>;\n};\n\nexport type PermissionRule<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n> = (\n  authData: TAuthDataShape,\n  eb: ExpressionBuilder<TSchema, TTable>,\n) => Condition;\n\nexport type AssetPermissions<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n> = {\n  // Why an array of rules?: https://github.com/rocicorp/mono/pull/3184/files#r1869680716\n  select?: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined;\n  /**\n   * @deprecated Use Mutators instead.\n   * @see {@link https://zero.rocicorp.dev/docs/writing-data}\n   */\n  insert?: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined;\n  /**\n   * @deprecated Use Mutators instead.\n   * @see {@link https://zero.rocicorp.dev/docs/writing-data}\n   */\n  update?:\n    | {\n        preMutation?: PermissionRule<TAuthDataShape, TSchema, TTable>[];\n        postMutation?: PermissionRule<TAuthDataShape, TSchema, TTable>[];\n      }\n    | undefined;\n  /**\n   * @deprecated Use Mutators instead.\n   * @see {@link https://zero.rocicorp.dev/docs/writing-data}\n   */\n  delete?: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined;\n};\n\nexport type PermissionsConfig<TAuthDataShape, TSchema extends Schema> = {\n  [K in keyof TSchema['tables']]?: {\n    row?: AssetPermissions<TAuthDataShape, TSchema, K & string> | undefined;\n    cell?:\n      | {\n          [C in keyof TSchema['tables'][K]['columns']]?: Omit<\n            AssetPermissions<TAuthDataShape, TSchema, K & string>,\n            'cell'\n          >;\n        }\n      | undefined;\n  };\n};\n\nexport async function definePermissions<TAuthDataShape, TSchema extends Schema>(\n  schema: TSchema,\n  definer: () =>\n    | Promise<PermissionsConfig<TAuthDataShape, TSchema>>\n    | PermissionsConfig<TAuthDataShape, TSchema>,\n): Promise<CompiledPermissionsConfig | undefined> {\n  const expressionBuilders = {} as Record<\n    string,\n    ExpressionBuilder<Schema, string>\n  >;\n  for (const name of Object.keys(schema.tables)) {\n    expressionBuilders[name] = new StaticQuery(\n      schema,\n      name,\n      {table: name},\n      defaultFormat,\n    ).expressionBuilder();\n  }\n\n  const config = await definer();\n  return compilePermissions(schema, config, expressionBuilders);\n}\n\nfunction compilePermissions<TAuthDataShape, TSchema extends Schema>(\n  schema: TSchema,\n  authz: PermissionsConfig<TAuthDataShape, TSchema> | undefined,\n  expressionBuilders: Record<string, ExpressionBuilder<Schema, string>>,\n): CompiledPermissionsConfig | undefined {\n  if (!authz) {\n    return undefined;\n  }\n  const nameMapper = clientToServer(schema.tables);\n  const ret: CompiledPermissionsConfig = {tables: {}};\n  for (const [tableName, tableConfig] of Object.entries(authz)) {\n    const serverName = schema.tables[tableName].serverName ?? tableName;\n    ret.tables[serverName] = {\n      row: compileRowConfig(\n        nameMapper,\n        tableName,\n        tableConfig.row,\n        expressionBuilders[tableName],\n      ),\n      cell: compileCellConfig(\n        nameMapper,\n        tableName,\n        tableConfig.cell,\n        expressionBuilders[tableName],\n      ),\n    };\n  }\n\n  return ret;\n}\n\nfunction compileRowConfig<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  clientToServer: NameMapper,\n  tableName: TTable,\n  rowRules: AssetPermissions<TAuthDataShape, TSchema, TTable> | undefined,\n  expressionBuilder: ExpressionBuilder<TSchema, TTable>,\n): CompiledAssetPermissions | undefined {\n  if (!rowRules) {\n    return undefined;\n  }\n  return {\n    select: compileRules(\n      clientToServer,\n      tableName,\n      rowRules.select,\n      expressionBuilder,\n    ),\n    insert: compileRules(\n      clientToServer,\n      tableName,\n      rowRules.insert,\n      expressionBuilder,\n    ),\n    update: {\n      preMutation: compileRules(\n        clientToServer,\n        tableName,\n        rowRules.update?.preMutation,\n        expressionBuilder,\n      ),\n      postMutation: compileRules(\n        clientToServer,\n        tableName,\n        rowRules.update?.postMutation,\n        expressionBuilder,\n      ),\n    },\n    delete: compileRules(\n      clientToServer,\n      tableName,\n      rowRules.delete,\n      expressionBuilder,\n    ),\n  };\n}\n\n/**\n * What is this \"allow\" and why are permissions policies an array of rules?\n *\n * Please read: https://github.com/rocicorp/mono/pull/3184/files#r1869680716\n */\nfunction compileRules<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  clientToServer: NameMapper,\n  tableName: TTable,\n  rules: PermissionRule<TAuthDataShape, TSchema, TTable>[] | undefined,\n  expressionBuilder: ExpressionBuilder<TSchema, TTable>,\n): ['allow', Condition][] | undefined {\n  if (!rules) {\n    return undefined;\n  }\n\n  return rules.map(rule => {\n    const cond = rule(authDataRef as TAuthDataShape, expressionBuilder);\n    return ['allow', mapCondition(cond, tableName, clientToServer)] as const;\n  });\n}\n\nfunction compileCellConfig<\n  TAuthDataShape,\n  TSchema extends Schema,\n  TTable extends keyof TSchema['tables'] & string,\n>(\n  clientToServer: NameMapper,\n  tableName: TTable,\n  cellRules:\n    | Record<string, AssetPermissions<TAuthDataShape, TSchema, TTable>>\n    | undefined,\n  expressionBuilder: ExpressionBuilder<TSchema, TTable>,\n): Record<string, CompiledAssetPermissions> | undefined {\n  if (!cellRules) {\n    return undefined;\n  }\n  const ret: Record<string, CompiledAssetPermissions> = {};\n  for (const [columnName, rules] of Object.entries(cellRules)) {\n    ret[columnName] = {\n      select: compileRules(\n        clientToServer,\n        tableName,\n        rules.select,\n        expressionBuilder,\n      ),\n      insert: compileRules(\n        clientToServer,\n        tableName,\n        rules.insert,\n        expressionBuilder,\n      ),\n      update: {\n        preMutation: compileRules(\n          clientToServer,\n          tableName,\n          rules.update?.preMutation,\n          expressionBuilder,\n        ),\n        postMutation: compileRules(\n          clientToServer,\n          tableName,\n          rules.update?.postMutation,\n          expressionBuilder,\n        ),\n      },\n      delete: compileRules(\n        clientToServer,\n        tableName,\n        rules.delete,\n        expressionBuilder,\n      ),\n    };\n  }\n  return ret;\n}\n\nclass CallTracker {\n  readonly #anchor: Anchor;\n  readonly #path: string[];\n  constructor(anchor: Anchor, path: string[]) {\n    this.#anchor = anchor;\n    this.#path = path;\n  }\n\n  get(target: {[toStaticParam]: () => Parameter}, prop: string | symbol) {\n    if (prop === toStaticParam) {\n      return target[toStaticParam];\n    }\n    assert(typeof prop === 'string');\n    const path = [...this.#path, prop];\n    return new Proxy(\n      {\n        [toStaticParam]: () => staticParam(this.#anchor, path),\n      },\n      new CallTracker(this.#anchor, path),\n    );\n  }\n}\n\nfunction baseTracker(anchor: Anchor) {\n  return new Proxy(\n    {\n      [toStaticParam]: () => {\n        throw new Error('no JWT field specified');\n      },\n    },\n    new CallTracker(anchor, []),\n  );\n}\n\nexport const authDataRef = baseTracker('authData');\nexport const preMutationRowRef = baseTracker('preMutationRow');\n","export function escapeLike(val: string) {\n  return val.replace(/[%_]/g, '\\\\$&');\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\nimport type {Schema} from '../../../zero-schema/src/builder/schema-builder.ts';\nimport type {SchemaQuery} from '../mutate/custom.ts';\nimport {newQuery} from './query-impl.ts';\nimport type {Query} from './query.ts';\n\nexport type QueryFn<\n  TContext,\n  TTakesContext extends boolean,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n> = TTakesContext extends false\n  ? {(...args: TArg): TReturnQuery}\n  : {(context: TContext, ...args: TArg): TReturnQuery};\n\nexport type SyncedQuery<\n  TName extends string,\n  TContext,\n  TTakesContext extends boolean,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n> = QueryFn<TContext, TTakesContext, TArg, TReturnQuery> & {\n  queryName: TName;\n  parse: ParseFn<TArg> | undefined;\n  takesContext: TTakesContext;\n};\n\nfunction normalizeParser<T extends ReadonlyJSONValue[]>(\n  parser: ParseFn<T> | HasParseFn<T> | undefined,\n): ParseFn<T> | undefined {\n  if (parser) {\n    if ('parse' in parser) {\n      return parser.parse.bind(parser);\n    }\n    return parser;\n  }\n  return undefined;\n}\n\nexport function syncedQuery<\n  TName extends string,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n>(\n  name: TName,\n  parser: ParseFn<TArg> | HasParseFn<TArg> | undefined,\n  fn: QueryFn<unknown, false, TArg, TReturnQuery>,\n): SyncedQuery<TName, unknown, false, TArg, TReturnQuery> {\n  const impl = syncedQueryImpl(name, fn, false);\n  const ret: any = (...args: TArg) => impl(undefined, args);\n  ret.queryName = name;\n  ret.parse = normalizeParser(parser);\n  ret.takesContext = false;\n  return ret;\n}\n\nexport function syncedQueryWithContext<\n  TName extends string,\n  TContext,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n>(\n  name: TName,\n  parser: ParseFn<TArg> | HasParseFn<TArg> | undefined,\n  fn: QueryFn<TContext, true, TArg, TReturnQuery>,\n): SyncedQuery<TName, TContext, true, TArg, TReturnQuery> {\n  const impl = syncedQueryImpl(name, fn, true);\n  const ret: any = (context: TContext, ...args: TArg) => impl(context, args);\n  ret.queryName = name;\n  ret.parse = normalizeParser(parser);\n  ret.takesContext = true;\n  return ret;\n}\n\nfunction syncedQueryImpl<\n  TName extends string,\n  TContext,\n  TArg extends ReadonlyJSONValue[],\n  TReturnQuery extends Query<any, any, any>,\n>(name: TName, fn: any, takesContext: boolean) {\n  return (context: TContext, args: TArg) => {\n    const q = takesContext ? fn(context, ...args) : fn(...args);\n    return q.nameAndArgs(name, args) as TReturnQuery;\n  };\n}\n\nexport function withValidation<T extends SyncedQuery<any, any, any, any, any>>(\n  fn: T,\n): T extends SyncedQuery<infer N, infer C, any, any, infer R>\n  ? SyncedQuery<N, C, true, ReadonlyJSONValue[], R>\n  : never {\n  if (!fn.parse) {\n    throw new Error('ret does not have a parse function defined');\n  }\n  const ret: any = (context: unknown, ...args: unknown[]) => {\n    const f = fn as any;\n    const parsed = f.parse(args);\n    return f.takesContext ? f(context, ...parsed) : f(...parsed);\n  };\n  ret.queryName = fn.queryName;\n  ret.parse = fn.parse;\n  ret.takesContext = true;\n\n  return ret;\n}\n\nexport type ParseFn<T extends ReadonlyJSONValue[]> = (args: unknown[]) => T;\n\nexport type HasParseFn<T extends ReadonlyJSONValue[]> = {\n  parse: ParseFn<T>;\n};\n\nexport type Parser<T extends ReadonlyJSONValue[]> = ParseFn<T> | HasParseFn<T>;\n\nexport type CustomQueryID = {\n  name: string;\n  args: ReadonlyArray<ReadonlyJSONValue>;\n};\n\n/**\n * Returns a set of query builders for the given schema.\n */\nexport function createBuilder<S extends Schema>(s: S): SchemaQuery<S> {\n  return makeQueryBuilders(s) as SchemaQuery<S>;\n}\n\n/**\n * This produces the query builders for a given schema.\n * For use in Zero on the server to process custom queries.\n */\nfunction makeQueryBuilders<S extends Schema>(schema: S): SchemaQuery<S> {\n  return new Proxy(\n    {},\n    {\n      get: (\n        target: Record<\n          string,\n          Omit<Query<S, string, any>, 'materialize' | 'preload'>\n        >,\n        prop: string,\n      ) => {\n        if (prop in target) {\n          return target[prop];\n        }\n\n        if (!(prop in schema.tables)) {\n          throw new Error(`Table ${prop} does not exist in schema`);\n        }\n\n        const q = newQuery(undefined, schema, prop);\n        target[prop] = q;\n        return q;\n      },\n    },\n  ) as SchemaQuery<S>;\n}\n"],"names":["table","relationships","clientToServer"],"mappings":"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","debugId":null}},
    {"offset": {"line": 19744, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}}]
}