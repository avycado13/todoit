// db/zero/mutators.ts

import type { Transaction } from "@rocicorp/zero";
import type { Schema } from "./schema.gen";

interface AuthDataForMutators {
	user: {
		id: string;
	};
	session?: {
		token: string;
	};
}

type Tx = Transaction<Schema>;

export function createMutators(authData: AuthDataForMutators | undefined) {
	return {
		tasks: {
			add: async (
				tx: Tx,
				{
					title,
					description,
					due_date,
					status,
				}: {
					title: string;
					description?: string;
					due_date?: number;
					status: string;
				},
			) => {
				// The user object from AuthSession has a slightly different shape
				if (!authData) {
					throw new Error("Not authenticated");
				}
				try {
					await tx.mutate.tasks.insert({
						title,
						description,
						due_date: due_date ?? null,
						status,
						created_at: Date.now(),
						updated_at: Date.now(),
						// Access the user ID correctly from the AuthSession type
						userId: authData.user.id,
						id: null
					});
					// ID is auto-generated by the database (serial)
				} catch (err) {
					console.error("Error adding task:", err);
					throw err;
				}
			},

			remove: async (tx: Tx, taskId: string) => {
				if (!authData?.user) {
					throw new Error("Not authenticated");
				}
				const task = await tx.query.tasks
					.where("id", parseInt(taskId))
					.where("userId", authData.user.id)
					.one();
				if (!task) return;
				await tx.mutate.tasks.delete({
					id: task.id,
				});
			},

			updateTask: async (
				tx: Tx,
				{
					id,
					status,
					title,
					description,
					due_date,
				}: {
					id: string;
					status: string;
					title: string | undefined | null;
					description: string | undefined | null;
					due_date: number | undefined | null;
				},
			) => {
				if (!authData?.user) throw new Error("Not authenticated");

				// Ensure the task belongs to the authenticated user
				const task = await tx.query.tasks
					.where("id", parseInt(id))
					.where("userId", authData.user.id)
					.one();

				if (!task) return;

				await tx.mutate.tasks.update(
					{
						id: task.id,
						status,
						title: title ?? undefined,
						description,
						due_date,
						updated_at: Date.now(),
					}, // update object
				);
			},
		},
	}
}

export type Mutators = ReturnType<typeof createMutators>;
